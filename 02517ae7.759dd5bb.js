(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{130:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),u=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},b=function(e){var t=u(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=u(n),p=a,d=b["".concat(o,".").concat(p)]||b[p]||m[p]||l;return n?r.a.createElement(d,i(i({ref:t},c),{},{components:n})):r.a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<l;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},55:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(6),l=(n(0),n(130)),o={id:"ch05",title:"Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors",sidebar_label:"Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors"},i={unversionedId:"ch05",id:"ch05",isDocsHomePage:!1,title:"Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors",description:"\x3c!---",source:"@site/../CQL_Guide/ch05.md",slug:"/ch05",permalink:"/cql-guide/ch05",version:"current",lastUpdatedBy:"Dominik Pich",lastUpdatedAt:1613056490,sidebar_label:"Chapter 5: Types of Cursors, OUT and OUT UNION, and FETCH flavors",sidebar:"someSidebar",previous:{title:"Chapter 4: Procedures, Functions, and Control Flow",permalink:"/cql-guide/ch04"},next:{title:"Chapter 6: Calling Procedures Defined Elsewhere",permalink:"/cql-guide/ch06"}},s=[{value:"Statement Cursors",id:"statement-cursors",children:[]},{value:"Value Cursors",id:"value-cursors",children:[]},{value:"OUT Statement",id:"out-statement",children:[]},{value:"OUT UNION Statement",id:"out-union-statement",children:[]},{value:"Result Set Cursors",id:"result-set-cursors",children:[]},{value:"Reshaping Data, Cursor <code>LIKE</code> forms",id:"reshaping-data-cursor-like-forms",children:[]},{value:"Fetch Statement Specifics",id:"fetch-statement-specifics",children:[]},{value:"Calling Procedures with Bulk Arguments",id:"calling-procedures-with-bulk-arguments",children:[]},{value:"Missing Data Columns, Nulls and Dummy Data",id:"missing-data-columns-nulls-and-dummy-data",children:[]}],c={rightToc:s};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"In the previous chapters we have used cursor variables without fully discussing them.\nMost of the uses are fairly self-evident but a more exhaustive discussion is also useful."),Object(l.b)("p",null,"First there are three types of cursors, as we will see below."),Object(l.b)("h3",{id:"statement-cursors"},"Statement Cursors"),Object(l.b)("p",null,"A statement cursor is based on a SQL ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," statement.  A full example might look like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"-- elsewhere\ncreate table xy_table(x integer, y integer);\n\ndeclare C cursor for select x, y from xy_table;\n")),Object(l.b)("p",null,"When compiled, this will result in creating a SQLite statement object (type ",Object(l.b)("inlineCode",{parentName:"p"},"sqlite_stmt*"),")\nand storing it in a variable called ",Object(l.b)("inlineCode",{parentName:"p"},"C"),".  This statement can then be used later in various ways."),Object(l.b)("p",null,"Here's perhaps the simplest way to use a cursor:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare x, y  integer;\nfetch C into x, y;\n")),Object(l.b)("p",null,"This will have the effect of reading one row from the results of the query into\nthe local variables ",Object(l.b)("inlineCode",{parentName:"p"},"x")," and ",Object(l.b)("inlineCode",{parentName:"p"},"y"),"."),Object(l.b)("p",null,"These variables might then be used to create some output such as"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'/* note use of double quotes so that \\n is legal */\ncall printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\n')),Object(l.b)("p",null,"Or any other use."),Object(l.b)("p",null,"More generally, there may or may not be a fetched value.  The cursor variable ",Object(l.b)("inlineCode",{parentName:"p"},"C"),"\ncan be used by itself as a virtual boolean indicating the presence of a row.\nSo a more complete example might be"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'if C then\n  call printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\nelse\n  call printf("nada\\n");\nend if\n')),Object(l.b)("p",null,"And even more generally"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'loop fetch C into x, y\nbegin\n  call printf("x:%d y:%d\\n", ifnull(x, 0), ifnull(y,0));\nend;\n')),Object(l.b)("p",null,"Here we read all the rows out and print them."),Object(l.b)("p",null,"Now if the table ",Object(l.b)("inlineCode",{parentName:"p"},"xy_table")," had instead had dozens of columns those declarations\nwould be very verbose and error prone.  And frankly annoying, especially if\nthe table definition was changing over time."),Object(l.b)("p",null,"To make this a little easier, there are also so-called 'automatic' cursors.  These\nhappen implicitly and include all the necessary storage to exactly match\nthe rows in their statement.  Using the automatic syntax for the above we might get"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from xy_table;\nfetch C;\nif (C) then\n  call printf("x:%d y:%d\\n", ifnull(C.x, 0), ifnull(C.y,0));\nend if;\n')),Object(l.b)("p",null,"or the equivalent loop form:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from xy_table;\nloop fetch C\nbegin\n  call printf("x:%d y:%d\\n", ifnull(C.x, 0), ifnull(C.y,0));\nend;\n')),Object(l.b)("p",null,'All the necessary local state is automatically created hence "automatic" cursor.\nThis pattern is generally preferred but the loose variables pattern is in\nsome sense more general.'),Object(l.b)("p",null,"In all the cases if the number or type of variables do not match the select statement,\nsemantic errors are produced."),Object(l.b)("h3",{id:"value-cursors"},"Value Cursors"),Object(l.b)("p",null,"The purpose of value cursors is to make it possible for a stored procedure to\nwork with structures as a unit rather than field by field.  SQL doesn't have\nthe notion of structure types but structures actually appear pretty directly\nin many places:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the columns of a table are a structure"),Object(l.b)("li",{parentName:"ul"},"the projection of a ",Object(l.b)("inlineCode",{parentName:"li"},"SELECT")," statement is a structure"),Object(l.b)("li",{parentName:"ul"},"other things directly derived from the above  (like the columns of a statement cursor)\nare likewise structures")),Object(l.b)("p",null,"Let's first start by how you declare a value cursor.  It is by analogy to one of the structure types above."),Object(l.b)("p",null,"So:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare C cursor like xy_table;\ndeclare C cursor like select 1 a, 'x' b;\ndeclare C cursor like my_view;\ndeclare C cursor like my_other_cursor;\ndeclare C cursor like my_previously_declared_stored_proc;\n")),Object(l.b)("p",null,"Any of those forms define a valid set of columns.  Note that the ",Object(l.b)("inlineCode",{parentName:"p"},"select")," example in no way causes the query provided to run. Instead, the select statement is analyzed and the column names and types are computed.  The cursor get the same field names and types.  Nothing happens at run time.\nThe last example assumes that there is a stored procedure defined somewhere earlier in this translation unit and that procedure returns a result set. The cursor declaration makes a cursor that could receive the result of that procedure.  We'll cover\nthat particular case in more detail below when we deal with the ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," statement."),Object(l.b)("p",null,"Now once we have declared the cursor we can load it with values using ",Object(l.b)("inlineCode",{parentName:"p"},"fetch")," in the value form."),Object(l.b)("p",null,"You can load up a cursor from values.  The values must be type-compatible of course."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"fetch C from values(1,2);\n")),Object(l.b)("p",null,"You can call a procedure that returns a single row:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"fetch C from call my_previously_declared_stored_proc();\n")),Object(l.b)("p",null,"You can fetch a cursor from another cursor:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"fetch C from D;\n")),Object(l.b)("p",null,"In this case D must be an 'automatic' cursor but it could be coming from a statement.\nThis lets you copy a row and save it for later.  E.g. you could copy the current max-valued\nrow into a value cursor and use it after the loop."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select id, value, <other_stuff> from <somewhere> where <conditions>;\ndeclare D cursor like C;\n\nfetch D from values (-1, -999);\n\nloop fetch C\nbegin\n  if (D.max < C.max) then\n    fetch D from C;\n  end if;\nend;\n\n-- this could print <other stuff> too\ncall printf("id:%d value:%d", D.id, D.value);\n')),Object(l.b)("p",null,"Value cursors are always 'automatic' -- they have their own storage."),Object(l.b)("p",null,"Value cursors also may or may not be holding a row."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C like xy_table;\nif not C then\n  call printf("this will always be true because it starts empty\\n");\nend if;\n')),Object(l.b)("p",null,"When you call a procedure you may or may not get a row as we'll see below."),Object(l.b)("h3",{id:"out-statement"},"OUT Statement"),Object(l.b)("p",null,"Value cursors were initially designed to create a convenient way for\na procedure to return a single row from a complex query\nwithout having a crazy number of ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," parameters.  It's easiest\nto illustrate this with an example."),Object(l.b)("p",null,"The older verbose pattern looks like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc get_a_row(id_ integer not null,\n                      out got_row bool not null,\n                      out w integer not null,\n                      out x integer,\n                      out y text not null,\n                      out z real)\nbegin\n  declare C for select w, x, y, z from somewhere where id = id_;\n  fetch C into w, x, y, z;\n  set got_row := C;\nend;\n")),Object(l.b)("p",null,"Now you can imagine this gets very annoying if ",Object(l.b)("inlineCode",{parentName:"p"},"get_a_row")," has to produce\na couple dozen column values.  And of course you have to get the types\nexactly right.  And they might evolve over time.  Joy."),Object(l.b)("p",null,"On the receiving side you get to do something just as annoying:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare w integer not null\ndeclare x integer;\ndeclare y text;\ndeclare z real;\ndeclare got_row bool not null;\ncall get_a_row(id, got_row, w, x, y, z);\n")),Object(l.b)("p",null,"Using the ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement we get the equivalent functionality with a much simplified pattern. It looks like this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc get_a_row(id_ integer not null)\nbegin\n   declare C for select a, b, c, d from somewhere where id = id_;\n   fetch C;\n   out C;\nend;\n")),Object(l.b)("p",null,"To use it you simply do this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare C like get_a_row;\nfetch C from call get_a_row(id);\n")),Object(l.b)("p",null,"In fact originally the above was the only way to load a value cursor, before\nthe calculus was generalized. The original form still works, and does both\nthings in one step:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare C cursor fetch from call get_a_row(id);\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," statement lets you return a single row economically and\nlets you then test if there actually was a row and read the columns.\nIt infers all the various column names and types so it is resilient\nto schema change and generally a lot less error prone than having a\nlarge number of ",Object(l.b)("inlineCode",{parentName:"p"},"out")," arguments to your procedure."),Object(l.b)("p",null,"Once you have the result in a value cursor you can do the usual\ncursor operations to move it around or otherwise work with it."),Object(l.b)("p",null,"The use of the ",Object(l.b)("inlineCode",{parentName:"p"},"LIKE")," keyword to refer to the types of complex entities spread to other\nplaces in CQL as a very useful construct, but it began here with the\nneed to describe a cursor shape economically, by reference."),Object(l.b)("h3",{id:"out-union-statement"},"OUT UNION Statement"),Object(l.b)("p",null,"The semantics of the ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement are that it always produces one row\nof output (a procedure can produce no row if an ",Object(l.b)("inlineCode",{parentName:"p"},"out")," never actually ran but the procedure does use ",Object(l.b)("inlineCode",{parentName:"p"},"out"),").\nIf an ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement runs more than once the most recent row becomes the result.  So the ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement really does\nmirror having one ",Object(l.b)("inlineCode",{parentName:"p"},"out")," variable for each column.  This was its intent and procedures\nthat return at most, or exactly, one row are very common.  However, in general, one row results\ndo not suffice; you might want to produce a result set from various sources\nwith maybe arbitary compution in there as well.  For that you need to be able to emit multiple\nrows from a computed source.  This is exactly what ",Object(l.b)("inlineCode",{parentName:"p"},"out union")," provides."),Object(l.b)("p",null,"Here's a (somewhat contrived) example of the kind of thing you can do with this form:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc foo(n integer not null)\nbegin\n  declare C cursor like select 1 value;\n  declare i integer not null;\n  set i := 0;\n  while (i < n)\n  begin\n     -- emit one row for every integer\n     fetch C from values(i);\n     out union C;\n  end;\nend;\n")),Object(l.b)("p",null,"In ",Object(l.b)("inlineCode",{parentName:"p"},"foo")," above, we make an entire result set out of thin air.  It isn't very\ninteresting but of course any computation would have been possible."),Object(l.b)("p",null,"This pattern is very flexibe as we see below in ",Object(l.b)("inlineCode",{parentName:"p"},"bar")," where\nwe're going to merge two different data streams."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create table t1(id integer, stuff text, [other things too]);\ncreate table t2(id integer, stuff text, [other things too]);\n\ncreate proc bar()\nbegin\n  declare C cursor for select * from t1 order by id;\n  declare D cursor for select * from t2 order by id;\n\n  fetch C;\n  fetch D;\n\n  -- we're going to merge these two queries\n  while (C or D)\n  begin\n    -- if both have a row pick the smaller id\n    if (C and D) then\n       if (C.id < D.id) then\n         out union C;\n         fetch C;\n       else\n         out union D;\n         fetch D;\n       end if;\n    else if C then\n      -- only C has a row, emit that\n      out union C;\n      fetch C;\n    else\n      -- only D has a row, emit that\n      out union D;\n      fetch D;\n    end if;\n  end;\nend;\n")),Object(l.b)("p",null,"Just like ",Object(l.b)("inlineCode",{parentName:"p"},"foo"),", in ",Object(l.b)("inlineCode",{parentName:"p"},"bar"),", each time ",Object(l.b)("inlineCode",{parentName:"p"},"out union")," runs a new row is accumulated.  Now, if you build\na procedure that ends with a ",Object(l.b)("inlineCode",{parentName:"p"},"select")," statement CQL automatically creates a fetcher function\nthat does exactly the same thing -- it loops over the SQLite statement for the select and fetches\neach row, materializing a result.  With ",Object(l.b)("inlineCode",{parentName:"p"},"out union")," you take manual control of this process, allowing you\nto build arbitrary result sets.  Note that either of ",Object(l.b)("inlineCode",{parentName:"p"},"C")," or ",Object(l.b)("inlineCode",{parentName:"p"},"D")," above could have been modified, replaced, skipped,\nnormalized, etc. with any kind of computation.  Even entirely synthetic rows can be computed\nand inserted into the output as we saw in ",Object(l.b)("inlineCode",{parentName:"p"},"foo"),"."),Object(l.b)("h3",{id:"result-set-cursors"},"Result Set Cursors"),Object(l.b)("p",null,"So ",Object(l.b)("inlineCode",{parentName:"p"},"OUT UNION")," makes it possible to create arbitrary result sets using a mix of sources and filtering.  Unfortunately this result type is not a simple row, nor is it a SQLite statement and so while it can produce ordinary result sets for CQL callers, CQL could not itself consume that result type."),Object(l.b)("p",null,"To address this hole, and thereby make it a lot easier to test these result sets (which really is the most interesting use case for re-consuming a result set) we need an additional cursor type.  The syntax is exactly the same as the statement cursor cases described above but, instead of holding a SQLite statement, the cursor holds a result set pointer and the current/max row numbers.  Stepping through it simply increments the row number and fetches the next row out of the rowset instead of from SQLite."),Object(l.b)("p",null,"Example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'-- reading the above\ncreate proc reader()\nbegin\n  declare C cursor for call bar();\n  loop fetch C\n  begin\n    call printf("%d %s\\n", C.id, C.stuff);  -- or whatever\n  end;\nend;\n')),Object(l.b)("p",null,"If ",Object(l.b)("inlineCode",{parentName:"p"},"bar")," had been created with a ",Object(l.b)("inlineCode",{parentName:"p"},"select union")," and ",Object(l.b)("inlineCode",{parentName:"p"},"order by")," to merge the results, the above would have worked with ",Object(l.b)("inlineCode",{parentName:"p"},"C")," being a standard statement cursor, iterating over the union.   Since ",Object(l.b)("inlineCode",{parentName:"p"},"foo")," produces a result set, CQL transparently produces a suitable cursor implementation behind the scenes but otherwise the usage is the same."),Object(l.b)("p",null,"Note this is a lousy way to iterate over rows; you have to materialize the entire result set so that you can just step over it.  Re-consuming like this is not recommended at all for production code but it is ideal for testing result sets that were made with ",Object(l.b)("inlineCode",{parentName:"p"},"out union")," which otherwise would require C/C++ to test.  Testing CQL with CQL is generally a lot easier."),Object(l.b)("h3",{id:"reshaping-data-cursor-like-forms"},"Reshaping Data, Cursor ",Object(l.b)("inlineCode",{parentName:"h3"},"LIKE")," forms"),Object(l.b)("p",null,"There are lots of cases where you have big rows with many columns and there are various manipulations you need to do.  Some of these choices are emitting extra, related, rows, some of them are altering some of the columns before emitting the rows into the result set for use by some client."),Object(l.b)("p",null,"What follows is a set of useful syntactic sugar constructs that simplify handling complex rows.  The idea is that pretty much anywhere you can specify a list of columns you can instead use the ",Object(l.b)("inlineCode",{parentName:"p"},"LIKE x")," construct to get the columns as the appear in object ",Object(l.b)("inlineCode",{parentName:"p"},"x")," -- which is usually a cursor.  It\u2019s a lot easier to illustrate with examples, even though these are, again, a bit contrived."),Object(l.b)("p",null,"First we need some table with lots of columns usually the column names are much bigger which makes it all the more important to not have to type them over and over."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create table big (\n  id integer primary key,\n  id2 integer unique,\n  a integer,\n  b integer,\n  c integer,\n  d integer,\n  e integer,\n  f integer);\n")),Object(l.b)("p",null,"We're going to emit two rows as the result of this proc.  Easy enough..."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc foo(id_ integer not null)\nbegin\n  -- this is the shape of the result we want, it's some of the columns of \"big\"\n  -- note this query doesn't run, we just use it's shape to create a cursor\n  -- with those columns.\n  declare result cursor like select id, b, c, d from big;\n\n  -- fetch the main row, specified by id_\n  declare main_row cursor for select * from big where id = id_;\n  fetch main_row;\n\n  -- now fetch the result columns out of the main row\n  -- like result means \"the column names found in 'result'\"\n  fetch result from cursor main_row(like result);\n\n  -- this is our first result row\n  out union result;\n\n  -- now we want the related row, but we only need 2 columns\n  declare alt_row cursor for select b, c from big where big.id2 = main_row.id2;\n  fetch alt_row;\n\n  -- update some of the fields of the result from the alt result\n  update cursor result(like alt_row) from cursor alt_row;\n\n  -- and emit that row\n  out union result;\nend;\n")),Object(l.b)("p",null,"Now let's briefly discuss what is above.  The two essential parts are:"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"fetch result from cursor main_row(like result);")),Object(l.b)("p",null,"and"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"update cursor result(like alt_row) from cursor alt_row;")),Object(l.b)("p",null,"In the first case what we're saying is that we want to load the columns of ",Object(l.b)("inlineCode",{parentName:"p"},"result")," from ",Object(l.b)("inlineCode",{parentName:"p"},"main_row"),"\nbut we only want to take the columns that are actually present in ",Object(l.b)("inlineCode",{parentName:"p"},"result"),".  So this is a narrowing\nof a wide row into a smaller row.  In this case the smaller row, ",Object(l.b)("inlineCode",{parentName:"p"},"result")," is what we want to emit.\nWe needed the other columns to compute ",Object(l.b)("inlineCode",{parentName:"p"},"alt_row"),"."),Object(l.b)("p",null,"The second case, what we're saying is that we want update ",Object(l.b)("inlineCode",{parentName:"p"},"result")," by replacing the columns\nfound in ",Object(l.b)("inlineCode",{parentName:"p"},"alt_row")," with the values in ",Object(l.b)("inlineCode",{parentName:"p"},"alt_row"),".   So in this case we're writing a smaller cursor\ninto part of a wider cursor.  Note that we used the ",Object(l.b)("inlineCode",{parentName:"p"},"update")," form here becuase it preserves\nall other columns.  If we used ",Object(l.b)("inlineCode",{parentName:"p"},"fetch")," we would be rewriting the entire row contents, using ",Object(l.b)("inlineCode",{parentName:"p"},"NULL"),"\nif necessary, not desired here."),Object(l.b)("p",null,"Here is the rewritten version of the above procedure; this is what ultimately gets compiled into C."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"CREATE PROC foo (id_ INTEGER NOT NULL)\nBEGIN\n  DECLARE result CURSOR LIKE SELECT id, b, c, d FROM big;\n  DECLARE main_row CURSOR FOR SELECT * FROM big WHERE id = id_;\n  FETCH main_row;\n\n  FETCH result(id, b, c, d)\n    FROM VALUES(main_row.id, main_row.b, main_row.c, main_row.d);\n  OUT UNION result;\n\n  DECLARE alt_row CURSOR FOR SELECT b, c FROM big WHERE big.id2 = main_row.id2;\n  FETCH alt_row;\n\n  UPDATE CURSOR result(b, c) FROM VALUES(alt_row.b, alt_row.c);\n  OUT UNION result;\nEND;\n")),Object(l.b)("p",null,"Of course you could have typed all that before but when there\u2019s 50 odd columns it gets old fast and it\u2019s very error prone.  The sugar form is going to be 100% correct and much less typing."),Object(l.b)("p",null,"Finally, while I've shown both ",Object(l.b)("inlineCode",{parentName:"p"},"LIKE")," forms seperately they can also be used together.  For instance"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"    update cursor C(like X) from cursor D(like X);\n")),Object(l.b)("p",null,'The above would mean, "move the columns that are found in ',Object(l.b)("inlineCode",{parentName:"p"},"X")," from cursor ",Object(l.b)("inlineCode",{parentName:"p"},"D")," to cursor ",Object(l.b)("inlineCode",{parentName:"p"},"C"),'", presumably ',Object(l.b)("inlineCode",{parentName:"p"},"X")," has columns common to both."),Object(l.b)("h3",{id:"fetch-statement-specifics"},"Fetch Statement Specifics"),Object(l.b)("p",null,"Many of the examples used the ",Object(l.b)("inlineCode",{parentName:"p"},"FETCH")," statement in a sort of demonstrative way that is hopefully self-evident but the statement has many forms and so it's wroth going over them specifically.  Below we'll use the letters ",Object(l.b)("inlineCode",{parentName:"p"},"C")," and ",Object(l.b)("inlineCode",{parentName:"p"},"D")," for the names of cursors.  Usually ",Object(l.b)("inlineCode",{parentName:"p"},"C"),";"),Object(l.b)("h4",{id:"for-statement-or-result-set-cursors"},"For Statement or Result Set Cursors"),Object(l.b)("p",null,"A cursor declared in one of these forms:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"declare C cursor for select * from foo;")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"declare C cursor for call foo();"),"  (foo might end with a ",Object(l.b)("inlineCode",{parentName:"li"},"select")," or use ",Object(l.b)("inlineCode",{parentName:"li"},"out union"),")")),Object(l.b)("p",null,"Is either a statement cursor or a result set cursor.  In either case it moves through the results.  You load the next row with"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"FETCH C"),", or"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"FETCH C into x, y, z;"))),Object(l.b)("p",null,"In the first form ",Object(l.b)("inlineCode",{parentName:"p"},"C")," is said to be ",Object(l.b)("em",{parentName:"p"},"automatic")," in that it automatically declares the storage needed to hold all its columns.  As mentioned above automatic cursors have storage for their row."),Object(l.b)("p",null,"Having done this fetch you can use C as a scalar variable to see if it holds a row, e.g."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from foo limit 1;\nfetch C;\nif C then\n  -- bingo we have a row\n  call printf("%s\\n", C.whatever);\nend if\n')),Object(l.b)("p",null," You can easily iterate, e.g."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'declare C cursor for select * from foo;\nloop fetch C\nbegin\n  -- one time for every row\n  call printf("%s\\n", C.whatever);\nend;\n')),Object(l.b)("p",null," Automatic cursors are so much easier to use than explicit storage that explicit storage is rarely seen.  Storing to ",Object(l.b)("inlineCode",{parentName:"p"},"out")," parameters is a case where explicit is ok, the ",Object(l.b)("inlineCode",{parentName:"p"},"out")," parameters have to be declared anyway."),Object(l.b)("h4",{id:"for-value-cursors"},"For Value Cursors"),Object(l.b)("p",null," A cursor declared in one of these forms:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"declare C cursor fetch from call foo(args)")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"foo")," must be a procedure that returns one row with ",Object(l.b)("inlineCode",{parentName:"li"},"OUT")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},'`declare C cursor like select 1 id, "x" name;')),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"declare C cursor like X;")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"where X is the name of a table, a view, another cursor, or a procedure that returns a structured result")),Object(l.b)("p",{parentName:"li"},"Is a value cursor.  A value cursor is always ",Object(l.b)("em",{parentName:"p"},"automatic"),", it's purpose is to hold a row.  It doesn't iterate over anything but it can be re-loaded in a loop.")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C")," or ",Object(l.b)("inlineCode",{parentName:"p"},"fetch C into ...")," is not valid on such a cursor, it doesn't have a source to step through"),Object(l.b)("p",{parentName:"li"},"The canonical ways to load such a cursor is:")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from call foo(args);")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"foo")," must be a procedure that returns one row with ",Object(l.b)("inlineCode",{parentName:"li"},"OUT")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C(a,b,c...) from values(x, y, z);")))),Object(l.b)("p",null,"The first form is in some sense the origin of value cursor.  Value cursors were added to the language initially to have a way to capture the single row ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement results, much like result set cursors were added to capture procedure results from ",Object(l.b)("inlineCode",{parentName:"p"},"out union"),".  In the first form the cursor storage (a C struct) is provided by reference as a hidden out parameter to procedure and the procedure fills it in.  The procedure may or may not use the ",Object(l.b)("inlineCode",{parentName:"p"},"out")," statement in its control flow the the cursor might not hold a row.  You can use ",Object(l.b)("inlineCode",{parentName:"p"},"if C then ...")," as before to test for a row."),Object(l.b)("p",null,"The second form is more interesting as it allows the cursor to be loaded from arbitary expressions subject to some rules:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"you should think of the cursor as a logical row, it's fully loaded or not, therefore you must specify enough columns in the column list to ensure that all ",Object(l.b)("inlineCode",{parentName:"li"},"NOT NULL")," columns will get a value"),Object(l.b)("li",{parentName:"ul"},"if not mentioned in the list, NULL will be loaded if possible"),Object(l.b)("li",{parentName:"ul"},"if insufficient columns are named, an error is generated"),Object(l.b)("li",{parentName:"ul"},"if the value types specified are not compatible with the column types mentioned, an error is generated")),Object(l.b)("p",null,"With this form, any possible valid cursor values could be set, but many forms of updates that are common would be awkward. So there are various forms of syntatic sugar that are automatically rewitten into the canonical form.  Several standard rewrites happen."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from values(x, y, z)")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"if no columns are specified this is the same as naming all the columns, in order"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from arguments")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the arguments to the procedure in which this statement appears are used, in order, as the values"),Object(l.b)("li",{parentName:"ul"},"in this case ",Object(l.b)("inlineCode",{parentName:"li"},"C")," is also rewritten into ",Object(l.b)("inlineCode",{parentName:"li"},"C(a,b,c,..)")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from arguments like C")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the arguments to the procedure in which this statement appears are used, by name, as the values"),Object(l.b)("li",{parentName:"ul"},"the order in which the arguments appeared no longer matters, the names that match the columsn of C are used if present"),Object(l.b)("li",{parentName:"ul"},"the formal parameter name may have a single trailing underscore (this is what ",Object(l.b)("inlineCode",{parentName:"li"},"like C")," would generate)"),Object(l.b)("li",{parentName:"ul"},"e.g. if ",Object(l.b)("inlineCode",{parentName:"li"},"C")," has columns ",Object(l.b)("inlineCode",{parentName:"li"},"a")," and ",Object(l.b)("inlineCode",{parentName:"li"},"b")," then there must exist formals named ",Object(l.b)("inlineCode",{parentName:"li"},"a")," or ",Object(l.b)("inlineCode",{parentName:"li"},"a_")," and ",Object(l.b)("inlineCode",{parentName:"li"},"b")," or ",Object(l.b)("inlineCode",{parentName:"li"},"b_")," in any position"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C(a,b) from cursor D(a,b)")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the named columns of D are used as the values"),Object(l.b)("li",{parentName:"ul"},"in this case it becomes: `fetch C(a,b) from values(D.a, D.b);")))),Object(l.b)("p",null,"That most recent form does seem like it saves much but recall the first rewrite:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from cursor D")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"both cursors are expanded into all their columns, creating a copy from one to the other"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"fetch C from D")," can be used  if the cursors have the exact same column names and types; it also generates slightly better code and is a common case")),Object(l.b)("p",{parentName:"li"},"It is very normal to want to use some of the columns of a cursor in a standard way, these ",Object(l.b)("inlineCode",{parentName:"p"},"like")," forms do that job.")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C from cursor D(like C)")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"here ",Object(l.b)("inlineCode",{parentName:"li"},"D"),' is presumed to be "bigger" than ',Object(l.b)("inlineCode",{parentName:"li"},"C"),", in that it has all of the ",Object(l.b)("inlineCode",{parentName:"li"},"C")," columns and maybe more.  The ",Object(l.b)("inlineCode",{parentName:"li"},"like C")," expands into the names of the ",Object(l.b)("inlineCode",{parentName:"li"},"C")," columns so ",Object(l.b)("inlineCode",{parentName:"li"},"C")," is loaded from the ",Object(l.b)("inlineCode",{parentName:"li"},"C")," part of ",Object(l.b)("inlineCode",{parentName:"li"},"D")),Object(l.b)("li",{parentName:"ul"},"the expansion might be ",Object(l.b)("inlineCode",{parentName:"li"},"fetch C(a, b, g) from values (D.a, D.b, D.g)")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"D")," might have had fields ",Object(l.b)("inlineCode",{parentName:"li"},"c, d, e, f")," which were not used because they are not in ",Object(l.b)("inlineCode",{parentName:"li"},"C"),".")),Object(l.b)("p",{parentName:"li"},"The symmetric operation, loading some of the columns of a wider cursor can be expressed neatly:")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C(like D) from cursor D")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"like D")," expands into the columns of ",Object(l.b)("inlineCode",{parentName:"li"},"D")," causing the cursor to be loaded with what's in ",Object(l.b)("inlineCode",{parentName:"li"},"D")," and ",Object(l.b)("inlineCode",{parentName:"li"},"NULL")," (if needed)"),Object(l.b)("li",{parentName:"ul"},"this might look like ",Object(l.b)("inlineCode",{parentName:"li"},"fetch C(d1, d2) from values(D.d1, D.d2)"))))),Object(l.b)("p",null,"Like can be used in both places, for instance suppose ",Object(l.b)("inlineCode",{parentName:"p"},"E")," is a cursor that has a subset of the rows of both ",Object(l.b)("inlineCode",{parentName:"p"},"C")," and ",Object(l.b)("inlineCode",{parentName:"p"},"D"),".  Without ever loading this cursor, just by defining its type you can write a form like this:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"fetch C(like E) from cursor D(like E)")),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this means take the column names found in ",Object(l.b)("inlineCode",{parentName:"li"},"E")," and copy them from D to C."),Object(l.b)("li",{parentName:"ul"},"the usual type checking is done of course but the types of the columns in ",Object(l.b)("inlineCode",{parentName:"li"},"E")," won't matter, only those in ",Object(l.b)("inlineCode",{parentName:"li"},"C")," and ",Object(l.b)("inlineCode",{parentName:"li"},"D"))),Object(l.b)("p",{parentName:"li"},"As is mentioned above, the ",Object(l.b)("inlineCode",{parentName:"p"},"fetch"),' form means to load an entire row into the cursor.  This is important because "half loaded" cursors would be semantically problematic.  However there are many cases where you might like to amend the values of an already loaded cursor.  You can do this with the ',Object(l.b)("inlineCode",{parentName:"p"},"update")," form.")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"`update cursor C(a,b,..) from values(1,2,..);"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the update form is a no-op if the cursor is not already loaded with values (!!)"),Object(l.b)("li",{parentName:"ul"},"the columns and values are type checked so a valid row is ensured (or no row)"),Object(l.b)("li",{parentName:"ul"},"all the re-writes above are legal so ",Object(l.b)("inlineCode",{parentName:"li"},"update cursor C(like D) from D")," is possible, it is in fact the use-case for which this was designed.")))),Object(l.b)("h3",{id:"calling-procedures-with-bulk-arguments"},"Calling Procedures with Bulk Arguments"),Object(l.b)("p",null,"It's often desireable to treat bundles of arguments as a unit, or cursors as a unit, especially calling other procedures.  The patterns above\nare very helpful for moving data between cursors, arguments, and the database.  These can be rounded out with similar constructs for\nprocedure calls as follows."),Object(l.b)("p",null,"First we'll define some shapes to use in the examples.  Note that we made ",Object(l.b)("inlineCode",{parentName:"p"},"U")," using ",Object(l.b)("inlineCode",{parentName:"p"},"T"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create table T(x integer not null, y integer not null,  z integer not null);\ncreate table U(like T, a integer not null, b integer not null);\n")),Object(l.b)("p",null,"As we've seen, we can do this:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'create proc p1(like T)\nbegin\n   call printf("%d %d %d\\n", x_, y_, z_);\nend;\n')),Object(l.b)("p",null,"But the following is also possible. It isn't an especially fabulous example but of course\nit generalizes. The arguments will be ",Object(l.b)("inlineCode",{parentName:"p"},"x_"),", ",Object(l.b)("inlineCode",{parentName:"p"},"y_"),", and ",Object(l.b)("inlineCode",{parentName:"p"},"z_"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},'create proc p2(like T)\nbegin\n  call printf("%d %d %d\\n", from arguments);\nend;\n')),Object(l.b)("p",null,"Now we might want to chain these things together.  This next example uses a cursor to\ncall ",Object(l.b)("inlineCode",{parentName:"p"},"p1"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc q1()\nbegin\n declare C cursor for select * from T;\n loop fetch C\n begin\n   /* this is the same as call p(C.x, C.y, C.z) */\n   call p1(from C);\n end;\nend;\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"like")," construct allows you to select some of the arguments, or\nsome of a cursor to use as arguments.  This next procedure has more arguments\nthan just ",Object(l.b)("inlineCode",{parentName:"p"},"T"),". The arguments will be ",Object(l.b)("inlineCode",{parentName:"p"},"x_"),", ",Object(l.b)("inlineCode",{parentName:"p"},"y_"),", ",Object(l.b)("inlineCode",{parentName:"p"},"z_"),", ",Object(l.b)("inlineCode",{parentName:"p"},"a_"),", ",Object(l.b)("inlineCode",{parentName:"p"},"b_")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc q2(like U)\nbegin\n  /* just the args that match T: so this is still call p(x_, y_, z_) */\n  call p1(from arguments like T);\nend;\n")),Object(l.b)("p",null,"Or similarly. using a cursor."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create proc q3(like U)\nbegin\n declare C cursor for select * from U;\n loop fetch C\n begin\n  /* just the columns that match T so this is still call p(C.x, C.y, C.z) */\n  call p1(from C like T);\n end;\nend;\n")),Object(l.b)("p",null,"Note that the ",Object(l.b)("inlineCode",{parentName:"p"},"from")," argument forms do not have to be all the arguments.  For instance\nyou can get columns from two cursors like so:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  call something(from C, from D)\n")),Object(l.b)("p",null,"All the varieties can be combined but of course the procedure signature must match.  And\nall these forms work in function expressions as well as procedure calls."),Object(l.b)("p",null,"e.g."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  set x := a_function(from C);\n")),Object(l.b)("p",null,"Since these forms are simply syntatic sugar, they can also appear inside of functions in\nSQL statements. The variables mentioned will be expanded and become bound variables just\nlike any other variable that appears in a SQL statement."),Object(l.b)("p",null,"Note the form  x IN (from arguments) is not supported at this time, though this is a realitively\neasy addition."),Object(l.b)("h3",{id:"missing-data-columns-nulls-and-dummy-data"},"Missing Data Columns, Nulls and Dummy Data"),Object(l.b)("p",null,"What follows are the rules for columns that are missing.  This are also done by rewriting the AST. There are several options, with the dummy data choices (see below) being really only interesting in test code.  None of what follows applies to the ",Object(l.b)("inlineCode",{parentName:"p"},"update cursor")," statement because its purpose is to do partial updates."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"When fetching a row all the columns must come from somewhere, if the column is mentioned or mentioned by rewrite then it must have a value mentioned, or mentioned by rewrite"),Object(l.b)("li",{parentName:"ul"},"For columns that are not mentioned, a NULL value is used if it is legal",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"fetch C(a) from values(1)")," might turn into ",Object(l.b)("inlineCode",{parentName:"li"},"fetch C(a,b,c,d) from values (1, NULL, NULL, NULL)"))))),Object(l.b)("p",null,"In addition to the automatic NULL you may add the annotation ",Object(l.b)("inlineCode",{parentName:"p"},"@dummy_seed([long integer expression])"),", if present"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the expression is evaluated and stored in the hidden variable ",Object(l.b)("em",{parentName:"li"},"seed")),Object(l.b)("li",{parentName:"ul"},"all integers, and long integers get ",Object(l.b)("em",{parentName:"li"},"seed")," as their value (possibly truncated)"),Object(l.b)("li",{parentName:"ul"},"booleans get 1 if and only if ",Object(l.b)("em",{parentName:"li"},"seed")," is non-zero"),Object(l.b)("li",{parentName:"ul"},'strings get the name of the string column an underscore and the value as text (e.g.   "myText',Object(l.b)("em",{parentName:"li"},'7" if _seed')," is 7)"),Object(l.b)("li",{parentName:"ul"},"blobs are not currently supported for dummy data (CQL is missing blob conversions which are needed first)")),Object(l.b)("p",null,"This construct is hugely powerful in a loop to create many complete rows with very little effort, even if the schema change over time."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"declare i integer not null;\ndeclare C like my_table;\nset i := 0;\nwhile (i < 20)\nbegin\n   fetch C(id) from values(i+10000) @dummy_seed(i);\n   insert into my_table from cursor C;\nend;\n")),Object(l.b)("p",null,"Now in this example we don't need to know anything about ",Object(l.b)("inlineCode",{parentName:"p"},"my_table")," other than that it has a column named ",Object(l.b)("inlineCode",{parentName:"p"},"id"),".  As the example shows several things."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"we got the shape of the cursor from the table we were inserting into"),Object(l.b)("li",{parentName:"ul"},"you can do your own computation for some of the columns (those named) and leave the unnamed values to be defaulted"),Object(l.b)("li",{parentName:"ul"},"the rewrites mentioned above work for the ",Object(l.b)("inlineCode",{parentName:"li"},"insert")," statement as well as ",Object(l.b)("inlineCode",{parentName:"li"},"fetch")),Object(l.b)("li",{parentName:"ul"},"in fact ",Object(l.b)("inlineCode",{parentName:"li"},"insert into my_table(id) values(i+10000) @dummy_seed(i)")," would have worked too with no cursor at all",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"bonus, dummy blob data does work in insert statements because SQLite can do the string conversion easily"),Object(l.b)("li",{parentName:"ul"},"the dummy value for a blob is a blob that holds the text of the column name and the text of the seed just like a string column")))),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"@dummy_seed")," form can be modified with ",Object(l.b)("inlineCode",{parentName:"p"},"@dummy_nullables"),", this indicates that rather than using NULL for any nullable value that is missing, CQL should use the seed value.  This overrides the default behavior of using NULL where columns are needed.  Note the NULL filling works a little differently on insert statements.  Since SQLite will provide a NULL if one is legal the column doesn't have to be added to the list with a NULL value during rewriting, it can simply be omitted, making the statement smaller."),Object(l.b)("p",null,"Finally for ",Object(l.b)("inlineCode",{parentName:"p"},"insert")," statement only, SQLite will normally use the default value of a column if it has one, so there is no need to add missing columsn with default values to the insert statement.  However if you specify ",Object(l.b)("inlineCode",{parentName:"p"},"@dummy_defaults")," then columns with a default value will instead be rewritten and they will get ",Object(l.b)("inlineCode",{parentName:"p"},"_seed_")," as their value."),Object(l.b)("p",null,"Some examples.  Suppose columns a, b, c are not null;  m, n are nullable; and x, y have defaults."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000)\n-- rewrites to\ninsert into my_table(a, b, c) values(7, 1000, 1000);\n")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000) @dummy_nullables\n-- rewrites to\ninsert into my_table(a, b, c, m, n) values(7, 1000, 1000, 1000, 1000);\n")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"-- as written\ninsert into my_table(a) values(7) @dummy_seed(1000) @dummy_nullables @dummy_defaults\n-- rewrites to\ninsert into my_table(a, b, c, m, n, x, y) values(7, 1000, 1000, 1000, 1000, 1000, 1000);\n")),Object(l.b)("p",null,"The sugar features on ",Object(l.b)("inlineCode",{parentName:"p"},"fetch"),", ",Object(l.b)("inlineCode",{parentName:"p"},"insert"),", and ",Object(l.b)("inlineCode",{parentName:"p"},"update cursor")," are as symmetric as possible, but again, dummy data is generally only interesting in test code. Dummy  data will continue to give you valid test rows even if columns are added or removed from the tables in question."))}u.isMDXComponent=!0}}]);