(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return h}));var a=n(2),i=n(6),l=(n(0),n(139)),r=["components"],o={id:"ch09",title:"Chapter 9: Statements Summary and Error Checking",sidebar_label:"Chapter 9: Statements Summary and Error Checking"},s={unversionedId:"ch09",id:"ch09",isDocsHomePage:!1,title:"Chapter 9: Statements Summary and Error Checking",description:"\x3c!---",source:"@site/../CQL_Guide/ch09.md",slug:"/ch09",permalink:"/cql-guide/ch09",version:"current",lastUpdatedBy:"Winnie Quinn",lastUpdatedAt:1627625304,sidebar_label:"Chapter 9: Statements Summary and Error Checking",sidebar:"someSidebar",previous:{title:"Chapter 8: Functions",permalink:"/cql-guide/ch08"},next:{title:"Chapter 10: Schema Management Features",permalink:"/cql-guide/ch10"}},c=[{value:"The Primary SQL Statements",id:"the-primary-sql-statements",children:[]},{value:"The Primary Procedure Statements",id:"the-primary-procedure-statements",children:[]},{value:"The &quot;Meta&quot; Statements",id:"the-meta-statements",children:[]},{value:"Important Program Fragments",id:"important-program-fragments",children:[]},{value:"Special Note on the JOIN...USING form",id:"special-note-on-the-joinusing-form",children:[]}],b={rightToc:c};function h(e){var t=e.components,n=Object(i.a)(e,r);return Object(l.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,'The following is a brief discussion of the major statement types and the semantic rules that CQL enforces for each of the statements.  A detailed discussion of SQL statements (the bulk of these) is beyond the scope of this document and you should refer to the SQLite documentation for most details.  However, in many cases CQL does provide additional enforcement and it is helpful to describe the basic checking that happens for each fragment of CQL.  A much\nmore authoritative list of the things CQL checks for can be inferred from the error documentation.  "Tricky" errors have examples and suggested remediation.'),Object(l.b)("h3",{id:"the-primary-sql-statements"},"The Primary SQL Statements"),Object(l.b)("p",null,"These are roughly, the statements that involve the database."),Object(l.b)("h4",{id:"the-select-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"SELECT")," Statement"),Object(l.b)("p",null,"Top level statement list processing for select.  This is easily the hardest\nstatement to process. Each clause has its own set of complex rules and\nthe result of previous clauses constrains the next in a complex fashion.\nAmong the things that are verified:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the mentioned tables exist and have the mentioned columns"),Object(l.b)("li",{parentName:"ul"},"the columns are type compatible in their context"),Object(l.b)("li",{parentName:"ul"},"any variables in the expressions are compatible"),Object(l.b)("li",{parentName:"ul"},"aggregate functions are used only in places where aggregation makes sense"),Object(l.b)("li",{parentName:"ul"},"column and table names are unambiguous, especially when self-joins are involved"),Object(l.b)("li",{parentName:"ul"},"compound selects (e.g. with UNION) are type-consistent in all the fragments"),Object(l.b)("li",{parentName:"ul"},"the projection of a select has unique column labels if they are used")),Object(l.b)("h4",{id:"the-select--statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"SELECT *")," Statement"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"SELECT *")," is special in that it creates its own struct type by assembling\nall the columns of all the tables in the select's join result.  CQL rewrites these\ncolumn names into a new ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT")," with the specific columns explicitly listed.\nWhile this makes the program slightly bigger it means that logically deleted columns\nare never present in results because ",Object(l.b)("inlineCode",{parentName:"p"},"SELECT *")," won't select them and attempting\nto use a logically deleted column results in an error."),Object(l.b)("h4",{id:"the-create-table-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE TABLE")," Statement"),Object(l.b)("p",null,"Unlike the other parts of DDL we actually deeply care about the tables.\nWe have to grab all the columns and column types out of it and create\nthe appropriate structure type for the table.\nAlong the way we validate a bunch of stuff like:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"verify unique table name"),Object(l.b)("li",{parentName:"ul"},"no duplicate column names"),Object(l.b)("li",{parentName:"ul"},"recursive correctness of constraints (see constraints discussion below)")),Object(l.b)("h5",{id:"the-unique-key-clause"},"The ",Object(l.b)("inlineCode",{parentName:"h5"},"UNIQUE KEY")," Clause"),Object(l.b)("p",null,"Similar to other constraints, we don't actually do anything with this\nother than offer some validation.  Again we use the usual helpers\nfor name lookup within the context of the table that contains the constraint."),Object(l.b)("h5",{id:"the-foreign-key-clause"},"The ",Object(l.b)("inlineCode",{parentName:"h5"},"FOREIGN KEY")," Clause"),Object(l.b)("p",null,"Similar to other constraints, we don't actually do anything with this\nother than offer some validation.  Again we use the usual helpers\nfor name lookup within the context of the table with the foreign key.\nNote that the foreign has to be validated against two tables to fully validate it."),Object(l.b)("h5",{id:"the-primary-key-clause"},"The ",Object(l.b)("inlineCode",{parentName:"h5"},"PRIMARY KEY")," Clause"),Object(l.b)("p",null,"Similar to other constraints, we don't actually do anything with this\nother than offer some validation.  Again we use the usual helpers\nfor name lookup within the context of the table with the primary key."),Object(l.b)("h5",{id:"the-check-clause"},"The ",Object(l.b)("inlineCode",{parentName:"h5"},"CHECK")," Clause"),Object(l.b)("p",null,"Similar to other constraints, we don't actually do anything with this\nother than offer some validation.  The ",Object(l.b)("inlineCode",{parentName:"p"},"CHECK")," clause is validated\nafter the entire table has been processed so that even if it appears\nearly in the table, the clause can use any columns defined later in the\ntable."),Object(l.b)("h4",{id:"the-create-index-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE INDEX")," Statement"),Object(l.b)("p",null,"CQL doesn't really do anything with indices but we do validate that they make sense (so we lookup all the names of all the columns and so forth)."),Object(l.b)("h4",{id:"the-create-view-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE VIEW")," Statement"),Object(l.b)("p",null,"Create view analysis is very simple because the ",Object(l.b)("inlineCode",{parentName:"p"},"select")," analysis does the heavy lifting.  All we\nhave to do is validate that the view is unique, then validate the select statement."),Object(l.b)("p",null,"Additionally, views must not be allowed to have any NULL type columns, all nulls must be converted to\nsome type with a CAST.   e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"create view foo as select NULL n")," is not valid.  NULL is not a real storage type."),Object(l.b)("h4",{id:"the-create-trigger-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE TRIGGER")," Statement"),Object(l.b)("p",null,"The create trigger statement is quite a beast, validations include:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the trigger name must be unique"),Object(l.b)("li",{parentName:"ul"},"For ",Object(l.b)("inlineCode",{parentName:"li"},"insert"),' the "new.*" table is available in expressions/statement'),Object(l.b)("li",{parentName:"ul"},"For ",Object(l.b)("inlineCode",{parentName:"li"},"delete"),' the "old.*" table is available in expressions/statements'),Object(l.b)("li",{parentName:"ul"},"For ",Object(l.b)("inlineCode",{parentName:"li"},"update")," both are available",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"If optional columns present in the ",Object(l.b)("inlineCode",{parentName:"li"},"update"),", they must be unique/valid"))),Object(l.b)("li",{parentName:"ul"},"The ",Object(l.b)("inlineCode",{parentName:"li"},"when")," expression must evaluate to a numeric"),Object(l.b)("li",{parentName:"ul"},"The statement list must be error free with the usual rules plus new/old"),Object(l.b)("li",{parentName:"ul"},"The ",Object(l.b)("inlineCode",{parentName:"li"},"raise")," function may be used inside a trigger (NYI)"),Object(l.b)("li",{parentName:"ul"},"The table name must be a table (not a view) UNLESS the trigger type is ",Object(l.b)("inlineCode",{parentName:"li"},"INSTEAD OF")),Object(l.b)("li",{parentName:"ul"},"select statements inside the statement block do not count as returns for the procedure that includes the create trigger")),Object(l.b)("h4",{id:"the-drop-table-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DROP TABLE")," Statement"),Object(l.b)("p",null,"This is the basic checking for the drop table statement:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the table must exist in some version"),Object(l.b)("li",{parentName:"ul"},"it has to be a table and not a view")),Object(l.b)("h4",{id:"the-drop-view-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DROP VIEW")," Statement"),Object(l.b)("p",null,"This is the basic checking for the drop view statement:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the view must exist in some version"),Object(l.b)("li",{parentName:"ul"},"it has to be a view and not a table")),Object(l.b)("h4",{id:"the-drop-index-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DROP INDEX")," Statement"),Object(l.b)("p",null,"This is the basic checking for the drop index statement:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the index must exist in some version"),Object(l.b)("li",{parentName:"ul"},"it could be deleted now, that's ok, but the name has to be valid")),Object(l.b)("h4",{id:"the-drop-trigger-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DROP TRIGGER")," Statement"),Object(l.b)("p",null,"This is the basic checking for the drop trigger statement"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the trigger  must exist in some version"),Object(l.b)("li",{parentName:"ul"},"it could be deleted now, that's ok, but the name has to be valid")),Object(l.b)("h4",{id:"the-raise-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"RAISE")," Statement"),Object(l.b)("p",null,"CQL validates that ",Object(l.b)("inlineCode",{parentName:"p"},"RAISE")," is being used in the context of a trigger and that\nit has the correct arguments."),Object(l.b)("h4",{id:"the-alter-table-add-column-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"ALTER TABLE ADD COLUMN")," Statement"),Object(l.b)("p",null,"To validate ",Object(l.b)("inlineCode",{parentName:"p"},"alter table add column")," we check the following:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the table must exist and not be a view (in any version)"),Object(l.b)("li",{parentName:"ul"},"the column definition of the new column must be self-consistent"),Object(l.b)("li",{parentName:"ul"},"no auto increment columns may be added"),Object(l.b)("li",{parentName:"ul"},"added columns must be either nullable or have a default value")),Object(l.b)("p",null,"Note: Alter statements are typically used in the context of migration so it's\npossible the table that is mentioned is condemned in a future version.  We still have to run\nthe intervening upgrade steps so basically DDL gets to ignore the current deadness\nof the table as in context it's might be \"not dead yet\".  This will be more obvious\nin the context of the schema maintenance features. (q.v.)"),Object(l.b)("h4",{id:"the-delete-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DELETE")," Statement"),Object(l.b)("p",null,"The delete analyzer sets up a scope for the table being\ndeleted and the validates the WHERE clause if present against that scope.\nAdditionally we verify that the table actually was defined and is not a view."),Object(l.b)("h4",{id:"the-update-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"UPDATE")," Statement"),Object(l.b)("p",null,"The update analyzer sets up the scope for the table(s) being updated.  If there are\noptional clauses (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"LIMIT"),") they are evaluated just like in a select statement\nwith those same helper methods.  Expression fragments are evaluated just as\nin a select statement."),Object(l.b)("h4",{id:"the-insert-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"INSERT")," Statement"),Object(l.b)("p",null,"We check that the table exists and then we walk the columns and the value list\nto make sure they are valid for the table. Also we cannot insert into a view."),Object(l.b)("p",null,"Details:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The column list specifies the columns we will provide, they must exist and be unique."),Object(l.b)("li",{parentName:"ul"},"The columns specified must suffice to insert a row (all not nulls and not default present)"),Object(l.b)("li",{parentName:"ul"},"The insert list specifies the values that are to be inserted."),Object(l.b)("li",{parentName:"ul"},"The type of each value must match the type of the column."),Object(l.b)("li",{parentName:"ul"},"Autoinc columns may be specified as NULL."),Object(l.b)("li",{parentName:"ul"},"If there are too many or too few columns, that is an error."),Object(l.b)("li",{parentName:"ul"},"If no columns are specified that is the same as if all columns had been specified, in table order")),Object(l.b)("h4",{id:"the-throw-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"THROW")," Statement"),Object(l.b)("p",null,"Throw can literally go anywhere, so it's always ok."),Object(l.b)("h4",{id:"the-begin-transaction-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"BEGIN TRANSACTION")," Statement"),Object(l.b)("p",null,"Begin transaction can go anywhere, it's always ok."),Object(l.b)("p",null,"The sqlite documentation can be helpful (CQL syntax is a subset).  See: ",Object(l.b)("a",{parentName:"p",href:"https://www.sqlite.org/lang_transaction.html"},"https://www.sqlite.org/lang_transaction.html")),Object(l.b)("h4",{id:"the-commit-transaction-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"COMMIT TRANSACTION")," Statement"),Object(l.b)("p",null,"Commit transaction can go anywhere, it's always ok."),Object(l.b)("p",null,"The sqlite documentation can be helpful (CQL syntax is a subset).  See: ",Object(l.b)("a",{parentName:"p",href:"https://www.sqlite.org/lang_transaction.html"},"https://www.sqlite.org/lang_transaction.html")),Object(l.b)("h4",{id:"the-rollback-transaction-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"ROLLBACK TRANSACTION")," Statement"),Object(l.b)("p",null,"Rollback trans can go anywhere but if you're using the format\nwhere you rollback to a particular save point then we must have\nseen that name in a ",Object(l.b)("inlineCode",{parentName:"p"},"savepoint")," statement previously or it's an error."),Object(l.b)("p",null,"The sqlite documentation can be helpful (CQL syntax is a subset).  See: ",Object(l.b)("a",{parentName:"p",href:"https://www.sqlite.org/lang_transaction.html"},"https://www.sqlite.org/lang_transaction.html")),Object(l.b)("h4",{id:"the-savepoint-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"SAVEPOINT")," Statement"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"savepoint")," statement can go anywhere but we do record this savepoint name\nas having been seen so we can verify it in rollback.  So this is sort of a weak declaration of the savepoint name."),Object(l.b)("p",null,"The sqlite documentation can be helpful (CQL syntax is a subset).  ",Object(l.b)("a",{parentName:"p",href:"https://www.sqlite.org/lang_savepoint.html"},"https://www.sqlite.org/lang_savepoint.html")),Object(l.b)("h4",{id:"the-release-savepoint-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"RELEASE SAVEPOINT")," Statement"),Object(l.b)("p",null,"Release savepoint can go anywhere but we must have\nseen that name in a previous ",Object(l.b)("inlineCode",{parentName:"p"},"savepoint")," statement or it's an error."),Object(l.b)("p",null,"The sqlite documentation can be helpful (CQL syntax is a subset). ",Object(l.b)("a",{parentName:"p",href:"https://www.sqlite.org/lang_savepoint.html"},"https://www.sqlite.org/lang_savepoint.html")),Object(l.b)("h4",{id:"the-procedure-savepoint-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"PROCEDURE SAVEPOINT")," Statement"),Object(l.b)("p",null,"A common pattern is to have a savepoint associated with a particular procedure, the savepoint's scope is the same\nas the procedure.  More precisely"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create procedure foo()\nbegin\n  proc savepoint\n  begin\n   -- your code\n  end;\nend;\n")),Object(l.b)("p",null,"Becomes:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create procedure foo()\nbegin\n  savepoint @proc;  -- @proc is always the name of the current procedure\n  begin try\n    -- your code\n    release savepoint @proc;\n  end try;\n  begin catch\n    rollback transaction to savepoint @proc;\n    release savepoint @proc;\n    throw;\n  end catch;\nend;\n")),Object(l.b)("p",null,"This form is not quite syntatic sugar because there are some interesting rules:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"proc savepoint")," form must be used at the top level of the procedure hence no ",Object(l.b)("inlineCode",{parentName:"li"},"leave")," or ",Object(l.b)("inlineCode",{parentName:"li"},"continue")," may escape it"),Object(l.b)("li",{parentName:"ul"},"within ",Object(l.b)("inlineCode",{parentName:"li"},"begin"),"/",Object(l.b)("inlineCode",{parentName:"li"},"end")," the ",Object(l.b)("inlineCode",{parentName:"li"},"return")," form may not be used, you must use ",Object(l.b)("inlineCode",{parentName:"li"},"rollback return")," or ",Object(l.b)("inlineCode",{parentName:"li"},"commit return")," (see below)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"throw")," may be used to return an error as usual"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"proc savepoint")," may be used again, at the top level, in the same procedure, if there are for instance several sequential stages"),Object(l.b)("li",{parentName:"ul"},"a procedure using ",Object(l.b)("inlineCode",{parentName:"li"},"proc savepoint")," could call other such procedure, or a procedure that manipulates savepoints in some other way.")),Object(l.b)("h4",{id:"the-rollback-return-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"ROLLBACK RETURN")," Statement"),Object(l.b)("p",null,"This form may be used only inside of  a ",Object(l.b)("inlineCode",{parentName:"p"},"proc savepoint")," block.  It indicates that the savepoint should be rolled back and then the procedure\nshould return.  It is exactly equivalent to:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  rollback transaction to savepoint @proc;\n  release savepoint @proc;\n  return; -- wouldn't actually be allowed inside of proc savepoint, see note below\n")),Object(l.b)("p",null,"Note: to avoid errors, the loose ",Object(l.b)("inlineCode",{parentName:"p"},"return")," above is not actually allowed inside of ",Object(l.b)("inlineCode",{parentName:"p"},"proc savepoint")," you must use ",Object(l.b)("inlineCode",{parentName:"p"},"rollback return")," or ",Object(l.b)("inlineCode",{parentName:"p"},"commit return"),"."),Object(l.b)("h4",{id:"the-commit-return-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"COMMIT RETURN")," Statement"),Object(l.b)("p",null,"This form may be used only inside of  a ",Object(l.b)("inlineCode",{parentName:"p"},"proc savepoint")," block.  It indicates that the savepoint should be released and then the procedure\nshould return.  It is exactly equivalent to:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"  release savepoint @proc;\n  return; -- wouldn't actually be allowed inside of proc savepoint, see note below\n")),Object(l.b)("p",null,"Of course this isn't exactly a commit, in that there might be an outer savepoint or outer transaction that might\nstill be rolled back but it is commited at its level of nesting if you will.  Or, equivalently, you can think of\nit as merging the savepoint into the transaction in flight."),Object(l.b)("p",null,"Note: to avoid errors, the loose ",Object(l.b)("inlineCode",{parentName:"p"},"return")," above is not actually allowed inside of ",Object(l.b)("inlineCode",{parentName:"p"},"proc savepoint")," you must use ",Object(l.b)("inlineCode",{parentName:"p"},"rollback return")," or ",Object(l.b)("inlineCode",{parentName:"p"},"commit return"),"."),Object(l.b)("h4",{id:"the-create-virtual-table-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE VIRTUAL TABLE")," Statement"),Object(l.b)("p",null,"The SQLite ",Object(l.b)("inlineCode",{parentName:"p"},"CREATE VIRTUAL TABLE")," form (",Object(l.b)("a",{parentName:"p",href:"https://sqlite.org/lang_createvtab.html"},"https://sqlite.org/lang_createvtab.html"),") is problematic from CQL because:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"not parseable, because the module arguments can be literally anything (or nothing), even a letter to your gramma."),Object(l.b)("li",{parentName:"ul"},"the arguments do not necessarily say anything about the table's schema at all")),Object(l.b)("p",null,"So the CQL form departs from the standard syntax to this form:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create virtual table virt_table using my_module [(module arguments)]  as (\n  id integer not null,\n  name text\n);\n")),Object(l.b)("p",null,"The part after the ",Object(l.b)("inlineCode",{parentName:"p"},"AS")," is used by CQL as a table declaration for the virtual table.  The grammar for that\nis exactly the same as a normal ",Object(l.b)("inlineCode",{parentName:"p"},"CREATE TABLE")," statement.  However that part is not transmitted to\nSQLite; when the table is created, SQLite sees only the part it cares about, the part before the ",Object(l.b)("inlineCode",{parentName:"p"},"AS"),"."),Object(l.b)("p",null,"In order to have strict parsing rules, the module arguments follow one of these forms:"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"no arguments at all"),Object(l.b)("li",{parentName:"ol"},"a list of identifiers, constants, and parenthesized sublists just like in the ",Object(l.b)("inlineCode",{parentName:"li"},"@attribute")," form"),Object(l.b)("li",{parentName:"ol"},"the words ",Object(l.b)("inlineCode",{parentName:"li"},"arguments following"))),Object(l.b)("h5",{id:"case-1-example"},"Case 1 Example"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create virtual table virt_table using my_module as (\n  id integer not null,\n  name text\n);\n")),Object(l.b)("p",null,"becomes (to SQLite)"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"CREATE VIRTUAL TABLE virt_table USING my_module;\n")),Object(l.b)("p",null,"Note: empty arguments ",Object(l.b)("inlineCode",{parentName:"p"},"USING my_module()")," are not allowed in the SQLite docs but do seem to work in SQLite.\nWe take the position that no args should be done with no parens, at least for now."),Object(l.b)("h5",{id:"case-2-example"},"Case 2 Example"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"create virtual table virt_table using my_module(foo, 'goo', (1.5, (bar, baz))) as (\n  id integer not null,\n  name text\n);\n")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},'CREATE VIRTUAL TABLE virt_table USING my_module(foo, "goo", (1.5, (bar, baz)));\n')),Object(l.b)("p",null,"This form allows for very flexible arguments but not totally arbitary arguments, so it can still be\nparsed and validated."),Object(l.b)("h5",{id:"case-3-example"},"Case 3 Example"),Object(l.b)("p",null,"This case recognizes the popular choice that the arguments are often the actual schema declaration\nfor the table in question. So:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"create virtual table virt_table using my_module(arguments following) as (\n  id integer not null,\n  name text\n);\n")),Object(l.b)("p",null,"becomes"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"CREATE VIRTUAL TABLE virt_table USING my_module(\n  id INTEGER NOT NULL,\n  name TEXT\n);\n")),Object(l.b)("p",null,"The normalized text (keywords capitalized, whitespace normalized) of the table declaration in the ",Object(l.b)("inlineCode",{parentName:"p"},"as")," clause is used as the arguments."),Object(l.b)("h5",{id:"other-details"},"Other details"),Object(l.b)("p",null,"Virtual tables go into their own section in the JSON and they include the ",Object(l.b)("inlineCode",{parentName:"p"},"module")," and ",Object(l.b)("inlineCode",{parentName:"p"},"moduleArgs")," entries, they are additionally\nmarked ",Object(l.b)("inlineCode",{parentName:"p"},"isVirtual")," in case you want to use the same processing code for virtual tables as normal tables.  The JSON format is otherwise\nthe same, although some things can't happen in virtual tables (e.g. there is no ",Object(l.b)("inlineCode",{parentName:"p"},"TEMP")," option so ",Object(l.b)("inlineCode",{parentName:"p"},'"isTemp"')," must be false in the JSON."),Object(l.b)("p",null,"For purposes of schema processing, virtual tables are on the ",Object(l.b)("inlineCode",{parentName:"p"},"@recreate")," plan, just like indices, triggers, etc.  This is the only option since\nthe ",Object(l.b)("inlineCode",{parentName:"p"},"alter table")," form is not allowed on a virtual table."),Object(l.b)("p",null,'Semantic validation enforces "no alter statements on virtual tables" as well as other things like, no indices, and no triggers, since SQLite\ndoes not support any of those things.'),Object(l.b)("p",null,"Finally, because virtual tables are on the ",Object(l.b)("inlineCode",{parentName:"p"},"@recreate")," plan, you may not have foreign keys that reference virtual tables. Such keys seem\nlike a bad idea in any case."),Object(l.b)("h3",{id:"the-primary-procedure-statements"},"The Primary Procedure Statements"),Object(l.b)("p",null,"These are the statements which form the language of procedures, and do not involve the database."),Object(l.b)("h4",{id:"the-create-procedure-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CREATE PROCEDURE")," Statement"),Object(l.b)("p",null,"Semantic analysis of stored procedures is fairly easy at the core:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"check for duplicate names"),Object(l.b)("li",{parentName:"ul"},"validate the parameters are well formed"),Object(l.b)("li",{parentName:"ul"},"set the current proc in flight (this not allowed to nest)"),Object(l.b)("li",{parentName:"ul"},"recurse on the statement list and prop errors"),Object(l.b)("li",{parentName:"ul"},"record the name of the procedure for callers\nIn addition, while processing the statement:"),Object(l.b)("li",{parentName:"ul"},"we determine if it uses the database, this will change the emitted signature of the proc to include a ",Object(l.b)("inlineCode",{parentName:"li"},"sqlite3 *db"),"\ninput argument and it will return a sqlite error code (e.g. ",Object(l.b)("inlineCode",{parentName:"li"},"SQLITE_OK"),")"),Object(l.b)("li",{parentName:"ul"},'select statements that are loose in the proc represent the "return" of that\nselect;  this changes the signature to include a ',Object(l.b)("inlineCode",{parentName:"li"},"sqlite3_stmt **pstmt")," parameter corresponding to the returned statement")),Object(l.b)("h4",{id:"the-if-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"IF")," Statement"),Object(l.b)("p",null,"The top level if node links the initial condition with a possible\nseries of else_if nodes and then the else node.  Each condition is\nchecked for validity. The conditions must be valid expressions that\ncan be converted to a boolean."),Object(l.b)("h4",{id:"the-set-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"SET")," Statement"),Object(l.b)("p",null,"The set statement is for variable assignment.  We just validate\nthat the target exists and is compatible with the source.\nCursor variables cannot be set with simple assignment and CQL generates\nerrors if you attempt to do so."),Object(l.b)("h4",{id:"the-let-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"LET")," Statement"),Object(l.b)("p",null,"Let combines a ",Object(l.b)("inlineCode",{parentName:"p"},"DECLARE")," and a ",Object(l.b)("inlineCode",{parentName:"p"},"SET"),".  The variable is declared to be\nthe exact type of the right hand side.  All the validations for ",Object(l.b)("inlineCode",{parentName:"p"},"DECLARE"),"\nand ",Object(l.b)("inlineCode",{parentName:"p"},"SET")," are applicable, but there is no chance that the variable will\nnot be compatible with the expression.  The expression could still be\nerroneous in the first place.  The variable could be a duplicate."),Object(l.b)("h4",{id:"the-switch-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"SWITCH")," Statement"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"SWITCH")," form requires a number of conditions to successfully map\ndown to a ",Object(l.b)("inlineCode",{parentName:"p"},"C")," ",Object(l.b)("inlineCode",{parentName:"p"},"switch")," statement.  These are:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the switch-expression must be a not-null integral type (",Object(l.b)("inlineCode",{parentName:"li"},"integer not null")," or ",Object(l.b)("inlineCode",{parentName:"li"},"long integer not null"),")",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"WHEN")," expressions must be losslessly promotable to the type of the switch-expression"))),Object(l.b)("li",{parentName:"ul"},"the values in the ",Object(l.b)("inlineCode",{parentName:"li"},"WHEN")," clauses must be unique"),Object(l.b)("li",{parentName:"ul"},"If ",Object(l.b)("inlineCode",{parentName:"li"},"ALL VALUES")," is present then:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the switch-expression must be of an enum type"),Object(l.b)("li",{parentName:"ul"},"the ",Object(l.b)("inlineCode",{parentName:"li"},"WHEN")," values must cover every value of the enum except those beginning with '_'"),Object(l.b)("li",{parentName:"ul"},"there can be no extra ",Object(l.b)("inlineCode",{parentName:"li"},"WHEN")," values not in the enum"),Object(l.b)("li",{parentName:"ul"},"there can be no ",Object(l.b)("inlineCode",{parentName:"li"},"ELSE")," clause")))),Object(l.b)("h4",{id:"the-declare-procedure-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE PROCEDURE")," Statement"),Object(l.b)("p",null,"There are three forms of this declaration:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"a regular procedure with no DML",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. ",Object(l.b)("inlineCode",{parentName:"li"},"declare proc X(id integer);")))),Object(l.b)("li",{parentName:"ul"},"a regular procedure that uses DML (it will need a db parameter and returns a result code)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. ",Object(l.b)("inlineCode",{parentName:"li"},"declare proc X(id integer) using transaction;")))),Object(l.b)("li",{parentName:"ul"},"a procedure that returns a result set, you provide the result columns",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. ",Object(l.b)("inlineCode",{parentName:"li"},"declare proc X(id integer) : (A bool not null, B text);"),"\nThe main validations here are that there are no duplicate parameter names, or return value columns.")))),Object(l.b)("h4",{id:"the-declare-function-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE FUNCTION")," Statement"),Object(l.b)("p",null,"Function declarations are similar to than procedures; there must be a return type\n(use proc if there is none).  The ",Object(l.b)("inlineCode",{parentName:"p"},"DECLARE SELECT FUNCTION")," form indicates a function\nvisible to SQLite, other functions are usable in the ",Object(l.b)("inlineCode",{parentName:"p"},"call")," statement."),Object(l.b)("h4",{id:"the-declare-variable-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE")," Variable Statement"),Object(l.b)("p",null,"This declares a new local or global variable that is not a cursor.\nThe type is computed with the same helper that is used for analyzing\ncolumn definitions.  Once we have the type we walk the list of variable\nnames, check them for duplicates and such (see above) and assign their type.  The canonical\nname of the variable is defined here, if it is later used with a different casing the output\nwill always be as declared.   e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"declare Foo integer;  set foo = 1;")," is legal but the output\nwill always contain the variable written as ",Object(l.b)("inlineCode",{parentName:"p"},"Foo"),"."),Object(l.b)("h4",{id:"the-declare-cursor-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE")," Cursor Statement"),Object(l.b)("p",null,"There are two forms of the declare cursor, both of which allow CQL to infer the exact type of the cursor."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"declare foo cursor for select etc."),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the type of the cursor is the net struct type of the select list"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"declare foo cursor for call proc();"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"proc must be statement that produces a result set via select (see above)"),Object(l.b)("li",{parentName:"ul"},"the type of the cursor is the struct of the select returned by the proc"),Object(l.b)("li",{parentName:"ul"},"note if there is more than one loose select in the proc they must match exactly"))),Object(l.b)("li",{parentName:"ul"},"cursor names have the same rules duplicates as other variables\nWith this in mind, both cases simply recurse on either the select or the call\nand then pull out the structure type of that thing and use it for the cursor's shape.  If the\n",Object(l.b)("inlineCode",{parentName:"li"},"call")," is not semantically valid according to the rules for calls or the ",Object(l.b)("inlineCode",{parentName:"li"},"select")," is not semantically valid,\nthen of course this declaration will generate errors.")),Object(l.b)("p",null,"[marker: initial proof reading ended here, what follows is much rougher]"),Object(l.b)("h4",{id:"the-declare-value-cursor-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE")," Value Cursor Statement"),Object(l.b)("p",null,"This statement declares a cursor that will be based on the return type of a procedure\nwhen using this form the cursor is also fetched, hence the name.  The fetch result of\nthe stored proc will be used for the value.  At this point we use its type only."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the call must be semantically valid"),Object(l.b)("li",{parentName:"ul"},"the procedure must return an OUT parameter (not a result set)"),Object(l.b)("li",{parentName:"ul"},"the cursor name must be unique")),Object(l.b)("h4",{id:"the-while-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"WHILE")," Statement"),Object(l.b)("p",null,"While semantic analysis is super simple."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the condition must be numeric"),Object(l.b)("li",{parentName:"ul"},"the statement list must be error-free"),Object(l.b)("li",{parentName:"ul"},"loop_depth is increased allowing the use of interior leave/continue")),Object(l.b)("h4",{id:"the-loop-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"LOOP")," Statement"),Object(l.b)("p",null,'Loop analysis is just as simple as "while" -- because the loop_stmt\nliterally has an embedded fetch, you simply use the fetch helper to\nvalidate that the fetch is good and then visit the statement list.\nLoop depth is increased as with while.'),Object(l.b)("h4",{id:"the-call-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CALL")," Statement"),Object(l.b)("p",null,"There are three ways that a call can happen:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"signatures of procedures that we know in full:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"call foo();"),Object(l.b)("li",{parentName:"ul"},"declare cursor for call foo();"))),Object(l.b)("li",{parentName:"ul"},"some external call to some outside function we don't known",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. call printf('hello, world\\n');")))),Object(l.b)("p",null,'The cursor form can be used if and only if the procedure has a loose select\nor a call to a procedure with a loose select. In that case the procedure will\nhave a structure type, rather than just "ok" (the normal signature for a proc).\nIf the user is attempting to do the second case, cursor_name will be set and\nthe appropriate verification happens here.'),Object(l.b)("p",null,"Note:  Recursively calling fetch cursor is not really doable in general\nbecause at the point of the call we might not yet know that the method\ndoes in fact return a select.  You could make it work if you put the select\nbefore the recursive call."),Object(l.b)("p",null,"Semantic rules:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"for all cases each argument must be error-free (no internal type conflicts)"),Object(l.b)("li",{parentName:"ul"},"for known procs",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the call has to have the correct number of arguments"),Object(l.b)("li",{parentName:"ul"},"if the formal is an out parameter the argument must be a variable",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the type of the variable must be an exact type match for the formal"))),Object(l.b)("li",{parentName:"ul"},"non-out parameters must be type-compatible, but exact match is not required")))),Object(l.b)("h4",{id:"there-declare-out-call-statement"},"There ",Object(l.b)("inlineCode",{parentName:"h4"},"DECLARE OUT CALL")," Statement"),Object(l.b)("p",null,"This form is syntatic sugar and corresponds to declaring any ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," parameters\nof the ",Object(l.b)("inlineCode",{parentName:"p"},"CALL")," portion that are not already declared as the exact type of the\n",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," parameter.  This is intended to save you from declaring a lot of variables\njust so that you can use them as ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," arguments."),Object(l.b)("p",null,"Since any variables that already exist are not re-declared, there are no\nadditional semantic rules beyond the normal call except that it is an error\nto use this form if no ",Object(l.b)("inlineCode",{parentName:"p"},"OUT")," variables needed to be declared."),Object(l.b)("h4",{id:"the-fetch-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"FETCH")," Statement"),Object(l.b)("p",null,"The fetch statement has two forms:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"fetch C into var1, var2, var3 etc."),Object(l.b)("li",{parentName:"ul"},'fetch C;\nThe second form is called the auto_cursor.\nIn the first form the variables of the cursor must be assignment compatible\nwith declared structure type of the cursor and the count must be correct.\nIn the second form, the codegen will implicitly create local variables that\nare exactly the correct type, but that\'s later.  Since no semantic error is\npossible in that case we simply record that this is an auto_cursor and then\nlater we will allow the use of C.field during analysis.\nOf course "C" must be a valid cursor.')),Object(l.b)("h4",{id:"the-continue-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CONTINUE")," Statement"),Object(l.b)("p",null,"We just need to ensure that ",Object(l.b)("inlineCode",{parentName:"p"},"continue")," is inside a ",Object(l.b)("inlineCode",{parentName:"p"},"loop")," or ",Object(l.b)("inlineCode",{parentName:"p"},"while"),"."),Object(l.b)("h4",{id:"the-leave-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"LEAVE")," Statement"),Object(l.b)("p",null,"We just need to ensure that ",Object(l.b)("inlineCode",{parentName:"p"},"leave")," is inside a ",Object(l.b)("inlineCode",{parentName:"p"},"loop"),", ",Object(l.b)("inlineCode",{parentName:"p"},"while")," or ",Object(l.b)("inlineCode",{parentName:"p"},"switch"),"."),Object(l.b)("h4",{id:"the-trycatch-statements"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"TRY/CATCH")," Statements"),Object(l.b)("p",null,"No analysis needed here other than that the two statement lists are ok."),Object(l.b)("h4",{id:"the-open-cursor-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"OPEN")," CURSOR Statement"),Object(l.b)("p",null,"For open ","[cursor]",", we just validate that the name is in fact a cursor.\n",Object(l.b)("inlineCode",{parentName:"p"},"OPEN")," does nothing, it is included because other dialects require it\nand it may help with familiarity.  It might be deprecated at some point."),Object(l.b)("h4",{id:"the-close-cursor-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CLOSE")," CURSOR Statement"),Object(l.b)("p",null,"For close ","[cursor]",", we just validate that the name is in fact a cursor\nand it is not a boxed cursor.  Boxed cursor lifetime is managed by the\nbox object so manually closing it is not allowed.  Instead, the usual\nreference-counting semantics apply; the boxed cursor variable typically falls out of\nscope and is released, or is perhaps set to NULL to release its reference early."),Object(l.b)("h4",{id:"the-out-cursor-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"OUT")," CURSOR Statement"),Object(l.b)("p",null,"For out ","[cursor]",", we first validate that the name is a cursor\nthen we set the output type of the procedure we're in accordingly"),Object(l.b)("h3",{id:"the-meta-statements"},'The "Meta" Statements'),Object(l.b)("p",null,"The programs control the overall meaning the program or give the compiler specific directives\nas to how the program should be compiled."),Object(l.b)("h4",{id:"the-echo-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ECHO")," Statement"),Object(l.b)("p",null,"echo is valid in any top level contexts"),Object(l.b)("h4",{id:"the-previous-schema-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@PREVIOUS SCHEMA")," Statement"),Object(l.b)("p",null,"Begins the region where previous schema will be compared against what has been\ndeclared before this directive for alterations that could not be upgraded."),Object(l.b)("h4",{id:"the-schema_upgrade_script-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@SCHEMA_UPGRADE_SCRIPT")," Statement"),Object(l.b)("p",null,'When upgrading the DDL it\'s necessary to emit create table statements\nfor the original version of the schema.  These create statements conflict\nwith the current version of the schema.  This attribute tells CQL to\n1) ignore DDL in stored procedures for declaration purposes; only DDL outside of a proc counts\n2) do not make any columns "hidden" thereby allowing all annotations to be present\nso they can be used to validate other aspects of the migration script.'),Object(l.b)("h4",{id:"the-schema_upgrade_version-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@SCHEMA_UPGRADE_VERSION")," Statement"),Object(l.b)("p",null,"For sql stored procedures that are supposed to update previous schema versions\nyou can use this attribute to put CQL into that mindset.  This will make\nthe columns hidden for the version in question rather than the current version.\nThis is important because older schema migration procedures might still refer to\nold columns.  Those columns truly exist at that schema version."),Object(l.b)("h4",{id:"the-enforce_strict-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ENFORCE_STRICT")," Statement"),Object(l.b)("p",null,"Switch to strict mode for the indicated item, the choices are"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},'"FOREIGN KEY ON UPDATE" indicates there must be some "ON UPDATE" action in every FK'),Object(l.b)("li",{parentName:"ul"},'"FOREIGN KEY ON DELETE" indicates there must be some "ON DELETE" action in every FK'),Object(l.b)("li",{parentName:"ul"},'"JOIN" indicates only ANSI style joins may be used, "from A,B" is rejected'),Object(l.b)("li",{parentName:"ul"},'"UPSERT" indicates no upsert statement may be used (probably targeting downlevel SQLite)'),Object(l.b)("li",{parentName:"ul"},'"WINDOW FUNCTION" incdicates no window functions may be used (probably targeting downlevel SQLite)'),Object(l.b)("li",{parentName:"ul"},'"PROCEDURE" indicates no calls to undeclared procedures (like loose printf calls)'),Object(l.b)("li",{parentName:"ul"},'"WITHOUT ROWID" inciates WITHOUT ROWID may not be used'),Object(l.b)("li",{parentName:"ul"},'"TRANSACTION" indicates no transactions may be started, committed, or aborted'),Object(l.b)("li",{parentName:"ul"},'"SELECT IF NOTHING" indicates ',Object(l.b)("inlineCode",{parentName:"li"},"(select ...)")," expressions must include an ",Object(l.b)("inlineCode",{parentName:"li"},"IF NOTHING")," clause if they have a ",Object(l.b)("inlineCode",{parentName:"li"},"FROM")," part"),Object(l.b)("li",{parentName:"ul"},'"INSERT SELECT" indicates that insert with select for values may not include top level joins (avoiding a SQLite bug)'),Object(l.b)("li",{parentName:"ul"},'"TABLE FUNCTIONS" indicates table valued functions cannot be used on left/right joins (avoiding a SQLite bug)')),Object(l.b)("p",null,"See the grammar details for exact syntax."),Object(l.b)("h4",{id:"the-enforce_normal-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ENFORCE_NORMAL")," Statement"),Object(l.b)("p",null,"Turn off strict enforcement for the indicated item."),Object(l.b)("h4",{id:"the-enforce_push-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ENFORCE_PUSH")," Statement"),Object(l.b)("p",null,"Push the current strict settings onto the enforcement stack.  This does not change the current settings."),Object(l.b)("h4",{id:"the-enforce_pop-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ENFORCE_POP")," Statement"),Object(l.b)("p",null,"Pop the previous current strict settings from the enforcement stack."),Object(l.b)("h4",{id:"the-enforce_reset-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@ENFORCE_RESET")," Statement"),Object(l.b)("p",null,"Turns off all the strict modes.  Best used immediately after ",Object(l.b)("inlineCode",{parentName:"p"},"@ENFORCE_PUSH"),"."),Object(l.b)("h4",{id:"the-declare_schema_region-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@DECLARE_SCHEMA_REGION")," Statement"),Object(l.b)("p",null,"A schema region is an partitioning of the schema such that it\nonly uses objects in the same partition or one of its declared\ndependencies.  One schema region may be upgraded independently\nfrom any others (assuming they happen such that dependents are done first).\nHere we validate:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the region name is unique"),Object(l.b)("li",{parentName:"ul"},"the dependencies (if any) are unique and exist"),Object(l.b)("li",{parentName:"ul"},"the directive is not inside a procedure")),Object(l.b)("h4",{id:"the-begin_schema_region-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@BEGIN_SCHEMA_REGION")," Statement"),Object(l.b)("p",null,"Entering a schema region makes all the objects that follow part of that\nregion.  It also means that all the contained objects must refer to\nonly pieces of schema that are in the same region or a dependent region.\nHere we validate that region we are entering is in fact a valid region\nand that there isn't already a schema region."),Object(l.b)("h4",{id:"the-end_schema_region-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@END_SCHEMA_REGION")," Statement"),Object(l.b)("p",null,"Leaving a schema region puts you back in the default region.\nHere we check that we are in a schema region."),Object(l.b)("h4",{id:"the-emit_enums-statement"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"@EMIT_ENUMS")," Statement"),Object(l.b)("p",null,"Declared enumarations can be voluminous and it is undesirable for every\nemitted ",Object(l.b)("inlineCode",{parentName:"p"},".h")," file to contain every enumaration.  To avoid this problem\nyou can emit enumaration values of your choice using ",Object(l.b)("inlineCode",{parentName:"p"},"@emit_enums x, y, z"),"\nwhich places the named enumarations into the ",Object(l.b)("inlineCode",{parentName:"p"},".h")," file associated with\nthe current translation unit. If no enumarations are listed, all enums\nare emitted."),Object(l.b)("p",null,"Note: generated enum defintions are protected by ",Object(l.b)("inlineCode",{parentName:"p"},"#ifndef X ... #endif")," so multiple\ndefinitions are harmless and hence you can afford to use ",Object(l.b)("inlineCode",{parentName:"p"},"@emit_enums"),"\nfor the same enum in several translations units, if desired."),Object(l.b)("h3",{id:"important-program-fragments"},"Important Program Fragments"),Object(l.b)("p",null,"These items appear in a variety of places and are worth of discussion.  They are generally handled uniformly."),Object(l.b)("h4",{id:"argument-lists"},"Argument Lists"),Object(l.b)("p",null,"Walk an entire argument list and do the type inference on each argument.\nNot that this happens in the context of a function call and depending\non what the function is, there may be rules for compatibility of the\narguments with the function and each other.  That doesn't happen here.\nThis just gets the type of each arg and makes sure independently they are\nnot bogus."),Object(l.b)("h4",{id:"procedures-that-return-a-result-set"},"Procedures that return a Result Set"),Object(l.b)("p",null,"If a procedure is returning a select statement then we need to attach that\ntype to the procedures semantic info.  We have to do some extra validation\nat this point, especially if the proc already has some other select return.\nThis is where we make sure all the kinds of selects that might be returned\nare 100% compatible."),Object(l.b)("h4",{id:"general-name-lookups"},"General Name Lookups"),Object(l.b)("p",null,"Try to look up a ","[possibly]"," scoped name in one of the places:"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"a column in the current join if any (this must not conflict with #2)"),Object(l.b)("li",{parentName:"ol"},"a local or global variable"),Object(l.b)("li",{parentName:"ol"},"a field in an open cursor\notherwise, name not found.")),Object(l.b)("h4",{id:"object-types-with-a-discriminator"},"Object Types with a Discriminator"),Object(l.b)("p",null,"We check that ",Object(l.b)("inlineCode",{parentName:"p"},"object<Foo>")," only combines with ",Object(l.b)("inlineCode",{parentName:"p"},"object<Foo>")," or ",Object(l.b)("inlineCode",{parentName:"p"},"object")," in lists of objects (like IN)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"If there is a current object type, then the next item in the expression or must match"),Object(l.b)("li",{parentName:"ul"},"If there is no such type, then an object type that arrives becomes the required type"),Object(l.b)("li",{parentName:"ul"},"If they ever don't match record an error")),Object(l.b)("h4",{id:"the-case-expression"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CASE")," Expression"),Object(l.b)("p",null,'There are two parts to this, the "when" expression and the "then" expression.\nWe compute the aggregate type of the when expressions as we go, promoting it\nup to a larger type if needed (e.g. if one when is an int and the other is\na real then the result is a real).   Likewise nullability is computed as\nthe aggregate.  Note that if nothing matches the result is null, so we always\nget a nullable result unless there is an "else" expression.\nIf we started with case expr then each when expression must be comparable\nto the case expression.  If we started with case when xx then yy;  then\neach case expression must be numeric (typically boolean).'),Object(l.b)("h4",{id:"the-between-expressions"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"BETWEEN")," EXPRESSIONS"),Object(l.b)("p",null,"Between requires type compatibility between all three of its arguments.\nNullability follows the usual rules, if any might be null then the result\ntype might be null.  In any case the result's core type is BOOL."),Object(l.b)("h4",{id:"the-cast-expression"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"CAST")," Expression"),Object(l.b)("p",null,"For cast expressions we use the type provided for the semantic type\nthe only trick is that we preserve the combined_flags of the input argument."),Object(l.b)("h4",{id:"the-coalesce-function"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"COALESCE")," Function"),Object(l.b)("p",null,"Coalesce requires type compatibility between all of its arguments.  The result\nis a not null type if we find a not null item in the list.  There should be\nnothing after that item.  Note that ifnull and coalesce are really the same thing\nexcept ifnull must have exactly two arguments."),Object(l.b)("h4",{id:"the-in-and-not-in-expressions"},"The ",Object(l.b)("inlineCode",{parentName:"h4"},"IN")," AND ",Object(l.b)("inlineCode",{parentName:"h4"},"NOT IN")," Expressions"),Object(l.b)("p",null,"The in predicate is like many of the other multi-argument operators.  All the\nitems must be type compatible.  Note that in this case the nullablity of\nthe items does not matter, only the nullability of the item being tested.\nNote that null in (null) is null, not true."),Object(l.b)("h4",{id:"aggregate-functions"},"Aggregate Functions"),Object(l.b)("p",null,"Aggregate functions can only be used in certain places.  For instance\nthey may not appear in a ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," clause."),Object(l.b)("h4",{id:"user-defined-functions"},"User Defined Functions"),Object(l.b)("p",null,"User defined function, this is an external function\nThere are a few things to check:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"If this is declared without the select keyword then",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"we can't use these in SQL, so this has to be a loose expression"))),Object(l.b)("li",{parentName:"ul"},"If this is declared with the select keyword then",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"we can ONLY use these in SQL, not in a loose expression"))),Object(l.b)("li",{parentName:"ul"},"args have to be compatible with formals")),Object(l.b)("h4",{id:"calling-a-procedure-as-a-function"},"Calling a procedure as a function"),Object(l.b)("p",null,"There are a few things to check:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"we can't use these in SQL, so this has to be a loose expression"),Object(l.b)("li",{parentName:"ul"},"args have to be compatible with formals, except"),Object(l.b)("li",{parentName:"ul"},"the last formal must be an OUT arg and it must be a scalar type"),Object(l.b)("li",{parentName:"ul"},'that out arg will be treated as the return value of the "function"'),Object(l.b)("li",{parentName:"ul"},"in code-gen we will create a temporary for it, semantic analysis doesn't care")),Object(l.b)("h4",{id:"root-expressions"},"Root Expressions"),Object(l.b)("p",null,"A top level expression defines the context for that evaluation.  Different expressions\ncan have constraints.  e.g. aggregate functions may not appear in the ",Object(l.b)("inlineCode",{parentName:"p"},"WHERE")," clause of a statement.  There are cases where expression nesting can happen, this nesting changes the evaluation context accordingly, e.g. you can put a nested select in a where clause and that\nnested select could legally have aggregates.  Root expressions keep a stack of nested contexts to facilitate the changes."),Object(l.b)("h4",{id:"table-factors"},"Table Factors"),Object(l.b)("p",null,"A table factor is one of three things:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"a table name (a string)  select * from X"),Object(l.b)("li",{parentName:"ul"},"a select subquery (select X,Y from..) as T2"),Object(l.b)("li",{parentName:"ul"},"a list of table references select * from (X, Y, Z)\nHere we dispatch to the appropriate helper for each case.")),Object(l.b)("h4",{id:"joining-with-the-using-clause"},"Joining with the ",Object(l.b)("inlineCode",{parentName:"h4"},"USING")," Clause"),Object(l.b)("p",null,"When specifying joins, one of the alternatives is to give the shared\ncolumns in the join e.g. select * from X inner join Y using (a,b).\nThis method validates that all the columns are present on both sides of the\njoin, that they are unique, and they are comparable.\nThe return code tells us if any columns had SENSITIVE data.   See Special Note on JOIN...USING below"),Object(l.b)("h4",{id:"join-with-the-on-clause"},"JOIN WITH THE ",Object(l.b)("inlineCode",{parentName:"h4"},"ON")," Clause"),Object(l.b)("p",null,"The most explicit join condition is a full expression in an ON clause\nthis is like ",Object(l.b)("inlineCode",{parentName:"p"},"select a,b from X inner join Y on X.id = Y.id;"),"\nThe on expression should be something that can be used as a bool\nso any numeric will do.\nThe return code tells us if the ON condition used SENSITIVE data."),Object(l.b)("h4",{id:"table-valued-functions"},"TABLE VALUED FUNCTIONS"),Object(l.b)("p",null,"Table valued functions can appear anywhere a table is allowed.\nThe validation rules are:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"must be a valid function")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"must return a struct type (i.e. a table-valued-function)")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"must have valid arg expressions")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"arg expressions must match formal parameters\nThe name of the resulting table is the name of the function")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},'but it can be aliased later with "AS"'),Object(l.b)("h3",{parentName:"li",id:"special-note-on-the-select--and-select-t-forms"},"Special Note on the ",Object(l.b)("inlineCode",{parentName:"h3"},"select *")," and ",Object(l.b)("inlineCode",{parentName:"h3"},"select T.*")," forms"),Object(l.b)("p",{parentName:"li"},"The ",Object(l.b)("inlineCode",{parentName:"p"},"select *")," construct is very popular in many codebases but it can be unsafe to use in production code because, if the schema changes, the code might get columns it does not expect.  Note the extra columns could have appeared anywhere in the result set because the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," applies to the entire result of the ",Object(l.b)("inlineCode",{parentName:"p"},"FROM")," clause, joins and all,  so extra columns are not necessarily at the end and column ordinals are not preserved.  CQL mitigates this situation somewhat with some useful constraints/features:")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"in a ",Object(l.b)("inlineCode",{parentName:"p"},"select *"),", and indeed in any query, the column names of the select must be unique, this is because:"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"they could form the field names of an automatically generated cursor (see the section on cursors)"),Object(l.b)("li",{parentName:"ul"},"they could form the field names in a CQL result set (see section on result sets)"),Object(l.b)("li",{parentName:"ul"},"it's weird/confusing to not have unique names generally"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"when issuing a ",Object(l.b)("inlineCode",{parentName:"p"},"select *")," or a ",Object(l.b)("inlineCode",{parentName:"p"},"select T.*")," CQL will automatically expand the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," into the actual logical columns that exist in the schema at the time the code was compiled"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"this is important because if a column had been logically deleted from a table it would be unexpected in the result set even though it is still present in the database and would throw everything off"),Object(l.b)("li",{parentName:"ul"},"likewise if the schema were to change without updating the code, the code will still get the columns it was compiled with, not new columns")))),Object(l.b)("p",null,"Expanding the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," at compile time means Sqlite cannot see anything that might tempt it to include different columns in the result."),Object(l.b)("p",null,"With this done we just have to look at the places a ",Object(l.b)("inlineCode",{parentName:"p"},"select *")," might appear so we can see if it is safe to use ",Object(l.b)("inlineCode",{parentName:"p"},"*")," and, by extension of the same argument, ",Object(l.b)("inlineCode",{parentName:"p"},"T.*"),", or at least reasonably safe."),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"In an ",Object(l.b)("inlineCode",{parentName:"em"},"EXISTS")," or ",Object(l.b)("inlineCode",{parentName:"em"},"NOT EXISTS")," clause like `where not exists (select ")," from x)`*"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"this is perfectly safe, the particular columns do not matter, ",Object(l.b)("inlineCode",{parentName:"li"},"select *")," is not even expanded in this case.")),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"In a statement that produces a result set like `select ")," from table_or_view`*"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"binding to a CQL result set is done by column name and we know those names are unique"),Object(l.b)("li",{parentName:"ul"},"we won't include any columns that are logically deleted, so if you try to use a deleted column you'll get a compile time error")),Object(l.b)("p",null,"In a cursor statement like ",Object(l.b)("inlineCode",{parentName:"p"},"declare C cursor for select * from table_or_view")," there are two cases here"),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"Automatic Fetch  ",Object(l.b)("inlineCode",{parentName:"em"},"fetch C;"))),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"in this case you don't specify the column names yourself, they are inferred"),Object(l.b)("li",{parentName:"ul"},"you are therefore binding to the columns by name, so new columns in the cursor would be unused (until you choose to start using them)"),Object(l.b)("li",{parentName:"ul"},"if you try to access a deleted column you get a compile-time error")),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"Manual Fetch:  ",Object(l.b)("inlineCode",{parentName:"em"},"fetch C into a, b, c;"))),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"In this case the number and type of the columns must match exactly with the specified variables"),Object(l.b)("li",{parentName:"ul"},"If new columns are added, deleted, or changed, the above code will not compile")),Object(l.b)("p",null,"So consdering these cases above we can conclude that auto expanding the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," into the exact columns present in the compile-time schema version ensures that any incompatible changes result in compile time errors. Adding columns to tables does not cause problems even if the code is not recompiled. This makes the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," construct much safer, if not perfect, but no semantic would be safe from arbitary schema changes without recompilation.  At the very least here we can expect a meaningful runtime error rather than silently fetching the wrong columns."),Object(l.b)("h3",{id:"special-note-on-the-joinusing-form"},"Special Note on the JOIN...USING form"),Object(l.b)("p",null,"CQL varies slightly from SQLite in terms of the expected results for joins if the USING syntax is employed.  This is not the most common syntax (typically an ON clause is used) but Sqlite has special rules for this kind of join."),Object(l.b)("p",null,"Let's take a quick look.  First some sample data:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"create table A( id integer, a text, b text);\ncreate table B( id integer, c text, d text);\n\ninsert into A values(1, 'a1', 'b1');\ninsert into B values(1, 'c1', 'd1');\ninsert into A values(2, 'a2', 'b2');\ninsert into B values(2, 'c2', 'd2');\n")),Object(l.b)("p",null,"Now let's look at the normal join, this is our reference:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"select * from A T1 inner join B T2 on T1.id = T2.id;\n\nresult:\n\n1|a1|b1|1|c1|d1\n2|a2|b2|2|c2|d2\n")),Object(l.b)("p",null,"As expected, you get all the columns of A, and all the columns of B.  The 'id' column appears twice."),Object(l.b)("p",null,"However with the ",Object(l.b)("inlineCode",{parentName:"p"},"USING")," syntax:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"select * T1 inner join B T2 using (id);\n\nresult:\n\n1|a1|b1|c1|d1\n2|a2|b2|c2|d2\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"id")," column is now appearing exactly once.  However, the situation is not so simple as that.  It seems that what hapened was that the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," expansion has not included two copies of the ",Object(l.b)("inlineCode",{parentName:"p"},"id"),".  The following cases show that both copies of ",Object(l.b)("inlineCode",{parentName:"p"},"id")," are still logically in the join."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"select T1.*, 'xxx', T2.* from A T1 inner join B T2 using (id);\n\nresult:\n\n1|a1|b1|xxx|1|c1|d1\n2|a2|b2|xxx|2|c2|d2\n")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"T2.id")," column is part of the join, it just wasn't part of the ",Object(l.b)("inlineCode",{parentName:"p"},"*")),Object(l.b)("p",null,"In fact, looking further:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"select T1.id, T1.a, T1.b, 'xxx', T2.id, T2.c, T2.d from A T1 inner join B T2 using (id);\n\nresult:\n\n1|a1|b1|xxx|1|c1|d1\n2|a2|b2|xxx|2|c2|d2\n")),Object(l.b)("p",null,"There is no doubt, ",Object(l.b)("inlineCode",{parentName:"p"},"T2.id")," is a valid column and can be used in expressions freely. That means the column cannot be removed from the type calculus."),Object(l.b)("p",null,"Now in CQL, the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," and ",Object(l.b)("inlineCode",{parentName:"p"},"T.*")," forms are automatically expanded, SQLite doesn't see the ",Object(l.b)("inlineCode",{parentName:"p"},"*"),".  This is done so that if any columns have been logically deleted they can be elided from the result set.  Given that this happens, the ",Object(l.b)("inlineCode",{parentName:"p"},"*")," operator will expand to ALL the columns.  Just the same as if you did ",Object(l.b)("inlineCode",{parentName:"p"},"T1.*")," and ",Object(l.b)("inlineCode",{parentName:"p"},"T2.*"),"."),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"As a result, in CQL, there is no difference between  the ",Object(l.b)("inlineCode",{parentName:"em"},"USING")," form of a join and the ",Object(l.b)("inlineCode",{parentName:"em"},"ON")," form of a join.")),Object(l.b)("p",null,"In fact, only the ",Object(l.b)("inlineCode",{parentName:"p"},"select *")," form could possibly be different, so in most cases this ends up being moot anyway.  Typically you don't to use ",Object(l.b)("inlineCode",{parentName:"p"},"*")," in the presence of joins because of name duplication and ambiguity of the column names of the result set.  CQL's automatic expansion means you have a much better idea exactly what columns you will get -- those that were present in the schema you declared."))}h.isMDXComponent=!0},139:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),b=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=b(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},p=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=b(n),p=a,m=h["".concat(r,".").concat(p)]||h[p]||u[p]||l;return n?i.a.createElement(m,o(o({ref:t},c),{},{components:n})):i.a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var c=2;c<l;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);