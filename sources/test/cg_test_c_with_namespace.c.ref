
#include "test_namespace/out/cg_test_c_with_namespace.h"

#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-not-parentheses"
#pragma clang diagnostic ignored "-Wliteral-conversion"
extern CQL_WARN_UNUSED cql_code with_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code select_from_view(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code get_data(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_string_ref _Nonnull name_, cql_int32 id_);
extern CQL_WARN_UNUSED cql_code xyzzy(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_nullable_int32 id);

extern void plugh(cql_nullable_int32 id);

extern CQL_WARN_UNUSED cql_code complex_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code hierarchical_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_);
extern CQL_WARN_UNUSED cql_code hierarchical_unmatched_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_);
extern CQL_WARN_UNUSED cql_code union_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code union_all_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code union_all_with_nullable(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code with_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code with_recursive_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code parent_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code parent_proc_child(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code uses_proc_for_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code blob_returner(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);

typedef struct out_cursor_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} out_cursor_proc_row;
extern CQL_WARN_UNUSED cql_code out_cursor_proc(sqlite3 *_Nonnull _db_, out_cursor_proc_row *_Nonnull _result_);

typedef struct fetcher_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} fetcher_proc_row;
extern void fetcher_proc(fetcher_proc_row *_Nonnull _result_);

extern void totally_void_proc(void);

extern void compute(cql_int32 a_, cql_int32 *_Nonnull b_);

extern CQL_WARN_UNUSED cql_code dml_compute(sqlite3 *_Nonnull _db_, cql_int32 a_, cql_int32 *_Nonnull b_);

extern CQL_WARN_UNUSED cql_code thread_theme_info_list(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 thread_key_);

typedef struct out_no_db_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} out_no_db_row;
extern void out_no_db(out_no_db_row *_Nonnull _result_);

typedef struct declare_cursor_like_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_row;
extern void declare_cursor_like_cursor(declare_cursor_like_cursor_row *_Nonnull _result_);

typedef struct declare_cursor_like_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} declare_cursor_like_proc_row;
extern void declare_cursor_like_proc(declare_cursor_like_proc_row *_Nonnull _result_);

typedef struct declare_cursor_like_table_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} declare_cursor_like_table_row;
extern void declare_cursor_like_table(declare_cursor_like_table_row *_Nonnull _result_);

typedef struct declare_cursor_like_view_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 f1;
  cql_int32 f2;
  cql_int32 f3;
} declare_cursor_like_view_row;
extern void declare_cursor_like_view(declare_cursor_like_view_row *_Nonnull _result_);
extern void blob_out(cql_blob_ref _Nullable *_Nonnull x);


typedef struct fetch_to_cursor_from_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_row;
extern void fetch_to_cursor_from_cursor(fetch_to_cursor_from_cursor_row *_Nonnull _result_);

typedef struct global_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a;
  cql_int32 b;
} global_cursor_row;
extern CQL_WARN_UNUSED cql_code simple_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code complex_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);

typedef struct out_cursor_identity_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_int32 data;
} out_cursor_identity_row;
extern CQL_WARN_UNUSED cql_code out_cursor_identity(sqlite3 *_Nonnull _db_, out_cursor_identity_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code radioactive_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code autodropper(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);

typedef struct simple_cursor_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
} simple_cursor_proc_row;
extern void simple_cursor_proc(simple_cursor_proc_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code redundant_cast(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);

typedef struct p1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} p1_row;
extern void p1(p1_row *_Nonnull _result_);


typedef struct p2_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} p2_row;
extern CQL_WARN_UNUSED cql_code p2(sqlite3 *_Nonnull _db_, p2_row *_Nonnull _result_);


typedef struct out_union_two_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_two_row;

typedef struct out_union_from_select_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_from_select_row;

typedef struct out_union_values_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} out_union_values_row;
extern CQL_WARN_UNUSED cql_code window_function_invocation(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
cql_result_set_type_decl(out_union_with_dml_result_set, out_union_with_dml_result_set_ref);
extern CQL_WARN_UNUSED cql_code out_union_with_dml_fetch_results(sqlite3 *_Nonnull _db_, out_union_with_dml_result_set_ref _Nullable *_Nonnull _result_set_, cql_nullable_int32 id);

cql_result_set_type_decl(out_union_no_dml_result_set, out_union_no_dml_result_set_ref);
extern void out_union_no_dml_fetch_results(out_union_no_dml_result_set_ref _Nullable *_Nonnull _result_set_, cql_nullable_int32 id);

extern CQL_WARN_UNUSED cql_code use_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code lotsa_columns_no_getters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code lotsa_columns_no_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_);
cql_string_literal(_literal_1_This_is_a_test_, "This is a \" \\ test '' \n \" ");
cql_string_literal(_literal_2_b_, "b");
cql_string_literal(_literal_3_c_, "c");
cql_string_literal(_literal_4_a_, "a");
cql_string_literal(_literal_5_x_, "x");
cql_string_literal(_literal_6_before_echo_echo_test, "before echo");
cql_string_literal(_literal_7_after_echo_echo_test, "after echo");
cql_string_literal(_literal_8_Testing_c_literal, "\"Testing\" \\''");
cql_string_literal(_literal_9_bar_fetch_to_cursor_from_cursor, "bar");
cql_string_literal(_literal_10_y_, "y");

// The statement ending at line XXXX

/*
DECLARE i0_nullable INTEGER;
*/
cql_nullable_int32 i0_nullable;

// The statement ending at line XXXX

/*
DECLARE i1_nullable INTEGER;
*/
cql_nullable_int32 i1_nullable;

// The statement ending at line XXXX

/*
DECLARE r0_nullable REAL;
*/
cql_nullable_double r0_nullable;

// The statement ending at line XXXX

/*
DECLARE l0_nullable LONG_INT;
*/
cql_nullable_int64 l0_nullable;

// The statement ending at line XXXX

/*
DECLARE l1_nullable LONG_INT;
*/
cql_nullable_int64 l1_nullable;

// The statement ending at line XXXX

/*
DECLARE b0_nullable BOOL;
*/
cql_nullable_bool b0_nullable;

// The statement ending at line XXXX

/*
DECLARE t0_nullable TEXT;
*/
cql_string_ref t0_nullable = NULL;

// The statement ending at line XXXX

/*
DECLARE i2 INTEGER NOT NULL;
*/
cql_int32 i2 = 0;

// The statement ending at line XXXX

/*
DECLARE r2 REAL NOT NULL;
*/
cql_double r2 = 0;

// The statement ending at line XXXX

/*
DECLARE l2 LONG_INT NOT NULL;
*/
cql_int64 l2 = 0;

// The statement ending at line XXXX

/*
DECLARE b2 BOOL NOT NULL;
*/
cql_bool b2 = 0;

// The statement ending at line XXXX

/*
DECLARE t2 TEXT NOT NULL;
*/
cql_string_ref t2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC test (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    CALL puts('true');
  END IF;
END;
*/

#undef _PROC_
#define _PROC_ "test"
void test(cql_int32 i) {
  if (i) {
    puts("true");
  }

}
cql_int32 _between_0_ = 0;
cql_nullable_int32 _between_1_;
cql_nullable_int32 _between_2_;
cql_int32 _between_3_ = 0;
cql_nullable_int32 _between_4_;
cql_nullable_int32 _between_5_;

// The statement ending at line XXXX

/*
CREATE PROC out_test (OUT i INTEGER NOT NULL, OUT ii INTEGER)
BEGIN
  SET i := i2;
  SET ii := i0_nullable;
END;
*/

#undef _PROC_
#define _PROC_ "out_test"
void out_test(cql_int32 *_Nonnull i, cql_nullable_int32 *_Nonnull ii) {
  *i = i2;
  cql_set_nullable(*ii, i0_nullable.is_null, i0_nullable.value);

}

// The statement ending at line XXXX

/*
DECLARE longint_var LONG_INT;
*/
cql_nullable_int64 longint_var;
sqlite3_stmt *foo_cursor = NULL;
cql_bool _foo_cursor_has_row_ = 0;

// The statement ending at line XXXX

/*
DECLARE col1 INTEGER;
*/
cql_nullable_int32 col1;

// The statement ending at line XXXX

/*
DECLARE col2 REAL NOT NULL;
*/
cql_double col2 = 0;
sqlite3_stmt *basic_cursor = NULL;
cql_bool _basic_cursor_has_row_ = 0;

// The statement ending at line XXXX

/*
DECLARE arg1 INTEGER NOT NULL;
*/
cql_int32 arg1 = 0;

// The statement ending at line XXXX

/*
DECLARE arg2 INTEGER NOT NULL;
*/
cql_int32 arg2 = 0;
sqlite3_stmt *exchange_cursor = NULL;
cql_bool _exchange_cursor_has_row_ = 0;
sqlite3_stmt *_temp_stmt = NULL;

// The statement ending at line XXXX

/*
CREATE PROC outparm_test (OUT foo INTEGER NOT NULL)
BEGIN
  SET foo := 1;
  DELETE FROM bar WHERE id = foo;
END;
*/

#undef _PROC_
#define _PROC_ "outparm_test"
CQL_WARN_UNUSED cql_code outparm_test(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull foo) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  *foo = 1;
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "DELETE FROM bar WHERE id = ?");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, *foo);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC throwing ()
BEGIN
  BEGIN TRY
    DELETE FROM bar;
  END TRY;
  BEGIN CATCH
    CALL printf("error\n");
    THROW;
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "throwing"
CQL_WARN_UNUSED cql_code throwing(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_code _rc_thrown_ = SQLITE_OK;
  // try
  {
    _rc_ = cql_exec(_db_,
      "DELETE FROM bar");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }
    goto catch_end_1;
  }
  catch_start_1: {
    _rc_thrown_ = _rc_;
    printf("error\n");
    _rc_ = cql_best_error(_rc_thrown_);
    goto cql_cleanup;
  }
  catch_end_1:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
cql_string_ref _between_6_ = NULL;
cql_string_ref _between_7_ = NULL;
cql_string_ref _between_8_ = NULL;
cql_string_ref _between_9_ = NULL;
cql_string_ref _between_10_ = NULL;
cql_string_ref _between_11_ = NULL;
cql_string_ref _between_12_ = NULL;
cql_string_ref _between_13_ = NULL;

// The statement ending at line XXXX

/*
CREATE PROC with_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#undef _PROC_
#define _PROC_ "with_result_set"
static int32_t with_result_set_perf_index;

cql_string_literal(with_result_set_stored_procedure_name, "with_result_set");

typedef struct with_result_set_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} with_result_set_row;

cql_int32 with_result_set_get_id(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable with_result_set_get_name(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool with_result_set_get_rate_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 with_result_set_get_rate_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool with_result_set_get_type_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 with_result_set_get_type_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool with_result_set_get_size_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double with_result_set_get_size_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t with_result_set_data_types[with_result_set_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define with_result_set_refs_offset cql_offsetof(with_result_set_row, name) // count = 1

static cql_uint16 with_result_set_col_offsets[] = { 5,
  cql_offsetof(with_result_set_row, id),
  cql_offsetof(with_result_set_row, name),
  cql_offsetof(with_result_set_row, rate),
  cql_offsetof(with_result_set_row, type),
  cql_offsetof(with_result_set_row, size)
};

cql_int32 with_result_set_result_count(with_result_set_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_result_set_fetch_results(sqlite3 *_Nonnull _db_, with_result_set_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_result_set, &with_result_set_perf_index);
  cql_code rc = with_result_set(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_result_set_data_types,
    .col_offsets = with_result_set_col_offsets,
    .refs_count = 1,
    .refs_offset = with_result_set_refs_offset,
    .rowsize = sizeof(with_result_set_row),
    .crc = CRC_with_result_set,
    .perf_index = &with_result_set_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code with_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC select_from_view ()
BEGIN
  SELECT id, type
    FROM baz;
END;
*/

#undef _PROC_
#define _PROC_ "select_from_view"
static int32_t select_from_view_perf_index;

cql_string_literal(select_from_view_stored_procedure_name, "select_from_view");

typedef struct select_from_view_row {
  cql_int32 id;
  cql_nullable_int32 type;
} select_from_view_row;

cql_int32 select_from_view_get_id(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_bool select_from_view_get_type_is_null(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 select_from_view_get_type_value(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t select_from_view_data_types[select_from_view_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32, // type
};

static cql_uint16 select_from_view_col_offsets[] = { 2,
  cql_offsetof(select_from_view_row, id),
  cql_offsetof(select_from_view_row, type)
};

cql_int32 select_from_view_result_count(select_from_view_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code select_from_view_fetch_results(sqlite3 *_Nonnull _db_, select_from_view_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_select_from_view, &select_from_view_perf_index);
  cql_code rc = select_from_view(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = select_from_view_data_types,
    .col_offsets = select_from_view_col_offsets,
    .rowsize = sizeof(select_from_view_row),
    .crc = CRC_select_from_view,
    .perf_index = &select_from_view_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code select_from_view(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, type "
      "FROM baz");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC make_view ()
BEGIN
  CREATE VIEW MyView AS
  SELECT 1 AS f1, 2 AS f2, 3 AS f3;
END;
*/

#undef _PROC_
#define _PROC_ "make_view"
CQL_WARN_UNUSED cql_code make_view(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIEW MyView AS "
    "SELECT 1 AS f1, 2 AS f2, 3 AS f3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC make_index ()
BEGIN
  CREATE INDEX index_1 ON bar (id);
END;
*/

#undef _PROC_
#define _PROC_ "make_index"
CQL_WARN_UNUSED cql_code make_index(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE INDEX index_1 ON bar (id)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC get_data (name_ TEXT NOT NULL, id_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM bar
    WHERE id = id_ AND name = name_;
END;
*/

#undef _PROC_
#define _PROC_ "get_data"
static int32_t get_data_perf_index;

cql_string_literal(get_data_stored_procedure_name, "get_data");

typedef struct get_data_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} get_data_row;

cql_int32 get_data_get_id(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable get_data_get_name(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool get_data_get_rate_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 get_data_get_rate_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool get_data_get_type_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 get_data_get_type_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool get_data_get_size_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double get_data_get_size_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t get_data_data_types[get_data_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define get_data_refs_offset cql_offsetof(get_data_row, name) // count = 1

static cql_uint16 get_data_col_offsets[] = { 5,
  cql_offsetof(get_data_row, id),
  cql_offsetof(get_data_row, name),
  cql_offsetof(get_data_row, rate),
  cql_offsetof(get_data_row, type),
  cql_offsetof(get_data_row, size)
};

cql_int32 get_data_result_count(get_data_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code get_data_fetch_results(sqlite3 *_Nonnull _db_, get_data_result_set_ref _Nullable *_Nonnull result_set, cql_string_ref _Nonnull name_, cql_int32 id_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_get_data, &get_data_perf_index);
  cql_code rc = get_data(_db_, &stmt, name_, id_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = get_data_data_types,
    .col_offsets = get_data_col_offsets,
    .refs_count = 1,
    .refs_offset = get_data_refs_offset,
    .rowsize = sizeof(get_data_row),
    .crc = CRC_get_data,
    .perf_index = &get_data_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code get_data(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_string_ref _Nonnull name_, cql_int32 id_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, name, rate, type, size "
      "FROM bar "
      "WHERE id = ? AND name = ?");
  cql_multibind(&_rc_, _db_, _result_, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, name_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC easy_fetch ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  FETCH C;
  CALL printf("%d %s\n", C.id, C.name);
  DECLARE C2 CURSOR FOR SELECT *
    FROM bar
    WHERE C AND id = C.id;
END;
*/

#undef _PROC_
#define _PROC_ "easy_fetch"

typedef struct easy_fetch_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} easy_fetch_C_row;

#define easy_fetch_C_refs_offset cql_offsetof(easy_fetch_C_row, name) // count = 1
CQL_WARN_UNUSED cql_code easy_fetch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  easy_fetch_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = easy_fetch_C_refs_offset };
  sqlite3_stmt *C2 = NULL;
  cql_bool _C2_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 5,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.id,
                 CQL_DATA_TYPE_STRING, &C_.name,
                 CQL_DATA_TYPE_INT64, &C_.rate,
                 CQL_DATA_TYPE_INT32, &C_.type,
                 CQL_DATA_TYPE_DOUBLE, &C_.size);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_alloc_cstr(_cstr_1, C_.name);
  printf("%d %s\n", C_.id, _cstr_1);
  cql_free_cstr(_cstr_1, C_.name);
  _rc_ = cql_prepare(_db_, &C2,
    "SELECT id, name, rate, type, size "
      "FROM bar "
      "WHERE ? AND id = ?");
  cql_multibind(&_rc_, _db_, &C2, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, C_._has_row_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, C_.id);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  cql_teardown_row(C_);
  cql_finalize_stmt(&C2);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC copy_int (a INTEGER, OUT b INTEGER)
BEGIN
  SET b := a;
END;
*/

#undef _PROC_
#define _PROC_ "copy_int"
void copy_int(cql_nullable_int32 a, cql_nullable_int32 *_Nonnull b) {
  cql_set_nullable(*b, a.is_null, a.value);

}

// The statement ending at line XXXX

/*
CREATE PROC insert_rowid_reader ()
BEGIN
  DECLARE row LONG_INT;
  SET row := last_insert_rowid();
END;
*/

#undef _PROC_
#define _PROC_ "insert_rowid_reader"
CQL_WARN_UNUSED cql_code insert_rowid_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int64 row;
  cql_set_null(row);

  cql_set_notnull(row, sqlite3_last_insert_rowid(_db_));
  _rc_ = SQLITE_OK;

  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC changes_reader ()
BEGIN
  DECLARE ct INTEGER;
  SET ct := changes();
END;
*/

#undef _PROC_
#define _PROC_ "changes_reader"
CQL_WARN_UNUSED cql_code changes_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 ct;
  cql_set_null(ct);

  cql_set_notnull(ct, sqlite3_changes(_db_));
  _rc_ = SQLITE_OK;

  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE s TEXT NOT NULL;
*/
cql_string_ref s = NULL;

// The statement ending at line XXXX

/*
DECLARE PROC xyzzy (id INTEGER) (A INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC xyzzy_test ()
BEGIN
  DECLARE xyzzy_cursor CURSOR FOR CALL xyzzy(1);
END;
*/

#undef _PROC_
#define _PROC_ "xyzzy_test"
CQL_WARN_UNUSED cql_code xyzzy_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *xyzzy_cursor = NULL;
  cql_nullable_int32 _tmp_n_int_1;
  cql_set_null(_tmp_n_int_1);
  cql_bool _xyzzy_cursor_has_row_ = 0;

  cql_set_notnull(_tmp_n_int_1, 1);
  _rc_ = xyzzy(_db_, &xyzzy_cursor, _tmp_n_int_1);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&xyzzy_cursor);
  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE PROC plugh (id INTEGER);
*/

// The statement ending at line XXXX

/*
CREATE PROC complex_return ()
BEGIN
  SELECT CAST(1 AS BOOL) AS _bool, 2 AS _integer, CAST(3 AS LONG_INT) AS _longint, 3.0 AS _real, 'xyz' AS _text, CAST(NULL AS BOOL) AS _nullable_bool;
END;
*/

#undef _PROC_
#define _PROC_ "complex_return"
static int32_t complex_return_perf_index;

cql_string_literal(complex_return_stored_procedure_name, "complex_return");

typedef struct complex_return_row {
  cql_bool _bool;
  cql_int32 _integer;
  cql_int64 _longint;
  cql_double _real;
  cql_nullable_bool _nullable_bool;
  cql_string_ref _Nonnull _text;
} complex_return_row;

cql_bool complex_return_get__bool(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._bool;
}

cql_int32 complex_return_get__integer(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._integer;
}

cql_int64 complex_return_get__longint(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._longint;
}

cql_double complex_return_get__real(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._real;
}

cql_string_ref _Nonnull complex_return_get__text(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._text;
}

cql_bool complex_return_get__nullable_bool_is_null(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._nullable_bool.is_null;
}

cql_bool complex_return_get__nullable_bool_value(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._nullable_bool.value;
}

uint8_t complex_return_data_types[complex_return_data_types_count] = {
  CQL_DATA_TYPE_BOOL | CQL_DATA_TYPE_NOT_NULL, // _bool
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // _integer
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // _longint
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // _real
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // _text
  CQL_DATA_TYPE_BOOL, // _nullable_bool
};

#define complex_return_refs_offset cql_offsetof(complex_return_row, _text) // count = 1

static cql_uint16 complex_return_col_offsets[] = { 6,
  cql_offsetof(complex_return_row, _bool),
  cql_offsetof(complex_return_row, _integer),
  cql_offsetof(complex_return_row, _longint),
  cql_offsetof(complex_return_row, _real),
  cql_offsetof(complex_return_row, _text),
  cql_offsetof(complex_return_row, _nullable_bool)
};

cql_int32 complex_return_result_count(complex_return_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code complex_return_fetch_results(sqlite3 *_Nonnull _db_, complex_return_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_complex_return, &complex_return_perf_index);
  cql_code rc = complex_return(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = complex_return_data_types,
    .col_offsets = complex_return_col_offsets,
    .refs_count = 1,
    .refs_offset = complex_return_refs_offset,
    .rowsize = sizeof(complex_return_row),
    .crc = CRC_complex_return,
    .perf_index = &complex_return_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code complex_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT CAST(1 AS BOOL), 2, CAST(3 AS LONG_INT), 3.0, 'xyz', NULL");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC hierarchical_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
*/

#undef _PROC_
#define _PROC_ "hierarchical_query"
static int32_t hierarchical_query_perf_index;

cql_string_literal(hierarchical_query_stored_procedure_name, "hierarchical_query");

typedef struct hierarchical_query_row {
  cql_int32 id;
} hierarchical_query_row;

cql_int32 hierarchical_query_get_id(hierarchical_query_result_set_ref _Nonnull result_set, cql_int32 row) {
  hierarchical_query_row *data = (hierarchical_query_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

uint8_t hierarchical_query_data_types[hierarchical_query_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 hierarchical_query_col_offsets[] = { 1,
  cql_offsetof(hierarchical_query_row, id)
};

cql_int32 hierarchical_query_result_count(hierarchical_query_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_query_fetch_results(sqlite3 *_Nonnull _db_, hierarchical_query_result_set_ref _Nullable *_Nonnull result_set, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_hierarchical_query, &hierarchical_query_perf_index);
  cql_code rc = hierarchical_query(_db_, &stmt, rate_, limit_, offset_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = hierarchical_query_data_types,
    .col_offsets = hierarchical_query_col_offsets,
    .rowsize = sizeof(hierarchical_query_row),
    .crc = CRC_hierarchical_query,
    .perf_index = &hierarchical_query_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id "
      "FROM foo "
      "WHERE id IN (SELECT id "
      "FROM bar "
      "WHERE rate = ? "
    "ORDER BY name "
    "LIMIT ? "
    "OFFSET ?) "
    "ORDER BY id");
  cql_multibind(&_rc_, _db_, _result_, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, rate_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, limit_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, offset_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC hierarchical_unmatched_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id NOT IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
*/

#undef _PROC_
#define _PROC_ "hierarchical_unmatched_query"
static int32_t hierarchical_unmatched_query_perf_index;

cql_string_literal(hierarchical_unmatched_query_stored_procedure_name, "hierarchical_unmatched_query");

typedef struct hierarchical_unmatched_query_row {
  cql_int32 id;
} hierarchical_unmatched_query_row;

cql_int32 hierarchical_unmatched_query_get_id(hierarchical_unmatched_query_result_set_ref _Nonnull result_set, cql_int32 row) {
  hierarchical_unmatched_query_row *data = (hierarchical_unmatched_query_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

uint8_t hierarchical_unmatched_query_data_types[hierarchical_unmatched_query_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 hierarchical_unmatched_query_col_offsets[] = { 1,
  cql_offsetof(hierarchical_unmatched_query_row, id)
};

cql_int32 hierarchical_unmatched_query_result_count(hierarchical_unmatched_query_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_unmatched_query_fetch_results(sqlite3 *_Nonnull _db_, hierarchical_unmatched_query_result_set_ref _Nullable *_Nonnull result_set, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_hierarchical_unmatched_query, &hierarchical_unmatched_query_perf_index);
  cql_code rc = hierarchical_unmatched_query(_db_, &stmt, rate_, limit_, offset_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = hierarchical_unmatched_query_data_types,
    .col_offsets = hierarchical_unmatched_query_col_offsets,
    .rowsize = sizeof(hierarchical_unmatched_query_row),
    .crc = CRC_hierarchical_unmatched_query,
    .perf_index = &hierarchical_unmatched_query_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_unmatched_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id "
      "FROM foo "
      "WHERE id NOT IN (SELECT id "
      "FROM bar "
      "WHERE rate = ? "
    "ORDER BY name "
    "LIMIT ? "
    "OFFSET ?) "
    "ORDER BY id");
  cql_multibind(&_rc_, _db_, _result_, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, rate_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, limit_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, offset_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC union_select ()
BEGIN
  SELECT 1 AS A
  UNION
  SELECT 2 AS A;
END;
*/

#undef _PROC_
#define _PROC_ "union_select"
static int32_t union_select_perf_index;

cql_string_literal(union_select_stored_procedure_name, "union_select");

typedef struct union_select_row {
  cql_int32 A;
} union_select_row;

cql_int32 union_select_get_A(union_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_select_row *data = (union_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].A;
}

uint8_t union_select_data_types[union_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
};

static cql_uint16 union_select_col_offsets[] = { 1,
  cql_offsetof(union_select_row, A)
};

cql_int32 union_select_result_count(union_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_select_fetch_results(sqlite3 *_Nonnull _db_, union_select_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_select, &union_select_perf_index);
  cql_code rc = union_select(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_select_data_types,
    .col_offsets = union_select_col_offsets,
    .rowsize = sizeof(union_select_row),
    .crc = CRC_union_select,
    .perf_index = &union_select_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code union_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1 "
    "UNION "
    "SELECT 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC union_all_select ()
BEGIN
  SELECT 1 AS A
  UNION ALL
  SELECT 2 AS A;
END;
*/

#undef _PROC_
#define _PROC_ "union_all_select"
static int32_t union_all_select_perf_index;

cql_string_literal(union_all_select_stored_procedure_name, "union_all_select");

typedef struct union_all_select_row {
  cql_int32 A;
} union_all_select_row;

cql_int32 union_all_select_get_A(union_all_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_all_select_row *data = (union_all_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].A;
}

uint8_t union_all_select_data_types[union_all_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
};

static cql_uint16 union_all_select_col_offsets[] = { 1,
  cql_offsetof(union_all_select_row, A)
};

cql_int32 union_all_select_result_count(union_all_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_all_select_fetch_results(sqlite3 *_Nonnull _db_, union_all_select_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_all_select, &union_all_select_perf_index);
  cql_code rc = union_all_select(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_all_select_data_types,
    .col_offsets = union_all_select_col_offsets,
    .rowsize = sizeof(union_all_select_row),
    .crc = CRC_union_all_select,
    .perf_index = &union_all_select_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code union_all_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1 "
    "UNION ALL "
    "SELECT 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC union_all_with_nullable ()
BEGIN
  SELECT nullable('foo') AS name
  UNION ALL
  SELECT name
    FROM bar;
END;
*/

#undef _PROC_
#define _PROC_ "union_all_with_nullable"
static int32_t union_all_with_nullable_perf_index;

cql_string_literal(union_all_with_nullable_stored_procedure_name, "union_all_with_nullable");

typedef struct union_all_with_nullable_row {
  cql_string_ref _Nullable name;
} union_all_with_nullable_row;

cql_string_ref _Nullable union_all_with_nullable_get_name(union_all_with_nullable_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_all_with_nullable_row *data = (union_all_with_nullable_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

uint8_t union_all_with_nullable_data_types[union_all_with_nullable_data_types_count] = {
  CQL_DATA_TYPE_STRING, // name
};

#define union_all_with_nullable_refs_offset cql_offsetof(union_all_with_nullable_row, name) // count = 1

static cql_uint16 union_all_with_nullable_col_offsets[] = { 1,
  cql_offsetof(union_all_with_nullable_row, name)
};

cql_int32 union_all_with_nullable_result_count(union_all_with_nullable_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_all_with_nullable_fetch_results(sqlite3 *_Nonnull _db_, union_all_with_nullable_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_all_with_nullable, &union_all_with_nullable_perf_index);
  cql_code rc = union_all_with_nullable(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_all_with_nullable_data_types,
    .col_offsets = union_all_with_nullable_col_offsets,
    .refs_count = 1,
    .refs_offset = union_all_with_nullable_refs_offset,
    .rowsize = sizeof(union_all_with_nullable_row),
    .crc = CRC_union_all_with_nullable,
    .perf_index = &union_all_with_nullable_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code union_all_with_nullable(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 'foo' "
    "UNION ALL "
    "SELECT name "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_stmt_using_cursor ()
BEGIN
  DECLARE C CURSOR FOR WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
  FETCH C;
END;
*/

#undef _PROC_
#define _PROC_ "with_stmt_using_cursor"

typedef struct with_stmt_using_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_stmt_using_cursor_C_row;
CQL_WARN_UNUSED cql_code with_stmt_using_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  with_stmt_using_cursor_C_row C_ = { 0 };

  _rc_ = cql_prepare(_db_, &C,
    "WITH "
    "X (a, b, c) AS (SELECT 1, 2, 3) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 3,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.a,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.b,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.c);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_stmt ()
BEGIN
  WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
END;
*/

#undef _PROC_
#define _PROC_ "with_stmt"
static int32_t with_stmt_perf_index;

cql_string_literal(with_stmt_stored_procedure_name, "with_stmt");

typedef struct with_stmt_row {
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_stmt_row;

cql_int32 with_stmt_get_a(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 with_stmt_get_b(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

cql_int32 with_stmt_get_c(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].c;
}

uint8_t with_stmt_data_types[with_stmt_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // c
};

static cql_uint16 with_stmt_col_offsets[] = { 3,
  cql_offsetof(with_stmt_row, a),
  cql_offsetof(with_stmt_row, b),
  cql_offsetof(with_stmt_row, c)
};

cql_int32 with_stmt_result_count(with_stmt_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_stmt_fetch_results(sqlite3 *_Nonnull _db_, with_stmt_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_stmt, &with_stmt_perf_index);
  cql_code rc = with_stmt(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_stmt_data_types,
    .col_offsets = with_stmt_col_offsets,
    .rowsize = sizeof(with_stmt_row),
    .crc = CRC_with_stmt,
    .perf_index = &with_stmt_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code with_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "WITH "
    "X (a, b, c) AS (SELECT 1, 2, 3) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_recursive_stmt ()
BEGIN
  WITH RECURSIVE
  X (a, b, c) AS (SELECT 1, 2, 3
  UNION ALL
  SELECT 4, 5, 6)
  SELECT *
    FROM X;
END;
*/

#undef _PROC_
#define _PROC_ "with_recursive_stmt"
static int32_t with_recursive_stmt_perf_index;

cql_string_literal(with_recursive_stmt_stored_procedure_name, "with_recursive_stmt");

typedef struct with_recursive_stmt_row {
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_recursive_stmt_row;

cql_int32 with_recursive_stmt_get_a(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 with_recursive_stmt_get_b(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

cql_int32 with_recursive_stmt_get_c(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].c;
}

uint8_t with_recursive_stmt_data_types[with_recursive_stmt_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // c
};

static cql_uint16 with_recursive_stmt_col_offsets[] = { 3,
  cql_offsetof(with_recursive_stmt_row, a),
  cql_offsetof(with_recursive_stmt_row, b),
  cql_offsetof(with_recursive_stmt_row, c)
};

cql_int32 with_recursive_stmt_result_count(with_recursive_stmt_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_recursive_stmt_fetch_results(sqlite3 *_Nonnull _db_, with_recursive_stmt_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_recursive_stmt, &with_recursive_stmt_perf_index);
  cql_code rc = with_recursive_stmt(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_recursive_stmt_data_types,
    .col_offsets = with_recursive_stmt_col_offsets,
    .rowsize = sizeof(with_recursive_stmt_row),
    .crc = CRC_with_recursive_stmt,
    .perf_index = &with_recursive_stmt_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code with_recursive_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "WITH RECURSIVE "
    "X (a, b, c) AS (SELECT 1, 2, 3 "
    "UNION ALL "
    "SELECT 4, 5, 6) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC parent_proc ()
BEGIN
  SELECT 1 AS one, 2 AS two, 3 AS three;
END;
*/

#undef _PROC_
#define _PROC_ "parent_proc"
static int32_t parent_proc_perf_index;

cql_string_literal(parent_proc_stored_procedure_name, "parent_proc");

typedef struct parent_proc_row {
  cql_int32 one;
  cql_int32 two;
  cql_int32 three;
} parent_proc_row;

cql_int32 parent_proc_get_one(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].one;
}

cql_int32 parent_proc_get_two(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].two;
}

cql_int32 parent_proc_get_three(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].three;
}

uint8_t parent_proc_data_types[parent_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // one
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // two
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // three
};

static cql_uint16 parent_proc_col_offsets[] = { 3,
  cql_offsetof(parent_proc_row, one),
  cql_offsetof(parent_proc_row, two),
  cql_offsetof(parent_proc_row, three)
};

cql_int32 parent_proc_result_count(parent_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc_fetch_results(sqlite3 *_Nonnull _db_, parent_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_parent_proc, &parent_proc_perf_index);
  cql_code rc = parent_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = parent_proc_data_types,
    .col_offsets = parent_proc_col_offsets,
    .rowsize = sizeof(parent_proc_row),
    .crc = CRC_parent_proc,
    .perf_index = &parent_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1, 2, 3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC parent_proc_child ()
BEGIN
  SELECT 4 AS four, 5 AS five, 6 AS six;
END;
*/

#undef _PROC_
#define _PROC_ "parent_proc_child"
static int32_t parent_proc_child_perf_index;

cql_string_literal(parent_proc_child_stored_procedure_name, "parent_proc_child");

typedef struct parent_proc_child_row {
  cql_int32 four;
  cql_int32 five;
  cql_int32 six;
} parent_proc_child_row;

cql_int32 parent_proc_child_get_four(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].four;
}

cql_int32 parent_proc_child_get_five(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].five;
}

cql_int32 parent_proc_child_get_six(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].six;
}

uint8_t parent_proc_child_data_types[parent_proc_child_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // four
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // five
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // six
};

static cql_uint16 parent_proc_child_col_offsets[] = { 3,
  cql_offsetof(parent_proc_child_row, four),
  cql_offsetof(parent_proc_child_row, five),
  cql_offsetof(parent_proc_child_row, six)
};

cql_int32 parent_proc_child_result_count(parent_proc_child_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc_child_fetch_results(sqlite3 *_Nonnull _db_, parent_proc_child_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_parent_proc_child, &parent_proc_child_perf_index);
  cql_code rc = parent_proc_child(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = parent_proc_child_data_types,
    .col_offsets = parent_proc_child_col_offsets,
    .rowsize = sizeof(parent_proc_child_row),
    .crc = CRC_parent_proc_child,
    .perf_index = &parent_proc_child_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc_child(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 4, 5, 6");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC outint_nullable (OUT output INTEGER, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
*/

#undef _PROC_
#define _PROC_ "outint_nullable"
CQL_WARN_UNUSED cql_code outint_nullable(sqlite3 *_Nonnull _db_, cql_nullable_int32 *_Nonnull output, cql_bool *_Nonnull result) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  _C_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 1,
                 CQL_DATA_TYPE_INT32, output);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  *result = _C_has_row_;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC outint_notnull (OUT output INTEGER NOT NULL, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
*/

#undef _PROC_
#define _PROC_ "outint_notnull"
CQL_WARN_UNUSED cql_code outint_notnull(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull output, cql_bool *_Nonnull result) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  _C_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, output);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  *result = _C_has_row_;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE result INTEGER;
*/
cql_nullable_int32 result;

// The statement ending at line XXXX

/*
DECLARE text_result TEXT;
*/
cql_string_ref text_result = NULL;

// The statement ending at line XXXX

/*
DECLARE obj_var OBJECT;
*/
cql_object_ref obj_var = NULL;

// The statement ending at line XXXX

/*
DECLARE obj_var2 OBJECT NOT NULL;
*/
cql_object_ref obj_var2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC obj_proc (OUT an_object OBJECT)
BEGIN
  SET an_object := NULL;
END;
*/

#undef _PROC_
#define _PROC_ "obj_proc"
void obj_proc(cql_object_ref _Nullable *_Nonnull an_object) {
  *(void **)an_object = NULL; // set out arg to non-garbage
  cql_set_object_ref(an_object, NULL);

}

// The statement ending at line XXXX

/*
CREATE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL)
BEGIN
  SET o := coalesce(i, -1);
END;
*/

#undef _PROC_
#define _PROC_ "unused_temp"
void unused_temp(cql_nullable_int32 i, cql_int32 *_Nonnull o) {
  do {
    if (!i.is_null) {
      *o = i.value;
      break;
    }
    *o = - 1;
  } while (0);

}

// The statement ending at line XXXX

/*
@ECHO c, "int Garbonzo; // a chick pea\n";
*/
int Garbonzo; // a chick pea

// The statement ending at line XXXX

/*
@ECHO c, "///'\a\b\f\t\v'\r\n";
*/
///'	'

// The statement ending at line XXXX

/*
CREATE PROC echo_test ()
BEGIN
  DECLARE s TEXT;
  SET s := "before echo";
  @ECHO c, "#define ECHO_TEST 1\n";
  SET s := "after echo";
END;
*/

#undef _PROC_
#define _PROC_ "echo_test"
void echo_test(void) {
  cql_string_ref s = NULL;

  cql_set_string_ref(&s, _literal_6_before_echo_echo_test);
  #define ECHO_TEST 1
  cql_set_string_ref(&s, _literal_7_after_echo_echo_test);

  cql_string_release(s);
}

// The statement ending at line XXXX

/*
CREATE PROC insert_values (id_ INTEGER NOT NULL, type_ INTEGER)
BEGIN
  INSERT INTO bar(id, type) VALUES(id_, type_);
END;
*/

#undef _PROC_
#define _PROC_ "insert_values"
CQL_WARN_UNUSED cql_code insert_values(sqlite3 *_Nonnull _db_, cql_int32 id_, cql_nullable_int32 type_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO bar(id, type) VALUES(?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_,
                CQL_DATA_TYPE_INT32, &type_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC alter_table_test ()
BEGIN
  ALTER TABLE bar ADD COLUMN size REAL;
END;
*/

#undef _PROC_
#define _PROC_ "alter_table_test"
CQL_WARN_UNUSED cql_code alter_table_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "ALTER TABLE bar ADD COLUMN size REAL");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC drop_table_test ()
BEGIN
  DROP TABLE IF EXISTS bar;
END;
*/

#undef _PROC_
#define _PROC_ "drop_table_test"
CQL_WARN_UNUSED cql_code drop_table_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP TABLE IF EXISTS bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;
*/

#undef _PROC_
#define _PROC_ "uses_proc_for_result"
static int32_t uses_proc_for_result_perf_index;

cql_string_literal(uses_proc_for_result_stored_procedure_name, "uses_proc_for_result");

typedef struct uses_proc_for_result_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} uses_proc_for_result_row;

cql_int32 uses_proc_for_result_get_id(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable uses_proc_for_result_get_name(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool uses_proc_for_result_get_rate_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 uses_proc_for_result_get_rate_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool uses_proc_for_result_get_type_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 uses_proc_for_result_get_type_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool uses_proc_for_result_get_size_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double uses_proc_for_result_get_size_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t uses_proc_for_result_data_types[uses_proc_for_result_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define uses_proc_for_result_refs_offset cql_offsetof(uses_proc_for_result_row, name) // count = 1

static cql_uint16 uses_proc_for_result_col_offsets[] = { 5,
  cql_offsetof(uses_proc_for_result_row, id),
  cql_offsetof(uses_proc_for_result_row, name),
  cql_offsetof(uses_proc_for_result_row, rate),
  cql_offsetof(uses_proc_for_result_row, type),
  cql_offsetof(uses_proc_for_result_row, size)
};

cql_int32 uses_proc_for_result_result_count(uses_proc_for_result_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code uses_proc_for_result_fetch_results(sqlite3 *_Nonnull _db_, uses_proc_for_result_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_uses_proc_for_result, &uses_proc_for_result_perf_index);
  cql_code rc = uses_proc_for_result(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = uses_proc_for_result_data_types,
    .col_offsets = uses_proc_for_result_col_offsets,
    .refs_count = 1,
    .refs_offset = uses_proc_for_result_refs_offset,
    .rowsize = sizeof(uses_proc_for_result_row),
    .crc = CRC_uses_proc_for_result,
    .perf_index = &uses_proc_for_result_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code uses_proc_for_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = with_result_set(_db_, &*_result_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}
sqlite3_stmt *expanded_select = NULL;
cql_bool _expanded_select_has_row_ = 0;
sqlite3_stmt *table_expanded_select = NULL;
cql_bool _table_expanded_select_has_row_ = 0;

// The statement ending at line XXXX

/*
CREATE PROC index_dropper ()
BEGIN
  DROP INDEX index_1;
END;
*/

#undef _PROC_
#define _PROC_ "index_dropper"
CQL_WARN_UNUSED cql_code index_dropper(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP INDEX index_1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC misc_dml_proc ()
BEGIN
  INSERT INTO foo(id) VALUES(NULL);
  INSERT INTO foo(id) VALUES(NULL);
  UPDATE bar
  SET name = 'bar'
    WHERE name = 'baz';
  DELETE FROM foo WHERE id = 1;
END;
*/

#undef _PROC_
#define _PROC_ "misc_dml_proc"
CQL_WARN_UNUSED cql_code misc_dml_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "UPDATE bar "
    "SET name = 'bar' "
      "WHERE name = 'baz'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM foo WHERE id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC dummy_user ()
BEGIN
  INSERT INTO bar(id, name, rate, type, size) VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;
*/

#undef _PROC_
#define _PROC_ "dummy_user"
CQL_WARN_UNUSED cql_code dummy_user(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_int32 _seed_ = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _seed_ = 123;
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO bar(id, name, rate, type, size) VALUES(?, printf('name_%d', ?), ?, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 5,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC proc_with_out_arg (OUT foo TEXT)
BEGIN
  SET foo := 'x';
END;
*/

#undef _PROC_
#define _PROC_ "proc_with_out_arg"
void proc_with_out_arg(cql_string_ref _Nullable *_Nonnull foo) {
  *(void **)foo = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*foo, _literal_5_x_);

}

// The statement ending at line XXXX

/*
CREATE PROC calls_out_proc (OUT foo TEXT)
BEGIN
  SET foo := 'x';
  DECLARE bar TEXT;
  CALL proc_with_out_arg(foo);
  CALL proc_with_out_arg(bar);
END;
*/

#undef _PROC_
#define _PROC_ "calls_out_proc"
void calls_out_proc(cql_string_ref _Nullable *_Nonnull foo) {
  cql_string_ref bar = NULL;

  *(void **)foo = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*foo, _literal_5_x_);
  cql_set_string_ref(&*foo, NULL);
  proc_with_out_arg(foo);
  cql_set_string_ref(&bar, NULL);
  proc_with_out_arg(&bar);

  cql_string_release(bar);
}

// The statement ending at line XXXX

/*
DECLARE blob_var BLOB;
*/
cql_blob_ref blob_var = NULL;

// The statement ending at line XXXX

/*
DECLARE blob_var2 BLOB NOT NULL;
*/
cql_blob_ref blob_var2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;
*/

#undef _PROC_
#define _PROC_ "blob_proc"
void blob_proc(cql_blob_ref _Nullable *_Nonnull a_blob) {
  *(void **)a_blob = NULL; // set out arg to non-garbage
  cql_set_blob_ref(&*a_blob, NULL);

}

// The statement ending at line XXXX

/*
DECLARE blob_var_notnull BLOB NOT NULL;
*/
cql_blob_ref blob_var_notnull = NULL;

// The statement ending at line XXXX

/*
CREATE PROC blob_returner ()
BEGIN
  SELECT *
    FROM blob_table;
END;
*/

#undef _PROC_
#define _PROC_ "blob_returner"
static int32_t blob_returner_perf_index;

cql_string_literal(blob_returner_stored_procedure_name, "blob_returner");

typedef struct blob_returner_row {
  cql_int32 blob_id;
  cql_blob_ref _Nonnull b_notnull;
  cql_blob_ref _Nullable b_nullable;
} blob_returner_row;

cql_int32 blob_returner_get_blob_id(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].blob_id;
}

cql_blob_ref _Nonnull blob_returner_get_b_notnull(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b_notnull;
}

cql_blob_ref _Nullable blob_returner_get_b_nullable(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b_nullable;
}

uint8_t blob_returner_data_types[blob_returner_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // blob_id
  CQL_DATA_TYPE_BLOB | CQL_DATA_TYPE_NOT_NULL, // b_notnull
  CQL_DATA_TYPE_BLOB, // b_nullable
};

#define blob_returner_refs_offset cql_offsetof(blob_returner_row, b_notnull) // count = 2

static cql_uint16 blob_returner_col_offsets[] = { 3,
  cql_offsetof(blob_returner_row, blob_id),
  cql_offsetof(blob_returner_row, b_notnull),
  cql_offsetof(blob_returner_row, b_nullable)
};

cql_int32 blob_returner_result_count(blob_returner_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code blob_returner_fetch_results(sqlite3 *_Nonnull _db_, blob_returner_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_blob_returner, &blob_returner_perf_index);
  cql_code rc = blob_returner(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = blob_returner_data_types,
    .col_offsets = blob_returner_col_offsets,
    .refs_count = 2,
    .refs_offset = blob_returner_refs_offset,
    .rowsize = sizeof(blob_returner_row),
    .crc = CRC_blob_returner,
    .perf_index = &blob_returner_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code blob_returner(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT blob_id, b_notnull, b_nullable "
      "FROM blob_table");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC voidproc ()
BEGIN
  DECLARE unused INTEGER;
END;
*/

#undef _PROC_
#define _PROC_ "voidproc"
void voidproc(void) {
  cql_nullable_int32 unused;
  cql_set_null(unused);


}

// The statement ending at line XXXX

/*
CREATE PROC out_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT bar.*, 'xyzzy' AS extra1, 'plugh' AS extra2
    FROM bar;
  FETCH C;
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "out_cursor_proc"

#define out_cursor_proc_refs_offset cql_offsetof(out_cursor_proc_row, name) // count = 3
static int32_t out_cursor_proc_perf_index;

cql_string_literal(out_cursor_proc_stored_procedure_name, "out_cursor_proc");

cql_int32 out_cursor_proc_get_id(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_string_ref _Nullable out_cursor_proc_get_name(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->name;
}

cql_bool out_cursor_proc_get_rate_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.is_null;
}

cql_int64 out_cursor_proc_get_rate_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.value;
}

cql_bool out_cursor_proc_get_type_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.is_null;
}

cql_int32 out_cursor_proc_get_type_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.value;
}

cql_bool out_cursor_proc_get_size_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.is_null;
}

cql_double out_cursor_proc_get_size_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.value;
}

cql_string_ref _Nonnull out_cursor_proc_get_extra1(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->extra1;
}

cql_string_ref _Nonnull out_cursor_proc_get_extra2(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->extra2;
}

uint8_t out_cursor_proc_data_types[out_cursor_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // extra1
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // extra2
};

static cql_uint16 out_cursor_proc_col_offsets[] = { 7,
  cql_offsetof(out_cursor_proc_row, id),
  cql_offsetof(out_cursor_proc_row, name),
  cql_offsetof(out_cursor_proc_row, rate),
  cql_offsetof(out_cursor_proc_row, type),
  cql_offsetof(out_cursor_proc_row, size),
  cql_offsetof(out_cursor_proc_row, extra1),
  cql_offsetof(out_cursor_proc_row, extra2)
};

cql_int32 out_cursor_proc_result_count(out_cursor_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code out_cursor_proc_fetch_results(sqlite3 *_Nonnull _db_, out_cursor_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_cursor_proc, &out_cursor_proc_perf_index);
  *result_set = NULL;
  out_cursor_proc_row *row = (out_cursor_proc_row *)calloc(1, sizeof(out_cursor_proc_row));
  cql_code rc = out_cursor_proc(_db_, row);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .data_types = out_cursor_proc_data_types,
    .col_offsets = out_cursor_proc_col_offsets,
    .refs_count = 3,
    .refs_offset = out_cursor_proc_refs_offset,
    .rowsize = sizeof(out_cursor_proc_row),
    .crc = CRC_out_cursor_proc,
    .perf_index = &out_cursor_proc_perf_index,
  };
  return cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct out_cursor_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} out_cursor_proc_C_row;

#define out_cursor_proc_C_refs_offset cql_offsetof(out_cursor_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code out_cursor_proc(sqlite3 *_Nonnull _db_, out_cursor_proc_row *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  memset(_result_, 0, sizeof(*_result_));
  sqlite3_stmt *C = NULL;
  out_cursor_proc_C_row C_ = { ._refs_count_ = 3, ._refs_offset_ = out_cursor_proc_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C,
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size, 'xyzzy', 'plugh' "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 7,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.id,
                 CQL_DATA_TYPE_STRING, &C_.name,
                 CQL_DATA_TYPE_INT64, &C_.rate,
                 CQL_DATA_TYPE_INT32, &C_.type,
                 CQL_DATA_TYPE_DOUBLE, &C_.size,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.extra1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.extra2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _result_->_has_row_ = C_._has_row_;
  _result_->_refs_count_ = 3;
  _result_->_refs_offset_ = out_cursor_proc_refs_offset;
  _result_->id = C_.id;
  cql_set_string_ref(&_result_->name, C_.name);
  _result_->rate = C_.rate;
  _result_->type = C_.type;
  _result_->size = C_.size;
  cql_set_string_ref(&_result_->extra1, C_.extra1);
  cql_set_string_ref(&_result_->extra2, C_.extra2);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC read_cursor_proc ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;
*/

#undef _PROC_
#define _PROC_ "read_cursor_proc"

typedef struct read_cursor_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} read_cursor_proc_C_row;

#define read_cursor_proc_C_refs_offset cql_offsetof(read_cursor_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code read_cursor_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  read_cursor_proc_C_row C_ = { ._refs_count_ = 3, ._refs_offset_ = read_cursor_proc_C_refs_offset };

  cql_teardown_row(C_);
  _rc_ = out_cursor_proc(_db_, (out_cursor_proc_row *)&C_); // out_cursor_proc_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_then_fetch_from_proc ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
END;
*/

#undef _PROC_
#define _PROC_ "declare_cursor_then_fetch_from_proc"

typedef struct declare_cursor_then_fetch_from_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} declare_cursor_then_fetch_from_proc_C_row;

#define declare_cursor_then_fetch_from_proc_C_refs_offset cql_offsetof(declare_cursor_then_fetch_from_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code declare_cursor_then_fetch_from_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  declare_cursor_then_fetch_from_proc_C_row C_ = { ._refs_count_ = 3, ._refs_offset_ = declare_cursor_then_fetch_from_proc_C_refs_offset };

  cql_teardown_row(C_);
  _rc_ = out_cursor_proc(_db_, (out_cursor_proc_row *)&C_); // out_cursor_proc_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE PROC fetcher_proc () OUT (a INTEGER, b TEXT);
*/

// The statement ending at line XXXX

/*
DECLARE PROC totally_void_proc ();
*/

// The statement ending at line XXXX

/*
DECLARE PROC compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
DECLARE PROC dml_compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
CREATE PROC dml_user (OUT a_ INTEGER NOT NULL)
BEGIN
  SET a_ := dml_compute(1);
END;
*/

#undef _PROC_
#define _PROC_ "dml_user"
CQL_WARN_UNUSED cql_code dml_user(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull a_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = dml_compute(_db_, 1, &*a_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC thread_theme_info_list (thread_key_ LONG_INT NOT NULL)
BEGIN
  SELECT *
    FROM (SELECT thread_key
    FROM threads) AS T;
END;
*/

#undef _PROC_
#define _PROC_ "thread_theme_info_list"
static int32_t thread_theme_info_list_perf_index;

cql_string_literal(thread_theme_info_list_stored_procedure_name, "thread_theme_info_list");

typedef struct thread_theme_info_list_row {
  cql_int64 thread_key;
} thread_theme_info_list_row;

cql_int64 thread_theme_info_list_get_thread_key(thread_theme_info_list_result_set_ref _Nonnull result_set, cql_int32 row) {
  thread_theme_info_list_row *data = (thread_theme_info_list_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].thread_key;
}

uint8_t thread_theme_info_list_data_types[thread_theme_info_list_data_types_count] = {
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // thread_key
};

static cql_uint16 thread_theme_info_list_col_offsets[] = { 1,
  cql_offsetof(thread_theme_info_list_row, thread_key)
};

cql_int32 thread_theme_info_list_result_count(thread_theme_info_list_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code thread_theme_info_list_fetch_results(sqlite3 *_Nonnull _db_, thread_theme_info_list_result_set_ref _Nullable *_Nonnull result_set, cql_int64 thread_key_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_thread_theme_info_list, &thread_theme_info_list_perf_index);
  cql_code rc = thread_theme_info_list(_db_, &stmt, thread_key_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = thread_theme_info_list_data_types,
    .col_offsets = thread_theme_info_list_col_offsets,
    .rowsize = sizeof(thread_theme_info_list_row),
    .crc = CRC_thread_theme_info_list,
    .perf_index = &thread_theme_info_list_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code thread_theme_info_list(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_, cql_int64 thread_key_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT thread_key "
      "FROM (SELECT thread_key "
      "FROM threads) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC fetch_values_dummy ()
BEGIN
  DECLARE C CURSOR LIKE SELECT *
    FROM bar;
  FETCH C(id, name, rate, type, size) FROM VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
*/

#undef _PROC_
#define _PROC_ "fetch_values_dummy"

typedef struct fetch_values_dummy_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} fetch_values_dummy_C_row;

#define fetch_values_dummy_C_refs_offset cql_offsetof(fetch_values_dummy_C_row, name) // count = 1
void fetch_values_dummy(void) {
  fetch_values_dummy_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = fetch_values_dummy_C_refs_offset };
  cql_int32 _seed_ = 0;
  cql_string_ref _tmp_text_0 = NULL;

  _seed_ = 123;
  C_._has_row_ = 1;
  C_.id = _seed_;
  {
    char *_printf_result = sqlite3_mprintf("name_%d", _seed_);
    cql_string_release(_tmp_text_0);
    _tmp_text_0 = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }
  cql_set_string_ref(&C_.name, _tmp_text_0);
  cql_set_notnull(C_.rate, _seed_);
  cql_set_notnull(C_.type, _seed_);
  cql_set_notnull(C_.size, _seed_);

  cql_teardown_row(C_);
  cql_string_release(_tmp_text_0);
}

// The statement ending at line XXXX

/*
CREATE PROC c_literal (OUT x TEXT)
BEGIN
  SET x := "\"Testing\" \\''";
END;
*/

#undef _PROC_
#define _PROC_ "c_literal"
void c_literal(cql_string_ref _Nullable *_Nonnull x) {
  *(void **)x = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*x, _literal_8_Testing_c_literal);

}

// The statement ending at line XXXX

/*
CREATE PROC no_cleanup_label_needed_proc ()
BEGIN
  BEGIN TRY
    DECLARE C CURSOR FOR SELECT 1 AS N;
    FETCH C;
  END TRY;
  BEGIN CATCH
    DECLARE x INTEGER;
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "no_cleanup_label_needed_proc"

typedef struct no_cleanup_label_needed_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 N;
} no_cleanup_label_needed_proc_C_row;
CQL_WARN_UNUSED cql_code no_cleanup_label_needed_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  no_cleanup_label_needed_proc_C_row C_ = { 0 };
  cql_nullable_int32 x;
  cql_set_null(x);

  // try
  {
    _rc_ = cql_prepare(_db_, &C,
      "SELECT 1");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_2; }
    _rc_ = sqlite3_step(C);
    C_._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.N);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto catch_start_2; }
    goto catch_end_2;
  }
  catch_start_2: {
  }
  catch_end_2:;
  _rc_ = SQLITE_OK;

  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC no_code_after_catch ()
BEGIN
  BEGIN TRY
    @ATTRIBUTE(foo)
    DECLARE x INTEGER;
  END TRY;
  BEGIN CATCH
    @ATTRIBUTE(bar)
    DECLARE y INTEGER;
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "no_code_after_catch"
CQL_WARN_UNUSED cql_code no_code_after_catch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_nullable_int32 y;
  cql_set_null(y);

  // try
  {
    goto catch_end_3;
  }
  {
  }
  catch_end_3:;
  _rc_ = SQLITE_OK;

  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_no_db ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  FETCH C(A, B) FROM VALUES(3, 12);
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "out_no_db"
static int32_t out_no_db_perf_index;

cql_string_literal(out_no_db_stored_procedure_name, "out_no_db");

cql_int32 out_no_db_get_A(out_no_db_result_set_ref _Nonnull result_set) {
  out_no_db_row *data = (out_no_db_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_double out_no_db_get_B(out_no_db_result_set_ref _Nonnull result_set) {
  out_no_db_row *data = (out_no_db_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t out_no_db_data_types[out_no_db_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 out_no_db_col_offsets[] = { 2,
  cql_offsetof(out_no_db_row, A),
  cql_offsetof(out_no_db_row, B)
};

cql_int32 out_no_db_result_count(out_no_db_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void out_no_db_fetch_results( out_no_db_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_no_db, &out_no_db_perf_index);
  *result_set = NULL;
  out_no_db_row *row = (out_no_db_row *)calloc(1, sizeof(out_no_db_row));
  out_no_db(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = out_no_db_data_types,
    .col_offsets = out_no_db_col_offsets,
    .rowsize = sizeof(out_no_db_row),
    .crc = CRC_out_no_db,
    .perf_index = &out_no_db_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct out_no_db_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} out_no_db_C_row;
void out_no_db(out_no_db_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  out_no_db_C_row C_ = { 0 };

  C_._has_row_ = 1;
  C_.A = 3;
  C_.B = 12;
  _result_->_has_row_ = C_._has_row_;
  _result_->A = C_.A;
  _result_->B = C_.B;

}

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C1(A, B) FROM VALUES(3, 12);
  OUT C1;
END;
*/

#undef _PROC_
#define _PROC_ "declare_cursor_like_cursor"
static int32_t declare_cursor_like_cursor_perf_index;

cql_string_literal(declare_cursor_like_cursor_stored_procedure_name, "declare_cursor_like_cursor");

cql_int32 declare_cursor_like_cursor_get_A(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  declare_cursor_like_cursor_row *data = (declare_cursor_like_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_double declare_cursor_like_cursor_get_B(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  declare_cursor_like_cursor_row *data = (declare_cursor_like_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t declare_cursor_like_cursor_data_types[declare_cursor_like_cursor_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 declare_cursor_like_cursor_col_offsets[] = { 2,
  cql_offsetof(declare_cursor_like_cursor_row, A),
  cql_offsetof(declare_cursor_like_cursor_row, B)
};

cql_int32 declare_cursor_like_cursor_result_count(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_cursor_fetch_results( declare_cursor_like_cursor_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_cursor, &declare_cursor_like_cursor_perf_index);
  *result_set = NULL;
  declare_cursor_like_cursor_row *row = (declare_cursor_like_cursor_row *)calloc(1, sizeof(declare_cursor_like_cursor_row));
  declare_cursor_like_cursor(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_cursor_data_types,
    .col_offsets = declare_cursor_like_cursor_col_offsets,
    .rowsize = sizeof(declare_cursor_like_cursor_row),
    .crc = CRC_declare_cursor_like_cursor,
    .perf_index = &declare_cursor_like_cursor_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct declare_cursor_like_cursor_C0_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_C0_row;

typedef struct declare_cursor_like_cursor_C1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_C1_row;
void declare_cursor_like_cursor(declare_cursor_like_cursor_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_cursor_C0_row C0_ = { 0 };
  declare_cursor_like_cursor_C1_row C1_ = { 0 };

  C1_._has_row_ = 1;
  C1_.A = 3;
  C1_.B = 12;
  _result_->_has_row_ = C1_._has_row_;
  _result_->A = C1_.A;
  _result_->B = C1_.B;

}

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_proc ()
BEGIN
  DECLARE C CURSOR LIKE fetcher_proc;
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "declare_cursor_like_proc"

#define declare_cursor_like_proc_refs_offset cql_offsetof(declare_cursor_like_proc_row, b) // count = 1
static int32_t declare_cursor_like_proc_perf_index;

cql_string_literal(declare_cursor_like_proc_stored_procedure_name, "declare_cursor_like_proc");

cql_bool declare_cursor_like_proc_get_a_is_null(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->a.is_null;
}

cql_int32 declare_cursor_like_proc_get_a_value(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->a.value;
}

cql_string_ref _Nullable declare_cursor_like_proc_get_b(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->b;
}

uint8_t declare_cursor_like_proc_data_types[declare_cursor_like_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32, // a
  CQL_DATA_TYPE_STRING, // b
};

static cql_uint16 declare_cursor_like_proc_col_offsets[] = { 2,
  cql_offsetof(declare_cursor_like_proc_row, a),
  cql_offsetof(declare_cursor_like_proc_row, b)
};

cql_int32 declare_cursor_like_proc_result_count(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_proc_fetch_results( declare_cursor_like_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_proc, &declare_cursor_like_proc_perf_index);
  *result_set = NULL;
  declare_cursor_like_proc_row *row = (declare_cursor_like_proc_row *)calloc(1, sizeof(declare_cursor_like_proc_row));
  declare_cursor_like_proc(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_proc_data_types,
    .col_offsets = declare_cursor_like_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = declare_cursor_like_proc_refs_offset,
    .rowsize = sizeof(declare_cursor_like_proc_row),
    .crc = CRC_declare_cursor_like_proc,
    .perf_index = &declare_cursor_like_proc_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct declare_cursor_like_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} declare_cursor_like_proc_C_row;

#define declare_cursor_like_proc_C_refs_offset cql_offsetof(declare_cursor_like_proc_C_row, b) // count = 1
void declare_cursor_like_proc(declare_cursor_like_proc_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_proc_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = declare_cursor_like_proc_C_refs_offset };

  _result_->_has_row_ = C_._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = declare_cursor_like_proc_refs_offset;
  _result_->a = C_.a;
  cql_set_string_ref(&_result_->b, C_.b);

  cql_teardown_row(C_);
}

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_table ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "declare_cursor_like_table"

#define declare_cursor_like_table_refs_offset cql_offsetof(declare_cursor_like_table_row, name) // count = 1
static int32_t declare_cursor_like_table_perf_index;

cql_string_literal(declare_cursor_like_table_stored_procedure_name, "declare_cursor_like_table");

cql_int32 declare_cursor_like_table_get_id(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_string_ref _Nullable declare_cursor_like_table_get_name(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->name;
}

cql_bool declare_cursor_like_table_get_rate_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.is_null;
}

cql_int64 declare_cursor_like_table_get_rate_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.value;
}

cql_bool declare_cursor_like_table_get_type_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.is_null;
}

cql_int32 declare_cursor_like_table_get_type_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.value;
}

cql_bool declare_cursor_like_table_get_size_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.is_null;
}

cql_double declare_cursor_like_table_get_size_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.value;
}

uint8_t declare_cursor_like_table_data_types[declare_cursor_like_table_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

static cql_uint16 declare_cursor_like_table_col_offsets[] = { 5,
  cql_offsetof(declare_cursor_like_table_row, id),
  cql_offsetof(declare_cursor_like_table_row, name),
  cql_offsetof(declare_cursor_like_table_row, rate),
  cql_offsetof(declare_cursor_like_table_row, type),
  cql_offsetof(declare_cursor_like_table_row, size)
};

cql_int32 declare_cursor_like_table_result_count(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_table_fetch_results( declare_cursor_like_table_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_table, &declare_cursor_like_table_perf_index);
  *result_set = NULL;
  declare_cursor_like_table_row *row = (declare_cursor_like_table_row *)calloc(1, sizeof(declare_cursor_like_table_row));
  declare_cursor_like_table(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_table_data_types,
    .col_offsets = declare_cursor_like_table_col_offsets,
    .refs_count = 1,
    .refs_offset = declare_cursor_like_table_refs_offset,
    .rowsize = sizeof(declare_cursor_like_table_row),
    .crc = CRC_declare_cursor_like_table,
    .perf_index = &declare_cursor_like_table_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct declare_cursor_like_table_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} declare_cursor_like_table_C_row;

#define declare_cursor_like_table_C_refs_offset cql_offsetof(declare_cursor_like_table_C_row, name) // count = 1
void declare_cursor_like_table(declare_cursor_like_table_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_table_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = declare_cursor_like_table_C_refs_offset };

  _result_->_has_row_ = C_._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = declare_cursor_like_table_refs_offset;
  _result_->id = C_.id;
  cql_set_string_ref(&_result_->name, C_.name);
  _result_->rate = C_.rate;
  _result_->type = C_.type;
  _result_->size = C_.size;

  cql_teardown_row(C_);
}

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_view ()
BEGIN
  DECLARE C CURSOR LIKE MyView;
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "declare_cursor_like_view"
static int32_t declare_cursor_like_view_perf_index;

cql_string_literal(declare_cursor_like_view_stored_procedure_name, "declare_cursor_like_view");

cql_int32 declare_cursor_like_view_get_f1(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f1;
}

cql_int32 declare_cursor_like_view_get_f2(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f2;
}

cql_int32 declare_cursor_like_view_get_f3(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f3;
}

uint8_t declare_cursor_like_view_data_types[declare_cursor_like_view_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f1
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f2
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f3
};

static cql_uint16 declare_cursor_like_view_col_offsets[] = { 3,
  cql_offsetof(declare_cursor_like_view_row, f1),
  cql_offsetof(declare_cursor_like_view_row, f2),
  cql_offsetof(declare_cursor_like_view_row, f3)
};

cql_int32 declare_cursor_like_view_result_count(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_view_fetch_results( declare_cursor_like_view_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_view, &declare_cursor_like_view_perf_index);
  *result_set = NULL;
  declare_cursor_like_view_row *row = (declare_cursor_like_view_row *)calloc(1, sizeof(declare_cursor_like_view_row));
  declare_cursor_like_view(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_view_data_types,
    .col_offsets = declare_cursor_like_view_col_offsets,
    .rowsize = sizeof(declare_cursor_like_view_row),
    .crc = CRC_declare_cursor_like_view,
    .perf_index = &declare_cursor_like_view_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct declare_cursor_like_view_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 f1;
  cql_int32 f2;
  cql_int32 f3;
} declare_cursor_like_view_C_row;
void declare_cursor_like_view(declare_cursor_like_view_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_view_C_row C_ = { 0 };

  _result_->_has_row_ = C_._has_row_;
  _result_->f1 = C_.f1;
  _result_->f2 = C_.f2;
  _result_->f3 = C_.f3;

}

// The statement ending at line XXXX

/*
CREATE PROC weird_quoting ()
BEGIN
  DELETE FROM bar WHERE name LIKE "\n\n";
  DELETE FROM bar WHERE name = ' '' \n '' \';
  DELETE FROM bar WHERE name <> "'";
  DELETE FROM bar WHERE name >= '\';
END;
*/

#undef _PROC_
#define _PROC_ "weird_quoting"
CQL_WARN_UNUSED cql_code weird_quoting(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\n\n'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name = ' '' \\n '' \\'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name <> ''''");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name >= '\\'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC long_auto_table_maker ()
BEGIN
  CREATE TABLE long_int_autoinc(
    id LONG_INT PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );
END;
*/

#undef _PROC_
#define _PROC_ "long_auto_table_maker"
CQL_WARN_UNUSED cql_code long_auto_table_maker(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE TABLE long_int_autoinc( "
      "id INTEGER PRIMARY KEY AUTOINCREMENT, "
      "name TEXT "
    ")");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE PROC blob_out (OUT x BLOB);
*/

// The statement ending at line XXXX

/*
CREATE PROC blob_call1 ()
BEGIN
  DECLARE b BLOB;
  CALL blob_out(b);
END;
*/

#undef _PROC_
#define _PROC_ "blob_call1"
void blob_call1(void) {
  cql_blob_ref b = NULL;

  cql_set_blob_ref(&b, NULL);
  blob_out(&b);

  cql_blob_release(b);
}

// The statement ending at line XXXX

/*
CREATE PROC blob_call2 ()
BEGIN
  DECLARE b BLOB;
  SET b := blob_out();
END;
*/

#undef _PROC_
#define _PROC_ "blob_call2"
void blob_call2(void) {
  cql_blob_ref b = NULL;

  cql_set_blob_ref(&b, NULL);
  blob_out(&b);

  cql_blob_release(b);
}

// The statement ending at line XXXX

/*
CREATE PROC blob_no_else ()
BEGIN
  DECLARE b BLOB;
  DECLARE b1 BLOB;
  SET b := CASE b WHEN b THEN b1
  END;
END;
*/

#undef _PROC_
#define _PROC_ "blob_no_else"
void blob_no_else(void) {
  cql_blob_ref b = NULL;
  cql_blob_ref b1 = NULL;
  cql_blob_ref _tmp_n_blob_1 = NULL;

  do {
      cql_set_blob_ref(&_tmp_n_blob_1, b);
      if (!_tmp_n_blob_1) goto case_else_3;
    if (cql_is_nullable_true(!b, _tmp_n_blob_1 == b)) {
      cql_set_blob_ref(&b, b1);
      break;
    }
    case_else_3:
    cql_set_blob_ref(&b, NULL);
  } while (0);

  cql_blob_release(b);
  cql_blob_release(b1);
  cql_blob_release(_tmp_n_blob_1);
}

// The statement ending at line XXXX

/*
CREATE PROC with_inserter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) SELECT *
    FROM x;
END;
*/

#undef _PROC_
#define _PROC_ "with_inserter"
CQL_WARN_UNUSED cql_code with_inserter(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "INSERT INTO foo(id) SELECT a "
      "FROM x");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC multi_rewrite (blob_id_ INTEGER NOT NULL, b_notnull_ BLOB NOT NULL, b_nullable_ BLOB, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT, type_ INTEGER, size_ REAL, OUT out_arg INTEGER NOT NULL)
BEGIN
  INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(blob_id_, b_notnull_, b_nullable_);
  SET out_arg := 1;
END;
*/

#undef _PROC_
#define _PROC_ "multi_rewrite"
CQL_WARN_UNUSED cql_code multi_rewrite(sqlite3 *_Nonnull _db_, cql_int32 blob_id_, cql_blob_ref _Nonnull b_notnull_, cql_blob_ref _Nullable b_nullable_, cql_int32 id_, cql_string_ref _Nullable name_, cql_nullable_int64 rate_, cql_nullable_int32 type_, cql_nullable_double size_, cql_int32 *_Nonnull out_arg) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(?, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, blob_id_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BLOB, b_notnull_,
                CQL_DATA_TYPE_BLOB, b_nullable_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  *out_arg = 1;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC fetch_to_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, "foo" AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0(A, B) FROM VALUES(2, "bar");
  FETCH C1 FROM C0;
  OUT C1;
END;
*/

#undef _PROC_
#define _PROC_ "fetch_to_cursor_from_cursor"

#define fetch_to_cursor_from_cursor_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_row, B) // count = 1
static int32_t fetch_to_cursor_from_cursor_perf_index;

cql_string_literal(fetch_to_cursor_from_cursor_stored_procedure_name, "fetch_to_cursor_from_cursor");

cql_int32 fetch_to_cursor_from_cursor_get_A(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  fetch_to_cursor_from_cursor_row *data = (fetch_to_cursor_from_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_string_ref _Nonnull fetch_to_cursor_from_cursor_get_B(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  fetch_to_cursor_from_cursor_row *data = (fetch_to_cursor_from_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t fetch_to_cursor_from_cursor_data_types[fetch_to_cursor_from_cursor_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 fetch_to_cursor_from_cursor_col_offsets[] = { 2,
  cql_offsetof(fetch_to_cursor_from_cursor_row, A),
  cql_offsetof(fetch_to_cursor_from_cursor_row, B)
};

cql_int32 fetch_to_cursor_from_cursor_result_count(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void fetch_to_cursor_from_cursor_fetch_results( fetch_to_cursor_from_cursor_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_fetch_to_cursor_from_cursor, &fetch_to_cursor_from_cursor_perf_index);
  *result_set = NULL;
  fetch_to_cursor_from_cursor_row *row = (fetch_to_cursor_from_cursor_row *)calloc(1, sizeof(fetch_to_cursor_from_cursor_row));
  fetch_to_cursor_from_cursor(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = fetch_to_cursor_from_cursor_data_types,
    .col_offsets = fetch_to_cursor_from_cursor_col_offsets,
    .refs_count = 1,
    .refs_offset = fetch_to_cursor_from_cursor_refs_offset,
    .rowsize = sizeof(fetch_to_cursor_from_cursor_row),
    .crc = CRC_fetch_to_cursor_from_cursor,
    .perf_index = &fetch_to_cursor_from_cursor_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct fetch_to_cursor_from_cursor_C0_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_C0_row;

#define fetch_to_cursor_from_cursor_C0_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_C0_row, B) // count = 1

typedef struct fetch_to_cursor_from_cursor_C1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_C1_row;

#define fetch_to_cursor_from_cursor_C1_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_C1_row, B) // count = 1
void fetch_to_cursor_from_cursor(fetch_to_cursor_from_cursor_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  fetch_to_cursor_from_cursor_C0_row C0_ = { ._refs_count_ = 1, ._refs_offset_ = fetch_to_cursor_from_cursor_C0_refs_offset };
  fetch_to_cursor_from_cursor_C1_row C1_ = { ._refs_count_ = 1, ._refs_offset_ = fetch_to_cursor_from_cursor_C1_refs_offset };

  C0_._has_row_ = 1;
  C0_.A = 2;
  cql_set_string_ref(&C0_.B, _literal_9_bar_fetch_to_cursor_from_cursor);
  C1_._has_row_ = C0_._has_row_;
  C1_.A = C0_.A;
  cql_set_string_ref(&C1_.B, C0_.B);
  _result_->_has_row_ = C1_._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = fetch_to_cursor_from_cursor_refs_offset;
  _result_->A = C1_.A;
  cql_set_string_ref(&_result_->B, C1_.B);

  cql_teardown_row(C0_);
  cql_teardown_row(C1_);
}

// The statement ending at line XXXX

/*
CREATE PROC loop_statement_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.A);
  END;
END;
*/

#undef _PROC_
#define _PROC_ "loop_statement_cursor"

typedef struct loop_statement_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
} loop_statement_cursor_C_row;
CQL_WARN_UNUSED cql_code loop_statement_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  loop_statement_cursor_C_row C_ = { 0 };

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C);
    C_._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.A);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C_._has_row_) break;
    printf("%d\n", C_.A);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC loop_statement_not_auto_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  DECLARE A_ INTEGER NOT NULL;
  LOOP FETCH C INTO A_
  BEGIN
    CALL printf("%d\n", A_);
  END;
END;
*/

#undef _PROC_
#define _PROC_ "loop_statement_not_auto_cursor"
CQL_WARN_UNUSED cql_code loop_statement_not_auto_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_bool _C_has_row_ = 0;
  cql_int32 A_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C);
    _C_has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &A_);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!_C_has_row_) break;
    printf("%d\n", A_);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}
sqlite3_stmt *global_cursor = NULL;
global_cursor_row global_cursor_ = { 0 };

// The statement ending at line XXXX

/*
CREATE PROC make_trigger ()
BEGIN
  CREATE TEMP TRIGGER IF NOT EXISTS trigger1
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;
*/

#undef _PROC_
#define _PROC_ "make_trigger"
CQL_WARN_UNUSED cql_code make_trigger(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE TEMP TRIGGER IF NOT EXISTS trigger1 "
      "BEFORE DELETE ON bar "
      "FOR EACH ROW "
      "WHEN old.id > 7 "
    "BEGIN "
      "SELECT old.id; "
    "END");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC is_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS 1;
  SET b := 'x' IS 'x';
  SET b := 'x' IS 'y';
  SET b := 1 + (3 IS 4);
  DECLARE i INTEGER;
  DECLARE j INTEGER;
  SET i := 1;
  SET j := 2;
  SET b := i IS j;
END;
*/

#undef _PROC_
#define _PROC_ "is_test"
void is_test(void) {
  cql_bool b = 0;
  cql_nullable_int32 i;
  cql_set_null(i);
  cql_nullable_int32 j;
  cql_set_null(j);

  b = 1 == 1;
  b = cql_string_equal(_literal_5_x_, _literal_5_x_);
  b = cql_string_equal(_literal_5_x_, _literal_10_y_);
  b = !!(1 + (3 == 4));
  cql_set_notnull(i, 1);
  cql_set_notnull(j, 2);
  b = ((i.is_null == j.is_null) && (j.is_null || i.value == j.value));

}

// The statement ending at line XXXX

/*
CREATE PROC is_not_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS NOT 1;
  SET b := 'x' IS NOT 'x';
  SET b := 'x' IS NOT 'y';
  SET b := 1 + (3 IS NOT 4);
  DECLARE i INTEGER;
  DECLARE j INTEGER;
  SET i := 1;
  SET j := 2;
  SET b := i IS NOT j;
END;
*/

#undef _PROC_
#define _PROC_ "is_not_test"
void is_not_test(void) {
  cql_bool b = 0;
  cql_nullable_int32 i;
  cql_set_null(i);
  cql_nullable_int32 j;
  cql_set_null(j);

  b = 1 != 1;
  b = !cql_string_equal(_literal_5_x_, _literal_5_x_);
  b = !cql_string_equal(_literal_5_x_, _literal_10_y_);
  b = !!(1 + (3 != 4));
  cql_set_notnull(i, 1);
  cql_set_notnull(j, 2);
  b = !((i.is_null == j.is_null) && (j.is_null || i.value == j.value));

}

// The statement ending at line XXXX

/*
CREATE PROC in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL IN (1);
END;
*/

#undef _PROC_
#define _PROC_ "in_test"
void in_test(cql_nullable_int32 x, cql_nullable_bool *_Nonnull b) {
  cql_set_null(*b);

}

// The statement ending at line XXXX

/*
CREATE PROC not_in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL NOT IN (1);
END;
*/

#undef _PROC_
#define _PROC_ "not_in_test"
void not_in_test(cql_nullable_int32 x, cql_nullable_bool *_Nonnull b) {
  cql_set_null(*b);

}

// The statement ending at line XXXX

/*
CREATE PROC drop_trigger_test ()
BEGIN
  DROP TRIGGER IF EXISTS trigger1;
  DROP TRIGGER trigger1;
END;
*/

#undef _PROC_
#define _PROC_ "drop_trigger_test"
CQL_WARN_UNUSED cql_code drop_trigger_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER IF EXISTS trigger1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER trigger1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC simple_identity ()
BEGIN
  SELECT 1 AS id, 2 AS data;
END;
*/

#undef _PROC_
#define _PROC_ "simple_identity"
static int32_t simple_identity_perf_index;

cql_string_literal(simple_identity_stored_procedure_name, "simple_identity");

typedef struct simple_identity_row {
  cql_int32 id;
  cql_int32 data;
} simple_identity_row;

cql_int32 simple_identity_get_id(simple_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  simple_identity_row *data = (simple_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 simple_identity_get_data(simple_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  simple_identity_row *data = (simple_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t simple_identity_data_types[simple_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 simple_identity_col_offsets[] = { 2,
  cql_offsetof(simple_identity_row, id),
  cql_offsetof(simple_identity_row, data)
};

static cql_uint16 simple_identity_identity_columns[] = { 1,
  0, // id
};

cql_int32 simple_identity_result_count(simple_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code simple_identity_fetch_results(sqlite3 *_Nonnull _db_, simple_identity_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_simple_identity, &simple_identity_perf_index);
  cql_code rc = simple_identity(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = simple_identity_data_types,
    .col_offsets = simple_identity_col_offsets,
    .identity_columns = simple_identity_identity_columns,
    .rowsize = sizeof(simple_identity_row),
    .crc = CRC_simple_identity,
    .perf_index = &simple_identity_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code simple_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC complex_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;
*/

#undef _PROC_
#define _PROC_ "complex_identity"
static int32_t complex_identity_perf_index;

cql_string_literal(complex_identity_stored_procedure_name, "complex_identity");

typedef struct complex_identity_row {
  cql_int32 col1;
  cql_int32 col2;
  cql_int32 data;
} complex_identity_row;

cql_int32 complex_identity_get_col1(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].col1;
}

cql_int32 complex_identity_get_col2(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].col2;
}

cql_int32 complex_identity_get_data(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t complex_identity_data_types[complex_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // col1
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // col2
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 complex_identity_col_offsets[] = { 3,
  cql_offsetof(complex_identity_row, col1),
  cql_offsetof(complex_identity_row, col2),
  cql_offsetof(complex_identity_row, data)
};

static cql_uint16 complex_identity_identity_columns[] = { 2,
  0, // col1
  1, // col2
};

cql_int32 complex_identity_result_count(complex_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code complex_identity_fetch_results(sqlite3 *_Nonnull _db_, complex_identity_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_complex_identity, &complex_identity_perf_index);
  cql_code rc = complex_identity(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = complex_identity_data_types,
    .col_offsets = complex_identity_col_offsets,
    .identity_columns = complex_identity_identity_columns,
    .rowsize = sizeof(complex_identity_row),
    .crc = CRC_complex_identity,
    .perf_index = &complex_identity_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code complex_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1, 2, 3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_cursor_identity ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 2 AS data;
  FETCH C;
  OUT C;
END;
*/

#undef _PROC_
#define _PROC_ "out_cursor_identity"
static int32_t out_cursor_identity_perf_index;

cql_string_literal(out_cursor_identity_stored_procedure_name, "out_cursor_identity");

cql_int32 out_cursor_identity_get_id(out_cursor_identity_result_set_ref _Nonnull result_set) {
  out_cursor_identity_row *data = (out_cursor_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_int32 out_cursor_identity_get_data(out_cursor_identity_result_set_ref _Nonnull result_set) {
  out_cursor_identity_row *data = (out_cursor_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->data;
}

uint8_t out_cursor_identity_data_types[out_cursor_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 out_cursor_identity_col_offsets[] = { 2,
  cql_offsetof(out_cursor_identity_row, id),
  cql_offsetof(out_cursor_identity_row, data)
};

static cql_uint16 out_cursor_identity_identity_columns[] = { 1,
  0, // id
};

cql_int32 out_cursor_identity_result_count(out_cursor_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code out_cursor_identity_fetch_results(sqlite3 *_Nonnull _db_, out_cursor_identity_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_cursor_identity, &out_cursor_identity_perf_index);
  *result_set = NULL;
  out_cursor_identity_row *row = (out_cursor_identity_row *)calloc(1, sizeof(out_cursor_identity_row));
  cql_code rc = out_cursor_identity(_db_, row);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .data_types = out_cursor_identity_data_types,
    .col_offsets = out_cursor_identity_col_offsets,
    .identity_columns = out_cursor_identity_identity_columns,
    .rowsize = sizeof(out_cursor_identity_row),
    .crc = CRC_out_cursor_identity,
    .perf_index = &out_cursor_identity_perf_index,
  };
  return cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct out_cursor_identity_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_int32 data;
} out_cursor_identity_C_row;
CQL_WARN_UNUSED cql_code out_cursor_identity(sqlite3 *_Nonnull _db_, out_cursor_identity_row *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  memset(_result_, 0, sizeof(*_result_));
  sqlite3_stmt *C = NULL;
  out_cursor_identity_C_row C_ = { 0 };

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.id,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.data);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _result_->_has_row_ = C_._has_row_;
  _result_->id = C_.id;
  _result_->data = C_.data;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC radioactive_proc ()
BEGIN
  SELECT *
    FROM radioactive;
END;
*/

#undef _PROC_
#define _PROC_ "radioactive_proc"
static int32_t radioactive_proc_perf_index;

cql_string_literal(radioactive_proc_stored_procedure_name, "radioactive_proc");

typedef struct radioactive_proc_row {
  cql_int32 id;
  cql_string_ref _Nullable data;
} radioactive_proc_row;

cql_int32 radioactive_proc_get_id(radioactive_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  radioactive_proc_row *data = (radioactive_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable radioactive_proc_get_data(radioactive_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  radioactive_proc_row *data = (radioactive_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t radioactive_proc_data_types[radioactive_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // data
};

#define radioactive_proc_refs_offset cql_offsetof(radioactive_proc_row, data) // count = 1

static cql_uint16 radioactive_proc_col_offsets[] = { 2,
  cql_offsetof(radioactive_proc_row, id),
  cql_offsetof(radioactive_proc_row, data)
};

cql_int32 radioactive_proc_result_count(radioactive_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code radioactive_proc_fetch_results(sqlite3 *_Nonnull _db_, radioactive_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_radioactive_proc, &radioactive_proc_perf_index);
  cql_code rc = radioactive_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = radioactive_proc_data_types,
    .col_offsets = radioactive_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = radioactive_proc_refs_offset,
    .rowsize = sizeof(radioactive_proc_row),
    .crc = CRC_radioactive_proc,
    .perf_index = &radioactive_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code radioactive_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, data "
      "FROM radioactive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_deleter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  DELETE FROM foo WHERE id IN (SELECT *
    FROM x);
END;
*/

#undef _PROC_
#define _PROC_ "with_deleter"
CQL_WARN_UNUSED cql_code with_deleter(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "DELETE FROM foo WHERE id IN (SELECT a "
      "FROM x)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_updater ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;
*/

#undef _PROC_
#define _PROC_ "with_updater"
CQL_WARN_UNUSED cql_code with_updater(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "UPDATE bar "
    "SET name = 'xyzzy' "
      "WHERE id IN (SELECT a "
      "FROM x)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC autodropper ()
BEGIN
  SELECT 1 AS a, 2 AS b;
END;
*/

#undef _PROC_
#define _PROC_ "autodropper"
static int32_t autodropper_perf_index;

cql_string_literal(autodropper_stored_procedure_name, "autodropper");

typedef struct autodropper_row {
  cql_int32 a;
  cql_int32 b;
} autodropper_row;

cql_int32 autodropper_get_a(autodropper_result_set_ref _Nonnull result_set, cql_int32 row) {
  autodropper_row *data = (autodropper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 autodropper_get_b(autodropper_result_set_ref _Nonnull result_set, cql_int32 row) {
  autodropper_row *data = (autodropper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

uint8_t autodropper_data_types[autodropper_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
};

static cql_uint16 autodropper_col_offsets[] = { 2,
  cql_offsetof(autodropper_row, a),
  cql_offsetof(autodropper_row, b)
};

cql_int32 autodropper_result_count(autodropper_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code autodropper_fetch_results(sqlite3 *_Nonnull _db_, autodropper_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_autodropper, &autodropper_perf_index);
  cql_code rc = autodropper(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = autodropper_data_types,
    .col_offsets = autodropper_col_offsets,
    .rowsize = sizeof(autodropper_row),
    .crc = CRC_autodropper,
    .perf_index = &autodropper_perf_index,
      .autodrop_tables = "table1\0table2\0",
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code autodropper(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

// The statement ending at line XXXX

/*
CREATE PROC simple_cursor_proc ()
BEGIN
  DECLARE A_CURSOR CURSOR LIKE SELECT 1 AS id;
  FETCH a_cursor(id) FROM VALUES(1);
  OUT a_cursor;
END;
*/

#undef _PROC_
#define _PROC_ "simple_cursor_proc"
static int32_t simple_cursor_proc_perf_index;

cql_string_literal(simple_cursor_proc_stored_procedure_name, "simple_cursor_proc");

cql_int32 simple_cursor_proc_get_id(simple_cursor_proc_result_set_ref _Nonnull result_set) {
  simple_cursor_proc_row *data = (simple_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

uint8_t simple_cursor_proc_data_types[simple_cursor_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 simple_cursor_proc_col_offsets[] = { 1,
  cql_offsetof(simple_cursor_proc_row, id)
};

cql_int32 simple_cursor_proc_result_count(simple_cursor_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void simple_cursor_proc_fetch_results( simple_cursor_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_simple_cursor_proc, &simple_cursor_proc_perf_index);
  *result_set = NULL;
  simple_cursor_proc_row *row = (simple_cursor_proc_row *)calloc(1, sizeof(simple_cursor_proc_row));
  simple_cursor_proc(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = simple_cursor_proc_data_types,
    .col_offsets = simple_cursor_proc_col_offsets,
    .rowsize = sizeof(simple_cursor_proc_row),
    .crc = CRC_simple_cursor_proc,
    .perf_index = &simple_cursor_proc_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}


typedef struct simple_cursor_proc_A_CURSOR_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
} simple_cursor_proc_A_CURSOR_row;
void simple_cursor_proc(simple_cursor_proc_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  simple_cursor_proc_A_CURSOR_row A_CURSOR_ = { 0 };

  A_CURSOR_._has_row_ = 1;
  A_CURSOR_.id = 1;
  _result_->_has_row_ = A_CURSOR_._has_row_;
  _result_->id = A_CURSOR_.id;

}

// The statement ending at line XXXX

/*
CREATE PROC redundant_cast ()
BEGIN
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
*/

#undef _PROC_
#define _PROC_ "redundant_cast"
static int32_t redundant_cast_perf_index;

cql_string_literal(redundant_cast_stored_procedure_name, "redundant_cast");

typedef struct redundant_cast_row {
  cql_int32 plugh;
  cql_int32 five;
} redundant_cast_row;

cql_int32 redundant_cast_get_plugh(redundant_cast_result_set_ref _Nonnull result_set, cql_int32 row) {
  redundant_cast_row *data = (redundant_cast_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].plugh;
}

cql_int32 redundant_cast_get_five(redundant_cast_result_set_ref _Nonnull result_set, cql_int32 row) {
  redundant_cast_row *data = (redundant_cast_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].five;
}

uint8_t redundant_cast_data_types[redundant_cast_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // plugh
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // five
};

static cql_uint16 redundant_cast_col_offsets[] = { 2,
  cql_offsetof(redundant_cast_row, plugh),
  cql_offsetof(redundant_cast_row, five)
};

cql_int32 redundant_cast_result_count(redundant_cast_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code redundant_cast_fetch_results(sqlite3 *_Nonnull _db_, redundant_cast_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_redundant_cast, &redundant_cast_perf_index);
  cql_code rc = redundant_cast(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = redundant_cast_data_types,
    .col_offsets = redundant_cast_col_offsets,
    .rowsize = sizeof(redundant_cast_row),
    .crc = CRC_redundant_cast,
    .perf_index = &redundant_cast_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code redundant_cast(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT (5), T.xyzzy "
      "FROM (SELECT 1 AS xyzzy) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC view_creator ()
BEGIN
  CREATE VIEW alias_preserved AS
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
*/

#undef _PROC_
#define _PROC_ "view_creator"
CQL_WARN_UNUSED cql_code view_creator(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIEW alias_preserved AS "
    "SELECT (5) AS plugh, T.xyzzy AS five "
      "FROM (SELECT 1 AS xyzzy) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC settings_info ()
BEGIN
  DECLARE C CURSOR FOR SELECT SUM(A.unread_pending_thread_count) AS unread_pending_thread_count, SUM(A.switch_account_badge_count) AS switch_account_badge_count
    FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count
    FROM unread_pending_threads AS P
  UNION ALL
  SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count
    FROM switch_account_badges AS S) AS A;
END;
*/

#undef _PROC_
#define _PROC_ "settings_info"
CQL_WARN_UNUSED cql_code settings_info(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT SUM(A.unread_pending_thread_count), SUM(A.switch_account_badge_count) "
      "FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count "
      "FROM unread_pending_threads AS P "
    "UNION ALL "
    "SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count "
      "FROM switch_account_badges AS S) AS A");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC use_with_select ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( WITH
  threads2 (count) AS (SELECT 1 AS foo)
  SELECT COUNT(*)
    FROM threads2 );
END;
*/

#undef _PROC_
#define _PROC_ "use_with_select"
CQL_WARN_UNUSED cql_code use_with_select(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_int32 _tmp_int_0 = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "WITH "
    "threads2 (count) AS (SELECT 1) "
    "SELECT COUNT(*) "
      "FROM threads2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_int_0 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_notnull(x, _tmp_int_0);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM ReadFromRowset(rowset);
END;
*/

#undef _PROC_
#define _PROC_ "rowset_object_reader"
CQL_WARN_UNUSED cql_code rowset_object_reader(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable rowset) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C,
    "SELECT id "
      "FROM ReadFromRowset(?)");
  cql_multibind(&_rc_, _db_, &C, 1,
                CQL_DATA_TYPE_OBJECT, rowset);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC upsert_do_something ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
*/

#undef _PROC_
#define _PROC_ "upsert_do_something"
CQL_WARN_UNUSED cql_code upsert_do_something(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) SELECT id "
      "FROM bar "
      "WHERE 1 "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10 "
      "WHERE id <> 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC with_upsert_form ()
BEGIN
  WITH
  names (id) AS (VALUES(1), (5), (3), (12))
  INSERT INTO foo(id) SELECT id
    FROM names
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
*/

#undef _PROC_
#define _PROC_ "with_upsert_form"
CQL_WARN_UNUSED cql_code with_upsert_form(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "names (id) AS (VALUES(1), (5), (3), (12)) "
    "INSERT INTO foo(id) SELECT id "
      "FROM names "
      "WHERE 1 "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10 "
      "WHERE id <> 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC upsert_do_nothing (id_ INTEGER NOT NULL)
BEGIN
  INSERT INTO foo(id) VALUES(id_)
  ON CONFLICT DO NOTHING;
END;
*/

#undef _PROC_
#define _PROC_ "upsert_do_nothing"
CQL_WARN_UNUSED cql_code upsert_do_nothing(sqlite3 *_Nonnull _db_, cql_int32 id_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO foo(id) VALUES(?) "
    "ON CONFLICT DO NOTHING");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
cql_int32 _seed_ = 0;

// The statement ending at line XXXX

/*
DECLARE PROC p1 () OUT (id INTEGER NOT NULL, t TEXT);
*/

// The statement ending at line XXXX

/*
DECLARE PROC p2 () OUT (id INTEGER NOT NULL, t TEXT) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
CREATE PROC use_many_out_cursors ()
BEGIN
  DECLARE c1 CURSOR FETCH FROM CALL p1();
  DECLARE c2 CURSOR FETCH FROM CALL p2();
END;
*/

#undef _PROC_
#define _PROC_ "use_many_out_cursors"

typedef struct use_many_out_cursors_c1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} use_many_out_cursors_c1_row;

#define use_many_out_cursors_c1_refs_offset cql_offsetof(use_many_out_cursors_c1_row, t) // count = 1

typedef struct use_many_out_cursors_c2_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} use_many_out_cursors_c2_row;

#define use_many_out_cursors_c2_refs_offset cql_offsetof(use_many_out_cursors_c2_row, t) // count = 1
CQL_WARN_UNUSED cql_code use_many_out_cursors(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  use_many_out_cursors_c1_row c1_ = { ._refs_count_ = 1, ._refs_offset_ = use_many_out_cursors_c1_refs_offset };
  use_many_out_cursors_c2_row c2_ = { ._refs_count_ = 1, ._refs_offset_ = use_many_out_cursors_c2_refs_offset };

  cql_teardown_row(c1_);
  p1((p1_row *)&c1_); // p1_row identical to cursor type
  cql_teardown_row(c2_);
  _rc_ = p2(_db_, (p2_row *)&c2_); // p2_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(c1_);
  cql_teardown_row(c2_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC fetch_many_times (arg BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE p1;
  IF arg = 1 THEN
    FETCH C FROM CALL p1();
  ELSE IF arg = 2 THEN
    FETCH C FROM CALL p2();
  ELSE
    FETCH C FROM CALL p1();
    FETCH C FROM CALL p2();
  END IF;
END;
*/

#undef _PROC_
#define _PROC_ "fetch_many_times"

typedef struct fetch_many_times_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} fetch_many_times_C_row;

#define fetch_many_times_C_refs_offset cql_offsetof(fetch_many_times_C_row, t) // count = 1
CQL_WARN_UNUSED cql_code fetch_many_times(sqlite3 *_Nonnull _db_, cql_bool arg) {
  cql_code _rc_ = SQLITE_OK;
  fetch_many_times_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = fetch_many_times_C_refs_offset };

  if (arg == 1) {
    cql_teardown_row(C_);
    p1((p1_row *)&C_); // p1_row identical to cursor type
  }
  else {
    if (arg == 2) {
      cql_teardown_row(C_);
      _rc_ = p2(_db_, (p2_row *)&C_); // p2_row identical to cursor type
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    }
    else {
      cql_teardown_row(C_);
      p1((p1_row *)&C_); // p1_row identical to cursor type
      cql_teardown_row(C_);
      _rc_ = p2(_db_, (p2_row *)&C_); // p2_row identical to cursor type
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_union_two ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, '2' AS y;
  FETCH C(x, y) FROM VALUES(1, "y");
  OUT UNION C;
  OUT UNION C;
END;
*/

#undef _PROC_
#define _PROC_ "out_union_two_fetch_results"

#define out_union_two_refs_offset cql_offsetof(out_union_two_row, y) // count = 1
static int32_t out_union_two_perf_index;

cql_string_literal(out_union_two_stored_procedure_name, "out_union_two");

cql_int32 out_union_two_get_x(out_union_two_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_two_row *data = (out_union_two_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_string_ref _Nonnull out_union_two_get_y(out_union_two_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_two_row *data = (out_union_two_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_two_data_types[out_union_two_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // y
};

#define out_union_two_refs_offset cql_offsetof(out_union_two_row, y) // count = 1

static cql_uint16 out_union_two_col_offsets[] = { 2,
  cql_offsetof(out_union_two_row, x),
  cql_offsetof(out_union_two_row, y)
};

cql_int32 out_union_two_result_count(out_union_two_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_two_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_two_data_types,
  .col_offsets = out_union_two_col_offsets,
  .refs_count = 1,
  .refs_offset = out_union_two_refs_offset,
  .rowsize = sizeof(out_union_two_row),
  .crc = CRC_out_union_two,
  .perf_index = &out_union_two_perf_index,
};

typedef struct out_union_two_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_two_C_row;

#define out_union_two_C_refs_offset cql_offsetof(out_union_two_C_row, y) // count = 1
void out_union_two_fetch_results(out_union_two_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  out_union_two_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = out_union_two_C_refs_offset };

  cql_profile_start(CRC_out_union_two, &out_union_two_perf_index);
  C_._has_row_ = 1;
  C_.x = 1;
  cql_set_string_ref(&C_.y, _literal_10_y_);
  cql_retain_row(C_);
  if (C_._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C_, sizeof(C_));
  cql_retain_row(C_);
  if (C_._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C_, sizeof(C_));

  cql_results_from_data(SQLITE_OK, &_rows_, &out_union_two_info, (cql_result_set_ref *)_result_set_);
  cql_teardown_row(C_);
}

// The statement ending at line XXXX

/*
CREATE PROC out_union_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_two();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
*/

#undef _PROC_
#define _PROC_ "out_union_reader"

typedef struct out_union_reader_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_reader_c_row;

#define out_union_reader_c_refs_offset cql_offsetof(out_union_reader_c_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  out_union_two_result_set_ref c_result_set_ = NULL;
  cql_int32 c_row_num_ = 0;
  cql_int32 c_row_count_ = 0;
  out_union_reader_c_row c_ = { ._refs_count_ = 1, ._refs_offset_ = out_union_reader_c_refs_offset };

  out_union_two_fetch_results(&c_result_set_);
  c_row_num_ = c_row_count_ = -1;
  c_row_count_ = cql_result_set_get_count((cql_result_set_ref)c_result_set_);
  for (;;) {
    c_row_num_++;
    c_._has_row_ = c_row_num_ < c_row_count_;
    cql_copyoutrow((cql_result_set_ref)c_result_set_, c_row_num_, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c_.x,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &c_.y);
    if (!c_._has_row_) break;
    cql_alloc_cstr(_cstr_2, c_.y);
    printf("%d %s\n", c_.x, _cstr_2);
    cql_free_cstr(_cstr_2, c_.y);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(c_result_set_);
  cql_teardown_row(c_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_union_from_select ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x, '2' AS y;
  FETCH C;
  OUT UNION C;
  OUT UNION C;
END;
*/

#undef _PROC_
#define _PROC_ "out_union_from_select_fetch_results"

#define out_union_from_select_refs_offset cql_offsetof(out_union_from_select_row, y) // count = 1
static int32_t out_union_from_select_perf_index;

cql_string_literal(out_union_from_select_stored_procedure_name, "out_union_from_select");

cql_int32 out_union_from_select_get_x(out_union_from_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_from_select_row *data = (out_union_from_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_string_ref _Nonnull out_union_from_select_get_y(out_union_from_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_from_select_row *data = (out_union_from_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_from_select_data_types[out_union_from_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // y
};

#define out_union_from_select_refs_offset cql_offsetof(out_union_from_select_row, y) // count = 1

static cql_uint16 out_union_from_select_col_offsets[] = { 2,
  cql_offsetof(out_union_from_select_row, x),
  cql_offsetof(out_union_from_select_row, y)
};

cql_int32 out_union_from_select_result_count(out_union_from_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_from_select_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_from_select_data_types,
  .col_offsets = out_union_from_select_col_offsets,
  .refs_count = 1,
  .refs_offset = out_union_from_select_refs_offset,
  .rowsize = sizeof(out_union_from_select_row),
  .crc = CRC_out_union_from_select,
  .perf_index = &out_union_from_select_perf_index,
};

typedef struct out_union_from_select_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_from_select_C_row;

#define out_union_from_select_C_refs_offset cql_offsetof(out_union_from_select_C_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_from_select_fetch_results(sqlite3 *_Nonnull _db_, out_union_from_select_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_code _rc_ = SQLITE_OK;
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  sqlite3_stmt *C = NULL;
  out_union_from_select_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = out_union_from_select_C_refs_offset };

  cql_profile_start(CRC_out_union_from_select, &out_union_from_select_perf_index);
  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1, '2'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.x,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C_.y);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_retain_row(C_);
  if (C_._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C_, sizeof(C_));
  cql_retain_row(C_);
  if (C_._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C_, sizeof(C_));
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_results_from_data(_rc_, &_rows_, &out_union_from_select_info, (cql_result_set_ref *)_result_set_);
  cql_finalize_stmt(&C);
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_union_dml_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_from_select();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
*/

#undef _PROC_
#define _PROC_ "out_union_dml_reader"

typedef struct out_union_dml_reader_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_dml_reader_c_row;

#define out_union_dml_reader_c_refs_offset cql_offsetof(out_union_dml_reader_c_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_dml_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  out_union_from_select_result_set_ref c_result_set_ = NULL;
  cql_int32 c_row_num_ = 0;
  cql_int32 c_row_count_ = 0;
  out_union_dml_reader_c_row c_ = { ._refs_count_ = 1, ._refs_offset_ = out_union_dml_reader_c_refs_offset };

  _rc_ = out_union_from_select_fetch_results(_db_, &c_result_set_);
  c_row_num_ = c_row_count_ = -1;
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  c_row_count_ = cql_result_set_get_count((cql_result_set_ref)c_result_set_);
  for (;;) {
    c_row_num_++;
    c_._has_row_ = c_row_num_ < c_row_count_;
    cql_copyoutrow((cql_result_set_ref)c_result_set_, c_row_num_, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c_.x,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &c_.y);
    if (!c_._has_row_) break;
    cql_alloc_cstr(_cstr_3, c_.y);
    printf("%d %s\n", c_.x, _cstr_3);
    cql_free_cstr(_cstr_3, c_.y);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(c_result_set_);
  cql_teardown_row(c_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE x CURSOR LIKE SELECT 1 AS x, 2 AS y;
  FETCH x(x, y) FROM VALUES(a, b);
  OUT UNION x;
END;
*/

#undef _PROC_
#define _PROC_ "out_union_values_fetch_results"
static int32_t out_union_values_perf_index;

cql_string_literal(out_union_values_stored_procedure_name, "out_union_values");

cql_int32 out_union_values_get_x(out_union_values_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_values_row *data = (out_union_values_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_int32 out_union_values_get_y(out_union_values_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_values_row *data = (out_union_values_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_values_data_types[out_union_values_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // y
};

static cql_uint16 out_union_values_col_offsets[] = { 2,
  cql_offsetof(out_union_values_row, x),
  cql_offsetof(out_union_values_row, y)
};

cql_int32 out_union_values_result_count(out_union_values_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_values_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_values_data_types,
  .col_offsets = out_union_values_col_offsets,
  .rowsize = sizeof(out_union_values_row),
  .crc = CRC_out_union_values,
  .perf_index = &out_union_values_perf_index,
};

typedef struct out_union_values_x_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} out_union_values_x_row;
void out_union_values_fetch_results(out_union_values_result_set_ref _Nullable *_Nonnull _result_set_, cql_int32 a, cql_int32 b) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  out_union_values_x_row x_ = { 0 };

  cql_profile_start(CRC_out_union_values, &out_union_values_perf_index);
  x_._has_row_ = 1;
  x_.x = a;
  x_.y = b;
  cql_retain_row(x_);
  if (x_._has_row_) cql_bytebuf_append(&_rows_, (const void *)&x_, sizeof(x_));

  cql_results_from_data(SQLITE_OK, &_rows_, &out_union_values_info, (cql_result_set_ref *)_result_set_);
}

// The statement ending at line XXXX

/*
CREATE PROC read_out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR FOR CALL out_union_values(a, b);
  FETCH C;
END;
*/

#undef _PROC_
#define _PROC_ "read_out_union_values"

typedef struct read_out_union_values_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} read_out_union_values_C_row;
CQL_WARN_UNUSED cql_code read_out_union_values(sqlite3 *_Nonnull _db_, cql_int32 a, cql_int32 b) {
  cql_code _rc_ = SQLITE_OK;
  out_union_values_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  read_out_union_values_C_row C_ = { 0 };

  out_union_values_fetch_results(&C_result_set_, a, b);
  C_row_num_ = C_row_count_ = -1;
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  C_row_num_++;
  C_._has_row_ = C_row_num_ < C_row_count_;
  cql_copyoutrow((cql_result_set_ref)C_result_set_, C_row_num_, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.x,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.y);
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC compound_select_expr ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
  LIMIT 1 );
END;
*/

#undef _PROC_
#define _PROC_ "compound_select_expr"
CQL_WARN_UNUSED cql_code compound_select_expr(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_int32 _tmp_int_0 = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 1 "
      "WHERE 0 "
    "UNION "
    "SELECT 2 "
    "LIMIT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_int_0 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_notnull(x, _tmp_int_0);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC window_function_invocation ()
BEGIN
  SELECT id, 
    row_number() OVER () AS row_num
    FROM foo;
END;
*/

#undef _PROC_
#define _PROC_ "window_function_invocation"
static int32_t window_function_invocation_perf_index;

cql_string_literal(window_function_invocation_stored_procedure_name, "window_function_invocation");

typedef struct window_function_invocation_row {
  cql_int32 id;
  cql_int32 row_num;
} window_function_invocation_row;

cql_int32 window_function_invocation_get_id(window_function_invocation_result_set_ref _Nonnull result_set, cql_int32 row) {
  window_function_invocation_row *data = (window_function_invocation_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 window_function_invocation_get_row_num(window_function_invocation_result_set_ref _Nonnull result_set, cql_int32 row) {
  window_function_invocation_row *data = (window_function_invocation_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].row_num;
}

uint8_t window_function_invocation_data_types[window_function_invocation_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // row_num
};

static cql_uint16 window_function_invocation_col_offsets[] = { 2,
  cql_offsetof(window_function_invocation_row, id),
  cql_offsetof(window_function_invocation_row, row_num)
};

cql_int32 window_function_invocation_result_count(window_function_invocation_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window_function_invocation_fetch_results(sqlite3 *_Nonnull _db_, window_function_invocation_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window_function_invocation, &window_function_invocation_perf_index);
  cql_code rc = window_function_invocation(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window_function_invocation_data_types,
    .col_offsets = window_function_invocation_col_offsets,
    .rowsize = sizeof(window_function_invocation_row),
    .crc = CRC_window_function_invocation,
    .perf_index = &window_function_invocation_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code window_function_invocation(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id,  "
      "row_number() OVER () "
      "FROM foo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC update_cursor ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, 2 AS y;
  UPDATE CURSOR C(x) FROM VALUES(2);
END;
*/

#undef _PROC_
#define _PROC_ "update_cursor"

typedef struct update_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} update_cursor_C_row;
CQL_WARN_UNUSED cql_code update_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  update_cursor_C_row C_ = { 0 };

  if (C_._has_row_) {
    C_.x = 2;
  }
  _rc_ = SQLITE_OK;

  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE PROC out_union_with_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
DECLARE PROC out_union_no_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC use_return ()
BEGIN
  BEGIN TRY
    SELECT 1 AS x;
  END TRY;
  BEGIN CATCH
    RETURN;
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "use_return"
static int32_t use_return_perf_index;

cql_string_literal(use_return_stored_procedure_name, "use_return");

typedef struct use_return_row {
  cql_int32 x;
} use_return_row;

cql_int32 use_return_get_x(use_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  use_return_row *data = (use_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t use_return_data_types[use_return_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 use_return_col_offsets[] = { 1,
  cql_offsetof(use_return_row, x)
};

cql_int32 use_return_result_count(use_return_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code use_return_fetch_results(sqlite3 *_Nonnull _db_, use_return_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_use_return, &use_return_perf_index);
  cql_code rc = use_return(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = use_return_data_types,
    .col_offsets = use_return_col_offsets,
    .rowsize = sizeof(use_return_row),
    .crc = CRC_use_return,
    .perf_index = &use_return_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code use_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  // try
  {
    _rc_ = cql_prepare(_db_, _result_,
      "SELECT 1");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_4; }
    goto catch_end_4;
  }
  catch_start_4: {
    _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
    goto cql_cleanup; // return
  }
  catch_end_4:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC use_return_no_error_flow ()
BEGIN
  IF 1 THEN
    RETURN;
  END IF;
END;
*/

#undef _PROC_
#define _PROC_ "use_return_no_error_flow"
void use_return_no_error_flow(void) {
  if (1) {
    goto cql_cleanup; // return
  }

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC empty_proc ()
BEGIN
END;
*/

#undef _PROC_
#define _PROC_ "empty_proc"
void empty_proc(void) {

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC empty_blocks ()
BEGIN
  IF 1 THEN
  END IF;
  IF 2 THEN
  ELSE
  END IF;
  IF 3 THEN
  ELSE IF 4 THEN
  ELSE
  END IF;
  WHILE 1
  BEGIN
  END;
  DECLARE c CURSOR FOR SELECT 1 AS x;
  LOOP FETCH c
  BEGIN
  END;
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "empty_blocks"

typedef struct empty_blocks_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} empty_blocks_c_row;
CQL_WARN_UNUSED cql_code empty_blocks(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *c = NULL;
  empty_blocks_c_row c_ = { 0 };

  if (1) {
  }
  if (2) {
  }
  else {
  }
  if (3) {
  }
  else {
    if (4) {
    }
    else {
    }
  }
  for (;;) {
  if (!(1)) break;
  }
  _rc_ = cql_prepare(_db_, &c,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(c);
    c_._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, c, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c_.x);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!c_._has_row_) break;
  }
  // try
  {
    goto catch_end_5;
  }
  {
  }
  catch_end_5:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&c);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC tail_catch ()
BEGIN
  BEGIN TRY
  END TRY;
  BEGIN CATCH
    BEGIN TRY
    END TRY;
    BEGIN CATCH
    END CATCH;
  END CATCH;
END;
*/

#undef _PROC_
#define _PROC_ "tail_catch"
CQL_WARN_UNUSED cql_code tail_catch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  // try
  {
    goto catch_end_6;
  }
  {
    // try
    {
      goto catch_end_7;
    }
    {
    }
    catch_end_7:;
  }
  catch_end_6:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC pretty_print_with_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "it's high noon\r\n\f\b\t\v");
END;
*/

#undef _PROC_
#define _PROC_ "pretty_print_with_quote"
CQL_WARN_UNUSED cql_code pretty_print_with_quote(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, 'it''s high noon\r\n\f\b\t\v')");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC hex_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "\x01\x02\xa1\x1bg");
END;
*/

#undef _PROC_
#define _PROC_ "hex_quote"
CQL_WARN_UNUSED cql_code hex_quote(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, '\x01\x02\xa1\x1bg')");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC lotsa_columns_no_getters ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#undef _PROC_
#define _PROC_ "lotsa_columns_no_getters"
static int32_t lotsa_columns_no_getters_perf_index;

cql_string_literal(lotsa_columns_no_getters_stored_procedure_name, "lotsa_columns_no_getters");

typedef struct lotsa_columns_no_getters_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} lotsa_columns_no_getters_row;

uint8_t lotsa_columns_no_getters_data_types[lotsa_columns_no_getters_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define lotsa_columns_no_getters_refs_offset cql_offsetof(lotsa_columns_no_getters_row, name) // count = 1

static cql_uint16 lotsa_columns_no_getters_col_offsets[] = { 5,
  cql_offsetof(lotsa_columns_no_getters_row, id),
  cql_offsetof(lotsa_columns_no_getters_row, name),
  cql_offsetof(lotsa_columns_no_getters_row, rate),
  cql_offsetof(lotsa_columns_no_getters_row, type),
  cql_offsetof(lotsa_columns_no_getters_row, size)
};

cql_int32 lotsa_columns_no_getters_result_count(lotsa_columns_no_getters_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code lotsa_columns_no_getters_fetch_results(sqlite3 *_Nonnull _db_, lotsa_columns_no_getters_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_lotsa_columns_no_getters, &lotsa_columns_no_getters_perf_index);
  cql_code rc = lotsa_columns_no_getters(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = lotsa_columns_no_getters_data_types,
    .col_offsets = lotsa_columns_no_getters_col_offsets,
    .refs_count = 1,
    .refs_offset = lotsa_columns_no_getters_refs_offset,
    .rowsize = sizeof(lotsa_columns_no_getters_row),
    .crc = CRC_lotsa_columns_no_getters,
    .perf_index = &lotsa_columns_no_getters_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code lotsa_columns_no_getters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC lotsa_columns_no_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#undef _PROC_
#define _PROC_ "lotsa_columns_no_result_set"
CQL_WARN_UNUSED cql_code lotsa_columns_no_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_ = NULL;
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_) _rc_ = SQLITE_ERROR;
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC early_out_rc_cleared (OUT x INTEGER)
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  FETCH C;
  IF C THEN
    RETURN;
  END IF;
END;
*/

#undef _PROC_
#define _PROC_ "early_out_rc_cleared"

typedef struct early_out_rc_cleared_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} early_out_rc_cleared_C_row;
CQL_WARN_UNUSED cql_code early_out_rc_cleared(sqlite3 *_Nonnull _db_, cql_nullable_int32 *_Nonnull x) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  early_out_rc_cleared_C_row C_ = { 0 };

  _rc_ = cql_prepare(_db_, &C,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.x);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (C_._has_row_) {
    _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
    goto cql_cleanup; // return
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C);
  return _rc_;
}

// The statement ending at line XXXX

// The statement ending at line XXXX

/*
CREATE PROC ext ()
BEGIN
  WITH
  frag_test (id) AS (SELECT 1 AS id),
  ext (id, f2) AS (SELECT frag_test.*, f2
    FROM frag_test
    LEFT OUTER JOIN ext_test_table ON f1 = id)
  SELECT *
    FROM ext;
END;
*/

cql_int32 ext_get_id(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return frag_test_get_id(result_set, row);
}

cql_bool ext_get_f2_is_null(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f2_is_null(result_set, row);
}

cql_int32 ext_get_f2_value(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f2_value(result_set, row);
}

cql_int32 ext_result_count(frag_test_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

// The statement ending at line XXXX

/*
CREATE PROC ext2 ()
BEGIN
  WITH
  frag_test (id) AS (SELECT 1 AS id),
  ext2 (id, f3) AS (SELECT frag_test.*, f3
    FROM frag_test
    LEFT OUTER JOIN ext_test_table ON f1 = id)
  SELECT *
    FROM ext2;
END;
*/

cql_int32 ext2_get_id(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return frag_test_get_id(result_set, row);
}

cql_bool ext2_get_f3_is_null(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f3_is_null(result_set, row);
}

cql_int32 ext2_get_f3_value(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f3_value(result_set, row);
}

cql_int32 ext2_result_count(frag_test_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

// The statement ending at line XXXX

/*
CREATE PROC try_boxing (OUT result OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET result FROM CURSOR C;
END;
*/

#undef _PROC_
#define _PROC_ "try_boxing"
CQL_WARN_UNUSED cql_code try_boxing(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable *_Nonnull result) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_object_ref C_object_ = NULL;
  cql_bool _C_has_row_ = 0;

  *(void **)result = NULL; // set out arg to non-garbage
  C = NULL;
  _rc_ = cql_prepare(_db_, &C,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  cql_object_release(C_object_);
  C_object_ = cql_box_stmt(C);
  cql_set_object_ref(&result, C_object_);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_object_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC try_unboxing (boxed_cursor OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR boxed_cursor;
  FETCH C;
END;
*/

#undef _PROC_
#define _PROC_ "try_unboxing"

typedef struct try_unboxing_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} try_unboxing_C_row;

#define try_unboxing_C_refs_offset cql_offsetof(try_unboxing_C_row, name) // count = 1
CQL_WARN_UNUSED cql_code try_unboxing(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable boxed_cursor) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C = NULL;
  cql_object_ref C_object_ = NULL;
  try_unboxing_C_row C_ = { ._refs_count_ = 1, ._refs_offset_ = try_unboxing_C_refs_offset };

  C = cql_unbox_stmt(boxed_cursor);
  cql_set_object_ref(&C_object_, boxed_cursor);
  _rc_ = sqlite3_step(C);
  C_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C, 5,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C_.id,
                 CQL_DATA_TYPE_STRING, &C_.name,
                 CQL_DATA_TYPE_INT64, &C_.rate,
                 CQL_DATA_TYPE_INT32, &C_.type,
                 CQL_DATA_TYPE_DOUBLE, &C_.size);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_object_);
  cql_teardown_row(C_);
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_int_notnull ()
BEGIN
  DECLARE x INTEGER NOT NULL;
  SET x := CAST(3.2 AS INTEGER);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_int_notnull"
void local_cast_int_notnull(void) {
  cql_int32 x = 0;

  x = ((cql_int32)(3.2));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_int ()
BEGIN
  DECLARE x INTEGER;
  DECLARE r REAL;
  SET r := 3.2;
  SET x := CAST(r AS INTEGER);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_int"
void local_cast_int(void) {
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_int32)(r.value)));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_long_notnull ()
BEGIN
  DECLARE x LONG_INT NOT NULL;
  SET x := CAST(3.2 AS LONG_INT);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_long_notnull"
void local_cast_long_notnull(void) {
  cql_int64 x = 0;

  x = ((cql_int64)(3.2));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_long ()
BEGIN
  DECLARE x LONG_INT;
  DECLARE r REAL;
  SET r := 3.2;
  SET x := CAST(r AS LONG_INT);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_long"
void local_cast_long(void) {
  cql_nullable_int64 x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_int64)(r.value)));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_real_notnull ()
BEGIN
  DECLARE x REAL NOT NULL;
  SET x := CAST(3 AS REAL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_real_notnull"
void local_cast_real_notnull(void) {
  cql_double x = 0;

  x = ((cql_double)(3));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_real ()
BEGIN
  DECLARE x REAL;
  DECLARE r INTEGER;
  SET r := 3;
  SET x := CAST(r AS REAL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_real"
void local_cast_real(void) {
  cql_nullable_double x;
  cql_set_null(x);
  cql_nullable_int32 r;
  cql_set_null(r);

  cql_set_notnull(r, 3);
  cql_set_nullable(x, r.is_null, ((cql_double)(r.value)));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_bool_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  SET x := CAST(3.2 AS BOOL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_bool_notnull"
void local_cast_bool_notnull(void) {
  cql_bool x = 0;

  x = ((cql_bool)!!(3.2));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_bool ()
BEGIN
  DECLARE x BOOL;
  DECLARE r REAL;
  SET r := 3.2;
  SET x := CAST(r AS BOOL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_bool"
void local_cast_bool(void) {
  cql_nullable_bool x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_bool)!!(r.value)));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_notnull ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1;
  DECLARE x REAL NOT NULL;
  SET x := CAST(b AS REAL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_from_bool_notnull"
void local_cast_from_bool_notnull(void) {
  cql_bool b = 0;
  cql_double x = 0;

  b = 1;
  x = ((cql_double)!!(b));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool ()
BEGIN
  DECLARE b BOOL;
  SET b := 1;
  DECLARE x REAL;
  SET x := CAST(b AS REAL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_from_bool"
void local_cast_from_bool(void) {
  cql_nullable_bool b;
  cql_set_null(b);
  cql_nullable_double x;
  cql_set_null(x);

  cql_set_notnull(b, 1);
  cql_set_nullable(x, b.is_null, ((cql_double)!!(b.value)));

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_no_op_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  DECLARE b BOOL NOT NULL;
  SET b := 1;
  SET x := CAST(b AS BOOL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_from_bool_no_op_notnull"
void local_cast_from_bool_no_op_notnull(void) {
  cql_bool x = 0;
  cql_bool b = 0;

  b = 1;
  x = b;

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_no_op ()
BEGIN
  DECLARE b BOOL;
  SET b := 1;
  DECLARE x BOOL;
  SET x := CAST(b AS BOOL);
END;
*/

#undef _PROC_
#define _PROC_ "local_cast_from_bool_no_op"
void local_cast_from_bool_no_op(void) {
  cql_nullable_bool b;
  cql_set_null(b);
  cql_nullable_bool x;
  cql_set_null(x);

  cql_set_notnull(b, 1);
  cql_set_nullable(x, b.is_null, b.value);

cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    DECLARE X INTEGER;
  END;
END;
*/

#undef _PROC_
#define _PROC_ "base_proc_savepoint"
CQL_WARN_UNUSED cql_code base_proc_savepoint(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_code _rc_thrown_ = SQLITE_OK;
  cql_nullable_int32 X;
  cql_set_null(X);

  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_8; }
    goto catch_end_8;
  }
  catch_start_8: {
    _rc_thrown_ = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TRANSACTION TO SAVEPOINT base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_);
    goto cql_cleanup;
  }
  catch_end_8:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint_commit_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      COMMIT RETURN;
    END IF;
  END;
END;
*/

#undef _PROC_
#define _PROC_ "base_proc_savepoint_commit_return"
CQL_WARN_UNUSED cql_code base_proc_savepoint_commit_return(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_code _rc_thrown_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_commit_return");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    if (1) {
      _rc_ = cql_exec(_db_,
        "RELEASE SAVEPOINT base_proc_savepoint_commit_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_9; }
      _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
      goto cql_cleanup; // return
    }
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_9; }
    goto catch_end_9;
  }
  catch_start_9: {
    _rc_thrown_ = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TRANSACTION TO SAVEPOINT base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_);
    goto cql_cleanup;
  }
  catch_end_9:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint_rollback_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    END IF;
  END;
END;
*/

#undef _PROC_
#define _PROC_ "base_proc_savepoint_rollback_return"
CQL_WARN_UNUSED cql_code base_proc_savepoint_rollback_return(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_code _rc_thrown_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_rollback_return");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    if (1) {
      _rc_ = cql_exec(_db_,
        "ROLLBACK TRANSACTION TO SAVEPOINT base_proc_savepoint_rollback_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
      _rc_ = cql_exec(_db_,
        "RELEASE SAVEPOINT base_proc_savepoint_rollback_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
      _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
      goto cql_cleanup; // return
    }
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
    goto catch_end_10;
  }
  catch_start_10: {
    _rc_thrown_ = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TRANSACTION TO SAVEPOINT base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE SAVEPOINT base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_);
    goto cql_cleanup;
  }
  catch_end_10:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}

// The statement ending at line XXXX

/*
DECLARE x INTEGER NOT NULL;
*/
cql_int32 x = 0;

// The statement ending at line XXXX

/*
CREATE PROC end_proc ()
BEGIN
  DECLARE x INTEGER;
END;
*/

#undef _PROC_
#define _PROC_ "end_proc"
void end_proc(void) {
  cql_nullable_int32 x;
  cql_set_null(x);


cql_cleanup:
  ; // label requires some statement
}

// The statement ending at line XXXX

/*
DECLARE end_marker INTEGER;
*/
cql_nullable_int32 end_marker;

#undef _PROC_
#define _PROC_ cql_startup

cql_code cql_startup(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_bool _tmp_n_bool_1;
  cql_nullable_bool _tmp_n_bool_0;
  cql_nullable_double _tmp_n_double_1;
  cql_nullable_double _tmp_n_double_2;
  cql_nullable_double _tmp_n_double_3;
  cql_int32 _tmp_int_1 = 0;
  cql_nullable_int32 _tmp_n_int_2;
  cql_bool _tmp_bool_0 = 0;
  cql_int32 _tmp_int_2 = 0;
  cql_nullable_int32 _tmp_n_int_3;
  cql_nullable_int32 _tmp_n_int_0;
  cql_nullable_bool _tmp_n_bool_2;
  cql_nullable_int64 _tmp_n_int64_1;
  cql_nullable_int32 _tmp_n_int_1;
  cql_string_ref _tmp_text_0 = NULL;
  cql_object_ref _tmp_n_object_2 = NULL;
  cql_object_ref _tmp_object_2 = NULL;
  cql_object_ref _tmp_n_object_1 = NULL;
  cql_object_ref _tmp_n_object_0 = NULL;
  cql_blob_ref _tmp_n_blob_2 = NULL;
  cql_blob_ref _tmp_blob_2 = NULL;
  cql_blob_ref _tmp_n_blob_1 = NULL;
  cql_blob_ref _tmp_blob_0 = NULL;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1;
  */
  i2 = 1;
  
  // The statement ending at line XXXX
  
  /*
  SET i1_nullable := 88;
  */
  cql_set_notnull(i1_nullable, 88);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i1_nullable;
  */
  cql_set_nullable(i0_nullable, i1_nullable.is_null, i1_nullable.value);
  
  // The statement ending at line XXXX
  
  /*
  SET t0_nullable := NULL;
  */
  cql_set_string_ref(&t0_nullable, NULL);
  
  // The statement ending at line XXXX
  
  /*
  SET t0_nullable := t2;
  */
  cql_set_string_ref(&t0_nullable, t2);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := - -1;
  */
  i2 = - - 1;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := -i2;
  */
  cql_set_notnull(i0_nullable, - i2);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := -NULL;
  */
  cql_set_null(i0_nullable);
  
  // The statement ending at line XXXX
  
  /*
  SET i1_nullable := -i0_nullable;
  */
  cql_set_nullable(i1_nullable, i0_nullable.is_null, - i0_nullable.value);
  
  // The statement ending at line XXXX
  
  /*
  SET r0_nullable := 2.2;
  */
  cql_set_notnull(r0_nullable, 2.2);
  
  // The statement ending at line XXXX
  
  /*
  SET r2 := 3.5;
  */
  r2 = 3.5;
  
  // The statement ending at line XXXX
  
  /*
  SET i1_nullable := NOT NOT i0_nullable;
  */
  cql_set_nullable(_tmp_n_bool_1, i0_nullable.is_null, ! i0_nullable.value);
  cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, ! _tmp_n_bool_1.value);
  cql_set_nullable(i1_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := NOT NOT b2;
  */
  i2 = ! ! b2;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 * 3 + 5;
  */
  i2 = 1 * 3 + 5;
  
  // The statement ending at line XXXX
  
  /*
  SET r0_nullable := r0_nullable * i1_nullable;
  */
  cql_combine_nullables(r0_nullable, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  
  // The statement ending at line XXXX
  
  /*
  SET r0_nullable := r0_nullable * i2;
  */
  cql_set_nullable(r0_nullable, r0_nullable.is_null, r0_nullable.value * i2);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := 12 * i1_nullable;
  */
  cql_set_nullable(i0_nullable, i1_nullable.is_null, 12 * i1_nullable.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := NULL * i1_nullable;
  */
  cql_set_null(i0_nullable);
  
  // The statement ending at line XXXX
  
  /*
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i1_nullable;
  */
  cql_combine_nullables(_tmp_n_double_1, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(_tmp_n_double_2, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(r0_nullable, _tmp_n_double_1.is_null, _tmp_n_double_2.is_null, _tmp_n_double_1.value + _tmp_n_double_2.value);
  
  // The statement ending at line XXXX
  
  /*
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i0_nullable + r0_nullable;
  */
  cql_combine_nullables(_tmp_n_double_2, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(_tmp_n_double_3, r0_nullable.is_null, i0_nullable.is_null, r0_nullable.value * i0_nullable.value);
  cql_combine_nullables(_tmp_n_double_1, _tmp_n_double_2.is_null, _tmp_n_double_3.is_null, _tmp_n_double_2.value + _tmp_n_double_3.value);
  cql_combine_nullables(r0_nullable, _tmp_n_double_1.is_null, r0_nullable.is_null, _tmp_n_double_1.value + r0_nullable.value);
  
  // The statement ending at line XXXX
  
  /*
  SET t2 := "This is a \" \\ test '' \n \" ";
  */
  cql_set_string_ref(&t2, _literal_1_This_is_a_test_);
  
  // The statement ending at line XXXX
  
  /*
  CALL printf("Hello, world\n");
  */
  printf("Hello, world\n");
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := r2 AND l2;
  */
  i2 = r2 && l2;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := coalesce(side_effect1(), 7) AND coalesce(side_effect2(), 5);
  */
  do {
    _tmp_n_int_3 = side_effect1();
    if (!_tmp_n_int_3.is_null) {
      _tmp_int_2 = _tmp_n_int_3.value;
      break;
    }
    _tmp_int_2 = 7;
  } while (0);
  if (!(_tmp_int_2)) {
    _tmp_bool_0 = 0;
  }
  else {
    do {
      _tmp_n_int_2 = side_effect2();
      if (!_tmp_n_int_2.is_null) {
        _tmp_int_1 = _tmp_n_int_2.value;
        break;
      }
      _tmp_int_1 = 5;
    } while (0);
    _tmp_bool_0 = !!(_tmp_int_1);
  }
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := NULL AND NULL;
  */
  cql_set_null(_tmp_n_bool_0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i0_nullable AND i1_nullable;
  */
  if (cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (cql_is_nullable_false(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := NULL AND i1_nullable;
  */
  if (0) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (cql_is_nullable_false(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i0_nullable AND NULL;
  */
  if (cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (0) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := r2 OR l2;
  */
  i2 = r2 || l2;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := coalesce(side_effect1(), 7) OR coalesce(side_effect2(), 5);
  */
  do {
    _tmp_n_int_3 = side_effect1();
    if (!_tmp_n_int_3.is_null) {
      _tmp_int_2 = _tmp_n_int_3.value;
      break;
    }
    _tmp_int_2 = 7;
  } while (0);
  if (_tmp_int_2) {
    _tmp_bool_0 = 1;
  }
  else {
    do {
      _tmp_n_int_2 = side_effect2();
      if (!_tmp_n_int_2.is_null) {
        _tmp_int_1 = _tmp_n_int_2.value;
        break;
      }
      _tmp_int_1 = 5;
    } while (0);
    _tmp_bool_0 = !!(_tmp_int_1);
  }
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := NULL OR NULL;
  */
  cql_set_null(_tmp_n_bool_0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i0_nullable OR i1_nullable;
  */
  if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := NULL OR i1_nullable;
  */
  if (0) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i0_nullable OR NULL;
  */
  if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := NULL IS NULL;
  */
  i2 = 1;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 + 2 * 3 IS NULL;
  */
  i2 = 0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := i0_nullable + i1_nullable IS NULL;
  */
  cql_combine_nullables(_tmp_n_int_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value + i1_nullable.value);
  i2 = _tmp_n_int_0.is_null;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := NULL IS NOT NULL;
  */
  i2 = !1;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 + 2 * 3 IS NOT NULL;
  */
  i2 = 1;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := i0_nullable + i1_nullable IS NOT NULL;
  */
  cql_combine_nullables(_tmp_n_int_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value + i1_nullable.value);
  i2 = !_tmp_n_int_0.is_null;
  
  // The statement ending at line XXXX
  
  /*
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable = i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  */
  if (1) {
    i2 = 1;
  }
  else {
    cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value == i1_nullable.value);
    if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
      i2 = 2;
    }
    else {
      i2 = 3;
    }
  }
  
  // The statement ending at line XXXX
  
  /*
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable OR i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  */
  if (1) {
    i2 = 1;
  }
  else {
    if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
        cql_set_notnull(_tmp_n_bool_0, 1);
      }
      else {
        cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 0);
      }
    }
    if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
      i2 = 2;
    }
    else {
      i2 = 3;
    }
  }
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := BETWEEN REWRITE _between_0_ := 1 CHECK (_between_0_ >= 0 AND _between_0_ <= 3);
  */
  _between_0_ = 1;
  b2 = _between_0_ >= 0 && _between_0_ <= 3;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := BETWEEN REWRITE _between_1_ := i1_nullable CHECK (_between_1_ >= i0_nullable AND _between_1_ <= r2);
  */
  cql_set_nullable(_between_1_, i1_nullable.is_null, i1_nullable.value);
  cql_combine_nullables(_tmp_n_bool_2, _between_1_.is_null, i0_nullable.is_null, _between_1_.value >= i0_nullable.value);
  if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_set_nullable(_tmp_n_bool_1, _between_1_.is_null, _between_1_.value <= r2);
    if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_2.is_null, _tmp_n_bool_1.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := BETWEEN REWRITE _between_2_ := i1_nullable CHECK (_between_2_ >= r2 AND _between_2_ <= i0_nullable);
  */
  cql_set_nullable(_between_2_, i1_nullable.is_null, i1_nullable.value);
  cql_set_nullable(_tmp_n_bool_2, _between_2_.is_null, _between_2_.value >= r2);
  if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_1, _between_2_.is_null, i0_nullable.is_null, _between_2_.value <= i0_nullable.value);
    if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_2.is_null, _tmp_n_bool_1.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := BETWEEN REWRITE _between_3_ := 1 CHECK (_between_3_ < 0 OR _between_3_ > 3);
  */
  _between_3_ = 1;
  b2 = _between_3_ < 0 || _between_3_ > 3;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := BETWEEN REWRITE _between_4_ := i1_nullable CHECK (_between_4_ < i0_nullable OR _between_4_ > r2);
  */
  cql_set_nullable(_between_4_, i1_nullable.is_null, i1_nullable.value);
  cql_combine_nullables(_tmp_n_bool_2, _between_4_.is_null, i0_nullable.is_null, _between_4_.value < i0_nullable.value);
  if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_set_nullable(_tmp_n_bool_1, _between_4_.is_null, _between_4_.value > r2);
    if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_2.is_null, _tmp_n_bool_1.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := BETWEEN REWRITE _between_5_ := i1_nullable CHECK (_between_5_ < r2 OR _between_5_ > i0_nullable);
  */
  cql_set_nullable(_between_5_, i1_nullable.is_null, i1_nullable.value);
  cql_set_nullable(_tmp_n_bool_2, _between_5_.is_null, _between_5_.value < r2);
  if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_1, _between_5_.is_null, i0_nullable.is_null, _between_5_.value > i0_nullable.value);
    if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_2.is_null, _tmp_n_bool_1.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET longint_var := (l0_nullable + l1_nullable) * 5;
  */
  cql_combine_nullables(_tmp_n_int64_1, l0_nullable.is_null, l1_nullable.is_null, l0_nullable.value + l1_nullable.value);
  cql_set_nullable(longint_var, _tmp_n_int64_1.is_null, _tmp_n_int64_1.value * 5);
  
  // The statement ending at line XXXX
  
  /*
  DECLARE foo_cursor CURSOR FOR SELECT id, i2
    FROM foo
    WHERE id = i0_nullable;
  */
  _rc_ = cql_prepare(_db_, &foo_cursor,
    "SELECT id, ? "
      "FROM foo "
      "WHERE id = ?");
  cql_multibind(&_rc_, _db_, &foo_cursor, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, i2,
                CQL_DATA_TYPE_INT32, &i0_nullable);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  FETCH foo_cursor INTO i0_nullable, i2;
  */
  _rc_ = sqlite3_step(foo_cursor);
  _foo_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, foo_cursor, 2,
                 CQL_DATA_TYPE_INT32, &i0_nullable,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &i2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  DECLARE basic_cursor CURSOR FOR SELECT 1, 2.5;
  */
  _rc_ = cql_prepare(_db_, &basic_cursor,
    "SELECT 1, 2.5");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  OPEN basic_cursor;
  */
  
  // The statement ending at line XXXX
  
  /*
  FETCH basic_cursor INTO col1, col2;
  */
  _rc_ = sqlite3_step(basic_cursor);
  _basic_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, basic_cursor, 2,
                 CQL_DATA_TYPE_INT32, &col1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_DOUBLE, &col2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  CLOSE basic_cursor;
  */
  cql_finalize_stmt(&basic_cursor);
  
  // The statement ending at line XXXX
  
  /*
  SET arg1 := 7;
  */
  arg1 = 7;
  
  // The statement ending at line XXXX
  
  /*
  SET arg2 := 11;
  */
  arg2 = 11;
  
  // The statement ending at line XXXX
  
  /*
  DECLARE exchange_cursor CURSOR FOR SELECT arg2, arg1;
  */
  _rc_ = cql_prepare(_db_, &exchange_cursor,
    "SELECT ?, ?");
  cql_multibind(&_rc_, _db_, &exchange_cursor, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, arg2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, arg1);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  OPEN exchange_cursor;
  */
  
  // The statement ending at line XXXX
  
  /*
  FETCH exchange_cursor INTO arg1, arg2;
  */
  _rc_ = sqlite3_step(exchange_cursor);
  _exchange_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, exchange_cursor, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &arg1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &arg2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  CLOSE exchange_cursor;
  */
  cql_finalize_stmt(&exchange_cursor);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ( SELECT i2 + 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ? + 1");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    i2 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := ( SELECT i0_nullable + 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ? + 1");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_INT32, &i0_nullable);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_int32(_temp_stmt, 0, &i0_nullable);
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  DELETE FROM bar WHERE name LIKE '\\ " \n';
  */
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\\\\ \" \\n'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := CASE WHEN 1 THEN 100
  WHEN 2 THEN 200
  WHEN NULL THEN 500
  ELSE 300
  END;
  */
  do {
    if (1) {
      i2 = 100;
      break;
    }
    if (2) {
      i2 = 200;
      break;
    }
    i2 = 300;
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 3 IN (1, 2, NULL, 4);
  */
  do {
    _tmp_int_2 = 3;
    _tmp_bool_0 = 1;
    if (_tmp_int_2 == 1) break;
    if (_tmp_int_2 == 2) break;
    if (_tmp_int_2 == 4) break;
    _tmp_bool_0 = 0;
  } while (0);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i1_nullable IN (1, 2, NULL, b0_nullable);
  */
  do {
    cql_set_nullable(_tmp_n_int_2, i1_nullable.is_null, i1_nullable.value);
    if (_tmp_n_int_2.is_null) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (_tmp_n_int_2.value == 1) break;
    if (_tmp_n_int_2.value == 2) break;
    if (cql_is_nullable_true(b0_nullable.is_null, _tmp_n_int_2.value == b0_nullable.value)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 3 NOT IN (1, 2, NULL, 4);
  */
  do {
    _tmp_int_2 = 3;
    _tmp_bool_0 = 0;
    if (_tmp_int_2 == 1) break;
    if (_tmp_int_2 == 2) break;
    if (_tmp_int_2 == 4) break;
    _tmp_bool_0 = 1;
  } while (0);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := i1_nullable NOT IN (1, 2, NULL, b0_nullable);
  */
  do {
    cql_set_nullable(_tmp_n_int_2, i1_nullable.is_null, i1_nullable.value);
    if (_tmp_n_int_2.is_null) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (_tmp_n_int_2.value == 1) break;
    if (_tmp_n_int_2.value == 2) break;
    if (cql_is_nullable_true(b0_nullable.is_null, _tmp_n_int_2.value == b0_nullable.value)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := BETWEEN REWRITE _between_6_ := 'b' CHECK (_between_6_ >= 'a' AND _between_6_ <= 'c');
  */
  cql_set_string_ref(&_between_6_, _literal_2_b_);
  b2 = cql_string_compare(_between_6_, _literal_4_a_) >= 0 && cql_string_compare(_between_6_, _literal_3_c_) <= 0;
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_7_ := 'b' CHECK (_between_7_ >= 'a' AND _between_7_ <= t0_nullable);
  */
  cql_set_string_ref(&_between_7_, _literal_2_b_);
  if (!(cql_string_compare(_between_7_, _literal_4_a_) >= 0)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_1, !_between_7_, !t0_nullable, cql_string_compare(_between_7_, t0_nullable) <= 0);
    if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_8_ := 'b' CHECK (_between_8_ >= t0_nullable AND _between_8_ <= 'c');
  */
  cql_set_string_ref(&_between_8_, _literal_2_b_);
  cql_combine_nullables(_tmp_n_bool_2, !_between_8_, !t0_nullable, cql_string_compare(_between_8_, t0_nullable) >= 0);
  if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (!(cql_string_compare(_between_8_, _literal_3_c_) <= 0)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_9_ := 'b' CHECK (_between_9_ >= NULL AND _between_9_ <= 'c');
  */
  cql_set_string_ref(&_between_9_, _literal_2_b_);
  cql_set_null(_tmp_n_bool_2);
  if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (!(cql_string_compare(_between_9_, _literal_3_c_) <= 0)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := BETWEEN REWRITE _between_10_ := 'b' CHECK (_between_10_ < 'a' OR _between_10_ > 'c');
  */
  cql_set_string_ref(&_between_10_, _literal_2_b_);
  b2 = cql_string_compare(_between_10_, _literal_4_a_) < 0 || cql_string_compare(_between_10_, _literal_3_c_) > 0;
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_11_ := 'b' CHECK (_between_11_ < 'a' OR _between_11_ > t0_nullable);
  */
  cql_set_string_ref(&_between_11_, _literal_2_b_);
  if (cql_string_compare(_between_11_, _literal_4_a_) < 0) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_1, !_between_11_, !t0_nullable, cql_string_compare(_between_11_, t0_nullable) > 0);
    if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_12_ := 'b' CHECK (_between_12_ < t0_nullable OR _between_12_ > 'c');
  */
  cql_set_string_ref(&_between_12_, _literal_2_b_);
  cql_combine_nullables(_tmp_n_bool_2, !_between_12_, !t0_nullable, cql_string_compare(_between_12_, t0_nullable) < 0);
  if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_string_compare(_between_12_, _literal_3_c_) > 0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := BETWEEN REWRITE _between_13_ := 'b' CHECK (_between_13_ < NULL OR _between_13_ > 'c');
  */
  cql_set_string_ref(&_between_13_, _literal_2_b_);
  cql_set_null(_tmp_n_bool_2);
  if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_string_compare(_between_13_, _literal_3_c_) > 0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ifnull(i0_nullable, 3);
  */
  do {
    if (!i0_nullable.is_null) {
      i2 = i0_nullable.value;
      break;
    }
    i2 = 3;
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET i0_nullable := ifnull(i0_nullable, i1_nullable);
  */
  do {
    if (!i0_nullable.is_null) {
      cql_set_notnull(i0_nullable, i0_nullable.value);
      break;
    }
    cql_set_nullable(i0_nullable, i1_nullable.is_null, i1_nullable.value);
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  CALL copy_int(i0_nullable, i1_nullable);
  */
  copy_int(i0_nullable, &i1_nullable);
  
  // The statement ending at line XXXX
  
  /*
  SET s := printf('%d and %d', 1, 2);
  */
  {
    char *_printf_result = sqlite3_mprintf("%d and %d", 1, 2);
    cql_string_release(s);
    s = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }
  
  // The statement ending at line XXXX
  
  /*
  SET s := printf('%d and %d', 3, 4);
  */
  {
    char *_printf_result = sqlite3_mprintf("%d and %d", 3, 4);
    cql_string_release(s);
    s = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }
  
  // The statement ending at line XXXX
  
  /*
  SET S := 'x';
  */
  cql_set_string_ref(&s, _literal_5_x_);
  
  // The statement ending at line XXXX
  
  /*
  SET result := simple_func(2);
  */
  cql_set_notnull(_tmp_n_int_2, 2);
  result = simple_func(_tmp_n_int_2);
  
  // The statement ending at line XXXX
  
  /*
  SET result := simple_func(simple_func(1));
  */
  cql_set_notnull(_tmp_n_int_3, 1);
  _tmp_n_int_1 = simple_func(_tmp_n_int_3);
  result = simple_func(_tmp_n_int_1);
  
  // The statement ending at line XXXX
  
  /*
  SET text_result := text_func(123, 456);
  */
  cql_set_notnull(_tmp_n_int_2, 123);
  cql_set_string_ref(&_tmp_text_0, text_func(_tmp_n_int_2, 456));
  cql_set_string_ref(&text_result, _tmp_text_0);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := NULL;
  */
  cql_set_object_ref(&obj_var, NULL);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := obj_var2;
  */
  cql_set_object_ref(&obj_var, obj_var2);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := obj_var = obj_var;
  */
  cql_combine_nullables(b0_nullable, !obj_var, !obj_var, obj_var == obj_var);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := obj_var IN (obj_var, obj_var);
  */
  do {
    cql_set_object_ref(&_tmp_n_object_2, obj_var);
    if (!_tmp_n_object_2) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_2 == obj_var)) break;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_2 == obj_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := obj_var2 IN (obj_var2, obj_var2);
  */
  do {
    cql_set_object_ref(&_tmp_object_2, obj_var2);
    _tmp_bool_0 = 1;
    if (_tmp_object_2 == obj_var2) break;
    if (_tmp_object_2 == obj_var2) break;
    _tmp_bool_0 = 0;
  } while (0);
  b2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := obj_var NOT IN (obj_var, obj_var);
  */
  do {
    cql_set_object_ref(&_tmp_n_object_2, obj_var);
    if (!_tmp_n_object_2) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_2 == obj_var)) break;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_2 == obj_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := obj_var2 NOT IN (obj_var2, obj_var2);
  */
  do {
    cql_set_object_ref(&_tmp_object_2, obj_var2);
    _tmp_bool_0 = 0;
    if (_tmp_object_2 == obj_var2) break;
    if (_tmp_object_2 == obj_var2) break;
    _tmp_bool_0 = 1;
  } while (0);
  b2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := CASE obj_var WHEN obj_var THEN 1
  ELSE 2
  END;
  */
  do {
      cql_set_object_ref(&_tmp_n_object_1, obj_var);
      if (!_tmp_n_object_1) goto case_else_1;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) {
      i2 = 1;
      break;
    }
    case_else_1:
    i2 = 2;
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := CASE 1 WHEN 1 THEN obj_var2
  ELSE NULL
  END;
  */
  do {
      _tmp_int_1 = 1;
    if (_tmp_int_1 == 1) {
      cql_set_object_ref(&obj_var, obj_var2);
      break;
    }
    cql_set_object_ref(&obj_var, NULL);
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := obj_func();
  */
  cql_set_object_ref(&obj_var, obj_func());
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := obj_func_create();
  */
  cql_object_release(obj_var);
  obj_var = obj_func_create();
  
  // The statement ending at line XXXX
  
  /*
  SET text_result := text_func_create();
  */
  cql_string_release(text_result);
  text_result = text_func_create();
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var2 := attest_notnull(obj_func());
  */
  cql_set_object_ref(&_tmp_n_object_0, obj_func());
  cql_invariant(!!_tmp_n_object_0);
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var2 := attest_notnull(obj_func_create());
  */
  cql_object_release(_tmp_n_object_0);
  _tmp_n_object_0 = obj_func_create();
  cql_invariant(!!_tmp_n_object_0);
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := attest_notnull(i0_nullable);
  */
  cql_invariant(!i0_nullable.is_null);
  i2 = i0_nullable.value;
  
  // The statement ending at line XXXX
  
  /*
  INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5);
  */
  _rc_ = cql_exec(_db_,
    "INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  INSERT INTO foo DEFAULT VALUES;
  */
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo DEFAULT VALUES");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := ( SELECT EXISTS (SELECT *
    FROM bar) );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT EXISTS (SELECT * "
      "FROM bar)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    b2 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  DECLARE expanded_select CURSOR FOR SELECT *
    FROM bar;
  */
  _rc_ = cql_prepare(_db_, &expanded_select,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  DECLARE table_expanded_select CURSOR FOR SELECT bar.*
    FROM bar;
  */
  _rc_ = cql_prepare(_db_, &table_expanded_select,
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET l2 := 3147483647L;
  */
  l2 = 3147483647L;
  
  // The statement ending at line XXXX
  
  /*
  SET l2 := 3147483647L;
  */
  l2 = 3147483647L;
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := NULL;
  */
  cql_set_blob_ref(&blob_var, NULL);
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := blob_var2;
  */
  cql_set_blob_ref(&blob_var, blob_var2);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := blob_var = blob_var;
  */
  cql_combine_nullables(b0_nullable, !blob_var, !blob_var, blob_var == blob_var);
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := blob_var IN (blob_var, blob_var);
  */
  do {
    cql_set_blob_ref(&_tmp_n_blob_2, blob_var);
    if (!_tmp_n_blob_2) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_2 == blob_var)) break;
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_2 == blob_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := blob_var2 IN (blob_var, blob_var2);
  */
  do {
    cql_set_blob_ref(&_tmp_blob_2, blob_var2);
    _tmp_bool_0 = 1;
    if (cql_is_nullable_true(!blob_var, _tmp_blob_2 == blob_var)) break;
    if (_tmp_blob_2 == blob_var2) break;
    _tmp_bool_0 = 0;
  } while (0);
  b2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET b0_nullable := blob_var NOT IN (blob_var, blob_var);
  */
  do {
    cql_set_blob_ref(&_tmp_n_blob_2, blob_var);
    if (!_tmp_n_blob_2) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_2 == blob_var)) break;
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_2 == blob_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);
  
  // The statement ending at line XXXX
  
  /*
  SET b2 := blob_var2 NOT IN (blob_var, blob_var2);
  */
  do {
    cql_set_blob_ref(&_tmp_blob_2, blob_var2);
    _tmp_bool_0 = 0;
    if (cql_is_nullable_true(!blob_var, _tmp_blob_2 == blob_var)) break;
    if (_tmp_blob_2 == blob_var2) break;
    _tmp_bool_0 = 1;
  } while (0);
  b2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := CASE blob_var WHEN blob_var THEN 1
  ELSE 2
  END;
  */
  do {
      cql_set_blob_ref(&_tmp_n_blob_1, blob_var);
      if (!_tmp_n_blob_1) goto case_else_2;
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_1 == blob_var)) {
      i2 = 1;
      break;
    }
    case_else_2:
    i2 = 2;
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := CASE 1 WHEN 1 THEN blob_var2
  ELSE NULL
  END;
  */
  do {
      _tmp_int_1 = 1;
    if (_tmp_int_1 == 1) {
      cql_set_blob_ref(&blob_var, blob_var2);
      break;
    }
    cql_set_blob_ref(&blob_var, NULL);
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := blob_func();
  */
  cql_set_blob_ref(&blob_var, blob_func());
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := blob_func_create();
  */
  cql_blob_release(blob_var);
  blob_var = blob_func_create();
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := ( SELECT b_nullable
    FROM blob_table
    WHERE blob_id = 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT b_nullable "
      "FROM blob_table "
      "WHERE blob_id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_blob_ref(_temp_stmt, 0, &blob_var);
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  SET blob_var := ( SELECT b_notnull
    FROM blob_table
    WHERE blob_id = 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT b_notnull "
      "FROM blob_table "
      "WHERE blob_id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_blob_ref(_temp_stmt, 0, &_tmp_blob_0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_blob_ref(&blob_var, _tmp_blob_0);
  
  // The statement ending at line XXXX
  
  /*
  INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, blob_var, blob_var_notnull);
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_BLOB, blob_var,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BLOB, blob_var_notnull);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  SET obj_var := CASE WHEN 1 THEN obj_var
  END;
  */
  do {
    if (1) {
      break;
    }
    cql_set_object_ref(&obj_var, NULL);
  } while (0);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := outparm_test();
  */
  _rc_ = outparm_test(_db_, &i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := compute(compute(1));
  */
  compute(1, &_tmp_int_1);
  compute(_tmp_int_1, &i2);
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := dml_compute(dml_compute(1));
  */
  _rc_ = dml_compute(_db_, 1, &_tmp_int_1);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = dml_compute(_db_, _tmp_int_1, &i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) VALUES(ifnull(( SELECT a
    FROM x ), 0));
  */
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "INSERT INTO foo(id) VALUES(ifnull(( SELECT a "
      "FROM x ), 0))");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET r2 := ( SELECT SqlUserFunc(123) );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT SqlUserFunc(123)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    r2 = sqlite3_column_double(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  
  // The statement ending at line XXXX
  
  /*
  DECLARE global_cursor CURSOR FOR SELECT 1 AS a, 2 AS b;
  */
  _rc_ = cql_prepare(_db_, &global_cursor,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  FETCH global_cursor;
  */
  _rc_ = sqlite3_step(global_cursor);
  global_cursor_._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, global_cursor, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &global_cursor_.a,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &global_cursor_.b);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 'x' LIKE 'y';
  */
  i2 = cql_string_like(_literal_5_x_, _literal_10_y_) == 0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 'x' NOT LIKE 'y';
  */
  i2 = cql_string_like(_literal_5_x_, _literal_10_y_) != 0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ( SELECT 'x' LIKE 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' LIKE 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ( SELECT 'x' NOT LIKE 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' NOT LIKE 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ( SELECT 'x' MATCH 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' MATCH 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := ( SELECT 'x' GLOB 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' GLOB 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 << 2 | 1 << 4 & 1 >> 8;
  */
  i2 = ((1 << 2 | 1) << 4 & 1) >> 8;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 << 2 | (1 << 4) & (1 >> 8);
  */
  i2 = (1 << 2 | 1 << 4) & 1 >> 8;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 << 2 | (1 << 4 & (1 >> 8));
  */
  i2 = 1 << 2 | 1 << 4 & 1 >> 8;
  
  // The statement ending at line XXXX
  
  /*
  SET i2 := 1 | ~i2;
  */
  i2 = 1 | ~ i2;
  
  // The statement ending at line XXXX
  
  /*
  WITH
  foo (id) AS (SELECT 1 AS id)
  INSERT INTO bar(id) VALUES(ifnull(( SELECT id
    FROM foo ), 0)) @DUMMY_SEED(1337);
  */
  _seed_ = 1337;
  _rc_ = cql_exec(_db_,
    "WITH "
    "foo (id) AS (SELECT 1 AS id) "
    "INSERT INTO bar(id) VALUES(ifnull(( SELECT id "
      "FROM foo ), 0))");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  INSERT INTO bar(id) VALUES(1) @DUMMY_SEED(1338)
  ON CONFLICT (id) DO UPDATE
  SET id = 10;
  */
  _seed_ = 1338;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id) VALUES(1) "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SET l0_nullable := cql_get_blob_size(( SELECT blob_var ));
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ?");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_BLOB, blob_var);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_blob_ref(_temp_stmt, 0, &_tmp_n_blob_1);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_nullable(l0_nullable, !_tmp_n_blob_1, cql_get_blob_size(_tmp_n_blob_1));
  
  // The statement ending at line XXXX
  
  /*
  SET l2 := cql_get_blob_size(blob_var2);
  */
  l2 = cql_get_blob_size(blob_var2);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 * (2 / 3);
  */
  x = 1 * (2 / 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 * 2 / 3;
  */
  x = 1 * 2 / 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 + 2 / 3;
  */
  x = 1 + 2 / 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 + (2 - 3);
  */
  x = 1 + (2 - 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 + 2 * 3;
  */
  x = 1 + 2 * 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 * (2 + 3);
  */
  x = 1 * (2 + 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 - (2 + 3);
  */
  x = 1 - (2 + 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 - (2 - 3);
  */
  x = 1 - (2 - 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 - 2 - (2 - 3);
  */
  x = 1 - 2 - (2 - 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 - 2 - (2 - 3);
  */
  x = 1 - 2 - (2 - 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 / 2 / 3;
  */
  x = 1 / 2 / 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 / (2 / 3);
  */
  x = 1 / (2 / 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 / 2;
  */
  x = 1 / 2;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 * 2 * (3 * 4);
  */
  x = 1 * 2 * (3 * 4);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 * 2 * (3 * 4);
  */
  x = 1 * 2 * (3 * 4);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | 2 & 3;
  */
  x = (1 | 2) & 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | (2 & 3);
  */
  x = 1 | 2 & 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | 2 | 3;
  */
  x = 1 | 2 | 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | (2 | 3);
  */
  x = 1 | (2 | 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | (3 + 4 | 5);
  */
  x = 1 | (3 + 4 | 5);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | 3 + (4 | 5);
  */
  x = 1 | 3 + (4 | 5);
  
  // The statement ending at line XXXX
  
  /*
  SET x := (1 | 3) + (4 | 5);
  */
  x = (1 | 3) + (4 | 5);
  
  // The statement ending at line XXXX
  
  /*
  SET x := (1 + 2) * 5;
  */
  x = (1 + 2) * 5;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 + 2 - 1;
  */
  x = 1 + 2 - 1;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 << 2 | 3;
  */
  x = 1 << 2 | 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 << (2 | 3);
  */
  x = 1 << (2 | 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | (2 << 3);
  */
  x = 1 | 2 << 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 << (2 << 3);
  */
  x = 1 << (2 << 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 < (2 > 3);
  */
  x = 1 < (2 > 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 << (2 >> 3);
  */
  x = 1 << (2 >> 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | (2 | 3);
  */
  x = 1 | (2 | 3);
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 | 2 | 3;
  */
  x = 1 | 2 | 3;
  
  // The statement ending at line XXXX
  
  /*
  SET x := 1 = 2 <> 3;
  */
  x = 1 == (2 != 3);
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    SUM(amount) OVER (ORDER BY month) AS RunningTotal
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "SUM(amount) OVER (ORDER BY month) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  
  // The statement ending at line XXXX
  
  /*
  SELECT month, amount, 
    AVG(amount) OVER (GROUPS CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
  */
  _rc_ = cql_prepare(_db_, _result_,
    "SELECT month, amount,  "
      "AVG(amount) OVER (GROUPS CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

cql_cleanup:
  cql_string_release(t0_nullable);
  cql_string_release(t2);
  cql_finalize_stmt(&foo_cursor);
  cql_finalize_stmt(&basic_cursor);
  cql_finalize_stmt(&exchange_cursor);
  cql_finalize_stmt(&_temp_stmt);
  cql_string_release(_between_6_);
  cql_string_release(_between_7_);
  cql_string_release(_between_8_);
  cql_string_release(_between_9_);
  cql_string_release(_between_10_);
  cql_string_release(_between_11_);
  cql_string_release(_between_12_);
  cql_string_release(_between_13_);
  cql_string_release(s);
  cql_string_release(text_result);
  cql_string_release(_tmp_text_0);
  cql_object_release(obj_var);
  cql_object_release(obj_var2);
  cql_object_release(_tmp_n_object_2);
  cql_object_release(_tmp_object_2);
  cql_object_release(_tmp_n_object_1);
  cql_object_release(_tmp_n_object_0);
  cql_finalize_stmt(&expanded_select);
  cql_finalize_stmt(&table_expanded_select);
  cql_blob_release(blob_var);
  cql_blob_release(blob_var2);
  cql_blob_release(_tmp_n_blob_2);
  cql_blob_release(_tmp_blob_2);
  cql_blob_release(_tmp_n_blob_1);
  cql_blob_release(_tmp_blob_0);
  cql_blob_release(blob_var_notnull);
  cql_finalize_stmt(&global_cursor);
  return _rc_;
}
