
#include "test_namespace/out/cg_test_c_with_namespace.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-not-parentheses"
#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#pragma clang diagnostic ignored "-Wliteral-conversion"
#pragma clang diagnostic ignored "-Wunused-but-set-variable"
extern CQL_WARN_UNUSED cql_code with_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code select_from_view(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code get_data(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_string_ref _Nonnull name_, cql_int32 id_);
extern CQL_WARN_UNUSED cql_code xyzzy(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_nullable_int32 id);

extern void plugh(cql_nullable_int32 id);

extern CQL_WARN_UNUSED cql_code complex_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code hierarchical_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_);
extern CQL_WARN_UNUSED cql_code hierarchical_unmatched_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_);
extern CQL_WARN_UNUSED cql_code union_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code union_all_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code union_all_with_nullable(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code with_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code with_recursive_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code parent_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code parent_proc_child(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct cursor_with_object_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_object_ref _Nullable object_;
} cursor_with_object_row;
extern void cursor_with_object(cql_object_ref _Nullable object_, cursor_with_object_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code uses_proc_for_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code blob_returner(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct out_cursor_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} out_cursor_proc_row;
extern CQL_WARN_UNUSED cql_code out_cursor_proc(sqlite3 *_Nonnull _db_, out_cursor_proc_row *_Nonnull _result_);

typedef struct fetcher_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} fetcher_proc_row;
extern void fetcher_proc(fetcher_proc_row *_Nonnull _result_);

extern void totally_void_proc(void);

extern void compute(cql_int32 a_, cql_int32 *_Nonnull b_);

extern CQL_WARN_UNUSED cql_code dml_compute(sqlite3 *_Nonnull _db_, cql_int32 a_, cql_int32 *_Nonnull b_);

extern CQL_WARN_UNUSED cql_code thread_theme_info_list(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 thread_key_);

typedef struct out_no_db_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} out_no_db_row;
extern void out_no_db(out_no_db_row *_Nonnull _result_);

typedef struct declare_cursor_like_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_row;
extern void declare_cursor_like_cursor(declare_cursor_like_cursor_row *_Nonnull _result_);

typedef struct declare_cursor_like_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} declare_cursor_like_proc_row;
extern void declare_cursor_like_proc(declare_cursor_like_proc_row *_Nonnull _result_);

typedef struct declare_cursor_like_table_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} declare_cursor_like_table_row;
extern void declare_cursor_like_table(declare_cursor_like_table_row *_Nonnull _result_);

typedef struct declare_cursor_like_view_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 f1;
  cql_int32 f2;
  cql_int32 f3;
} declare_cursor_like_view_row;
extern void declare_cursor_like_view(declare_cursor_like_view_row *_Nonnull _result_);
extern void blob_out(cql_blob_ref _Nullable *_Nonnull x);


typedef struct fetch_to_cursor_from_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_row;
extern void fetch_to_cursor_from_cursor(fetch_to_cursor_from_cursor_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code simple_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct out_union_helper_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} out_union_helper_row;

typedef struct out_union_dml_helper_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} out_union_dml_helper_row;

typedef struct forward_out_union_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} forward_out_union_row;
#ifndef result_set_type_decl_extern_out_union_helper_result_set
#define result_set_type_decl_extern_out_union_helper_result_set 1
cql_result_set_type_decl(extern_out_union_helper_result_set, extern_out_union_helper_result_set_ref);
#endif
extern void extern_out_union_helper_fetch_results(extern_out_union_helper_result_set_ref _Nullable *_Nonnull _result_set_);


typedef struct forward_out_union_extern_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} forward_out_union_extern_row;

typedef struct forward_out_union_dml_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} forward_out_union_dml_row;

typedef struct global_cursor_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a;
  cql_int32 b;
} global_cursor_row;
extern CQL_WARN_UNUSED cql_code simple_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code complex_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct out_cursor_identity_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_int32 data;
} out_cursor_identity_row;
extern CQL_WARN_UNUSED cql_code out_cursor_identity(sqlite3 *_Nonnull _db_, out_cursor_identity_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code radioactive_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code autodropper(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct simple_cursor_proc_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
} simple_cursor_proc_row;
extern void simple_cursor_proc(simple_cursor_proc_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code redundant_cast(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code top_level_select_alias_unused(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code top_level_select_alias_used_in_orderby(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct p1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} p1_row;
extern void p1(p1_row *_Nonnull _result_);


typedef struct p2_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} p2_row;
extern CQL_WARN_UNUSED cql_code p2(sqlite3 *_Nonnull _db_, p2_row *_Nonnull _result_);


typedef struct out_union_two_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_two_row;

typedef struct out_union_from_select_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_from_select_row;

typedef struct out_union_values_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} out_union_values_row;

typedef struct out_union_dml_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable data;
} out_union_dml_row;
extern CQL_WARN_UNUSED cql_code window_function_invocation(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
#ifndef result_set_type_decl_out_union_with_dml_result_set
#define result_set_type_decl_out_union_with_dml_result_set 1
cql_result_set_type_decl(out_union_with_dml_result_set, out_union_with_dml_result_set_ref);
#endif
extern CQL_WARN_UNUSED cql_code out_union_with_dml_fetch_results(sqlite3 *_Nonnull _db_, out_union_with_dml_result_set_ref _Nullable *_Nonnull _result_set_, cql_nullable_int32 id);

#ifndef result_set_type_decl_out_union_no_dml_result_set
#define result_set_type_decl_out_union_no_dml_result_set 1
cql_result_set_type_decl(out_union_no_dml_result_set, out_union_no_dml_result_set_ref);
#endif
extern void out_union_no_dml_fetch_results(out_union_no_dml_result_set_ref _Nullable *_Nonnull _result_set_, cql_nullable_int32 id);

extern CQL_WARN_UNUSED cql_code use_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code lotsa_columns_no_getters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code sproc_with_copy(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct emit_object_with_setters_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 i;
  cql_int64 l;
  cql_bool b;
  cql_double d;
  cql_object_ref _Nonnull o;
  cql_object_ref _Nonnull x;
  cql_string_ref _Nonnull t;
  cql_blob_ref _Nonnull bl;
} emit_object_with_setters_row;
extern void emit_object_with_setters(cql_object_ref _Nonnull o, cql_object_ref _Nonnull x, cql_int32 i, cql_int64 l, cql_bool b, cql_double d, cql_string_ref _Nonnull t, cql_blob_ref _Nonnull bl, emit_object_with_setters_row *_Nonnull _result_);

typedef struct emit_setters_with_nullables_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 i;
  cql_nullable_int64 l;
  cql_nullable_bool b;
  cql_nullable_double d;
  cql_object_ref _Nullable o;
  cql_object_ref _Nullable x;
  cql_string_ref _Nullable t;
  cql_blob_ref _Nullable bl;
} emit_setters_with_nullables_row;
extern void emit_setters_with_nullables(cql_object_ref _Nullable o, cql_object_ref _Nullable x, cql_nullable_int32 i, cql_nullable_int64 l, cql_nullable_bool b, cql_nullable_double d, cql_string_ref _Nullable t, cql_blob_ref _Nullable bl, emit_setters_with_nullables_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code no_out_with_setters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code lotsa_columns_no_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_sensitive_with_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_not_nullable_sensitive_with_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_sensitive_with_no_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_union_all_table_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_alias_column_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_alias_column_name_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_sensitive_with_no_context_and_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_no_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window1(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window2(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window3(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window4(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window5(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window6(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window7(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window8(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window9(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window10(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window11(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window12(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window13(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window14(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window15(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code window16(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code virtual1(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code virtual2(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);

typedef struct private_out_union_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} private_out_union_row;

typedef struct no_getters_out_union_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} no_getters_out_union_row;

typedef struct suppress_results_out_union_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} suppress_results_out_union_row;
// static CQL_WARN_UNUSED cql_code private_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_nullable_int32 *_Nonnull x);

typedef struct global_cursor2_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_string_ref _Nonnull x;
} global_cursor2_row;

#define global_cursor2_refs_offset cql_offsetof(global_cursor2_row, x) // count = 1
extern void out2_proc(cql_nullable_int32 x, cql_int32 *_Nonnull y, cql_int32 *_Nonnull z);


typedef struct out_object_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_object_ref _Nonnull o;
} out_object_row;
extern void out_object(cql_object_ref _Nonnull o, out_object_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code result_set_proc_with_contract_in_fetch_results(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_string_ref _Nonnull t);

typedef struct out_proc_with_contract_in_fetch_results_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} out_proc_with_contract_in_fetch_results_row;
extern void out_proc_with_contract_in_fetch_results(cql_string_ref _Nonnull t, out_proc_with_contract_in_fetch_results_row *_Nonnull _result_);
extern CQL_WARN_UNUSED cql_code nullability_improvements_are_erased_for_sql(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code sensitive_function_is_a_no_op(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code foo(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code shared_conditional_user(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int32 x);
extern CQL_WARN_UNUSED cql_code nested_shared_stuff(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern CQL_WARN_UNUSED cql_code use_nested_select_shared_frag_form(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
// static CQL_WARN_UNUSED cql_code simple_shared_frag(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
cql_string_literal(_literal_1_text_, "text");
cql_string_literal(_literal_2_This_is_a_test_, "This is a \" \\ test '' \n \" ");
cql_string_literal(_literal_3_b_, "b");
cql_string_literal(_literal_4_a_, "a");
cql_string_literal(_literal_5_c_, "c");
cql_string_literal(_literal_6_x_, "x");
cql_string_literal(_literal_7_before_echo_echo_test, "before echo");
cql_string_literal(_literal_8_after_echo_echo_test, "after echo");
cql_string_literal(_literal_9_Testing_c_literal, "\"Testing\" \\''");
cql_string_literal(_literal_10_bar_fetch_to_cursor_from_cursor, "bar");
cql_string_literal(_literal_11_y_, "y");
cql_string_literal(_literal_12_, "");
cql_string_literal(_literal_13_garbonzo_, "garbonzo");
cql_string_literal(_literal_14_T_various_lets, "T");
cql_string_literal(_literal_15_NT_various_lets, "NT");
cql_string_literal(_literal_16_ST_various_lets, "ST");
cql_string_literal(_literal_17_foo_binary_ops_with_null, "foo");
cql_string_literal(_literal_18_null_BigFormat, "null");
cql_string_literal(_literal_19_arguments_are_evaluated_left_to_right, "1");
cql_string_literal(_literal_20_arguments_are_evaluated_left_to_right, "2");
cql_string_literal(_literal_21_arguments_are_evaluated_left_to_right, "3");
cql_string_literal(_literal_22_arguments_are_evaluated_left_to_right, "4");
cql_string_literal(_literal_23_hello_sensitive_function_is_a_no_op, "hello");
cql_string_literal(_literal_24_slash_star_and_star_slash, "/*  */");

// The statement ending at line XXXX

/*
DECLARE i0_nullable INTEGER;
*/
cql_nullable_int32 i0_nullable;

// The statement ending at line XXXX

/*
DECLARE i1_nullable INTEGER;
*/
cql_nullable_int32 i1_nullable;

// The statement ending at line XXXX

/*
DECLARE r0_nullable REAL;
*/
cql_nullable_double r0_nullable;

// The statement ending at line XXXX

/*
DECLARE l0_nullable LONG_INT;
*/
cql_nullable_int64 l0_nullable;

// The statement ending at line XXXX

/*
DECLARE l1_nullable LONG_INT;
*/
cql_nullable_int64 l1_nullable;

// The statement ending at line XXXX

/*
DECLARE b0_nullable BOOL;
*/
cql_nullable_bool b0_nullable;

// The statement ending at line XXXX

/*
DECLARE t0_nullable TEXT;
*/
cql_string_ref t0_nullable = NULL;

// The statement ending at line XXXX

/*
DECLARE i2 INTEGER NOT NULL;
*/
cql_int32 i2 = 0;

// The statement ending at line XXXX

/*
DECLARE r2 REAL NOT NULL;
*/
cql_double r2 = 0;

// The statement ending at line XXXX

/*
DECLARE l2 LONG_INT NOT NULL;
*/
cql_int64 l2 = 0;

// The statement ending at line XXXX

/*
DECLARE b2 BOOL NOT NULL;
*/
cql_bool b2 = 0;

// The statement ending at line XXXX

/*
DECLARE t2 TEXT NOT NULL;
*/
cql_string_ref t2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC test (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    CALL puts('true');
  END IF;
END;
*/

#define _PROC_ "test"
// export: DECLARE PROC test (i INTEGER NOT NULL);
void test(cql_int32 i) {
  if (i) {
    puts("true");
  }

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC proc_with_return_guard (a INTEGER)
BEGIN
  IF a IS NOT NULL THEN
    RETURN;
  END IF;
  LET x := a;
END;
*/

#define _PROC_ "proc_with_return_guard"
// export: DECLARE PROC proc_with_return_guard (a INTEGER);
void proc_with_return_guard(cql_nullable_int32 a) {
  cql_nullable_int32 x;
  cql_set_null(x);

  if (!a.is_null) {
    goto cql_cleanup; // return
  }
  cql_set_nullable(x, a.is_null, a.value);

cql_cleanup:
  ; // label requires some statement
}
#undef _PROC_
cql_int32 _between_0_ = 0;
cql_nullable_int32 _between_1_;
cql_nullable_int32 _between_2_;
cql_int32 _between_3_ = 0;
cql_nullable_int32 _between_4_;
cql_nullable_int32 _between_5_;

// The statement ending at line XXXX

/*
CREATE PROC out_test (OUT i INTEGER NOT NULL, OUT ii INTEGER)
BEGIN
  SET i := i2;
  SET ii := i0_nullable;
END;
*/

#define _PROC_ "out_test"
// export: DECLARE PROC out_test (OUT i INTEGER NOT NULL, OUT ii INTEGER);
void out_test(cql_int32 *_Nonnull i, cql_nullable_int32 *_Nonnull ii) {
  cql_contract_argument_notnull((void *)i, 1);
  cql_contract_argument_notnull((void *)ii, 2);

  *i = 0; // set out arg to non-garbage
  cql_set_null(*ii); // set out arg to non-garbage
  *i = i2;
  cql_set_nullable(*ii, i0_nullable.is_null, i0_nullable.value);

}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE longint_var LONG_INT;
*/
cql_nullable_int64 longint_var;
sqlite3_stmt *foo_cursor_stmt = NULL;
cql_bool _foo_cursor_has_row_ = 0;

// The statement ending at line XXXX

/*
DECLARE col1 INTEGER;
*/
cql_nullable_int32 col1;

// The statement ending at line XXXX

/*
DECLARE col2 REAL NOT NULL;
*/
cql_double col2 = 0;
sqlite3_stmt *basic_cursor_stmt = NULL;
cql_bool _basic_cursor_has_row_ = 0;

// The statement ending at line XXXX

/*
DECLARE arg1 INTEGER NOT NULL;
*/
cql_int32 arg1 = 0;

// The statement ending at line XXXX

/*
DECLARE arg2 INTEGER NOT NULL;
*/
cql_int32 arg2 = 0;
sqlite3_stmt *exchange_cursor_stmt = NULL;
cql_bool _exchange_cursor_has_row_ = 0;
sqlite3_stmt *_temp_stmt = NULL;

// The statement ending at line XXXX

/*
CREATE PROC outparm_test (OUT foo INTEGER NOT NULL)
BEGIN
  SET foo := 1;
  DELETE FROM bar WHERE id = foo;
END;
*/

#define _PROC_ "outparm_test"
// export: DECLARE PROC outparm_test (OUT foo INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code outparm_test(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull foo) {
  cql_contract_argument_notnull((void *)foo, 1);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  *foo = 0; // set out arg to non-garbage
  *foo = 1;
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "DELETE FROM bar WHERE id = ?");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, *foo);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC throwing ()
BEGIN
  BEGIN TRY
    DELETE FROM bar;
  END TRY;
  BEGIN CATCH
    CALL printf("error\n");
    THROW;
  END CATCH;
END;
*/

#define _PROC_ "throwing"
// export: DECLARE PROC throwing () USING TRANSACTION;
CQL_WARN_UNUSED cql_code throwing(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  // try
  {
    _rc_ = cql_exec(_db_,
      "DELETE FROM bar");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }
    goto catch_end_1;
  }
  catch_start_1: {
    int32_t _rc_thrown_1 = _rc_;
    printf("error\n");
    _rc_ = cql_best_error(_rc_thrown_1);
    goto cql_cleanup;
  }
  catch_end_1:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_
cql_string_ref _between_6_ = NULL;
cql_string_ref _between_7_ = NULL;
cql_string_ref _between_8_ = NULL;
cql_string_ref _between_9_ = NULL;
cql_string_ref _between_10_ = NULL;
cql_string_ref _between_11_ = NULL;
cql_string_ref _between_12_ = NULL;
cql_string_ref _between_13_ = NULL;

// The statement ending at line XXXX

/*
CREATE PROC with_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "with_result_set"
static int32_t with_result_set_perf_index;

cql_string_proc_name(with_result_set_stored_procedure_name, "with_result_set");

typedef struct with_result_set_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} with_result_set_row;

cql_int32 with_result_set_get_id(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable with_result_set_get_name(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool with_result_set_get_rate_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 with_result_set_get_rate_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool with_result_set_get_type_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 with_result_set_get_type_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool with_result_set_get_size_is_null(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double with_result_set_get_size_value(with_result_set_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_result_set_row *data = (with_result_set_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t with_result_set_data_types[with_result_set_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define with_result_set_refs_offset cql_offsetof(with_result_set_row, name) // count = 1

static cql_uint16 with_result_set_col_offsets[] = { 5,
  cql_offsetof(with_result_set_row, id),
  cql_offsetof(with_result_set_row, name),
  cql_offsetof(with_result_set_row, rate),
  cql_offsetof(with_result_set_row, type),
  cql_offsetof(with_result_set_row, size)
};

cql_int32 with_result_set_result_count(with_result_set_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_result_set_fetch_results(sqlite3 *_Nonnull _db_, with_result_set_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_result_set, &with_result_set_perf_index);
  cql_code rc = with_result_set(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_result_set_data_types,
    .col_offsets = with_result_set_col_offsets,
    .refs_count = 1,
    .refs_offset = with_result_set_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(with_result_set_row),
    .crc = CRC_with_result_set,
    .perf_index = &with_result_set_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC with_result_set () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code with_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC select_from_view ()
BEGIN
  SELECT id, type
    FROM baz;
END;
*/

#define _PROC_ "select_from_view"
static int32_t select_from_view_perf_index;

cql_string_proc_name(select_from_view_stored_procedure_name, "select_from_view");

typedef struct select_from_view_row {
  cql_int32 id;
  cql_nullable_int32 type;
} select_from_view_row;

cql_int32 select_from_view_get_id(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_bool select_from_view_get_type_is_null(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 select_from_view_get_type_value(select_from_view_result_set_ref _Nonnull result_set, cql_int32 row) {
  select_from_view_row *data = (select_from_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t select_from_view_data_types[select_from_view_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32, // type
};

static cql_uint16 select_from_view_col_offsets[] = { 2,
  cql_offsetof(select_from_view_row, id),
  cql_offsetof(select_from_view_row, type)
};

cql_int32 select_from_view_result_count(select_from_view_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code select_from_view_fetch_results(sqlite3 *_Nonnull _db_, select_from_view_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_select_from_view, &select_from_view_perf_index);
  cql_code rc = select_from_view(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = select_from_view_data_types,
    .col_offsets = select_from_view_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(select_from_view_row),
    .crc = CRC_select_from_view,
    .perf_index = &select_from_view_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC select_from_view () (id INTEGER NOT NULL, type INTEGER);
CQL_WARN_UNUSED cql_code select_from_view(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, type "
      "FROM baz");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC make_view ()
BEGIN
  CREATE VIEW MyView AS
  SELECT 1 AS f1, 2 AS f2, 3 AS f3;
END;
*/

#define _PROC_ "make_view"
// export: DECLARE PROC make_view () USING TRANSACTION;
CQL_WARN_UNUSED cql_code make_view(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIEW MyView AS "
    "SELECT 1 AS f1, 2 AS f2, 3 AS f3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC make_index ()
BEGIN
  CREATE INDEX index_1 ON bar (id);
END;
*/

#define _PROC_ "make_index"
// export: DECLARE PROC make_index () USING TRANSACTION;
CQL_WARN_UNUSED cql_code make_index(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE INDEX index_1 ON bar (id)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC get_data (name_ TEXT NOT NULL, id_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM bar
    WHERE id = id_ AND name = name_;
END;
*/

#define _PROC_ "get_data"
static int32_t get_data_perf_index;

cql_string_proc_name(get_data_stored_procedure_name, "get_data");

typedef struct get_data_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} get_data_row;

cql_int32 get_data_get_id(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable get_data_get_name(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool get_data_get_rate_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 get_data_get_rate_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool get_data_get_type_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 get_data_get_type_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool get_data_get_size_is_null(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double get_data_get_size_value(get_data_result_set_ref _Nonnull result_set, cql_int32 row) {
  get_data_row *data = (get_data_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t get_data_data_types[get_data_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define get_data_refs_offset cql_offsetof(get_data_row, name) // count = 1

static cql_uint16 get_data_col_offsets[] = { 5,
  cql_offsetof(get_data_row, id),
  cql_offsetof(get_data_row, name),
  cql_offsetof(get_data_row, rate),
  cql_offsetof(get_data_row, type),
  cql_offsetof(get_data_row, size)
};

cql_int32 get_data_result_count(get_data_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code get_data_fetch_results(sqlite3 *_Nonnull _db_, get_data_result_set_ref _Nullable *_Nonnull result_set, cql_string_ref _Nonnull name_, cql_int32 id_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_get_data, &get_data_perf_index);
  cql_code rc = get_data(_db_, &stmt, name_, id_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = get_data_data_types,
    .col_offsets = get_data_col_offsets,
    .refs_count = 1,
    .refs_offset = get_data_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(get_data_row),
    .crc = CRC_get_data,
    .perf_index = &get_data_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC get_data (name_ TEXT NOT NULL, id_ INTEGER NOT NULL) (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code get_data(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_string_ref _Nonnull name_, cql_int32 id_) {
  cql_contract_argument_notnull((void *)name_, 1);

  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar "
      "WHERE id = ? AND name = ?");
  cql_multibind(&_rc_, _db_, _result_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, name_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC easy_fetch ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  FETCH C;
  CALL printf("%d %s\n", C.id, C.name);
  DECLARE C2 CURSOR FOR SELECT *
    FROM bar
    WHERE C AND id = C.id;
END;
*/

#define _PROC_ "easy_fetch"
// export: DECLARE PROC easy_fetch () USING TRANSACTION;

typedef struct easy_fetch_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} easy_fetch_C_row;

#define easy_fetch_C_refs_offset cql_offsetof(easy_fetch_C_row, name) // count = 1
CQL_WARN_UNUSED cql_code easy_fetch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  easy_fetch_C_row C = { ._refs_count_ = 1, ._refs_offset_ = easy_fetch_C_refs_offset };
  sqlite3_stmt *C2_stmt = NULL;
  cql_bool _C2_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 5,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.id,
                 CQL_DATA_TYPE_STRING, &C.name,
                 CQL_DATA_TYPE_INT64, &C.rate,
                 CQL_DATA_TYPE_INT32, &C.type,
                 CQL_DATA_TYPE_DOUBLE, &C.size);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_alloc_cstr(_cstr_1, C.name);
  printf("%d %s\n", C.id, _cstr_1);
  cql_free_cstr(_cstr_1, C.name);
  _rc_ = cql_prepare(_db_, &C2_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar "
      "WHERE ? AND id = ?");
  cql_multibind(&_rc_, _db_, &C2_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, C._has_row_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, C.id);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  cql_finalize_stmt(&C2_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC copy_int (a INTEGER, OUT b INTEGER)
BEGIN
  SET b := a;
END;
*/

#define _PROC_ "copy_int"
// export: DECLARE PROC copy_int (a INTEGER, OUT b INTEGER);
void copy_int(cql_nullable_int32 a, cql_nullable_int32 *_Nonnull b) {
  cql_contract_argument_notnull((void *)b, 2);

  cql_set_null(*b); // set out arg to non-garbage
  cql_set_nullable(*b, a.is_null, a.value);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC insert_rowid_reader ()
BEGIN
  DECLARE row LONG_INT;
  SET row := last_insert_rowid();
END;
*/

#define _PROC_ "insert_rowid_reader"
// export: DECLARE PROC insert_rowid_reader () USING TRANSACTION;
CQL_WARN_UNUSED cql_code insert_rowid_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int64 row;
  cql_set_null(row);

  cql_set_notnull(row, sqlite3_last_insert_rowid(_db_));
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC changes_reader ()
BEGIN
  DECLARE ct INTEGER;
  SET ct := changes();
END;
*/

#define _PROC_ "changes_reader"
// export: DECLARE PROC changes_reader () USING TRANSACTION;
CQL_WARN_UNUSED cql_code changes_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 ct;
  cql_set_null(ct);

  cql_set_notnull(ct, sqlite3_changes(_db_));
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE s TEXT NOT NULL;
*/
cql_string_ref s = NULL;

// The statement ending at line XXXX

/*
DECLARE PROC xyzzy (id INTEGER) (A INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC xyzzy_test ()
BEGIN
  DECLARE xyzzy_cursor CURSOR FOR CALL xyzzy(1);
END;
*/

#define _PROC_ "xyzzy_test"
// export: DECLARE PROC xyzzy_test () USING TRANSACTION;
CQL_WARN_UNUSED cql_code xyzzy_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 _tmp_n_int_0;
  cql_set_null(_tmp_n_int_0);
  sqlite3_stmt *xyzzy_cursor_stmt = NULL;
  cql_bool _xyzzy_cursor_has_row_ = 0;

  cql_set_notnull(_tmp_n_int_0, 1);
  _rc_ = xyzzy(_db_, &xyzzy_cursor_stmt, _tmp_n_int_0);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&xyzzy_cursor_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC plugh (id INTEGER);
*/

// The statement ending at line XXXX

/*
CREATE PROC complex_return ()
BEGIN
  SELECT TRUE AS _bool, 2 AS _integer, CAST(3 AS LONG_INT) AS _longint, 3.0 AS _real, 'xyz' AS _text, CAST(NULL AS BOOL) AS _nullable_bool;
END;
*/

#define _PROC_ "complex_return"
static int32_t complex_return_perf_index;

cql_string_proc_name(complex_return_stored_procedure_name, "complex_return");

typedef struct complex_return_row {
  cql_bool _bool;
  cql_int32 _integer;
  cql_int64 _longint;
  cql_double _real;
  cql_nullable_bool _nullable_bool;
  cql_string_ref _Nonnull _text;
} complex_return_row;

cql_bool complex_return_get__bool(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._bool;
}

cql_int32 complex_return_get__integer(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._integer;
}

cql_int64 complex_return_get__longint(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._longint;
}

cql_double complex_return_get__real(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._real;
}

cql_string_ref _Nonnull complex_return_get__text(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._text;
}

cql_bool complex_return_get__nullable_bool_is_null(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._nullable_bool.is_null;
}

cql_bool complex_return_get__nullable_bool_value(complex_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_return_row *data = (complex_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row]._nullable_bool.value;
}

uint8_t complex_return_data_types[complex_return_data_types_count] = {
  CQL_DATA_TYPE_BOOL | CQL_DATA_TYPE_NOT_NULL, // _bool
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // _integer
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // _longint
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // _real
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // _text
  CQL_DATA_TYPE_BOOL, // _nullable_bool
};

#define complex_return_refs_offset cql_offsetof(complex_return_row, _text) // count = 1

static cql_uint16 complex_return_col_offsets[] = { 6,
  cql_offsetof(complex_return_row, _bool),
  cql_offsetof(complex_return_row, _integer),
  cql_offsetof(complex_return_row, _longint),
  cql_offsetof(complex_return_row, _real),
  cql_offsetof(complex_return_row, _text),
  cql_offsetof(complex_return_row, _nullable_bool)
};

cql_int32 complex_return_result_count(complex_return_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code complex_return_fetch_results(sqlite3 *_Nonnull _db_, complex_return_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_complex_return, &complex_return_perf_index);
  cql_code rc = complex_return(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = complex_return_data_types,
    .col_offsets = complex_return_col_offsets,
    .refs_count = 1,
    .refs_offset = complex_return_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(complex_return_row),
    .crc = CRC_complex_return,
    .perf_index = &complex_return_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC complex_return () (_bool BOOL NOT NULL, _integer INTEGER NOT NULL, _longint LONG_INT NOT NULL, _real REAL NOT NULL, _text TEXT NOT NULL, _nullable_bool BOOL);
CQL_WARN_UNUSED cql_code complex_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2, CAST(3 AS LONG_INT), 3.0, 'xyz', NULL");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC hierarchical_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
*/

#define _PROC_ "hierarchical_query"
static int32_t hierarchical_query_perf_index;

cql_string_proc_name(hierarchical_query_stored_procedure_name, "hierarchical_query");

typedef struct hierarchical_query_row {
  cql_int32 id;
} hierarchical_query_row;

cql_int32 hierarchical_query_get_id(hierarchical_query_result_set_ref _Nonnull result_set, cql_int32 row) {
  hierarchical_query_row *data = (hierarchical_query_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

uint8_t hierarchical_query_data_types[hierarchical_query_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 hierarchical_query_col_offsets[] = { 1,
  cql_offsetof(hierarchical_query_row, id)
};

cql_int32 hierarchical_query_result_count(hierarchical_query_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_query_fetch_results(sqlite3 *_Nonnull _db_, hierarchical_query_result_set_ref _Nullable *_Nonnull result_set, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_hierarchical_query, &hierarchical_query_perf_index);
  cql_code rc = hierarchical_query(_db_, &stmt, rate_, limit_, offset_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = hierarchical_query_data_types,
    .col_offsets = hierarchical_query_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(hierarchical_query_row),
    .crc = CRC_hierarchical_query,
    .perf_index = &hierarchical_query_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC hierarchical_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL) (id INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code hierarchical_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id "
      "FROM foo "
      "WHERE id IN (SELECT id "
      "FROM bar "
      "WHERE rate = ? "
    "ORDER BY name "
    "LIMIT ? "
    "OFFSET ?) "
    "ORDER BY id");
  cql_multibind(&_rc_, _db_, _result_stmt, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, rate_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, limit_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, offset_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC hierarchical_unmatched_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id NOT IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
*/

#define _PROC_ "hierarchical_unmatched_query"
static int32_t hierarchical_unmatched_query_perf_index;

cql_string_proc_name(hierarchical_unmatched_query_stored_procedure_name, "hierarchical_unmatched_query");

typedef struct hierarchical_unmatched_query_row {
  cql_int32 id;
} hierarchical_unmatched_query_row;

cql_int32 hierarchical_unmatched_query_get_id(hierarchical_unmatched_query_result_set_ref _Nonnull result_set, cql_int32 row) {
  hierarchical_unmatched_query_row *data = (hierarchical_unmatched_query_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

uint8_t hierarchical_unmatched_query_data_types[hierarchical_unmatched_query_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 hierarchical_unmatched_query_col_offsets[] = { 1,
  cql_offsetof(hierarchical_unmatched_query_row, id)
};

cql_int32 hierarchical_unmatched_query_result_count(hierarchical_unmatched_query_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code hierarchical_unmatched_query_fetch_results(sqlite3 *_Nonnull _db_, hierarchical_unmatched_query_result_set_ref _Nullable *_Nonnull result_set, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_hierarchical_unmatched_query, &hierarchical_unmatched_query_perf_index);
  cql_code rc = hierarchical_unmatched_query(_db_, &stmt, rate_, limit_, offset_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = hierarchical_unmatched_query_data_types,
    .col_offsets = hierarchical_unmatched_query_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(hierarchical_unmatched_query_row),
    .crc = CRC_hierarchical_unmatched_query,
    .perf_index = &hierarchical_unmatched_query_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC hierarchical_unmatched_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL) (id INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code hierarchical_unmatched_query(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 rate_, cql_int32 limit_, cql_int32 offset_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id "
      "FROM foo "
      "WHERE id NOT IN (SELECT id "
      "FROM bar "
      "WHERE rate = ? "
    "ORDER BY name "
    "LIMIT ? "
    "OFFSET ?) "
    "ORDER BY id");
  cql_multibind(&_rc_, _db_, _result_stmt, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, rate_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, limit_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, offset_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC union_select ()
BEGIN
  SELECT 1 AS A
  UNION
  SELECT 2 AS A;
END;
*/

#define _PROC_ "union_select"
static int32_t union_select_perf_index;

cql_string_proc_name(union_select_stored_procedure_name, "union_select");

typedef struct union_select_row {
  cql_int32 A;
} union_select_row;

cql_int32 union_select_get_A(union_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_select_row *data = (union_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].A;
}

uint8_t union_select_data_types[union_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
};

static cql_uint16 union_select_col_offsets[] = { 1,
  cql_offsetof(union_select_row, A)
};

cql_int32 union_select_result_count(union_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_select_fetch_results(sqlite3 *_Nonnull _db_, union_select_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_select, &union_select_perf_index);
  cql_code rc = union_select(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_select_data_types,
    .col_offsets = union_select_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(union_select_row),
    .crc = CRC_union_select,
    .perf_index = &union_select_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC union_select () (A INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code union_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1 "
    "UNION "
    "SELECT 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC union_all_select ()
BEGIN
  SELECT 1 AS A
  UNION ALL
  SELECT 2 AS A;
END;
*/

#define _PROC_ "union_all_select"
static int32_t union_all_select_perf_index;

cql_string_proc_name(union_all_select_stored_procedure_name, "union_all_select");

typedef struct union_all_select_row {
  cql_int32 A;
} union_all_select_row;

cql_int32 union_all_select_get_A(union_all_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_all_select_row *data = (union_all_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].A;
}

uint8_t union_all_select_data_types[union_all_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
};

static cql_uint16 union_all_select_col_offsets[] = { 1,
  cql_offsetof(union_all_select_row, A)
};

cql_int32 union_all_select_result_count(union_all_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_all_select_fetch_results(sqlite3 *_Nonnull _db_, union_all_select_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_all_select, &union_all_select_perf_index);
  cql_code rc = union_all_select(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_all_select_data_types,
    .col_offsets = union_all_select_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(union_all_select_row),
    .crc = CRC_union_all_select,
    .perf_index = &union_all_select_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC union_all_select () (A INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code union_all_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1 "
    "UNION ALL "
    "SELECT 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC union_all_with_nullable ()
BEGIN
  SELECT nullable('foo') AS name
  UNION ALL
  SELECT name
    FROM bar;
END;
*/

#define _PROC_ "union_all_with_nullable"
static int32_t union_all_with_nullable_perf_index;

cql_string_proc_name(union_all_with_nullable_stored_procedure_name, "union_all_with_nullable");

typedef struct union_all_with_nullable_row {
  cql_string_ref _Nullable name;
} union_all_with_nullable_row;

cql_string_ref _Nullable union_all_with_nullable_get_name(union_all_with_nullable_result_set_ref _Nonnull result_set, cql_int32 row) {
  union_all_with_nullable_row *data = (union_all_with_nullable_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

uint8_t union_all_with_nullable_data_types[union_all_with_nullable_data_types_count] = {
  CQL_DATA_TYPE_STRING, // name
};

#define union_all_with_nullable_refs_offset cql_offsetof(union_all_with_nullable_row, name) // count = 1

static cql_uint16 union_all_with_nullable_col_offsets[] = { 1,
  cql_offsetof(union_all_with_nullable_row, name)
};

cql_int32 union_all_with_nullable_result_count(union_all_with_nullable_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code union_all_with_nullable_fetch_results(sqlite3 *_Nonnull _db_, union_all_with_nullable_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_union_all_with_nullable, &union_all_with_nullable_perf_index);
  cql_code rc = union_all_with_nullable(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = union_all_with_nullable_data_types,
    .col_offsets = union_all_with_nullable_col_offsets,
    .refs_count = 1,
    .refs_offset = union_all_with_nullable_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(union_all_with_nullable_row),
    .crc = CRC_union_all_with_nullable,
    .perf_index = &union_all_with_nullable_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC union_all_with_nullable () (name TEXT);
CQL_WARN_UNUSED cql_code union_all_with_nullable(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 'foo' "
    "UNION ALL "
    "SELECT name "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_stmt_using_cursor ()
BEGIN
  DECLARE C CURSOR FOR WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
  FETCH C;
END;
*/

#define _PROC_ "with_stmt_using_cursor"
// export: DECLARE PROC with_stmt_using_cursor () USING TRANSACTION;

typedef struct with_stmt_using_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_stmt_using_cursor_C_row;
CQL_WARN_UNUSED cql_code with_stmt_using_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  with_stmt_using_cursor_C_row C = { 0 };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "WITH "
    "X (a, b, c) AS (SELECT 1, 2, 3) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 3,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.a,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.b,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.c);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_stmt ()
BEGIN
  WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
END;
*/

#define _PROC_ "with_stmt"
static int32_t with_stmt_perf_index;

cql_string_proc_name(with_stmt_stored_procedure_name, "with_stmt");

typedef struct with_stmt_row {
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_stmt_row;

cql_int32 with_stmt_get_a(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 with_stmt_get_b(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

cql_int32 with_stmt_get_c(with_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_stmt_row *data = (with_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].c;
}

uint8_t with_stmt_data_types[with_stmt_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // c
};

static cql_uint16 with_stmt_col_offsets[] = { 3,
  cql_offsetof(with_stmt_row, a),
  cql_offsetof(with_stmt_row, b),
  cql_offsetof(with_stmt_row, c)
};

cql_int32 with_stmt_result_count(with_stmt_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_stmt_fetch_results(sqlite3 *_Nonnull _db_, with_stmt_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_stmt, &with_stmt_perf_index);
  cql_code rc = with_stmt(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_stmt_data_types,
    .col_offsets = with_stmt_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(with_stmt_row),
    .crc = CRC_with_stmt,
    .perf_index = &with_stmt_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC with_stmt () (a INTEGER NOT NULL, b INTEGER NOT NULL, c INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code with_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "WITH "
    "X (a, b, c) AS (SELECT 1, 2, 3) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_recursive_stmt ()
BEGIN
  WITH RECURSIVE
  X (a, b, c) AS (SELECT 1, 2, 3
  UNION ALL
  SELECT 4, 5, 6)
  SELECT *
    FROM X;
END;
*/

#define _PROC_ "with_recursive_stmt"
static int32_t with_recursive_stmt_perf_index;

cql_string_proc_name(with_recursive_stmt_stored_procedure_name, "with_recursive_stmt");

typedef struct with_recursive_stmt_row {
  cql_int32 a;
  cql_int32 b;
  cql_int32 c;
} with_recursive_stmt_row;

cql_int32 with_recursive_stmt_get_a(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 with_recursive_stmt_get_b(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

cql_int32 with_recursive_stmt_get_c(with_recursive_stmt_result_set_ref _Nonnull result_set, cql_int32 row) {
  with_recursive_stmt_row *data = (with_recursive_stmt_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].c;
}

uint8_t with_recursive_stmt_data_types[with_recursive_stmt_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // c
};

static cql_uint16 with_recursive_stmt_col_offsets[] = { 3,
  cql_offsetof(with_recursive_stmt_row, a),
  cql_offsetof(with_recursive_stmt_row, b),
  cql_offsetof(with_recursive_stmt_row, c)
};

cql_int32 with_recursive_stmt_result_count(with_recursive_stmt_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code with_recursive_stmt_fetch_results(sqlite3 *_Nonnull _db_, with_recursive_stmt_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_with_recursive_stmt, &with_recursive_stmt_perf_index);
  cql_code rc = with_recursive_stmt(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = with_recursive_stmt_data_types,
    .col_offsets = with_recursive_stmt_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(with_recursive_stmt_row),
    .crc = CRC_with_recursive_stmt,
    .perf_index = &with_recursive_stmt_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC with_recursive_stmt () (a INTEGER NOT NULL, b INTEGER NOT NULL, c INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code with_recursive_stmt(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "WITH RECURSIVE "
    "X (a, b, c) AS (SELECT 1, 2, 3 "
    "UNION ALL "
    "SELECT 4, 5, 6) "
    "SELECT a, b, c "
      "FROM X");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC parent_proc ()
BEGIN
  SELECT 1 AS one, 2 AS two, 3 AS three;
END;
*/

#define _PROC_ "parent_proc"
static int32_t parent_proc_perf_index;

cql_string_proc_name(parent_proc_stored_procedure_name, "parent_proc");

typedef struct parent_proc_row {
  cql_int32 one;
  cql_int32 two;
  cql_int32 three;
} parent_proc_row;

cql_int32 parent_proc_get_one(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].one;
}

cql_int32 parent_proc_get_two(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].two;
}

cql_int32 parent_proc_get_three(parent_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_row *data = (parent_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].three;
}

uint8_t parent_proc_data_types[parent_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // one
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // two
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // three
};

static cql_uint16 parent_proc_col_offsets[] = { 3,
  cql_offsetof(parent_proc_row, one),
  cql_offsetof(parent_proc_row, two),
  cql_offsetof(parent_proc_row, three)
};

cql_int32 parent_proc_result_count(parent_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc_fetch_results(sqlite3 *_Nonnull _db_, parent_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_parent_proc, &parent_proc_perf_index);
  cql_code rc = parent_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = parent_proc_data_types,
    .col_offsets = parent_proc_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(parent_proc_row),
    .crc = CRC_parent_proc,
    .perf_index = &parent_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC parent_proc () (one INTEGER NOT NULL, two INTEGER NOT NULL, three INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code parent_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2, 3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC parent_proc_child ()
BEGIN
  SELECT 4 AS four, 5 AS five, 6 AS six;
END;
*/

#define _PROC_ "parent_proc_child"
static int32_t parent_proc_child_perf_index;

cql_string_proc_name(parent_proc_child_stored_procedure_name, "parent_proc_child");

typedef struct parent_proc_child_row {
  cql_int32 four;
  cql_int32 five;
  cql_int32 six;
} parent_proc_child_row;

cql_int32 parent_proc_child_get_four(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].four;
}

cql_int32 parent_proc_child_get_five(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].five;
}

cql_int32 parent_proc_child_get_six(parent_proc_child_result_set_ref _Nonnull result_set, cql_int32 row) {
  parent_proc_child_row *data = (parent_proc_child_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].six;
}

uint8_t parent_proc_child_data_types[parent_proc_child_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // four
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // five
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // six
};

static cql_uint16 parent_proc_child_col_offsets[] = { 3,
  cql_offsetof(parent_proc_child_row, four),
  cql_offsetof(parent_proc_child_row, five),
  cql_offsetof(parent_proc_child_row, six)
};

cql_int32 parent_proc_child_result_count(parent_proc_child_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code parent_proc_child_fetch_results(sqlite3 *_Nonnull _db_, parent_proc_child_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_parent_proc_child, &parent_proc_child_perf_index);
  cql_code rc = parent_proc_child(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = parent_proc_child_data_types,
    .col_offsets = parent_proc_child_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(parent_proc_child_row),
    .crc = CRC_parent_proc_child,
    .perf_index = &parent_proc_child_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC parent_proc_child () (four INTEGER NOT NULL, five INTEGER NOT NULL, six INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code parent_proc_child(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 4, 5, 6");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC outint_nullable (OUT output INTEGER, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
*/

#define _PROC_ "outint_nullable"
// export: DECLARE PROC outint_nullable (OUT output INTEGER, OUT result BOOL NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code outint_nullable(sqlite3 *_Nonnull _db_, cql_nullable_int32 *_Nonnull output, cql_bool *_Nonnull result) {
  cql_contract_argument_notnull((void *)output, 1);
  cql_contract_argument_notnull((void *)result, 2);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_bool _C_has_row_ = 0;

  cql_set_null(*output); // set out arg to non-garbage
  *result = 0; // set out arg to non-garbage
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  _C_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 1,
                 CQL_DATA_TYPE_INT32, output);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  *result = _C_has_row_;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC outint_notnull (OUT output INTEGER NOT NULL, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
*/

#define _PROC_ "outint_notnull"
// export: DECLARE PROC outint_notnull (OUT output INTEGER NOT NULL, OUT result BOOL NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code outint_notnull(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull output, cql_bool *_Nonnull result) {
  cql_contract_argument_notnull((void *)output, 1);
  cql_contract_argument_notnull((void *)result, 2);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_bool _C_has_row_ = 0;

  *output = 0; // set out arg to non-garbage
  *result = 0; // set out arg to non-garbage
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  _C_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, output);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  *result = _C_has_row_;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_
cql_nullable_int32 result;

// The statement ending at line XXXX

/*
DECLARE text_result TEXT;
*/
cql_string_ref text_result = NULL;

// The statement ending at line XXXX

/*
DECLARE obj_var OBJECT;
*/
cql_object_ref obj_var = NULL;

// The statement ending at line XXXX

/*
DECLARE obj_var2 OBJECT NOT NULL;
*/
cql_object_ref obj_var2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC obj_proc (OUT an_object OBJECT)
BEGIN
  SET an_object := NULL;
END;
*/

#define _PROC_ "obj_proc"
// export: DECLARE PROC obj_proc (OUT an_object OBJECT);
void obj_proc(cql_object_ref _Nullable *_Nonnull an_object) {
  cql_contract_argument_notnull((void *)an_object, 1);

  *(void **)an_object = NULL; // set out arg to non-garbage
  cql_set_object_ref(an_object, NULL);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC cursor_with_object (object_ OBJECT)
BEGIN
  DECLARE C CURSOR LIKE cursor_with_object ARGUMENTS;
  FETCH C(object_) FROM VALUES(object_);
  OUT C;
END;
*/

#define _PROC_ "cursor_with_object"

#define cursor_with_object_refs_offset cql_offsetof(cursor_with_object_row, object_) // count = 1
static int32_t cursor_with_object_perf_index;

cql_string_proc_name(cursor_with_object_stored_procedure_name, "cursor_with_object");

cql_object_ref _Nullable cursor_with_object_get_object_(cursor_with_object_result_set_ref _Nonnull result_set) {
  cursor_with_object_row *data = (cursor_with_object_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->object_;
}

uint8_t cursor_with_object_data_types[cursor_with_object_data_types_count] = {
  CQL_DATA_TYPE_OBJECT, // object_
};

static cql_uint16 cursor_with_object_col_offsets[] = { 1,
  cql_offsetof(cursor_with_object_row, object_)
};

cql_int32 cursor_with_object_result_count(cursor_with_object_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void cursor_with_object_fetch_results( cursor_with_object_result_set_ref _Nullable *_Nonnull result_set, cql_object_ref _Nullable object_) {
  cql_profile_start(CRC_cursor_with_object, &cursor_with_object_perf_index);
  *result_set = NULL;
  cursor_with_object_row *row = (cursor_with_object_row *)calloc(1, sizeof(cursor_with_object_row));
  cursor_with_object(object_, row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = cursor_with_object_data_types,
    .col_offsets = cursor_with_object_col_offsets,
    .refs_count = 1,
    .refs_offset = cursor_with_object_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(cursor_with_object_row),
    .crc = CRC_cursor_with_object,
    .perf_index = &cursor_with_object_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC cursor_with_object (object_ OBJECT) OUT (object_ OBJECT);

typedef struct cursor_with_object_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_object_ref _Nullable object_;
} cursor_with_object_C_row;

#define cursor_with_object_C_refs_offset cql_offsetof(cursor_with_object_C_row, object_) // count = 1
void cursor_with_object(cql_object_ref _Nullable object_, cursor_with_object_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  cursor_with_object_C_row C = { ._refs_count_ = 1, ._refs_offset_ = cursor_with_object_C_refs_offset };

  C._has_row_ = 1;
  cql_set_object_ref(&C.object_, object_);
  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = cursor_with_object_refs_offset;
  cql_set_object_ref(&_result_->object_, C.object_);

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL)
BEGIN
  SET o := coalesce(i, -1);
END;
*/

#define _PROC_ "unused_temp"
// export: DECLARE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL);
void unused_temp(cql_nullable_int32 i, cql_int32 *_Nonnull o) {
  cql_contract_argument_notnull((void *)o, 2);

  *o = 0; // set out arg to non-garbage
  do {
    if (!i.is_null) {
      *o = i.value;
      break;
    }
    *o = - 1;
  } while (0);

}
#undef _PROC_

// The statement ending at line XXXX

/*
@ECHO c, "int Garbonzo; // a chick pea\n";
*/
int Garbonzo; // a chick pea

// The statement ending at line XXXX

/*
@ECHO c, "///'\a\b\f\t\v'\r\n";
*/
///'	'

// The statement ending at line XXXX

/*
CREATE PROC echo_test ()
BEGIN
  DECLARE s TEXT;
  SET s := "before echo";
  @ECHO c, "#define ECHO_TEST 1\n";
  SET s := "after echo";
END;
*/

#define _PROC_ "echo_test"
// export: DECLARE PROC echo_test ();
void echo_test(void) {
  cql_string_ref s = NULL;

  cql_set_string_ref(&s, _literal_7_before_echo_echo_test);
  #define ECHO_TEST 1
  cql_set_string_ref(&s, _literal_8_after_echo_echo_test);

  cql_string_release(s);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC insert_values (id_ INTEGER NOT NULL, type_ INTEGER)
BEGIN
  INSERT INTO bar(id, type) VALUES(id_, type_);
END;
*/

#define _PROC_ "insert_values"
// export: DECLARE PROC insert_values (id_ INTEGER NOT NULL, type_ INTEGER) USING TRANSACTION;
CQL_WARN_UNUSED cql_code insert_values(sqlite3 *_Nonnull _db_, cql_int32 id_, cql_nullable_int32 type_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO bar(id, type) VALUES(?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_,
                CQL_DATA_TYPE_INT32, &type_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC alter_table_test ()
BEGIN
  ALTER TABLE bar ADD COLUMN size REAL;
END;
*/

#define _PROC_ "alter_table_test"
// export: DECLARE PROC alter_table_test () USING TRANSACTION;
CQL_WARN_UNUSED cql_code alter_table_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "ALTER TABLE bar ADD COLUMN size REAL");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC drop_table_test ()
BEGIN
  DROP TABLE IF EXISTS bar;
END;
*/

#define _PROC_ "drop_table_test"
// export: DECLARE PROC drop_table_test () USING TRANSACTION;
CQL_WARN_UNUSED cql_code drop_table_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP TABLE IF EXISTS bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;
*/

#define _PROC_ "uses_proc_for_result"
static int32_t uses_proc_for_result_perf_index;

cql_string_proc_name(uses_proc_for_result_stored_procedure_name, "uses_proc_for_result");

typedef struct uses_proc_for_result_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} uses_proc_for_result_row;

cql_int32 uses_proc_for_result_get_id(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable uses_proc_for_result_get_name(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool uses_proc_for_result_get_rate_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 uses_proc_for_result_get_rate_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool uses_proc_for_result_get_type_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 uses_proc_for_result_get_type_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool uses_proc_for_result_get_size_is_null(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double uses_proc_for_result_get_size_value(uses_proc_for_result_result_set_ref _Nonnull result_set, cql_int32 row) {
  uses_proc_for_result_row *data = (uses_proc_for_result_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t uses_proc_for_result_data_types[uses_proc_for_result_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define uses_proc_for_result_refs_offset cql_offsetof(uses_proc_for_result_row, name) // count = 1

static cql_uint16 uses_proc_for_result_col_offsets[] = { 5,
  cql_offsetof(uses_proc_for_result_row, id),
  cql_offsetof(uses_proc_for_result_row, name),
  cql_offsetof(uses_proc_for_result_row, rate),
  cql_offsetof(uses_proc_for_result_row, type),
  cql_offsetof(uses_proc_for_result_row, size)
};

cql_int32 uses_proc_for_result_result_count(uses_proc_for_result_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code uses_proc_for_result_fetch_results(sqlite3 *_Nonnull _db_, uses_proc_for_result_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_uses_proc_for_result, &uses_proc_for_result_perf_index);
  cql_code rc = uses_proc_for_result(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = uses_proc_for_result_data_types,
    .col_offsets = uses_proc_for_result_col_offsets,
    .refs_count = 1,
    .refs_offset = uses_proc_for_result_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(uses_proc_for_result_row),
    .crc = CRC_uses_proc_for_result,
    .perf_index = &uses_proc_for_result_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC uses_proc_for_result () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code uses_proc_for_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_finalize_stmt(_result_stmt);
  _rc_ = with_result_set(_db_, _result_stmt);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_
sqlite3_stmt *expanded_select_stmt = NULL;
cql_bool _expanded_select_has_row_ = 0;
sqlite3_stmt *table_expanded_select_stmt = NULL;
cql_bool _table_expanded_select_has_row_ = 0;

// The statement ending at line XXXX

/*
CREATE PROC index_dropper ()
BEGIN
  DROP INDEX index_1;
END;
*/

#define _PROC_ "index_dropper"
// export: DECLARE PROC index_dropper () USING TRANSACTION;
CQL_WARN_UNUSED cql_code index_dropper(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP INDEX index_1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC misc_dml_proc ()
BEGIN
  INSERT INTO foo(id) VALUES(NULL);
  INSERT INTO foo(id) VALUES(NULL);
  UPDATE bar
  SET name = 'bar'
    WHERE name = 'baz';
  DELETE FROM foo WHERE id = 1;
END;
*/

#define _PROC_ "misc_dml_proc"
// export: DECLARE PROC misc_dml_proc () USING TRANSACTION;
CQL_WARN_UNUSED cql_code misc_dml_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "UPDATE bar "
    "SET name = 'bar' "
      "WHERE name = 'baz'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM foo WHERE id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC dummy_user ()
BEGIN
  INSERT INTO bar(id, name, rate, type, size) VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;
*/

#define _PROC_ "dummy_user"
// export: DECLARE PROC dummy_user () USING TRANSACTION;
CQL_WARN_UNUSED cql_code dummy_user(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_int32 _seed_ = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _seed_ = 123;
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO bar(id, name, rate, type, size) VALUES(?, printf('name_%d', ?), ?, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 5,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _seed_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC proc_with_out_arg (OUT foo TEXT)
BEGIN
  SET foo := 'x';
END;
*/

#define _PROC_ "proc_with_out_arg"
// export: DECLARE PROC proc_with_out_arg (OUT foo TEXT);
void proc_with_out_arg(cql_string_ref _Nullable *_Nonnull foo) {
  cql_contract_argument_notnull((void *)foo, 1);

  *(void **)foo = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*foo, _literal_6_x_);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC calls_out_proc (OUT foo TEXT)
BEGIN
  SET foo := 'x';
  DECLARE bar TEXT;
  CALL proc_with_out_arg(foo);
  CALL proc_with_out_arg(bar);
END;
*/

#define _PROC_ "calls_out_proc"
// export: DECLARE PROC calls_out_proc (OUT foo TEXT);
void calls_out_proc(cql_string_ref _Nullable *_Nonnull foo) {
  cql_contract_argument_notnull((void *)foo, 1);

  cql_string_ref bar = NULL;

  *(void **)foo = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*foo, _literal_6_x_);
  cql_set_string_ref(&*foo, NULL);
  proc_with_out_arg(foo);
  cql_set_string_ref(&bar, NULL);
  proc_with_out_arg(&bar);

  cql_string_release(bar);
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE blob_var BLOB;
*/
cql_blob_ref blob_var = NULL;

// The statement ending at line XXXX

/*
DECLARE blob_var2 BLOB NOT NULL;
*/
cql_blob_ref blob_var2 = NULL;

// The statement ending at line XXXX

/*
CREATE PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;
*/

#define _PROC_ "blob_proc"
// export: DECLARE PROC blob_proc (OUT a_blob BLOB);
void blob_proc(cql_blob_ref _Nullable *_Nonnull a_blob) {
  cql_contract_argument_notnull((void *)a_blob, 1);

  *(void **)a_blob = NULL; // set out arg to non-garbage
  cql_set_blob_ref(&*a_blob, NULL);

}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE blob_var_notnull BLOB NOT NULL;
*/
cql_blob_ref blob_var_notnull = NULL;

// The statement ending at line XXXX

/*
CREATE PROC blob_returner ()
BEGIN
  SELECT *
    FROM blob_table;
END;
*/

#define _PROC_ "blob_returner"
static int32_t blob_returner_perf_index;

cql_string_proc_name(blob_returner_stored_procedure_name, "blob_returner");

typedef struct blob_returner_row {
  cql_int32 blob_id;
  cql_blob_ref _Nonnull b_notnull;
  cql_blob_ref _Nullable b_nullable;
} blob_returner_row;

cql_int32 blob_returner_get_blob_id(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].blob_id;
}

cql_blob_ref _Nonnull blob_returner_get_b_notnull(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b_notnull;
}

cql_blob_ref _Nullable blob_returner_get_b_nullable(blob_returner_result_set_ref _Nonnull result_set, cql_int32 row) {
  blob_returner_row *data = (blob_returner_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b_nullable;
}

uint8_t blob_returner_data_types[blob_returner_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // blob_id
  CQL_DATA_TYPE_BLOB | CQL_DATA_TYPE_NOT_NULL, // b_notnull
  CQL_DATA_TYPE_BLOB, // b_nullable
};

#define blob_returner_refs_offset cql_offsetof(blob_returner_row, b_notnull) // count = 2

static cql_uint16 blob_returner_col_offsets[] = { 3,
  cql_offsetof(blob_returner_row, blob_id),
  cql_offsetof(blob_returner_row, b_notnull),
  cql_offsetof(blob_returner_row, b_nullable)
};

cql_int32 blob_returner_result_count(blob_returner_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code blob_returner_fetch_results(sqlite3 *_Nonnull _db_, blob_returner_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_blob_returner, &blob_returner_perf_index);
  cql_code rc = blob_returner(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = blob_returner_data_types,
    .col_offsets = blob_returner_col_offsets,
    .refs_count = 2,
    .refs_offset = blob_returner_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(blob_returner_row),
    .crc = CRC_blob_returner,
    .perf_index = &blob_returner_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC blob_returner () (blob_id INTEGER NOT NULL, b_notnull BLOB NOT NULL, b_nullable BLOB);
CQL_WARN_UNUSED cql_code blob_returner(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT blob_id, b_notnull, b_nullable "
      "FROM blob_table");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC voidproc ()
BEGIN
  DECLARE unused INTEGER;
END;
*/

#define _PROC_ "voidproc"
// export: DECLARE PROC voidproc ();
void voidproc(void) {
  cql_nullable_int32 unused;
  cql_set_null(unused);


}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT bar.*, 'xyzzy' AS extra1, 'plugh' AS extra2
    FROM bar;
  FETCH C;
  OUT C;
END;
*/

#define _PROC_ "out_cursor_proc"

#define out_cursor_proc_refs_offset cql_offsetof(out_cursor_proc_row, name) // count = 3
static int32_t out_cursor_proc_perf_index;

cql_string_proc_name(out_cursor_proc_stored_procedure_name, "out_cursor_proc");

cql_int32 out_cursor_proc_get_id(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_string_ref _Nullable out_cursor_proc_get_name(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->name;
}

cql_bool out_cursor_proc_get_rate_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.is_null;
}

cql_int64 out_cursor_proc_get_rate_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.value;
}

cql_bool out_cursor_proc_get_type_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.is_null;
}

cql_int32 out_cursor_proc_get_type_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.value;
}

cql_bool out_cursor_proc_get_size_is_null(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.is_null;
}

cql_double out_cursor_proc_get_size_value(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.value;
}

cql_string_ref _Nonnull out_cursor_proc_get_extra1(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->extra1;
}

cql_string_ref _Nonnull out_cursor_proc_get_extra2(out_cursor_proc_result_set_ref _Nonnull result_set) {
  out_cursor_proc_row *data = (out_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->extra2;
}

uint8_t out_cursor_proc_data_types[out_cursor_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // extra1
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // extra2
};

static cql_uint16 out_cursor_proc_col_offsets[] = { 7,
  cql_offsetof(out_cursor_proc_row, id),
  cql_offsetof(out_cursor_proc_row, name),
  cql_offsetof(out_cursor_proc_row, rate),
  cql_offsetof(out_cursor_proc_row, type),
  cql_offsetof(out_cursor_proc_row, size),
  cql_offsetof(out_cursor_proc_row, extra1),
  cql_offsetof(out_cursor_proc_row, extra2)
};

cql_int32 out_cursor_proc_result_count(out_cursor_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code out_cursor_proc_fetch_results(sqlite3 *_Nonnull _db_, out_cursor_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_cursor_proc, &out_cursor_proc_perf_index);
  *result_set = NULL;
  out_cursor_proc_row *row = (out_cursor_proc_row *)calloc(1, sizeof(out_cursor_proc_row));
  cql_code rc = out_cursor_proc(_db_, row);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .data_types = out_cursor_proc_data_types,
    .col_offsets = out_cursor_proc_col_offsets,
    .refs_count = 3,
    .refs_offset = out_cursor_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(out_cursor_proc_row),
    .crc = CRC_out_cursor_proc,
    .perf_index = &out_cursor_proc_perf_index,
  };
  return cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC out_cursor_proc () OUT (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL, extra1 TEXT NOT NULL, extra2 TEXT NOT NULL) USING TRANSACTION;

typedef struct out_cursor_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} out_cursor_proc_C_row;

#define out_cursor_proc_C_refs_offset cql_offsetof(out_cursor_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code out_cursor_proc(sqlite3 *_Nonnull _db_, out_cursor_proc_row *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  memset(_result_, 0, sizeof(*_result_));
  sqlite3_stmt *C_stmt = NULL;
  out_cursor_proc_C_row C = { ._refs_count_ = 3, ._refs_offset_ = out_cursor_proc_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size, 'xyzzy', 'plugh' "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 7,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.id,
                 CQL_DATA_TYPE_STRING, &C.name,
                 CQL_DATA_TYPE_INT64, &C.rate,
                 CQL_DATA_TYPE_INT32, &C.type,
                 CQL_DATA_TYPE_DOUBLE, &C.size,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.extra1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.extra2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 3;
  _result_->_refs_offset_ = out_cursor_proc_refs_offset;
  _result_->id = C.id;
  cql_set_string_ref(&_result_->name, C.name);
  _result_->rate = C.rate;
  _result_->type = C.type;
  _result_->size = C.size;
  cql_set_string_ref(&_result_->extra1, C.extra1);
  cql_set_string_ref(&_result_->extra2, C.extra2);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC read_cursor_proc ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;
*/

#define _PROC_ "read_cursor_proc"
// export: DECLARE PROC read_cursor_proc () USING TRANSACTION;

typedef struct read_cursor_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} read_cursor_proc_C_row;

#define read_cursor_proc_C_refs_offset cql_offsetof(read_cursor_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code read_cursor_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  read_cursor_proc_C_row C = { ._refs_count_ = 3, ._refs_offset_ = read_cursor_proc_C_refs_offset };

  cql_teardown_row(C);
  _rc_ = out_cursor_proc(_db_, (out_cursor_proc_row *)&C); // out_cursor_proc_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_then_fetch_from_proc ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
END;
*/

#define _PROC_ "declare_cursor_then_fetch_from_proc"
// export: DECLARE PROC declare_cursor_then_fetch_from_proc () USING TRANSACTION;

typedef struct declare_cursor_then_fetch_from_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
  cql_string_ref _Nonnull extra1;
  cql_string_ref _Nonnull extra2;
} declare_cursor_then_fetch_from_proc_C_row;

#define declare_cursor_then_fetch_from_proc_C_refs_offset cql_offsetof(declare_cursor_then_fetch_from_proc_C_row, name) // count = 3
CQL_WARN_UNUSED cql_code declare_cursor_then_fetch_from_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  declare_cursor_then_fetch_from_proc_C_row C = { ._refs_count_ = 3, ._refs_offset_ = declare_cursor_then_fetch_from_proc_C_refs_offset };

  cql_teardown_row(C);
  _rc_ = out_cursor_proc(_db_, (out_cursor_proc_row *)&C); // out_cursor_proc_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC fetcher_proc () OUT (a INTEGER, b TEXT);
*/

// The statement ending at line XXXX

/*
DECLARE PROC totally_void_proc ();
*/

// The statement ending at line XXXX

/*
DECLARE PROC compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
DECLARE PROC dml_compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
CREATE PROC dml_user (OUT a_ INTEGER NOT NULL)
BEGIN
  SET a_ := dml_compute(1);
END;
*/

#define _PROC_ "dml_user"
// export: DECLARE PROC dml_user (OUT a_ INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code dml_user(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull a_) {
  cql_contract_argument_notnull((void *)a_, 1);

  cql_code _rc_ = SQLITE_OK;
  *a_ = 0; // set out arg to non-garbage
  _rc_ = dml_compute(_db_, 1, &*a_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC thread_theme_info_list (thread_key_ LONG_INT NOT NULL)
BEGIN
  SELECT *
    FROM (SELECT thread_key
    FROM threads) AS T;
END;
*/

#define _PROC_ "thread_theme_info_list"
static int32_t thread_theme_info_list_perf_index;

cql_string_proc_name(thread_theme_info_list_stored_procedure_name, "thread_theme_info_list");

typedef struct thread_theme_info_list_row {
  cql_int64 thread_key;
} thread_theme_info_list_row;

cql_int64 thread_theme_info_list_get_thread_key(thread_theme_info_list_result_set_ref _Nonnull result_set, cql_int32 row) {
  thread_theme_info_list_row *data = (thread_theme_info_list_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].thread_key;
}

uint8_t thread_theme_info_list_data_types[thread_theme_info_list_data_types_count] = {
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // thread_key
};

static cql_uint16 thread_theme_info_list_col_offsets[] = { 1,
  cql_offsetof(thread_theme_info_list_row, thread_key)
};

cql_int32 thread_theme_info_list_result_count(thread_theme_info_list_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code thread_theme_info_list_fetch_results(sqlite3 *_Nonnull _db_, thread_theme_info_list_result_set_ref _Nullable *_Nonnull result_set, cql_int64 thread_key_) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_thread_theme_info_list, &thread_theme_info_list_perf_index);
  cql_code rc = thread_theme_info_list(_db_, &stmt, thread_key_);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = thread_theme_info_list_data_types,
    .col_offsets = thread_theme_info_list_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(thread_theme_info_list_row),
    .crc = CRC_thread_theme_info_list,
    .perf_index = &thread_theme_info_list_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC thread_theme_info_list (thread_key_ LONG_INT NOT NULL) (thread_key LONG_INT NOT NULL);
CQL_WARN_UNUSED cql_code thread_theme_info_list(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int64 thread_key_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT thread_key "
      "FROM (SELECT thread_key "
      "FROM threads) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC fetch_values_dummy ()
BEGIN
  DECLARE C CURSOR LIKE SELECT *
    FROM bar;
  FETCH C(id, name, rate, type, size) FROM VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
*/

#define _PROC_ "fetch_values_dummy"
// export: DECLARE PROC fetch_values_dummy ();

typedef struct fetch_values_dummy_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} fetch_values_dummy_C_row;

#define fetch_values_dummy_C_refs_offset cql_offsetof(fetch_values_dummy_C_row, name) // count = 1
void fetch_values_dummy(void) {
  fetch_values_dummy_C_row C = { ._refs_count_ = 1, ._refs_offset_ = fetch_values_dummy_C_refs_offset };
  cql_string_ref _tmp_text_0 = NULL;
  cql_int32 _seed_ = 0;

  _seed_ = 123;
  C._has_row_ = 1;
  C.id = _seed_;
  {
    char *_printf_result = sqlite3_mprintf("name_%d", _seed_);
    cql_string_release(_tmp_text_0);
    _tmp_text_0 = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }
  cql_set_string_ref(&C.name, _tmp_text_0);
  cql_set_notnull(C.rate, _seed_);
  cql_set_notnull(C.type, _seed_);
  cql_set_notnull(C.size, _seed_);

  cql_teardown_row(C);
  cql_string_release(_tmp_text_0);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC c_literal (OUT x TEXT)
BEGIN
  SET x := "\"Testing\" \\''";
END;
*/

#define _PROC_ "c_literal"
// export: DECLARE PROC c_literal (OUT x TEXT);
void c_literal(cql_string_ref _Nullable *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  *(void **)x = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*x, _literal_9_Testing_c_literal);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC no_cleanup_label_needed_proc ()
BEGIN
  BEGIN TRY
    DECLARE C CURSOR FOR SELECT 1 AS N;
    FETCH C;
  END TRY;
  BEGIN CATCH
    DECLARE x INTEGER;
  END CATCH;
END;
*/

#define _PROC_ "no_cleanup_label_needed_proc"
// export: DECLARE PROC no_cleanup_label_needed_proc () USING TRANSACTION;

typedef struct no_cleanup_label_needed_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 N;
} no_cleanup_label_needed_proc_C_row;
CQL_WARN_UNUSED cql_code no_cleanup_label_needed_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  no_cleanup_label_needed_proc_C_row C = { 0 };
  cql_nullable_int32 x;
  cql_set_null(x);

  // try
  {
    _rc_ = cql_prepare(_db_, &C_stmt,
      "SELECT 1");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_2; }
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.N);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto catch_start_2; }
    goto catch_end_2;
  }
  catch_start_2: {
  }
  catch_end_2:;
  _rc_ = SQLITE_OK;

  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC no_code_after_catch ()
BEGIN
  BEGIN TRY
    @ATTRIBUTE(foo)
    DECLARE x INTEGER;
  END TRY;
  BEGIN CATCH
    @ATTRIBUTE(bar)
    DECLARE y INTEGER;
  END CATCH;
END;
*/

#define _PROC_ "no_code_after_catch"
// export: DECLARE PROC no_code_after_catch () USING TRANSACTION;
CQL_WARN_UNUSED cql_code no_code_after_catch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_nullable_int32 y;
  cql_set_null(y);

  // try
  {
    goto catch_end_3;
  }
  {
  }
  catch_end_3:;
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_no_db ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  FETCH C(A, B) FROM VALUES(3, 12);
  OUT C;
END;
*/

#define _PROC_ "out_no_db"
static int32_t out_no_db_perf_index;

cql_string_proc_name(out_no_db_stored_procedure_name, "out_no_db");

cql_int32 out_no_db_get_A(out_no_db_result_set_ref _Nonnull result_set) {
  out_no_db_row *data = (out_no_db_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_double out_no_db_get_B(out_no_db_result_set_ref _Nonnull result_set) {
  out_no_db_row *data = (out_no_db_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t out_no_db_data_types[out_no_db_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 out_no_db_col_offsets[] = { 2,
  cql_offsetof(out_no_db_row, A),
  cql_offsetof(out_no_db_row, B)
};

cql_int32 out_no_db_result_count(out_no_db_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void out_no_db_fetch_results( out_no_db_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_no_db, &out_no_db_perf_index);
  *result_set = NULL;
  out_no_db_row *row = (out_no_db_row *)calloc(1, sizeof(out_no_db_row));
  out_no_db(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = out_no_db_data_types,
    .col_offsets = out_no_db_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(out_no_db_row),
    .crc = CRC_out_no_db,
    .perf_index = &out_no_db_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC out_no_db () OUT (A INTEGER NOT NULL, B REAL NOT NULL);

typedef struct out_no_db_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} out_no_db_C_row;
void out_no_db(out_no_db_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  out_no_db_C_row C = { 0 };

  C._has_row_ = 1;
  C.A = 3;
  C.B = 12;
  _result_->_has_row_ = C._has_row_;
  _result_->A = C.A;
  _result_->B = C.B;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C1(A, B) FROM VALUES(3, 12);
  OUT C1;
END;
*/

#define _PROC_ "declare_cursor_like_cursor"
static int32_t declare_cursor_like_cursor_perf_index;

cql_string_proc_name(declare_cursor_like_cursor_stored_procedure_name, "declare_cursor_like_cursor");

cql_int32 declare_cursor_like_cursor_get_A(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  declare_cursor_like_cursor_row *data = (declare_cursor_like_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_double declare_cursor_like_cursor_get_B(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  declare_cursor_like_cursor_row *data = (declare_cursor_like_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t declare_cursor_like_cursor_data_types[declare_cursor_like_cursor_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 declare_cursor_like_cursor_col_offsets[] = { 2,
  cql_offsetof(declare_cursor_like_cursor_row, A),
  cql_offsetof(declare_cursor_like_cursor_row, B)
};

cql_int32 declare_cursor_like_cursor_result_count(declare_cursor_like_cursor_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_cursor_fetch_results( declare_cursor_like_cursor_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_cursor, &declare_cursor_like_cursor_perf_index);
  *result_set = NULL;
  declare_cursor_like_cursor_row *row = (declare_cursor_like_cursor_row *)calloc(1, sizeof(declare_cursor_like_cursor_row));
  declare_cursor_like_cursor(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_cursor_data_types,
    .col_offsets = declare_cursor_like_cursor_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(declare_cursor_like_cursor_row),
    .crc = CRC_declare_cursor_like_cursor,
    .perf_index = &declare_cursor_like_cursor_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC declare_cursor_like_cursor () OUT (A INTEGER NOT NULL, B REAL NOT NULL);

typedef struct declare_cursor_like_cursor_C0_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_C0_row;

typedef struct declare_cursor_like_cursor_C1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_double B;
} declare_cursor_like_cursor_C1_row;
void declare_cursor_like_cursor(declare_cursor_like_cursor_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_cursor_C0_row C0 = { 0 };
  declare_cursor_like_cursor_C1_row C1 = { 0 };

  C1._has_row_ = 1;
  C1.A = 3;
  C1.B = 12;
  _result_->_has_row_ = C1._has_row_;
  _result_->A = C1.A;
  _result_->B = C1.B;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_proc ()
BEGIN
  DECLARE C CURSOR LIKE fetcher_proc;
  OUT C;
END;
*/

#define _PROC_ "declare_cursor_like_proc"

#define declare_cursor_like_proc_refs_offset cql_offsetof(declare_cursor_like_proc_row, b) // count = 1
static int32_t declare_cursor_like_proc_perf_index;

cql_string_proc_name(declare_cursor_like_proc_stored_procedure_name, "declare_cursor_like_proc");

cql_bool declare_cursor_like_proc_get_a_is_null(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->a.is_null;
}

cql_int32 declare_cursor_like_proc_get_a_value(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->a.value;
}

cql_string_ref _Nullable declare_cursor_like_proc_get_b(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  declare_cursor_like_proc_row *data = (declare_cursor_like_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->b;
}

uint8_t declare_cursor_like_proc_data_types[declare_cursor_like_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32, // a
  CQL_DATA_TYPE_STRING, // b
};

static cql_uint16 declare_cursor_like_proc_col_offsets[] = { 2,
  cql_offsetof(declare_cursor_like_proc_row, a),
  cql_offsetof(declare_cursor_like_proc_row, b)
};

cql_int32 declare_cursor_like_proc_result_count(declare_cursor_like_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_proc_fetch_results( declare_cursor_like_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_proc, &declare_cursor_like_proc_perf_index);
  *result_set = NULL;
  declare_cursor_like_proc_row *row = (declare_cursor_like_proc_row *)calloc(1, sizeof(declare_cursor_like_proc_row));
  declare_cursor_like_proc(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_proc_data_types,
    .col_offsets = declare_cursor_like_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = declare_cursor_like_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(declare_cursor_like_proc_row),
    .crc = CRC_declare_cursor_like_proc,
    .perf_index = &declare_cursor_like_proc_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC declare_cursor_like_proc () OUT (a INTEGER, b TEXT);

typedef struct declare_cursor_like_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 a;
  cql_string_ref _Nullable b;
} declare_cursor_like_proc_C_row;

#define declare_cursor_like_proc_C_refs_offset cql_offsetof(declare_cursor_like_proc_C_row, b) // count = 1
void declare_cursor_like_proc(declare_cursor_like_proc_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_proc_C_row C = { ._refs_count_ = 1, ._refs_offset_ = declare_cursor_like_proc_C_refs_offset };

  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = declare_cursor_like_proc_refs_offset;
  _result_->a = C.a;
  cql_set_string_ref(&_result_->b, C.b);

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_table ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  OUT C;
END;
*/

#define _PROC_ "declare_cursor_like_table"

#define declare_cursor_like_table_refs_offset cql_offsetof(declare_cursor_like_table_row, name) // count = 1
static int32_t declare_cursor_like_table_perf_index;

cql_string_proc_name(declare_cursor_like_table_stored_procedure_name, "declare_cursor_like_table");

cql_int32 declare_cursor_like_table_get_id(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_string_ref _Nullable declare_cursor_like_table_get_name(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->name;
}

cql_bool declare_cursor_like_table_get_rate_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.is_null;
}

cql_int64 declare_cursor_like_table_get_rate_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.value;
}

cql_bool declare_cursor_like_table_get_type_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.is_null;
}

cql_int32 declare_cursor_like_table_get_type_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.value;
}

cql_bool declare_cursor_like_table_get_size_is_null(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.is_null;
}

cql_double declare_cursor_like_table_get_size_value(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  declare_cursor_like_table_row *data = (declare_cursor_like_table_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.value;
}

uint8_t declare_cursor_like_table_data_types[declare_cursor_like_table_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

static cql_uint16 declare_cursor_like_table_col_offsets[] = { 5,
  cql_offsetof(declare_cursor_like_table_row, id),
  cql_offsetof(declare_cursor_like_table_row, name),
  cql_offsetof(declare_cursor_like_table_row, rate),
  cql_offsetof(declare_cursor_like_table_row, type),
  cql_offsetof(declare_cursor_like_table_row, size)
};

cql_int32 declare_cursor_like_table_result_count(declare_cursor_like_table_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_table_fetch_results( declare_cursor_like_table_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_table, &declare_cursor_like_table_perf_index);
  *result_set = NULL;
  declare_cursor_like_table_row *row = (declare_cursor_like_table_row *)calloc(1, sizeof(declare_cursor_like_table_row));
  declare_cursor_like_table(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_table_data_types,
    .col_offsets = declare_cursor_like_table_col_offsets,
    .refs_count = 1,
    .refs_offset = declare_cursor_like_table_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(declare_cursor_like_table_row),
    .crc = CRC_declare_cursor_like_table,
    .perf_index = &declare_cursor_like_table_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC declare_cursor_like_table () OUT (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);

typedef struct declare_cursor_like_table_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} declare_cursor_like_table_C_row;

#define declare_cursor_like_table_C_refs_offset cql_offsetof(declare_cursor_like_table_C_row, name) // count = 1
void declare_cursor_like_table(declare_cursor_like_table_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_table_C_row C = { ._refs_count_ = 1, ._refs_offset_ = declare_cursor_like_table_C_refs_offset };

  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = declare_cursor_like_table_refs_offset;
  _result_->id = C.id;
  cql_set_string_ref(&_result_->name, C.name);
  _result_->rate = C.rate;
  _result_->type = C.type;
  _result_->size = C.size;

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC declare_cursor_like_view ()
BEGIN
  DECLARE C CURSOR LIKE MyView;
  OUT C;
END;
*/

#define _PROC_ "declare_cursor_like_view"
static int32_t declare_cursor_like_view_perf_index;

cql_string_proc_name(declare_cursor_like_view_stored_procedure_name, "declare_cursor_like_view");

cql_int32 declare_cursor_like_view_get_f1(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f1;
}

cql_int32 declare_cursor_like_view_get_f2(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f2;
}

cql_int32 declare_cursor_like_view_get_f3(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  declare_cursor_like_view_row *data = (declare_cursor_like_view_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->f3;
}

uint8_t declare_cursor_like_view_data_types[declare_cursor_like_view_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f1
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f2
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // f3
};

static cql_uint16 declare_cursor_like_view_col_offsets[] = { 3,
  cql_offsetof(declare_cursor_like_view_row, f1),
  cql_offsetof(declare_cursor_like_view_row, f2),
  cql_offsetof(declare_cursor_like_view_row, f3)
};

cql_int32 declare_cursor_like_view_result_count(declare_cursor_like_view_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void declare_cursor_like_view_fetch_results( declare_cursor_like_view_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_declare_cursor_like_view, &declare_cursor_like_view_perf_index);
  *result_set = NULL;
  declare_cursor_like_view_row *row = (declare_cursor_like_view_row *)calloc(1, sizeof(declare_cursor_like_view_row));
  declare_cursor_like_view(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = declare_cursor_like_view_data_types,
    .col_offsets = declare_cursor_like_view_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(declare_cursor_like_view_row),
    .crc = CRC_declare_cursor_like_view,
    .perf_index = &declare_cursor_like_view_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC declare_cursor_like_view () OUT (f1 INTEGER NOT NULL, f2 INTEGER NOT NULL, f3 INTEGER NOT NULL);

typedef struct declare_cursor_like_view_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 f1;
  cql_int32 f2;
  cql_int32 f3;
} declare_cursor_like_view_C_row;
void declare_cursor_like_view(declare_cursor_like_view_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  declare_cursor_like_view_C_row C = { 0 };

  _result_->_has_row_ = C._has_row_;
  _result_->f1 = C.f1;
  _result_->f2 = C.f2;
  _result_->f3 = C.f3;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC weird_quoting ()
BEGIN
  DELETE FROM bar WHERE name LIKE "\n\n";
  DELETE FROM bar WHERE name = ' '' \n '' \';
  DELETE FROM bar WHERE name <> "'";
  DELETE FROM bar WHERE name >= '\';
END;
*/

#define _PROC_ "weird_quoting"
// export: DECLARE PROC weird_quoting () USING TRANSACTION;
CQL_WARN_UNUSED cql_code weird_quoting(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\n\n'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name = ' '' \\n '' \\'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name <> ''''");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name >= '\\'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC long_auto_table_maker ()
BEGIN
  CREATE TABLE long_int_autoinc(
    id LONG_INT PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );
END;
*/

#define _PROC_ "long_auto_table_maker"
// export: DECLARE PROC long_auto_table_maker () USING TRANSACTION;
CQL_WARN_UNUSED cql_code long_auto_table_maker(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE TABLE long_int_autoinc( "
      "id INTEGER PRIMARY KEY AUTOINCREMENT, "
      "name TEXT "
    ")");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC blob_out (OUT x BLOB);
*/

// The statement ending at line XXXX

/*
CREATE PROC blob_call1 ()
BEGIN
  DECLARE b BLOB;
  CALL blob_out(b);
END;
*/

#define _PROC_ "blob_call1"
// export: DECLARE PROC blob_call1 ();
void blob_call1(void) {
  cql_blob_ref b = NULL;

  cql_set_blob_ref(&b, NULL);
  blob_out(&b);

  cql_blob_release(b);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC blob_call2 ()
BEGIN
  DECLARE b BLOB;
  SET b := blob_out();
END;
*/

#define _PROC_ "blob_call2"
// export: DECLARE PROC blob_call2 ();
void blob_call2(void) {
  cql_blob_ref b = NULL;

  cql_set_blob_ref(&b, NULL);
  blob_out(&b);

  cql_blob_release(b);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC blob_no_else ()
BEGIN
  DECLARE b BLOB;
  DECLARE b1 BLOB;
  SET b := CASE b WHEN b THEN b1
  END;
END;
*/

#define _PROC_ "blob_no_else"
// export: DECLARE PROC blob_no_else ();
void blob_no_else(void) {
  cql_blob_ref b = NULL;
  cql_blob_ref b1 = NULL;
  cql_blob_ref _tmp_n_blob_1 = NULL;

  do {
      cql_set_blob_ref(&_tmp_n_blob_1, b);
      if (!_tmp_n_blob_1) goto case_else_3;
    if (cql_is_nullable_true(!b, _tmp_n_blob_1 == b)) {
      cql_set_blob_ref(&b, b1);
      break;
    }
    case_else_3:
    cql_set_blob_ref(&b, NULL);
  } while (0);

  cql_blob_release(b);
  cql_blob_release(b1);
  cql_blob_release(_tmp_n_blob_1);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_inserter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) SELECT *
    FROM x;
END;
*/

#define _PROC_ "with_inserter"
// export: DECLARE PROC with_inserter () USING TRANSACTION;
CQL_WARN_UNUSED cql_code with_inserter(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "INSERT INTO foo(id) SELECT a "
      "FROM x");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC multi_rewrite (blob_id_ INTEGER NOT NULL, b_notnull_ BLOB NOT NULL, b_nullable_ BLOB, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT, type_ INTEGER, size_ REAL, OUT out_arg INTEGER NOT NULL)
BEGIN
  INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(blob_id_, b_notnull_, b_nullable_);
  SET out_arg := 1;
END;
*/

#define _PROC_ "multi_rewrite"
// export: DECLARE PROC multi_rewrite (blob_id_ INTEGER NOT NULL, b_notnull_ BLOB NOT NULL, b_nullable_ BLOB, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT, type_ INTEGER, size_ REAL, OUT out_arg INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code multi_rewrite(sqlite3 *_Nonnull _db_, cql_int32 blob_id_, cql_blob_ref _Nonnull b_notnull_, cql_blob_ref _Nullable b_nullable_, cql_int32 id_, cql_string_ref _Nullable name_, cql_nullable_int64 rate_, cql_nullable_int32 type_, cql_nullable_double size_, cql_int32 *_Nonnull out_arg) {
  cql_contract_argument_notnull((void *)b_notnull_, 2);
  cql_contract_argument_notnull((void *)out_arg, 9);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  *out_arg = 0; // set out arg to non-garbage
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(?, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 3,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, blob_id_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BLOB, b_notnull_,
                CQL_DATA_TYPE_BLOB, b_nullable_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  *out_arg = 1;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC fetch_to_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, "foo" AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0(A, B) FROM VALUES(2, "bar");
  FETCH C1(A, B) FROM VALUES(C0.A, C0.B);
  OUT C1;
END;
*/

#define _PROC_ "fetch_to_cursor_from_cursor"

#define fetch_to_cursor_from_cursor_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_row, B) // count = 1
static int32_t fetch_to_cursor_from_cursor_perf_index;

cql_string_proc_name(fetch_to_cursor_from_cursor_stored_procedure_name, "fetch_to_cursor_from_cursor");

cql_int32 fetch_to_cursor_from_cursor_get_A(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  fetch_to_cursor_from_cursor_row *data = (fetch_to_cursor_from_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->A;
}

cql_string_ref _Nonnull fetch_to_cursor_from_cursor_get_B(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  fetch_to_cursor_from_cursor_row *data = (fetch_to_cursor_from_cursor_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->B;
}

uint8_t fetch_to_cursor_from_cursor_data_types[fetch_to_cursor_from_cursor_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // A
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // B
};

static cql_uint16 fetch_to_cursor_from_cursor_col_offsets[] = { 2,
  cql_offsetof(fetch_to_cursor_from_cursor_row, A),
  cql_offsetof(fetch_to_cursor_from_cursor_row, B)
};

cql_int32 fetch_to_cursor_from_cursor_result_count(fetch_to_cursor_from_cursor_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void fetch_to_cursor_from_cursor_fetch_results( fetch_to_cursor_from_cursor_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_fetch_to_cursor_from_cursor, &fetch_to_cursor_from_cursor_perf_index);
  *result_set = NULL;
  fetch_to_cursor_from_cursor_row *row = (fetch_to_cursor_from_cursor_row *)calloc(1, sizeof(fetch_to_cursor_from_cursor_row));
  fetch_to_cursor_from_cursor(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = fetch_to_cursor_from_cursor_data_types,
    .col_offsets = fetch_to_cursor_from_cursor_col_offsets,
    .refs_count = 1,
    .refs_offset = fetch_to_cursor_from_cursor_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(fetch_to_cursor_from_cursor_row),
    .crc = CRC_fetch_to_cursor_from_cursor,
    .perf_index = &fetch_to_cursor_from_cursor_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC fetch_to_cursor_from_cursor () OUT (A INTEGER NOT NULL, B TEXT NOT NULL);

typedef struct fetch_to_cursor_from_cursor_C0_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_C0_row;

#define fetch_to_cursor_from_cursor_C0_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_C0_row, B) // count = 1

typedef struct fetch_to_cursor_from_cursor_C1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
  cql_string_ref _Nonnull B;
} fetch_to_cursor_from_cursor_C1_row;

#define fetch_to_cursor_from_cursor_C1_refs_offset cql_offsetof(fetch_to_cursor_from_cursor_C1_row, B) // count = 1
void fetch_to_cursor_from_cursor(fetch_to_cursor_from_cursor_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  fetch_to_cursor_from_cursor_C0_row C0 = { ._refs_count_ = 1, ._refs_offset_ = fetch_to_cursor_from_cursor_C0_refs_offset };
  fetch_to_cursor_from_cursor_C1_row C1 = { ._refs_count_ = 1, ._refs_offset_ = fetch_to_cursor_from_cursor_C1_refs_offset };

  C0._has_row_ = 1;
  C0.A = 2;
  cql_set_string_ref(&C0.B, _literal_10_bar_fetch_to_cursor_from_cursor);
  C1._has_row_ = 1;
  C1.A = C0.A;
  cql_set_string_ref(&C1.B, C0.B);
  _result_->_has_row_ = C1._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = fetch_to_cursor_from_cursor_refs_offset;
  _result_->A = C1.A;
  cql_set_string_ref(&_result_->B, C1.B);

  cql_teardown_row(C0);
  cql_teardown_row(C1);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC loop_statement_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.A);
  END;
END;
*/

#define _PROC_ "loop_statement_cursor"
// export: DECLARE PROC loop_statement_cursor () USING TRANSACTION;

typedef struct loop_statement_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 A;
} loop_statement_cursor_C_row;
CQL_WARN_UNUSED cql_code loop_statement_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  loop_statement_cursor_C_row C = { 0 };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.A);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C._has_row_) break;
    printf("%d\n", C.A);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC loop_statement_not_auto_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  DECLARE A_ INTEGER NOT NULL;
  LOOP FETCH C INTO A_
  BEGIN
    CALL printf("%d\n", A_);
  END;
END;
*/

#define _PROC_ "loop_statement_not_auto_cursor"
// export: DECLARE PROC loop_statement_not_auto_cursor () USING TRANSACTION;
CQL_WARN_UNUSED cql_code loop_statement_not_auto_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_bool _C_has_row_ = 0;
  cql_int32 A_ = 0;

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    _C_has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &A_);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!_C_has_row_) break;
    printf("%d\n", A_);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC simple_select ()
BEGIN
  SELECT 1 AS x;
END;
*/

#define _PROC_ "simple_select"
// export: DECLARE PROC simple_select () (x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code simple_select(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC call_in_loop ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    FETCH C;
  END;
END;
*/

#define _PROC_ "call_in_loop"
// export: DECLARE PROC call_in_loop () USING TRANSACTION;

typedef struct call_in_loop_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} call_in_loop_C_row;
CQL_WARN_UNUSED cql_code call_in_loop(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 i;
  cql_set_null(i);
  sqlite3_stmt *C_stmt = NULL;
  call_in_loop_C_row C = { 0 };

  cql_set_notnull(i, 0);
  for (;;) {
  if (!(i.value < 5)) break;
    cql_set_notnull(i, i.value + 1);
    cql_finalize_stmt(&C_stmt);
    _rc_ = simple_select(_db_, &C_stmt);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC call_in_loop_with_nullable_condition ()
BEGIN
  DECLARE i INTEGER;
  SET i := nullable(0);
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    FETCH C;
  END;
END;
*/

#define _PROC_ "call_in_loop_with_nullable_condition"
// export: DECLARE PROC call_in_loop_with_nullable_condition () USING TRANSACTION;

typedef struct call_in_loop_with_nullable_condition_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} call_in_loop_with_nullable_condition_C_row;
CQL_WARN_UNUSED cql_code call_in_loop_with_nullable_condition(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 i;
  cql_set_null(i);
  cql_nullable_bool _tmp_n_bool_0;
  cql_set_null(_tmp_n_bool_0);
  sqlite3_stmt *C_stmt = NULL;
  call_in_loop_with_nullable_condition_C_row C = { 0 };

  cql_set_notnull(i, 0);
  for (;;) {
  cql_set_nullable(_tmp_n_bool_0, i.is_null, i.value < 5);
  if (!cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) break;
    cql_set_nullable(i, i.is_null, i.value + 1);
    cql_finalize_stmt(&C_stmt);
    _rc_ = simple_select(_db_, &C_stmt);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC call_in_loop_boxed ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    DECLARE box OBJECT<C CURSOR>;
    SET box FROM CURSOR C;
    DECLARE D CURSOR FOR box;
    FETCH D;
  END;
END;
*/

#define _PROC_ "call_in_loop_boxed"
// export: DECLARE PROC call_in_loop_boxed () USING TRANSACTION;

typedef struct call_in_loop_boxed_D_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} call_in_loop_boxed_D_row;
CQL_WARN_UNUSED cql_code call_in_loop_boxed(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 i;
  cql_set_null(i);
  sqlite3_stmt *C_stmt = NULL;
  cql_object_ref C_object_ = NULL;
  cql_bool _C_has_row_ = 0;
  cql_object_ref box = NULL;
  sqlite3_stmt *D_stmt = NULL;
  cql_object_ref D_object_ = NULL;
  call_in_loop_boxed_D_row D = { 0 };

  cql_set_notnull(i, 0);
  for (;;) {
  if (!(i.value < 5)) break;
    cql_set_notnull(i, i.value + 1);
    C_stmt = NULL;
    _rc_ = simple_select(_db_, &C_stmt);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    cql_object_release(C_object_);
    C_object_ = cql_box_stmt(C_stmt);
    cql_set_object_ref(&box, C_object_);
    D_stmt = cql_unbox_stmt(box);
    cql_set_object_ref(&D_object_, box);
    _rc_ = sqlite3_step(D_stmt);
    D._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, D_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &D.x);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_object_);
  cql_object_release(box);
  cql_object_release(D_object_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_helper ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x;
  FETCH C(x) FROM VALUES(1);
  OUT UNION C;
END;
*/

#define _PROC_ "out_union_helper_fetch_results"
static int32_t out_union_helper_perf_index;

cql_string_proc_name(out_union_helper_stored_procedure_name, "out_union_helper");

cql_int32 out_union_helper_get_x(out_union_helper_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_helper_row *data = (out_union_helper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t out_union_helper_data_types[out_union_helper_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 out_union_helper_col_offsets[] = { 1,
  cql_offsetof(out_union_helper_row, x)
};

cql_int32 out_union_helper_result_count(out_union_helper_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_helper_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_helper_data_types,
  .col_offsets = out_union_helper_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_helper_row),
  .crc = CRC_out_union_helper,
  .perf_index = &out_union_helper_perf_index,
};
// export: DECLARE PROC out_union_helper () OUT UNION (x INTEGER NOT NULL);

typedef struct out_union_helper_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} out_union_helper_C_row;
void out_union_helper_fetch_results(out_union_helper_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  out_union_helper_C_row C = { 0 };

  cql_profile_start(CRC_out_union_helper, &out_union_helper_perf_index);
  C._has_row_ = 1;
  C.x = 1;
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));

  cql_results_from_data(SQLITE_OK, &_rows_, &out_union_helper_info, (cql_result_set_ref *)_result_set_);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_dml_helper ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  FETCH C;
  OUT UNION C;
END;
*/

#define _PROC_ "out_union_dml_helper_fetch_results"
static int32_t out_union_dml_helper_perf_index;

cql_string_proc_name(out_union_dml_helper_stored_procedure_name, "out_union_dml_helper");

cql_int32 out_union_dml_helper_get_x(out_union_dml_helper_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_dml_helper_row *data = (out_union_dml_helper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t out_union_dml_helper_data_types[out_union_dml_helper_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 out_union_dml_helper_col_offsets[] = { 1,
  cql_offsetof(out_union_dml_helper_row, x)
};

cql_int32 out_union_dml_helper_result_count(out_union_dml_helper_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_dml_helper_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_dml_helper_data_types,
  .col_offsets = out_union_dml_helper_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_dml_helper_row),
  .crc = CRC_out_union_dml_helper,
  .perf_index = &out_union_dml_helper_perf_index,
};
// export: DECLARE PROC out_union_dml_helper () OUT UNION (x INTEGER NOT NULL) USING TRANSACTION;

typedef struct out_union_dml_helper_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} out_union_dml_helper_C_row;
CQL_WARN_UNUSED cql_code out_union_dml_helper_fetch_results(sqlite3 *_Nonnull _db_, out_union_dml_helper_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_code _rc_ = SQLITE_OK;
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  sqlite3_stmt *C_stmt = NULL;
  out_union_dml_helper_C_row C = { 0 };

  cql_profile_start(CRC_out_union_dml_helper, &out_union_dml_helper_perf_index);
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));
  _rc_ = SQLITE_OK;

cql_cleanup:
  out_union_dml_helper_info.db = _db_;
  cql_results_from_data(_rc_, &_rows_, &out_union_dml_helper_info, (cql_result_set_ref *)_result_set_);
  out_union_dml_helper_info.db = NULL;
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC call_out_union_in_loop ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL out_union_helper();
    FETCH C;
  END;
END;
*/

#define _PROC_ "call_out_union_in_loop"
// export: DECLARE PROC call_out_union_in_loop () USING TRANSACTION;

typedef struct call_out_union_in_loop_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} call_out_union_in_loop_C_row;
CQL_WARN_UNUSED cql_code call_out_union_in_loop(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 i;
  cql_set_null(i);
  out_union_helper_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  call_out_union_in_loop_C_row C = { 0 };

  cql_set_notnull(i, 0);
  for (;;) {
  if (!(i.value < 5)) break;
    cql_set_notnull(i, i.value + 1);
    cql_object_release(C_result_set_);
    out_union_helper_fetch_results(&C_result_set_);
    C_row_num_ = C_row_count_ = -1;
    C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
    C_row_num_++;
    C._has_row_ = C_row_num_ < C_row_count_;
    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC forward_out_union ()
BEGIN
  CALL out_union_helper();
END;
*/

#define _PROC_ "forward_out_union_fetch_results"
static int32_t forward_out_union_perf_index;

cql_string_proc_name(forward_out_union_stored_procedure_name, "forward_out_union");

cql_int32 forward_out_union_get_x(forward_out_union_result_set_ref _Nonnull result_set, cql_int32 row) {
  forward_out_union_row *data = (forward_out_union_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t forward_out_union_data_types[forward_out_union_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 forward_out_union_col_offsets[] = { 1,
  cql_offsetof(forward_out_union_row, x)
};

cql_int32 forward_out_union_result_count(forward_out_union_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info forward_out_union_info = {
  .rc = SQLITE_OK,
  .data_types = forward_out_union_data_types,
  .col_offsets = forward_out_union_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(forward_out_union_row),
  .crc = CRC_forward_out_union,
  .perf_index = &forward_out_union_perf_index,
};
// export: DECLARE PROC forward_out_union () OUT UNION (x INTEGER NOT NULL);
void forward_out_union_fetch_results(forward_out_union_result_set_ref _Nullable *_Nonnull _result_set_) {
  *_result_set_ = NULL;

  cql_object_release(*_result_set_);
  out_union_helper_fetch_results((out_union_helper_result_set_ref *)_result_set_);

  if (!*_result_set_) *_result_set_ = (forward_out_union_result_set_ref)cql_no_rows_result_set();
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC extern_out_union_helper () OUT UNION (x INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC forward_out_union_extern ()
BEGIN
  CALL extern_out_union_helper();
END;
*/

#define _PROC_ "forward_out_union_extern_fetch_results"
static int32_t forward_out_union_extern_perf_index;

cql_string_proc_name(forward_out_union_extern_stored_procedure_name, "forward_out_union_extern");

cql_int32 forward_out_union_extern_get_x(forward_out_union_extern_result_set_ref _Nonnull result_set, cql_int32 row) {
  forward_out_union_extern_row *data = (forward_out_union_extern_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t forward_out_union_extern_data_types[forward_out_union_extern_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 forward_out_union_extern_col_offsets[] = { 1,
  cql_offsetof(forward_out_union_extern_row, x)
};

cql_int32 forward_out_union_extern_result_count(forward_out_union_extern_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info forward_out_union_extern_info = {
  .rc = SQLITE_OK,
  .data_types = forward_out_union_extern_data_types,
  .col_offsets = forward_out_union_extern_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(forward_out_union_extern_row),
  .crc = CRC_forward_out_union_extern,
  .perf_index = &forward_out_union_extern_perf_index,
};
// export: DECLARE PROC forward_out_union_extern () OUT UNION (x INTEGER NOT NULL);
void forward_out_union_extern_fetch_results(forward_out_union_extern_result_set_ref _Nullable *_Nonnull _result_set_) {
  *_result_set_ = NULL;

  cql_object_release(*_result_set_);
  extern_out_union_helper_fetch_results((extern_out_union_helper_result_set_ref *)_result_set_);

  if (!*_result_set_) *_result_set_ = (forward_out_union_extern_result_set_ref)cql_no_rows_result_set();
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC forward_out_union_dml ()
BEGIN
  CALL out_union_dml_helper();
END;
*/

#define _PROC_ "forward_out_union_dml_fetch_results"
static int32_t forward_out_union_dml_perf_index;

cql_string_proc_name(forward_out_union_dml_stored_procedure_name, "forward_out_union_dml");

cql_int32 forward_out_union_dml_get_x(forward_out_union_dml_result_set_ref _Nonnull result_set, cql_int32 row) {
  forward_out_union_dml_row *data = (forward_out_union_dml_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t forward_out_union_dml_data_types[forward_out_union_dml_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 forward_out_union_dml_col_offsets[] = { 1,
  cql_offsetof(forward_out_union_dml_row, x)
};

cql_int32 forward_out_union_dml_result_count(forward_out_union_dml_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info forward_out_union_dml_info = {
  .rc = SQLITE_OK,
  .data_types = forward_out_union_dml_data_types,
  .col_offsets = forward_out_union_dml_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(forward_out_union_dml_row),
  .crc = CRC_forward_out_union_dml,
  .perf_index = &forward_out_union_dml_perf_index,
};
// export: DECLARE PROC forward_out_union_dml () OUT UNION (x INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code forward_out_union_dml_fetch_results(sqlite3 *_Nonnull _db_, forward_out_union_dml_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_code _rc_ = SQLITE_OK;
  *_result_set_ = NULL;

  cql_object_release(*_result_set_);
  _rc_ = out_union_dml_helper_fetch_results(_db_, (out_union_dml_helper_result_set_ref *)_result_set_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_set_) *_result_set_ = (forward_out_union_dml_result_set_ref)cql_no_rows_result_set();
  return _rc_;
}
#undef _PROC_
sqlite3_stmt *global_cursor_stmt = NULL;
global_cursor_row global_cursor = { 0 };

// The statement ending at line XXXX

/*
CREATE PROC make_trigger ()
BEGIN
  CREATE TEMP TRIGGER IF NOT EXISTS trigger1
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;
*/

#define _PROC_ "make_trigger"
// export: DECLARE PROC make_trigger () USING TRANSACTION;
CQL_WARN_UNUSED cql_code make_trigger(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE TEMP TRIGGER IF NOT EXISTS trigger1 "
      "BEFORE DELETE ON bar "
      "FOR EACH ROW "
      "WHEN old.id > 7 "
    "BEGIN "
    "SELECT old.id; "
    "END");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC is_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS 1;
  SET b := 'x' IS 'x';
  SET b := 'x' IS 'y';
  SET b := 1 + (3 IS 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS j;
END;
*/

#define _PROC_ "is_test"
// export: DECLARE PROC is_test ();
void is_test(void) {
  cql_bool b = 0;
  cql_nullable_int32 i;
  cql_set_null(i);
  cql_nullable_int32 j;
  cql_set_null(j);

  b = 1 == 1;
  b = cql_string_equal(_literal_6_x_, _literal_6_x_);
  b = cql_string_equal(_literal_6_x_, _literal_11_y_);
  b = !!(1 + (3 == 4));
  cql_set_notnull(i, 1);
  cql_set_notnull(j, 2);
  b = ((i.is_null == j.is_null) && (j.is_null || i.value == j.value));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC is_blob ()
BEGIN
  DECLARE bl1 BLOB;
  DECLARE bl2 BLOB;
  DECLARE b BOOL NOT NULL;
  SET b := bl1 IS bl2;
  SET b := bl1 IS NOT bl2;
END;
*/

#define _PROC_ "is_blob"
// export: DECLARE PROC is_blob ();
void is_blob(void) {
  cql_blob_ref bl1 = NULL;
  cql_blob_ref bl2 = NULL;
  cql_bool b = 0;

  b = cql_blob_equal(bl1, bl2);
  b = !cql_blob_equal(bl1, bl2);

  cql_blob_release(bl1);
  cql_blob_release(bl2);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC is_not_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS NOT 1;
  SET b := 'x' IS NOT 'x';
  SET b := 'x' IS NOT 'y';
  SET b := 1 + (3 IS NOT 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS NOT j;
END;
*/

#define _PROC_ "is_not_test"
// export: DECLARE PROC is_not_test ();
void is_not_test(void) {
  cql_bool b = 0;
  cql_nullable_int32 i;
  cql_set_null(i);
  cql_nullable_int32 j;
  cql_set_null(j);

  b = 1 != 1;
  b = !cql_string_equal(_literal_6_x_, _literal_6_x_);
  b = !cql_string_equal(_literal_6_x_, _literal_11_y_);
  b = !!(1 + (3 != 4));
  cql_set_notnull(i, 1);
  cql_set_notnull(j, 2);
  b = !((i.is_null == j.is_null) && (j.is_null || i.value == j.value));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL IN (1);
END;
*/

#define _PROC_ "in_test"
// export: DECLARE PROC in_test (x INTEGER, OUT b BOOL);
void in_test(cql_nullable_int32 x, cql_nullable_bool *_Nonnull b) {
  cql_contract_argument_notnull((void *)b, 2);

  cql_set_null(*b); // set out arg to non-garbage
  cql_set_null(*b);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC not_in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL NOT IN (1);
END;
*/

#define _PROC_ "not_in_test"
// export: DECLARE PROC not_in_test (x INTEGER, OUT b BOOL);
void not_in_test(cql_nullable_int32 x, cql_nullable_bool *_Nonnull b) {
  cql_contract_argument_notnull((void *)b, 2);

  cql_set_null(*b); // set out arg to non-garbage
  cql_set_null(*b);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC drop_trigger_test ()
BEGIN
  DROP TRIGGER IF EXISTS trigger1;
  DROP TRIGGER trigger1;
END;
*/

#define _PROC_ "drop_trigger_test"
// export: DECLARE PROC drop_trigger_test () USING TRANSACTION;
CQL_WARN_UNUSED cql_code drop_trigger_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER IF EXISTS trigger1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER trigger1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:identity=(id))
CREATE PROC simple_identity ()
BEGIN
  SELECT 1 AS id, 2 AS data;
END;
*/

#define _PROC_ "simple_identity"
static int32_t simple_identity_perf_index;

cql_string_proc_name(simple_identity_stored_procedure_name, "simple_identity");

typedef struct simple_identity_row {
  cql_int32 id;
  cql_int32 data;
} simple_identity_row;

cql_int32 simple_identity_get_id(simple_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  simple_identity_row *data = (simple_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 simple_identity_get_data(simple_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  simple_identity_row *data = (simple_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t simple_identity_data_types[simple_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 simple_identity_col_offsets[] = { 2,
  cql_offsetof(simple_identity_row, id),
  cql_offsetof(simple_identity_row, data)
};

cql_uint16 simple_identity_identity_columns[] = { 1,
  0, // id
};

cql_int32 simple_identity_result_count(simple_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code simple_identity_fetch_results(sqlite3 *_Nonnull _db_, simple_identity_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_simple_identity, &simple_identity_perf_index);
  cql_code rc = simple_identity(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = simple_identity_data_types,
    .col_offsets = simple_identity_col_offsets,
    .identity_columns = simple_identity_identity_columns,
    .encode_context_index = -1,
    .rowsize = sizeof(simple_identity_row),
    .crc = CRC_simple_identity,
    .perf_index = &simple_identity_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC simple_identity () (id INTEGER NOT NULL, data INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code simple_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:identity=(col1, col2))
CREATE PROC complex_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;
*/

#define _PROC_ "complex_identity"
static int32_t complex_identity_perf_index;

cql_string_proc_name(complex_identity_stored_procedure_name, "complex_identity");

typedef struct complex_identity_row {
  cql_int32 col1;
  cql_int32 col2;
  cql_int32 data;
} complex_identity_row;

cql_int32 complex_identity_get_col1(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].col1;
}

cql_int32 complex_identity_get_col2(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].col2;
}

cql_int32 complex_identity_get_data(complex_identity_result_set_ref _Nonnull result_set, cql_int32 row) {
  complex_identity_row *data = (complex_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t complex_identity_data_types[complex_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // col1
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // col2
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 complex_identity_col_offsets[] = { 3,
  cql_offsetof(complex_identity_row, col1),
  cql_offsetof(complex_identity_row, col2),
  cql_offsetof(complex_identity_row, data)
};

cql_uint16 complex_identity_identity_columns[] = { 2,
  0, // col1
  1, // col2
};

cql_int32 complex_identity_result_count(complex_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code complex_identity_fetch_results(sqlite3 *_Nonnull _db_, complex_identity_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_complex_identity, &complex_identity_perf_index);
  cql_code rc = complex_identity(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = complex_identity_data_types,
    .col_offsets = complex_identity_col_offsets,
    .identity_columns = complex_identity_identity_columns,
    .encode_context_index = -1,
    .rowsize = sizeof(complex_identity_row),
    .crc = CRC_complex_identity,
    .perf_index = &complex_identity_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC complex_identity () (col1 INTEGER NOT NULL, col2 INTEGER NOT NULL, data INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code complex_identity(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2, 3");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:identity=(id))
CREATE PROC out_cursor_identity ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 2 AS data;
  FETCH C;
  OUT C;
END;
*/

#define _PROC_ "out_cursor_identity"
static int32_t out_cursor_identity_perf_index;

cql_string_proc_name(out_cursor_identity_stored_procedure_name, "out_cursor_identity");

cql_int32 out_cursor_identity_get_id(out_cursor_identity_result_set_ref _Nonnull result_set) {
  out_cursor_identity_row *data = (out_cursor_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_int32 out_cursor_identity_get_data(out_cursor_identity_result_set_ref _Nonnull result_set) {
  out_cursor_identity_row *data = (out_cursor_identity_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->data;
}

uint8_t out_cursor_identity_data_types[out_cursor_identity_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // data
};

static cql_uint16 out_cursor_identity_col_offsets[] = { 2,
  cql_offsetof(out_cursor_identity_row, id),
  cql_offsetof(out_cursor_identity_row, data)
};

cql_uint16 out_cursor_identity_identity_columns[] = { 1,
  0, // id
};

cql_int32 out_cursor_identity_result_count(out_cursor_identity_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code out_cursor_identity_fetch_results(sqlite3 *_Nonnull _db_, out_cursor_identity_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_out_cursor_identity, &out_cursor_identity_perf_index);
  *result_set = NULL;
  out_cursor_identity_row *row = (out_cursor_identity_row *)calloc(1, sizeof(out_cursor_identity_row));
  cql_code rc = out_cursor_identity(_db_, row);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .data_types = out_cursor_identity_data_types,
    .col_offsets = out_cursor_identity_col_offsets,
    .identity_columns = out_cursor_identity_identity_columns,
    .encode_context_index = -1,
    .rowsize = sizeof(out_cursor_identity_row),
    .crc = CRC_out_cursor_identity,
    .perf_index = &out_cursor_identity_perf_index,
  };
  return cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC out_cursor_identity () OUT (id INTEGER NOT NULL, data INTEGER NOT NULL) USING TRANSACTION;

typedef struct out_cursor_identity_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_int32 data;
} out_cursor_identity_C_row;
CQL_WARN_UNUSED cql_code out_cursor_identity(sqlite3 *_Nonnull _db_, out_cursor_identity_row *_Nonnull _result_) {
  cql_code _rc_ = SQLITE_OK;
  memset(_result_, 0, sizeof(*_result_));
  sqlite3_stmt *C_stmt = NULL;
  out_cursor_identity_C_row C = { 0 };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.id,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.data);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _result_->_has_row_ = C._has_row_;
  _result_->id = C.id;
  _result_->data = C.data;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC radioactive_proc ()
BEGIN
  SELECT *
    FROM radioactive;
END;
*/

#define _PROC_ "radioactive_proc"
static int32_t radioactive_proc_perf_index;

cql_string_proc_name(radioactive_proc_stored_procedure_name, "radioactive_proc");

typedef struct radioactive_proc_row {
  cql_int32 id;
  cql_string_ref _Nullable data;
} radioactive_proc_row;

cql_int32 radioactive_proc_get_id(radioactive_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  radioactive_proc_row *data = (radioactive_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable radioactive_proc_get_data(radioactive_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  radioactive_proc_row *data = (radioactive_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t radioactive_proc_data_types[radioactive_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // data
};

#define radioactive_proc_refs_offset cql_offsetof(radioactive_proc_row, data) // count = 1

static cql_uint16 radioactive_proc_col_offsets[] = { 2,
  cql_offsetof(radioactive_proc_row, id),
  cql_offsetof(radioactive_proc_row, data)
};

cql_int32 radioactive_proc_result_count(radioactive_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code radioactive_proc_fetch_results(sqlite3 *_Nonnull _db_, radioactive_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_radioactive_proc, &radioactive_proc_perf_index);
  cql_code rc = radioactive_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = radioactive_proc_data_types,
    .col_offsets = radioactive_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = radioactive_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(radioactive_proc_row),
    .crc = CRC_radioactive_proc,
    .perf_index = &radioactive_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void radioactive_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(radioactive_proc_data_types, radioactive_proc_data_types_count, col, encode);
}

// export: DECLARE PROC radioactive_proc () (id INTEGER NOT NULL, data TEXT @SENSITIVE);
CQL_WARN_UNUSED cql_code radioactive_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, data "
      "FROM radioactive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_deleter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  DELETE FROM foo WHERE id IN (SELECT *
    FROM x);
END;
*/

#define _PROC_ "with_deleter"
// export: DECLARE PROC with_deleter () USING TRANSACTION;
CQL_WARN_UNUSED cql_code with_deleter(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "DELETE FROM foo WHERE id IN (SELECT a "
      "FROM x)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_updater ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;
*/

#define _PROC_ "with_updater"
// export: DECLARE PROC with_updater () USING TRANSACTION;
CQL_WARN_UNUSED cql_code with_updater(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "UPDATE bar "
    "SET name = 'xyzzy' "
      "WHERE id IN (SELECT a "
      "FROM x)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodropper ()
BEGIN
  SELECT 1 AS a, 2 AS b;
END;
*/

#define _PROC_ "autodropper"
static int32_t autodropper_perf_index;

cql_string_proc_name(autodropper_stored_procedure_name, "autodropper");

typedef struct autodropper_row {
  cql_int32 a;
  cql_int32 b;
} autodropper_row;

cql_int32 autodropper_get_a(autodropper_result_set_ref _Nonnull result_set, cql_int32 row) {
  autodropper_row *data = (autodropper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].a;
}

cql_int32 autodropper_get_b(autodropper_result_set_ref _Nonnull result_set, cql_int32 row) {
  autodropper_row *data = (autodropper_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

uint8_t autodropper_data_types[autodropper_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
};

static cql_uint16 autodropper_col_offsets[] = { 2,
  cql_offsetof(autodropper_row, a),
  cql_offsetof(autodropper_row, b)
};

cql_int32 autodropper_result_count(autodropper_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code autodropper_fetch_results(sqlite3 *_Nonnull _db_, autodropper_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_autodropper, &autodropper_perf_index);
  cql_code rc = autodropper(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = autodropper_data_types,
    .col_offsets = autodropper_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(autodropper_row),
    .crc = CRC_autodropper,
    .perf_index = &autodropper_perf_index,
      .autodrop_tables = "table1\0table2\0",
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC autodropper () (a INTEGER NOT NULL, b INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code autodropper(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;
*/

// The statement ending at line XXXX

/*
CREATE PROC simple_cursor_proc ()
BEGIN
  DECLARE A_CURSOR CURSOR LIKE SELECT 1 AS id;
  FETCH a_cursor(id) FROM VALUES(1);
  OUT a_cursor;
END;
*/

#define _PROC_ "simple_cursor_proc"
static int32_t simple_cursor_proc_perf_index;

cql_string_proc_name(simple_cursor_proc_stored_procedure_name, "simple_cursor_proc");

cql_int32 simple_cursor_proc_get_id(simple_cursor_proc_result_set_ref _Nonnull result_set) {
  simple_cursor_proc_row *data = (simple_cursor_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

uint8_t simple_cursor_proc_data_types[simple_cursor_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
};

static cql_uint16 simple_cursor_proc_col_offsets[] = { 1,
  cql_offsetof(simple_cursor_proc_row, id)
};

cql_int32 simple_cursor_proc_result_count(simple_cursor_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void simple_cursor_proc_fetch_results( simple_cursor_proc_result_set_ref _Nullable *_Nonnull result_set) {
  cql_profile_start(CRC_simple_cursor_proc, &simple_cursor_proc_perf_index);
  *result_set = NULL;
  simple_cursor_proc_row *row = (simple_cursor_proc_row *)calloc(1, sizeof(simple_cursor_proc_row));
  simple_cursor_proc(row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = simple_cursor_proc_data_types,
    .col_offsets = simple_cursor_proc_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(simple_cursor_proc_row),
    .crc = CRC_simple_cursor_proc,
    .perf_index = &simple_cursor_proc_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC simple_cursor_proc () OUT (id INTEGER NOT NULL);

typedef struct simple_cursor_proc_A_CURSOR_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
} simple_cursor_proc_A_CURSOR_row;
void simple_cursor_proc(simple_cursor_proc_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  simple_cursor_proc_A_CURSOR_row A_CURSOR = { 0 };

  A_CURSOR._has_row_ = 1;
  A_CURSOR.id = 1;
  _result_->_has_row_ = A_CURSOR._has_row_;
  _result_->id = A_CURSOR.id;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC redundant_cast ()
BEGIN
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
*/

#define _PROC_ "redundant_cast"
static int32_t redundant_cast_perf_index;

cql_string_proc_name(redundant_cast_stored_procedure_name, "redundant_cast");

typedef struct redundant_cast_row {
  cql_int32 plugh;
  cql_int32 five;
} redundant_cast_row;

cql_int32 redundant_cast_get_plugh(redundant_cast_result_set_ref _Nonnull result_set, cql_int32 row) {
  redundant_cast_row *data = (redundant_cast_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].plugh;
}

cql_int32 redundant_cast_get_five(redundant_cast_result_set_ref _Nonnull result_set, cql_int32 row) {
  redundant_cast_row *data = (redundant_cast_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].five;
}

uint8_t redundant_cast_data_types[redundant_cast_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // plugh
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // five
};

static cql_uint16 redundant_cast_col_offsets[] = { 2,
  cql_offsetof(redundant_cast_row, plugh),
  cql_offsetof(redundant_cast_row, five)
};

cql_int32 redundant_cast_result_count(redundant_cast_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code redundant_cast_fetch_results(sqlite3 *_Nonnull _db_, redundant_cast_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_redundant_cast, &redundant_cast_perf_index);
  cql_code rc = redundant_cast(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = redundant_cast_data_types,
    .col_offsets = redundant_cast_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(redundant_cast_row),
    .crc = CRC_redundant_cast,
    .perf_index = &redundant_cast_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC redundant_cast () (plugh INTEGER NOT NULL, five INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code redundant_cast(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT (5), T.xyzzy "
      "FROM (SELECT 1 AS xyzzy) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC view_creator ()
BEGIN
  CREATE VIEW alias_preserved AS
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
*/

#define _PROC_ "view_creator"
// export: DECLARE PROC view_creator () USING TRANSACTION;
CQL_WARN_UNUSED cql_code view_creator(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIEW alias_preserved AS "
    "SELECT (5) AS plugh, T.xyzzy AS five "
      "FROM (SELECT 1 AS xyzzy) AS T");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC settings_info ()
BEGIN
  DECLARE C CURSOR FOR SELECT SUM(A.unread_pending_thread_count) AS unread_pending_thread_count, SUM(A.switch_account_badge_count) AS switch_account_badge_count
    FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count
    FROM unread_pending_threads AS P
  UNION ALL
  SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count
    FROM switch_account_badges AS S) AS A;
END;
*/

#define _PROC_ "settings_info"
// export: DECLARE PROC settings_info () USING TRANSACTION;
CQL_WARN_UNUSED cql_code settings_info(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT SUM(A.unread_pending_thread_count), SUM(A.switch_account_badge_count) "
      "FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count "
      "FROM unread_pending_threads AS P "
    "UNION ALL "
    "SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count "
      "FROM switch_account_badges AS S) AS A");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC top_level_select_alias_unused ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo;
END;
*/

#define _PROC_ "top_level_select_alias_unused"
static int32_t top_level_select_alias_unused_perf_index;

cql_string_proc_name(top_level_select_alias_unused_stored_procedure_name, "top_level_select_alias_unused");

typedef struct top_level_select_alias_unused_row {
  cql_int32 id;
  cql_int32 x;
} top_level_select_alias_unused_row;

cql_int32 top_level_select_alias_unused_get_id(top_level_select_alias_unused_result_set_ref _Nonnull result_set, cql_int32 row) {
  top_level_select_alias_unused_row *data = (top_level_select_alias_unused_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 top_level_select_alias_unused_get_x(top_level_select_alias_unused_result_set_ref _Nonnull result_set, cql_int32 row) {
  top_level_select_alias_unused_row *data = (top_level_select_alias_unused_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t top_level_select_alias_unused_data_types[top_level_select_alias_unused_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 top_level_select_alias_unused_col_offsets[] = { 2,
  cql_offsetof(top_level_select_alias_unused_row, id),
  cql_offsetof(top_level_select_alias_unused_row, x)
};

cql_int32 top_level_select_alias_unused_result_count(top_level_select_alias_unused_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code top_level_select_alias_unused_fetch_results(sqlite3 *_Nonnull _db_, top_level_select_alias_unused_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_top_level_select_alias_unused, &top_level_select_alias_unused_perf_index);
  cql_code rc = top_level_select_alias_unused(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = top_level_select_alias_unused_data_types,
    .col_offsets = top_level_select_alias_unused_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(top_level_select_alias_unused_row),
    .crc = CRC_top_level_select_alias_unused,
    .perf_index = &top_level_select_alias_unused_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC top_level_select_alias_unused () (id INTEGER NOT NULL, x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code top_level_select_alias_unused(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1, 2 "
    "UNION ALL "
    "SELECT foo.id, 2 "
      "FROM foo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC top_level_select_alias_used_in_orderby ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo
  ORDER BY id;
END;
*/

#define _PROC_ "top_level_select_alias_used_in_orderby"
static int32_t top_level_select_alias_used_in_orderby_perf_index;

cql_string_proc_name(top_level_select_alias_used_in_orderby_stored_procedure_name, "top_level_select_alias_used_in_orderby");

typedef struct top_level_select_alias_used_in_orderby_row {
  cql_int32 id;
  cql_int32 x;
} top_level_select_alias_used_in_orderby_row;

cql_int32 top_level_select_alias_used_in_orderby_get_id(top_level_select_alias_used_in_orderby_result_set_ref _Nonnull result_set, cql_int32 row) {
  top_level_select_alias_used_in_orderby_row *data = (top_level_select_alias_used_in_orderby_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 top_level_select_alias_used_in_orderby_get_x(top_level_select_alias_used_in_orderby_result_set_ref _Nonnull result_set, cql_int32 row) {
  top_level_select_alias_used_in_orderby_row *data = (top_level_select_alias_used_in_orderby_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t top_level_select_alias_used_in_orderby_data_types[top_level_select_alias_used_in_orderby_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 top_level_select_alias_used_in_orderby_col_offsets[] = { 2,
  cql_offsetof(top_level_select_alias_used_in_orderby_row, id),
  cql_offsetof(top_level_select_alias_used_in_orderby_row, x)
};

cql_int32 top_level_select_alias_used_in_orderby_result_count(top_level_select_alias_used_in_orderby_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code top_level_select_alias_used_in_orderby_fetch_results(sqlite3 *_Nonnull _db_, top_level_select_alias_used_in_orderby_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_top_level_select_alias_used_in_orderby, &top_level_select_alias_used_in_orderby_perf_index);
  cql_code rc = top_level_select_alias_used_in_orderby(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = top_level_select_alias_used_in_orderby_data_types,
    .col_offsets = top_level_select_alias_used_in_orderby_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(top_level_select_alias_used_in_orderby_row),
    .crc = CRC_top_level_select_alias_used_in_orderby,
    .perf_index = &top_level_select_alias_used_in_orderby_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC top_level_select_alias_used_in_orderby () (id INTEGER NOT NULL, x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code top_level_select_alias_used_in_orderby(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1 AS id, 2 "
    "UNION ALL "
    "SELECT foo.id, 2 "
      "FROM foo "
    "ORDER BY id");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_with_select ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( WITH
  threads2 (count) AS (SELECT 1 AS foo)
  SELECT COUNT(*)
    FROM threads2 );
END;
*/

#define _PROC_ "use_with_select"
// export: DECLARE PROC use_with_select () USING TRANSACTION;
CQL_WARN_UNUSED cql_code use_with_select(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_int32 _tmp_int_0 = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "WITH "
    "threads2 (count) AS (SELECT 1) "
    "SELECT COUNT(*) "
      "FROM threads2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_int_0 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_notnull(x, _tmp_int_0);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM ReadFromRowset(rowset);
END;
*/

#define _PROC_ "rowset_object_reader"
// export: DECLARE PROC rowset_object_reader (rowset OBJECT<rowset>) USING TRANSACTION;
CQL_WARN_UNUSED cql_code rowset_object_reader(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable rowset) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_bool _C_has_row_ = 0;

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT id "
      "FROM ReadFromRowset(?)");
  cql_multibind(&_rc_, _db_, &C_stmt, 1,
                CQL_DATA_TYPE_OBJECT, rowset);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC upsert_do_something ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
*/

#define _PROC_ "upsert_do_something"
// export: DECLARE PROC upsert_do_something () USING TRANSACTION;
CQL_WARN_UNUSED cql_code upsert_do_something(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) SELECT id "
      "FROM bar "
      "WHERE 1 "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10 "
      "WHERE id <> 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC with_upsert_form ()
BEGIN
  WITH
  names (id) AS (VALUES(1), (5), (3), (12))
  INSERT INTO foo(id) SELECT id
    FROM names
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
*/

#define _PROC_ "with_upsert_form"
// export: DECLARE PROC with_upsert_form () USING TRANSACTION;
CQL_WARN_UNUSED cql_code with_upsert_form(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "WITH "
    "names (id) AS (VALUES(1), (5), (3), (12)) "
    "INSERT INTO foo(id) SELECT id "
      "FROM names "
      "WHERE 1 "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10 "
      "WHERE id <> 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC upsert_do_nothing (id_ INTEGER NOT NULL)
BEGIN
  INSERT INTO foo(id) VALUES(id_)
  ON CONFLICT DO NOTHING;
END;
*/

#define _PROC_ "upsert_do_nothing"
// export: DECLARE PROC upsert_do_nothing (id_ INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code upsert_do_nothing(sqlite3 *_Nonnull _db_, cql_int32 id_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO foo(id) VALUES(?) "
    "ON CONFLICT DO NOTHING");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, id_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_
cql_int32 _seed_ = 0;

// The statement ending at line XXXX

/*
DECLARE PROC p1 () OUT (id INTEGER NOT NULL, t TEXT);
*/

// The statement ending at line XXXX

/*
DECLARE PROC p2 () OUT (id INTEGER NOT NULL, t TEXT) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
CREATE PROC use_many_out_cursors ()
BEGIN
  DECLARE c1 CURSOR FETCH FROM CALL p1();
  DECLARE c2 CURSOR FETCH FROM CALL p2();
END;
*/

#define _PROC_ "use_many_out_cursors"
// export: DECLARE PROC use_many_out_cursors () USING TRANSACTION;

typedef struct use_many_out_cursors_c1_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} use_many_out_cursors_c1_row;

#define use_many_out_cursors_c1_refs_offset cql_offsetof(use_many_out_cursors_c1_row, t) // count = 1

typedef struct use_many_out_cursors_c2_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} use_many_out_cursors_c2_row;

#define use_many_out_cursors_c2_refs_offset cql_offsetof(use_many_out_cursors_c2_row, t) // count = 1
CQL_WARN_UNUSED cql_code use_many_out_cursors(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  use_many_out_cursors_c1_row c1 = { ._refs_count_ = 1, ._refs_offset_ = use_many_out_cursors_c1_refs_offset };
  use_many_out_cursors_c2_row c2 = { ._refs_count_ = 1, ._refs_offset_ = use_many_out_cursors_c2_refs_offset };

  cql_teardown_row(c1);
  p1((p1_row *)&c1); // p1_row identical to cursor type
  cql_teardown_row(c2);
  _rc_ = p2(_db_, (p2_row *)&c2); // p2_row identical to cursor type
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(c1);
  cql_teardown_row(c2);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC fetch_many_times (arg BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE p1;
  IF arg = 1 THEN
    FETCH C FROM CALL p1();
  ELSE IF arg = 2 THEN
    FETCH C FROM CALL p2();
  ELSE
    FETCH C FROM CALL p1();
    FETCH C FROM CALL p2();
  END IF;
END;
*/

#define _PROC_ "fetch_many_times"
// export: DECLARE PROC fetch_many_times (arg BOOL NOT NULL) USING TRANSACTION;

typedef struct fetch_many_times_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable t;
} fetch_many_times_C_row;

#define fetch_many_times_C_refs_offset cql_offsetof(fetch_many_times_C_row, t) // count = 1
CQL_WARN_UNUSED cql_code fetch_many_times(sqlite3 *_Nonnull _db_, cql_bool arg) {
  cql_code _rc_ = SQLITE_OK;
  fetch_many_times_C_row C = { ._refs_count_ = 1, ._refs_offset_ = fetch_many_times_C_refs_offset };

  if (arg == 1) {
    cql_teardown_row(C);
    p1((p1_row *)&C); // p1_row identical to cursor type
  }
  else {
    if (arg == 2) {
      cql_teardown_row(C);
      _rc_ = p2(_db_, (p2_row *)&C); // p2_row identical to cursor type
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    }
    else {
      cql_teardown_row(C);
      p1((p1_row *)&C); // p1_row identical to cursor type
      cql_teardown_row(C);
      _rc_ = p2(_db_, (p2_row *)&C); // p2_row identical to cursor type
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_two ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, '2' AS y;
  FETCH C(x, y) FROM VALUES(1, "y");
  OUT UNION C;
  OUT UNION C;
END;
*/

#define _PROC_ "out_union_two_fetch_results"

#define out_union_two_refs_offset cql_offsetof(out_union_two_row, y) // count = 1
static int32_t out_union_two_perf_index;

cql_string_proc_name(out_union_two_stored_procedure_name, "out_union_two");

cql_int32 out_union_two_get_x(out_union_two_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_two_row *data = (out_union_two_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_string_ref _Nonnull out_union_two_get_y(out_union_two_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_two_row *data = (out_union_two_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_two_data_types[out_union_two_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // y
};

#define out_union_two_refs_offset cql_offsetof(out_union_two_row, y) // count = 1

static cql_uint16 out_union_two_col_offsets[] = { 2,
  cql_offsetof(out_union_two_row, x),
  cql_offsetof(out_union_two_row, y)
};

cql_int32 out_union_two_result_count(out_union_two_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_two_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_two_data_types,
  .col_offsets = out_union_two_col_offsets,
  .refs_count = 1,
  .refs_offset = out_union_two_refs_offset,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_two_row),
  .crc = CRC_out_union_two,
  .perf_index = &out_union_two_perf_index,
};
// export: DECLARE PROC out_union_two () OUT UNION (x INTEGER NOT NULL, y TEXT NOT NULL);

typedef struct out_union_two_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_two_C_row;

#define out_union_two_C_refs_offset cql_offsetof(out_union_two_C_row, y) // count = 1
void out_union_two_fetch_results(out_union_two_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  out_union_two_C_row C = { ._refs_count_ = 1, ._refs_offset_ = out_union_two_C_refs_offset };

  cql_profile_start(CRC_out_union_two, &out_union_two_perf_index);
  C._has_row_ = 1;
  C.x = 1;
  cql_set_string_ref(&C.y, _literal_11_y_);
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));

  cql_results_from_data(SQLITE_OK, &_rows_, &out_union_two_info, (cql_result_set_ref *)_result_set_);
  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_two();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
*/

#define _PROC_ "out_union_reader"
// export: DECLARE PROC out_union_reader () USING TRANSACTION;

typedef struct out_union_reader_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_reader_c_row;

#define out_union_reader_c_refs_offset cql_offsetof(out_union_reader_c_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  out_union_two_result_set_ref c_result_set_ = NULL;
  cql_int32 c_row_num_ = 0;
  cql_int32 c_row_count_ = 0;
  out_union_reader_c_row c = { ._refs_count_ = 1, ._refs_offset_ = out_union_reader_c_refs_offset };

  out_union_two_fetch_results(&c_result_set_);
  c_row_num_ = c_row_count_ = -1;
  c_row_count_ = cql_result_set_get_count((cql_result_set_ref)c_result_set_);
  for (;;) {
    c_row_num_++;
    c._has_row_ = c_row_num_ < c_row_count_;
    cql_copyoutrow(NULL, (cql_result_set_ref)c_result_set_, c_row_num_, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c.x,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &c.y);
    if (!c._has_row_) break;
    cql_alloc_cstr(_cstr_2, c.y);
    printf("%d %s\n", c.x, _cstr_2);
    cql_free_cstr(_cstr_2, c.y);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(c_result_set_);
  cql_teardown_row(c);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_from_select ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x, '2' AS y;
  FETCH C;
  OUT UNION C;
  OUT UNION C;
END;
*/

#define _PROC_ "out_union_from_select_fetch_results"

#define out_union_from_select_refs_offset cql_offsetof(out_union_from_select_row, y) // count = 1
static int32_t out_union_from_select_perf_index;

cql_string_proc_name(out_union_from_select_stored_procedure_name, "out_union_from_select");

cql_int32 out_union_from_select_get_x(out_union_from_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_from_select_row *data = (out_union_from_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_string_ref _Nonnull out_union_from_select_get_y(out_union_from_select_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_from_select_row *data = (out_union_from_select_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_from_select_data_types[out_union_from_select_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // y
};

#define out_union_from_select_refs_offset cql_offsetof(out_union_from_select_row, y) // count = 1

static cql_uint16 out_union_from_select_col_offsets[] = { 2,
  cql_offsetof(out_union_from_select_row, x),
  cql_offsetof(out_union_from_select_row, y)
};

cql_int32 out_union_from_select_result_count(out_union_from_select_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_from_select_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_from_select_data_types,
  .col_offsets = out_union_from_select_col_offsets,
  .refs_count = 1,
  .refs_offset = out_union_from_select_refs_offset,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_from_select_row),
  .crc = CRC_out_union_from_select,
  .perf_index = &out_union_from_select_perf_index,
};
// export: DECLARE PROC out_union_from_select () OUT UNION (x INTEGER NOT NULL, y TEXT NOT NULL) USING TRANSACTION;

typedef struct out_union_from_select_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_from_select_C_row;

#define out_union_from_select_C_refs_offset cql_offsetof(out_union_from_select_C_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_from_select_fetch_results(sqlite3 *_Nonnull _db_, out_union_from_select_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_code _rc_ = SQLITE_OK;
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  sqlite3_stmt *C_stmt = NULL;
  out_union_from_select_C_row C = { ._refs_count_ = 1, ._refs_offset_ = out_union_from_select_C_refs_offset };

  cql_profile_start(CRC_out_union_from_select, &out_union_from_select_perf_index);
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1, '2'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.y);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));
  _rc_ = SQLITE_OK;

cql_cleanup:
  out_union_from_select_info.db = _db_;
  cql_results_from_data(_rc_, &_rows_, &out_union_from_select_info, (cql_result_set_ref *)_result_set_);
  out_union_from_select_info.db = NULL;
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_dml_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_from_select();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
*/

#define _PROC_ "out_union_dml_reader"
// export: DECLARE PROC out_union_dml_reader () USING TRANSACTION;

typedef struct out_union_dml_reader_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_string_ref _Nonnull y;
} out_union_dml_reader_c_row;

#define out_union_dml_reader_c_refs_offset cql_offsetof(out_union_dml_reader_c_row, y) // count = 1
CQL_WARN_UNUSED cql_code out_union_dml_reader(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  out_union_from_select_result_set_ref c_result_set_ = NULL;
  cql_int32 c_row_num_ = 0;
  cql_int32 c_row_count_ = 0;
  out_union_dml_reader_c_row c = { ._refs_count_ = 1, ._refs_offset_ = out_union_dml_reader_c_refs_offset };

  _rc_ = out_union_from_select_fetch_results(_db_, &c_result_set_);
  c_row_num_ = c_row_count_ = -1;
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  c_row_count_ = cql_result_set_get_count((cql_result_set_ref)c_result_set_);
  for (;;) {
    c_row_num_++;
    c._has_row_ = c_row_num_ < c_row_count_;
    cql_copyoutrow(_db_, (cql_result_set_ref)c_result_set_, c_row_num_, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c.x,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &c.y);
    if (!c._has_row_) break;
    cql_alloc_cstr(_cstr_3, c.y);
    printf("%d %s\n", c.x, _cstr_3);
    cql_free_cstr(_cstr_3, c.y);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(c_result_set_);
  cql_teardown_row(c);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE x CURSOR LIKE SELECT 1 AS x, 2 AS y;
  FETCH x(x, y) FROM VALUES(a, b);
  OUT UNION x;
END;
*/

#define _PROC_ "out_union_values_fetch_results"
static int32_t out_union_values_perf_index;

cql_string_proc_name(out_union_values_stored_procedure_name, "out_union_values");

cql_int32 out_union_values_get_x(out_union_values_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_values_row *data = (out_union_values_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

cql_int32 out_union_values_get_y(out_union_values_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_values_row *data = (out_union_values_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t out_union_values_data_types[out_union_values_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // y
};

static cql_uint16 out_union_values_col_offsets[] = { 2,
  cql_offsetof(out_union_values_row, x),
  cql_offsetof(out_union_values_row, y)
};

cql_int32 out_union_values_result_count(out_union_values_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_values_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_values_data_types,
  .col_offsets = out_union_values_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_values_row),
  .crc = CRC_out_union_values,
  .perf_index = &out_union_values_perf_index,
};
// export: DECLARE PROC out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL) OUT UNION (x INTEGER NOT NULL, y INTEGER NOT NULL);

typedef struct out_union_values_x_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} out_union_values_x_row;
void out_union_values_fetch_results(out_union_values_result_set_ref _Nullable *_Nonnull _result_set_, cql_int32 a, cql_int32 b) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  out_union_values_x_row x = { 0 };

  cql_profile_start(CRC_out_union_values, &out_union_values_perf_index);
  x._has_row_ = 1;
  x.x = a;
  x.y = b;
  cql_retain_row(x);
  if (x._has_row_) cql_bytebuf_append(&_rows_, (const void *)&x, sizeof(x));

  cql_results_from_data(SQLITE_OK, &_rows_, &out_union_values_info, (cql_result_set_ref *)_result_set_);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC read_out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR FOR CALL out_union_values(a, b);
  FETCH C;
END;
*/

#define _PROC_ "read_out_union_values"
// export: DECLARE PROC read_out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL) USING TRANSACTION;

typedef struct read_out_union_values_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} read_out_union_values_C_row;
CQL_WARN_UNUSED cql_code read_out_union_values(sqlite3 *_Nonnull _db_, cql_int32 a, cql_int32 b) {
  cql_code _rc_ = SQLITE_OK;
  out_union_values_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  read_out_union_values_C_row C = { 0 };

  out_union_values_fetch_results(&C_result_set_, a, b);
  C_row_num_ = C_row_count_ = -1;
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  C_row_num_++;
  C._has_row_ = C_row_num_ < C_row_count_;
  cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.y);
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC out_union_dml ()
BEGIN
  DECLARE x CURSOR FOR SELECT *
    FROM radioactive;
  FETCH x;
  OUT UNION x;
END;
*/

#define _PROC_ "out_union_dml_fetch_results"

#define out_union_dml_refs_offset cql_offsetof(out_union_dml_row, data) // count = 1
static int32_t out_union_dml_perf_index;

cql_string_proc_name(out_union_dml_stored_procedure_name, "out_union_dml");

cql_int32 out_union_dml_get_id(out_union_dml_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_dml_row *data = (out_union_dml_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable out_union_dml_get_data(out_union_dml_result_set_ref _Nonnull result_set, cql_int32 row) {
  out_union_dml_row *data = (out_union_dml_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t out_union_dml_data_types[out_union_dml_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // data
};

#define out_union_dml_refs_offset cql_offsetof(out_union_dml_row, data) // count = 1

static cql_uint16 out_union_dml_col_offsets[] = { 2,
  cql_offsetof(out_union_dml_row, id),
  cql_offsetof(out_union_dml_row, data)
};

cql_int32 out_union_dml_result_count(out_union_dml_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info out_union_dml_info = {
  .rc = SQLITE_OK,
  .data_types = out_union_dml_data_types,
  .col_offsets = out_union_dml_col_offsets,
  .refs_count = 1,
  .refs_offset = out_union_dml_refs_offset,
  .encode_context_index = -1,
  .rowsize = sizeof(out_union_dml_row),
  .crc = CRC_out_union_dml,
  .perf_index = &out_union_dml_perf_index,
};
void out_union_dml_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(out_union_dml_data_types, out_union_dml_data_types_count, col, encode);
}

// export: DECLARE PROC out_union_dml () OUT UNION (id INTEGER NOT NULL, data TEXT @SENSITIVE) USING TRANSACTION;

typedef struct out_union_dml_x_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable data;
} out_union_dml_x_row;

#define out_union_dml_x_refs_offset cql_offsetof(out_union_dml_x_row, data) // count = 1
CQL_WARN_UNUSED cql_code out_union_dml_fetch_results(sqlite3 *_Nonnull _db_, out_union_dml_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_code _rc_ = SQLITE_OK;
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  sqlite3_stmt *x_stmt = NULL;
  out_union_dml_x_row x = { ._refs_count_ = 1, ._refs_offset_ = out_union_dml_x_refs_offset };

  cql_profile_start(CRC_out_union_dml, &out_union_dml_perf_index);
  _rc_ = cql_prepare(_db_, &x_stmt,
    "SELECT id, data "
      "FROM radioactive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(x_stmt);
  x._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, x_stmt, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &x.id,
                 CQL_DATA_TYPE_STRING, &x.data);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_retain_row(x);
  if (x._has_row_) cql_bytebuf_append(&_rows_, (const void *)&x, sizeof(x));
  _rc_ = SQLITE_OK;

cql_cleanup:
  out_union_dml_info.db = _db_;
  cql_results_from_data(_rc_, &_rows_, &out_union_dml_info, (cql_result_set_ref *)_result_set_);
  out_union_dml_info.db = NULL;
  cql_finalize_stmt(&x_stmt);
  cql_teardown_row(x);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC out_union_dml_for_call ()
BEGIN
  DECLARE C CURSOR FOR CALL out_union_dml();
  FETCH C;
END;
*/

#define _PROC_ "out_union_dml_for_call"
// export: DECLARE PROC out_union_dml_for_call () USING TRANSACTION;

typedef struct out_union_dml_for_call_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_string_ref _Nullable data;
} out_union_dml_for_call_C_row;

#define out_union_dml_for_call_C_refs_offset cql_offsetof(out_union_dml_for_call_C_row, data) // count = 1
CQL_WARN_UNUSED cql_code out_union_dml_for_call(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  out_union_dml_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  out_union_dml_for_call_C_row C = { ._refs_count_ = 1, ._refs_offset_ = out_union_dml_for_call_C_refs_offset };

  _rc_ = out_union_dml_fetch_results(_db_, &C_result_set_);
  C_row_num_ = C_row_count_ = -1;
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  C_row_num_++;
  C._has_row_ = C_row_num_ < C_row_count_;
  cql_copyoutrow(_db_, (cql_result_set_ref)C_result_set_, C_row_num_, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.id,
                 CQL_DATA_TYPE_STRING, &C.data);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_result_set_);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC compound_select_expr ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
  LIMIT 1 );
END;
*/

#define _PROC_ "compound_select_expr"
// export: DECLARE PROC compound_select_expr () USING TRANSACTION;
CQL_WARN_UNUSED cql_code compound_select_expr(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_int32 _tmp_int_0 = 0;
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 1 "
      "WHERE 0 "
    "UNION "
    "SELECT 2 "
    "LIMIT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_int_0 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_notnull(x, _tmp_int_0);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window_function_invocation ()
BEGIN
  SELECT id, 
    row_number() OVER () AS row_num
    FROM foo;
END;
*/

#define _PROC_ "window_function_invocation"
static int32_t window_function_invocation_perf_index;

cql_string_proc_name(window_function_invocation_stored_procedure_name, "window_function_invocation");

typedef struct window_function_invocation_row {
  cql_int32 id;
  cql_int32 row_num;
} window_function_invocation_row;

cql_int32 window_function_invocation_get_id(window_function_invocation_result_set_ref _Nonnull result_set, cql_int32 row) {
  window_function_invocation_row *data = (window_function_invocation_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_int32 window_function_invocation_get_row_num(window_function_invocation_result_set_ref _Nonnull result_set, cql_int32 row) {
  window_function_invocation_row *data = (window_function_invocation_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].row_num;
}

uint8_t window_function_invocation_data_types[window_function_invocation_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // row_num
};

static cql_uint16 window_function_invocation_col_offsets[] = { 2,
  cql_offsetof(window_function_invocation_row, id),
  cql_offsetof(window_function_invocation_row, row_num)
};

cql_int32 window_function_invocation_result_count(window_function_invocation_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window_function_invocation_fetch_results(sqlite3 *_Nonnull _db_, window_function_invocation_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window_function_invocation, &window_function_invocation_perf_index);
  cql_code rc = window_function_invocation(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window_function_invocation_data_types,
    .col_offsets = window_function_invocation_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window_function_invocation_row),
    .crc = CRC_window_function_invocation,
    .perf_index = &window_function_invocation_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window_function_invocation () (id INTEGER NOT NULL, row_num INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code window_function_invocation(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id,  "
      "row_number() OVER () "
      "FROM foo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC update_cursor ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, 2 AS y;
  UPDATE CURSOR C(x) FROM VALUES(2);
END;
*/

#define _PROC_ "update_cursor"
// export: DECLARE PROC update_cursor () USING TRANSACTION;

typedef struct update_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} update_cursor_C_row;
CQL_WARN_UNUSED cql_code update_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  update_cursor_C_row C = { 0 };

  if (C._has_row_) {
    C.x = 2;
  }
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC out_union_with_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL) USING TRANSACTION;
*/

// The statement ending at line XXXX

/*
DECLARE PROC out_union_no_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC use_return ()
BEGIN
  BEGIN TRY
    SELECT 1 AS x;
  END TRY;
  BEGIN CATCH
    RETURN;
  END CATCH;
END;
*/

#define _PROC_ "use_return"
static int32_t use_return_perf_index;

cql_string_proc_name(use_return_stored_procedure_name, "use_return");

typedef struct use_return_row {
  cql_int32 x;
} use_return_row;

cql_int32 use_return_get_x(use_return_result_set_ref _Nonnull result_set, cql_int32 row) {
  use_return_row *data = (use_return_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t use_return_data_types[use_return_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 use_return_col_offsets[] = { 1,
  cql_offsetof(use_return_row, x)
};

cql_int32 use_return_result_count(use_return_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code use_return_fetch_results(sqlite3 *_Nonnull _db_, use_return_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_use_return, &use_return_perf_index);
  cql_code rc = use_return(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = use_return_data_types,
    .col_offsets = use_return_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(use_return_row),
    .crc = CRC_use_return,
    .perf_index = &use_return_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC use_return () (x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code use_return(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  // try
  {
    _rc_ = cql_prepare(_db_, _result_stmt,
      "SELECT 1");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_4; }
    goto catch_end_4;
  }
  catch_start_4: {
    _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
    goto cql_cleanup; // return
  }
  catch_end_4:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_return_no_error_flow ()
BEGIN
  IF 1 THEN
    RETURN;
  END IF;
END;
*/

#define _PROC_ "use_return_no_error_flow"
// export: DECLARE PROC use_return_no_error_flow ();
void use_return_no_error_flow(void) {
  if (1) {
    goto cql_cleanup; // return
  }

cql_cleanup:
  ; // label requires some statement
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC empty_proc ()
BEGIN
END;
*/

#define _PROC_ "empty_proc"
// export: DECLARE PROC empty_proc ();
void empty_proc(void) {

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC empty_blocks ()
BEGIN
  IF 1 THEN
  END IF;
  IF 2 THEN
  ELSE
  END IF;
  IF 3 THEN
  ELSE IF 4 THEN
  ELSE
  END IF;
  WHILE 1
  BEGIN
  END;
  DECLARE c CURSOR FOR SELECT 1 AS x;
  LOOP FETCH c
  BEGIN
  END;
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
END;
*/

#define _PROC_ "empty_blocks"
// export: DECLARE PROC empty_blocks () USING TRANSACTION;

typedef struct empty_blocks_c_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} empty_blocks_c_row;
CQL_WARN_UNUSED cql_code empty_blocks(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *c_stmt = NULL;
  empty_blocks_c_row c = { 0 };

  if (1) {
  }
  if (2) {
  }
  else {
  }
  if (3) {
  }
  else {
    if (4) {
    }
    else {
    }
  }
  for (;;) {
  if (!(1)) break;
  }
  _rc_ = cql_prepare(_db_, &c_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(c_stmt);
    c._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, c_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &c.x);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!c._has_row_) break;
  }
  // try
  {
    goto catch_end_5;
  }
  {
  }
  catch_end_5:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&c_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC tail_catch ()
BEGIN
  BEGIN TRY
  END TRY;
  BEGIN CATCH
    BEGIN TRY
    END TRY;
    BEGIN CATCH
    END CATCH;
  END CATCH;
END;
*/

#define _PROC_ "tail_catch"
// export: DECLARE PROC tail_catch () USING TRANSACTION;
CQL_WARN_UNUSED cql_code tail_catch(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  // try
  {
    goto catch_end_6;
  }
  {
    // try
    {
      goto catch_end_7;
    }
    {
    }
    catch_end_7:;
  }
  catch_end_6:;
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC pretty_print_with_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "it's high noon\r\n\f\b\t\v");
END;
*/

#define _PROC_ "pretty_print_with_quote"
// export: DECLARE PROC pretty_print_with_quote () USING TRANSACTION;
CQL_WARN_UNUSED cql_code pretty_print_with_quote(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, 'it''s high noon\r\n\f\b\t\v')");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC hex_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "\x01\x02\xa1\x1bg");
END;
*/

#define _PROC_ "hex_quote"
// export: DECLARE PROC hex_quote () USING TRANSACTION;
CQL_WARN_UNUSED cql_code hex_quote(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, '\x01\x02\xa1\x1bg')");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:suppress_getters)
CREATE PROC lotsa_columns_no_getters ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "lotsa_columns_no_getters"
static int32_t lotsa_columns_no_getters_perf_index;

cql_string_proc_name(lotsa_columns_no_getters_stored_procedure_name, "lotsa_columns_no_getters");

typedef struct lotsa_columns_no_getters_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} lotsa_columns_no_getters_row;

uint8_t lotsa_columns_no_getters_data_types[lotsa_columns_no_getters_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define lotsa_columns_no_getters_refs_offset cql_offsetof(lotsa_columns_no_getters_row, name) // count = 1

static cql_uint16 lotsa_columns_no_getters_col_offsets[] = { 5,
  cql_offsetof(lotsa_columns_no_getters_row, id),
  cql_offsetof(lotsa_columns_no_getters_row, name),
  cql_offsetof(lotsa_columns_no_getters_row, rate),
  cql_offsetof(lotsa_columns_no_getters_row, type),
  cql_offsetof(lotsa_columns_no_getters_row, size)
};

cql_int32 lotsa_columns_no_getters_result_count(lotsa_columns_no_getters_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code lotsa_columns_no_getters_fetch_results(sqlite3 *_Nonnull _db_, lotsa_columns_no_getters_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_lotsa_columns_no_getters, &lotsa_columns_no_getters_perf_index);
  cql_code rc = lotsa_columns_no_getters(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = lotsa_columns_no_getters_data_types,
    .col_offsets = lotsa_columns_no_getters_col_offsets,
    .refs_count = 1,
    .refs_offset = lotsa_columns_no_getters_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(lotsa_columns_no_getters_row),
    .crc = CRC_lotsa_columns_no_getters,
    .perf_index = &lotsa_columns_no_getters_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC lotsa_columns_no_getters () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code lotsa_columns_no_getters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:generate_copy)
CREATE PROC sproc_with_copy ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "sproc_with_copy"
static int32_t sproc_with_copy_perf_index;

cql_string_proc_name(sproc_with_copy_stored_procedure_name, "sproc_with_copy");

typedef struct sproc_with_copy_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} sproc_with_copy_row;

cql_int32 sproc_with_copy_get_id(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable sproc_with_copy_get_name(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool sproc_with_copy_get_rate_is_null(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 sproc_with_copy_get_rate_value(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool sproc_with_copy_get_type_is_null(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 sproc_with_copy_get_type_value(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool sproc_with_copy_get_size_is_null(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double sproc_with_copy_get_size_value(sproc_with_copy_result_set_ref _Nonnull result_set, cql_int32 row) {
  sproc_with_copy_row *data = (sproc_with_copy_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t sproc_with_copy_data_types[sproc_with_copy_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define sproc_with_copy_refs_offset cql_offsetof(sproc_with_copy_row, name) // count = 1

static cql_uint16 sproc_with_copy_col_offsets[] = { 5,
  cql_offsetof(sproc_with_copy_row, id),
  cql_offsetof(sproc_with_copy_row, name),
  cql_offsetof(sproc_with_copy_row, rate),
  cql_offsetof(sproc_with_copy_row, type),
  cql_offsetof(sproc_with_copy_row, size)
};

cql_int32 sproc_with_copy_result_count(sproc_with_copy_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code sproc_with_copy_fetch_results(sqlite3 *_Nonnull _db_, sproc_with_copy_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_sproc_with_copy, &sproc_with_copy_perf_index);
  cql_code rc = sproc_with_copy(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = sproc_with_copy_data_types,
    .col_offsets = sproc_with_copy_col_offsets,
    .refs_count = 1,
    .refs_offset = sproc_with_copy_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(sproc_with_copy_row),
    .crc = CRC_sproc_with_copy,
    .perf_index = &sproc_with_copy_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC sproc_with_copy () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code sproc_with_copy(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:emit_setters)
CREATE PROC emit_object_with_setters (o OBJECT NOT NULL, x OBJECT NOT NULL, i INTEGER NOT NULL, l LONG_INT NOT NULL, b BOOL NOT NULL, d REAL NOT NULL, t TEXT NOT NULL, bl BLOB NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE emit_object_with_setters ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES(o, x, i, l, b, d, t, bl);
  OUT C;
END;
*/

#define _PROC_ "emit_object_with_setters"

#define emit_object_with_setters_refs_offset cql_offsetof(emit_object_with_setters_row, o) // count = 4
static int32_t emit_object_with_setters_perf_index;

cql_string_proc_name(emit_object_with_setters_stored_procedure_name, "emit_object_with_setters");

cql_object_ref _Nonnull emit_object_with_setters_get_o(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->o;
}

extern void emit_object_with_setters_set_o(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_object_ref _Nonnull new_value) {
  cql_contract_argument_notnull((void *)new_value, 2);
  cql_result_set_set_object_col((cql_result_set_ref)result_set, 0, 0, new_value);
}

cql_object_ref _Nonnull emit_object_with_setters_get_x(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->x;
}

extern void emit_object_with_setters_set_x(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_object_ref _Nonnull new_value) {
  cql_contract_argument_notnull((void *)new_value, 2);
  cql_result_set_set_object_col((cql_result_set_ref)result_set, 0, 1, new_value);
}

cql_int32 emit_object_with_setters_get_i(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->i;
}

extern void emit_object_with_setters_set_i(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_int32 new_value) {
  cql_nullable_int32 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, 0, 2, new_value_);
}

cql_int64 emit_object_with_setters_get_l(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->l;
}

extern void emit_object_with_setters_set_l(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_int64 new_value) {
  cql_nullable_int64 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int64_col((cql_result_set_ref)result_set, 0, 3, new_value_);
}

cql_bool emit_object_with_setters_get_b(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->b;
}

extern void emit_object_with_setters_set_b(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_bool new_value) {
  cql_nullable_bool new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_bool_col((cql_result_set_ref)result_set, 0, 4, new_value_);
}

cql_double emit_object_with_setters_get_d(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->d;
}

extern void emit_object_with_setters_set_d(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_double new_value) {
  cql_nullable_double new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_double_col((cql_result_set_ref)result_set, 0, 5, new_value_);
}

cql_string_ref _Nonnull emit_object_with_setters_get_t(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->t;
}

extern void emit_object_with_setters_set_t(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_string_ref _Nonnull new_value) {
  cql_contract_argument_notnull((void *)new_value, 2);
  cql_result_set_set_string_col((cql_result_set_ref)result_set, 0, 6, new_value);
}

cql_blob_ref _Nonnull emit_object_with_setters_get_bl(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  emit_object_with_setters_row *data = (emit_object_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->bl;
}

extern void emit_object_with_setters_set_bl(emit_object_with_setters_result_set_ref _Nonnull result_set, cql_blob_ref _Nonnull new_value) {
  cql_contract_argument_notnull((void *)new_value, 2);
  cql_result_set_set_blob_col((cql_result_set_ref)result_set, 0, 7, new_value);
}

uint8_t emit_object_with_setters_data_types[emit_object_with_setters_data_types_count] = {
  CQL_DATA_TYPE_OBJECT | CQL_DATA_TYPE_NOT_NULL, // o
  CQL_DATA_TYPE_OBJECT | CQL_DATA_TYPE_NOT_NULL, // x
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // i
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // l
  CQL_DATA_TYPE_BOOL | CQL_DATA_TYPE_NOT_NULL, // b
  CQL_DATA_TYPE_DOUBLE | CQL_DATA_TYPE_NOT_NULL, // d
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // t
  CQL_DATA_TYPE_BLOB | CQL_DATA_TYPE_NOT_NULL, // bl
};

static cql_uint16 emit_object_with_setters_col_offsets[] = { 8,
  cql_offsetof(emit_object_with_setters_row, o),
  cql_offsetof(emit_object_with_setters_row, x),
  cql_offsetof(emit_object_with_setters_row, i),
  cql_offsetof(emit_object_with_setters_row, l),
  cql_offsetof(emit_object_with_setters_row, b),
  cql_offsetof(emit_object_with_setters_row, d),
  cql_offsetof(emit_object_with_setters_row, t),
  cql_offsetof(emit_object_with_setters_row, bl)
};

cql_int32 emit_object_with_setters_result_count(emit_object_with_setters_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void emit_object_with_setters_fetch_results( emit_object_with_setters_result_set_ref _Nullable *_Nonnull result_set, cql_object_ref _Nonnull o, cql_object_ref _Nonnull x, cql_int32 i, cql_int64 l, cql_bool b, cql_double d, cql_string_ref _Nonnull t, cql_blob_ref _Nonnull bl) {
  cql_profile_start(CRC_emit_object_with_setters, &emit_object_with_setters_perf_index);
  *result_set = NULL;
  emit_object_with_setters_row *row = (emit_object_with_setters_row *)calloc(1, sizeof(emit_object_with_setters_row));
  emit_object_with_setters(o, x, i, l, b, d, t, bl, row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = emit_object_with_setters_data_types,
    .col_offsets = emit_object_with_setters_col_offsets,
    .refs_count = 4,
    .refs_offset = emit_object_with_setters_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(emit_object_with_setters_row),
    .crc = CRC_emit_object_with_setters,
    .perf_index = &emit_object_with_setters_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC emit_object_with_setters (o OBJECT NOT NULL, x OBJECT NOT NULL, i INTEGER NOT NULL, l LONG_INT NOT NULL, b BOOL NOT NULL, d REAL NOT NULL, t TEXT NOT NULL, bl BLOB NOT NULL) OUT (o OBJECT NOT NULL, x OBJECT NOT NULL, i INTEGER NOT NULL, l LONG_INT NOT NULL, b BOOL NOT NULL, d REAL NOT NULL, t TEXT NOT NULL, bl BLOB NOT NULL);

typedef struct emit_object_with_setters_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 i;
  cql_int64 l;
  cql_bool b;
  cql_double d;
  cql_object_ref _Nonnull o;
  cql_object_ref _Nonnull x;
  cql_string_ref _Nonnull t;
  cql_blob_ref _Nonnull bl;
} emit_object_with_setters_C_row;

#define emit_object_with_setters_C_refs_offset cql_offsetof(emit_object_with_setters_C_row, o) // count = 4
void emit_object_with_setters(cql_object_ref _Nonnull o, cql_object_ref _Nonnull x, cql_int32 i, cql_int64 l, cql_bool b, cql_double d, cql_string_ref _Nonnull t, cql_blob_ref _Nonnull bl, emit_object_with_setters_row *_Nonnull _result_) {
  cql_contract_argument_notnull((void *)o, 1);
  cql_contract_argument_notnull((void *)x, 2);
  cql_contract_argument_notnull((void *)t, 7);
  cql_contract_argument_notnull((void *)bl, 8);

  memset(_result_, 0, sizeof(*_result_));
  emit_object_with_setters_C_row C = { ._refs_count_ = 4, ._refs_offset_ = emit_object_with_setters_C_refs_offset };

  C._has_row_ = 1;
  cql_set_object_ref(&C.o, o);
  cql_set_object_ref(&C.x, x);
  C.i = i;
  C.l = l;
  C.b = b;
  C.d = d;
  cql_set_string_ref(&C.t, t);
  cql_set_blob_ref(&C.bl, bl);
  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 4;
  _result_->_refs_offset_ = emit_object_with_setters_refs_offset;
  cql_set_object_ref(&_result_->o, C.o);
  cql_set_object_ref(&_result_->x, C.x);
  _result_->i = C.i;
  _result_->l = C.l;
  _result_->b = C.b;
  _result_->d = C.d;
  cql_set_string_ref(&_result_->t, C.t);
  cql_set_blob_ref(&_result_->bl, C.bl);

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:emit_setters)
CREATE PROC emit_setters_with_nullables (o OBJECT, x OBJECT, i INTEGER, l LONG_INT, b BOOL, d REAL, t TEXT, bl BLOB)
BEGIN
  DECLARE C CURSOR LIKE emit_setters_with_nullables ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES(o, x, i, l, b, d, t, bl);
  OUT C;
END;
*/

#define _PROC_ "emit_setters_with_nullables"

#define emit_setters_with_nullables_refs_offset cql_offsetof(emit_setters_with_nullables_row, o) // count = 4
static int32_t emit_setters_with_nullables_perf_index;

cql_string_proc_name(emit_setters_with_nullables_stored_procedure_name, "emit_setters_with_nullables");

cql_object_ref _Nullable emit_setters_with_nullables_get_o(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->o;
}

extern void emit_setters_with_nullables_set_o(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_object_ref _Nullable new_value) {
  cql_result_set_set_object_col((cql_result_set_ref)result_set, 0, 0, new_value);
}

cql_object_ref _Nullable emit_setters_with_nullables_get_x(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->x;
}

extern void emit_setters_with_nullables_set_x(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_object_ref _Nullable new_value) {
  cql_result_set_set_object_col((cql_result_set_ref)result_set, 0, 1, new_value);
}

cql_bool emit_setters_with_nullables_get_i_is_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->i.is_null;
}

cql_int32 emit_setters_with_nullables_get_i_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->i.value;
}

extern void emit_setters_with_nullables_set_i_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_int32 new_value) {
  cql_nullable_int32 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, 0, 2, new_value_);
}

extern void emit_setters_with_nullables_set_i_to_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  cql_nullable_int32 new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, 0, 2, new_value_);
}

cql_bool emit_setters_with_nullables_get_l_is_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->l.is_null;
}

cql_int64 emit_setters_with_nullables_get_l_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->l.value;
}

extern void emit_setters_with_nullables_set_l_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_int64 new_value) {
  cql_nullable_int64 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int64_col((cql_result_set_ref)result_set, 0, 3, new_value_);
}

extern void emit_setters_with_nullables_set_l_to_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  cql_nullable_int64 new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_int64_col((cql_result_set_ref)result_set, 0, 3, new_value_);
}

cql_bool emit_setters_with_nullables_get_b_is_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->b.is_null;
}

cql_bool emit_setters_with_nullables_get_b_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->b.value;
}

extern void emit_setters_with_nullables_set_b_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_bool new_value) {
  cql_nullable_bool new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_bool_col((cql_result_set_ref)result_set, 0, 4, new_value_);
}

extern void emit_setters_with_nullables_set_b_to_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  cql_nullable_bool new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_bool_col((cql_result_set_ref)result_set, 0, 4, new_value_);
}

cql_bool emit_setters_with_nullables_get_d_is_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->d.is_null;
}

cql_double emit_setters_with_nullables_get_d_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->d.value;
}

extern void emit_setters_with_nullables_set_d_value(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_double new_value) {
  cql_nullable_double new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_double_col((cql_result_set_ref)result_set, 0, 5, new_value_);
}

extern void emit_setters_with_nullables_set_d_to_null(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  cql_nullable_double new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_double_col((cql_result_set_ref)result_set, 0, 5, new_value_);
}

cql_string_ref _Nullable emit_setters_with_nullables_get_t(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->t;
}

extern void emit_setters_with_nullables_set_t(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_string_ref _Nullable new_value) {
  cql_result_set_set_string_col((cql_result_set_ref)result_set, 0, 6, new_value);
}

cql_blob_ref _Nullable emit_setters_with_nullables_get_bl(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  emit_setters_with_nullables_row *data = (emit_setters_with_nullables_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->bl;
}

extern void emit_setters_with_nullables_set_bl(emit_setters_with_nullables_result_set_ref _Nonnull result_set, cql_blob_ref _Nullable new_value) {
  cql_result_set_set_blob_col((cql_result_set_ref)result_set, 0, 7, new_value);
}

uint8_t emit_setters_with_nullables_data_types[emit_setters_with_nullables_data_types_count] = {
  CQL_DATA_TYPE_OBJECT, // o
  CQL_DATA_TYPE_OBJECT, // x
  CQL_DATA_TYPE_INT32, // i
  CQL_DATA_TYPE_INT64, // l
  CQL_DATA_TYPE_BOOL, // b
  CQL_DATA_TYPE_DOUBLE, // d
  CQL_DATA_TYPE_STRING, // t
  CQL_DATA_TYPE_BLOB, // bl
};

static cql_uint16 emit_setters_with_nullables_col_offsets[] = { 8,
  cql_offsetof(emit_setters_with_nullables_row, o),
  cql_offsetof(emit_setters_with_nullables_row, x),
  cql_offsetof(emit_setters_with_nullables_row, i),
  cql_offsetof(emit_setters_with_nullables_row, l),
  cql_offsetof(emit_setters_with_nullables_row, b),
  cql_offsetof(emit_setters_with_nullables_row, d),
  cql_offsetof(emit_setters_with_nullables_row, t),
  cql_offsetof(emit_setters_with_nullables_row, bl)
};

cql_int32 emit_setters_with_nullables_result_count(emit_setters_with_nullables_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void emit_setters_with_nullables_fetch_results( emit_setters_with_nullables_result_set_ref _Nullable *_Nonnull result_set, cql_object_ref _Nullable o, cql_object_ref _Nullable x, cql_nullable_int32 i, cql_nullable_int64 l, cql_nullable_bool b, cql_nullable_double d, cql_string_ref _Nullable t, cql_blob_ref _Nullable bl) {
  cql_profile_start(CRC_emit_setters_with_nullables, &emit_setters_with_nullables_perf_index);
  *result_set = NULL;
  emit_setters_with_nullables_row *row = (emit_setters_with_nullables_row *)calloc(1, sizeof(emit_setters_with_nullables_row));
  emit_setters_with_nullables(o, x, i, l, b, d, t, bl, row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = emit_setters_with_nullables_data_types,
    .col_offsets = emit_setters_with_nullables_col_offsets,
    .refs_count = 4,
    .refs_offset = emit_setters_with_nullables_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(emit_setters_with_nullables_row),
    .crc = CRC_emit_setters_with_nullables,
    .perf_index = &emit_setters_with_nullables_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC emit_setters_with_nullables (o OBJECT, x OBJECT, i INTEGER, l LONG_INT, b BOOL, d REAL, t TEXT, bl BLOB) OUT (o OBJECT, x OBJECT, i INTEGER, l LONG_INT, b BOOL, d REAL, t TEXT, bl BLOB);

typedef struct emit_setters_with_nullables_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_nullable_int32 i;
  cql_nullable_int64 l;
  cql_nullable_bool b;
  cql_nullable_double d;
  cql_object_ref _Nullable o;
  cql_object_ref _Nullable x;
  cql_string_ref _Nullable t;
  cql_blob_ref _Nullable bl;
} emit_setters_with_nullables_C_row;

#define emit_setters_with_nullables_C_refs_offset cql_offsetof(emit_setters_with_nullables_C_row, o) // count = 4
void emit_setters_with_nullables(cql_object_ref _Nullable o, cql_object_ref _Nullable x, cql_nullable_int32 i, cql_nullable_int64 l, cql_nullable_bool b, cql_nullable_double d, cql_string_ref _Nullable t, cql_blob_ref _Nullable bl, emit_setters_with_nullables_row *_Nonnull _result_) {
  memset(_result_, 0, sizeof(*_result_));
  emit_setters_with_nullables_C_row C = { ._refs_count_ = 4, ._refs_offset_ = emit_setters_with_nullables_C_refs_offset };

  C._has_row_ = 1;
  cql_set_object_ref(&C.o, o);
  cql_set_object_ref(&C.x, x);
  cql_set_nullable(C.i, i.is_null, i.value);
  cql_set_nullable(C.l, l.is_null, l.value);
  cql_set_nullable(C.b, b.is_null, b.value);
  cql_set_nullable(C.d, d.is_null, d.value);
  cql_set_string_ref(&C.t, t);
  cql_set_blob_ref(&C.bl, bl);
  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 4;
  _result_->_refs_offset_ = emit_setters_with_nullables_refs_offset;
  cql_set_object_ref(&_result_->o, C.o);
  cql_set_object_ref(&_result_->x, C.x);
  _result_->i = C.i;
  _result_->l = C.l;
  _result_->b = C.b;
  _result_->d = C.d;
  cql_set_string_ref(&_result_->t, C.t);
  cql_set_blob_ref(&_result_->bl, C.bl);

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:emit_setters)
CREATE PROC no_out_with_setters ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "no_out_with_setters"
static int32_t no_out_with_setters_perf_index;

cql_string_proc_name(no_out_with_setters_stored_procedure_name, "no_out_with_setters");

typedef struct no_out_with_setters_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} no_out_with_setters_row;

cql_int32 no_out_with_setters_get_id(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

extern void no_out_with_setters_set_id(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row, cql_int32 new_value) {
  cql_nullable_int32 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, row, 0, new_value_);
}

cql_string_ref _Nullable no_out_with_setters_get_name(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

extern void no_out_with_setters_set_name(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row, cql_string_ref _Nullable new_value) {
  cql_result_set_set_string_col((cql_result_set_ref)result_set, row, 1, new_value);
}

cql_bool no_out_with_setters_get_rate_is_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 no_out_with_setters_get_rate_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

extern void no_out_with_setters_set_rate_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row, cql_int64 new_value) {
  cql_nullable_int64 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int64_col((cql_result_set_ref)result_set, row, 2, new_value_);
}

extern void no_out_with_setters_set_rate_to_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  cql_nullable_int64 new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_int64_col((cql_result_set_ref)result_set, row, 2, new_value_);
}

cql_bool no_out_with_setters_get_type_is_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 no_out_with_setters_get_type_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

extern void no_out_with_setters_set_type_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row, cql_int32 new_value) {
  cql_nullable_int32 new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, row, 3, new_value_);
}

extern void no_out_with_setters_set_type_to_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  cql_nullable_int32 new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_int32_col((cql_result_set_ref)result_set, row, 3, new_value_);
}

cql_bool no_out_with_setters_get_size_is_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double no_out_with_setters_get_size_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  no_out_with_setters_row *data = (no_out_with_setters_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

extern void no_out_with_setters_set_size_value(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row, cql_double new_value) {
  cql_nullable_double new_value_;
  cql_set_notnull(new_value_, new_value);
  cql_result_set_set_double_col((cql_result_set_ref)result_set, row, 4, new_value_);
}

extern void no_out_with_setters_set_size_to_null(no_out_with_setters_result_set_ref _Nonnull result_set, cql_int32 row) {
  cql_nullable_double new_value_;
  cql_set_null(new_value_);
  cql_result_set_set_double_col((cql_result_set_ref)result_set, row, 4, new_value_);
}

uint8_t no_out_with_setters_data_types[no_out_with_setters_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define no_out_with_setters_refs_offset cql_offsetof(no_out_with_setters_row, name) // count = 1

static cql_uint16 no_out_with_setters_col_offsets[] = { 5,
  cql_offsetof(no_out_with_setters_row, id),
  cql_offsetof(no_out_with_setters_row, name),
  cql_offsetof(no_out_with_setters_row, rate),
  cql_offsetof(no_out_with_setters_row, type),
  cql_offsetof(no_out_with_setters_row, size)
};

cql_int32 no_out_with_setters_result_count(no_out_with_setters_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code no_out_with_setters_fetch_results(sqlite3 *_Nonnull _db_, no_out_with_setters_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_no_out_with_setters, &no_out_with_setters_perf_index);
  cql_code rc = no_out_with_setters(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = no_out_with_setters_data_types,
    .col_offsets = no_out_with_setters_col_offsets,
    .refs_count = 1,
    .refs_offset = no_out_with_setters_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(no_out_with_setters_row),
    .crc = CRC_no_out_with_setters,
    .perf_index = &no_out_with_setters_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC no_out_with_setters () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code no_out_with_setters(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC lotsa_columns_no_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "lotsa_columns_no_result_set"
// export: DECLARE PROC lotsa_columns_no_result_set () (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code lotsa_columns_no_result_set(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC early_out_rc_cleared (OUT x INTEGER)
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  FETCH C;
  IF C THEN
    RETURN;
  END IF;
END;
*/

#define _PROC_ "early_out_rc_cleared"
// export: DECLARE PROC early_out_rc_cleared (OUT x INTEGER) USING TRANSACTION;

typedef struct early_out_rc_cleared_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
} early_out_rc_cleared_C_row;
CQL_WARN_UNUSED cql_code early_out_rc_cleared(sqlite3 *_Nonnull _db_, cql_nullable_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  early_out_rc_cleared_C_row C = { 0 };

  cql_set_null(*x); // set out arg to non-garbage
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.x);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (C._has_row_) {
    _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
    goto cql_cleanup; // return
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=(id, name))
@ATTRIBUTE(cql:custom_type_for_encoded_column)
CREATE PROC vault_sensitive_with_values_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_sensitive_with_values_proc"
static int32_t vault_sensitive_with_values_proc_perf_index;

cql_string_proc_name(vault_sensitive_with_values_proc_stored_procedure_name, "vault_sensitive_with_values_proc");

typedef struct vault_sensitive_with_values_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_sensitive_with_values_proc_row;

cql_int32 vault_sensitive_with_values_proc_get_id(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_values_proc_row *data = (vault_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_sensitive_with_values_proc_get_name(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_values_proc_row *data = (vault_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_sensitive_with_values_proc_get_title(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_values_proc_row *data = (vault_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_sensitive_with_values_proc_get_type_is_null(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_values_proc_row *data = (vault_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_sensitive_with_values_proc_get_type_value(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_values_proc_row *data = (vault_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_sensitive_with_values_proc_data_types[vault_sensitive_with_values_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64, // type
};

#define vault_sensitive_with_values_proc_refs_offset cql_offsetof(vault_sensitive_with_values_proc_row, name) // count = 2

static cql_uint16 vault_sensitive_with_values_proc_col_offsets[] = { 4,
  cql_offsetof(vault_sensitive_with_values_proc_row, id),
  cql_offsetof(vault_sensitive_with_values_proc_row, name),
  cql_offsetof(vault_sensitive_with_values_proc_row, title),
  cql_offsetof(vault_sensitive_with_values_proc_row, type)
};

cql_int32 vault_sensitive_with_values_proc_result_count(vault_sensitive_with_values_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_sensitive_with_values_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_sensitive_with_values_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_sensitive_with_values_proc, &vault_sensitive_with_values_proc_perf_index);
  cql_code rc = vault_sensitive_with_values_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_sensitive_with_values_proc_data_types,
    .col_offsets = vault_sensitive_with_values_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_sensitive_with_values_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_sensitive_with_values_proc_row),
    .crc = CRC_vault_sensitive_with_values_proc,
    .perf_index = &vault_sensitive_with_values_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_sensitive_with_values_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_sensitive_with_values_proc_data_types, vault_sensitive_with_values_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_sensitive_with_values_proc () (id INTEGER NOT NULL, name TEXT @SENSITIVE, title TEXT, type LONG_INT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_sensitive_with_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=(id, name))
@ATTRIBUTE(cql:custom_type_for_encoded_column)
CREATE PROC vault_not_nullable_sensitive_with_values_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_not_nullable_sensitive;
END;
*/

#define _PROC_ "vault_not_nullable_sensitive_with_values_proc"
static int32_t vault_not_nullable_sensitive_with_values_proc_perf_index;

cql_string_proc_name(vault_not_nullable_sensitive_with_values_proc_stored_procedure_name, "vault_not_nullable_sensitive_with_values_proc");

typedef struct vault_not_nullable_sensitive_with_values_proc_row {
  cql_int32 id;
  cql_int64 type;
  cql_string_ref _Nonnull name;
  cql_string_ref _Nonnull title;
} vault_not_nullable_sensitive_with_values_proc_row;

cql_int32 vault_not_nullable_sensitive_with_values_proc_get_id(vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_not_nullable_sensitive_with_values_proc_row *data = (vault_not_nullable_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nonnull vault_not_nullable_sensitive_with_values_proc_get_name(vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_not_nullable_sensitive_with_values_proc_row *data = (vault_not_nullable_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nonnull vault_not_nullable_sensitive_with_values_proc_get_title(vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_not_nullable_sensitive_with_values_proc_row *data = (vault_not_nullable_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_int64 vault_not_nullable_sensitive_with_values_proc_get_type(vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_not_nullable_sensitive_with_values_proc_row *data = (vault_not_nullable_sensitive_with_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type;
}

uint8_t vault_not_nullable_sensitive_with_values_proc_data_types[vault_not_nullable_sensitive_with_values_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // title
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_NOT_NULL, // type
};

#define vault_not_nullable_sensitive_with_values_proc_refs_offset cql_offsetof(vault_not_nullable_sensitive_with_values_proc_row, name) // count = 2

static cql_uint16 vault_not_nullable_sensitive_with_values_proc_col_offsets[] = { 4,
  cql_offsetof(vault_not_nullable_sensitive_with_values_proc_row, id),
  cql_offsetof(vault_not_nullable_sensitive_with_values_proc_row, name),
  cql_offsetof(vault_not_nullable_sensitive_with_values_proc_row, title),
  cql_offsetof(vault_not_nullable_sensitive_with_values_proc_row, type)
};

cql_int32 vault_not_nullable_sensitive_with_values_proc_result_count(vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_not_nullable_sensitive_with_values_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_not_nullable_sensitive_with_values_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_not_nullable_sensitive_with_values_proc, &vault_not_nullable_sensitive_with_values_proc_perf_index);
  cql_code rc = vault_not_nullable_sensitive_with_values_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_not_nullable_sensitive_with_values_proc_data_types,
    .col_offsets = vault_not_nullable_sensitive_with_values_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_not_nullable_sensitive_with_values_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_not_nullable_sensitive_with_values_proc_row),
    .crc = CRC_vault_not_nullable_sensitive_with_values_proc,
    .perf_index = &vault_not_nullable_sensitive_with_values_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_not_nullable_sensitive_with_values_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_not_nullable_sensitive_with_values_proc_data_types, vault_not_nullable_sensitive_with_values_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_not_nullable_sensitive_with_values_proc () (id INTEGER NOT NULL, name TEXT NOT NULL @SENSITIVE, title TEXT NOT NULL, type LONG_INT NOT NULL @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_not_nullable_sensitive_with_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_not_nullable_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_sensitive_with_no_values_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_sensitive_with_no_values_proc"
static int32_t vault_sensitive_with_no_values_proc_perf_index;

cql_string_proc_name(vault_sensitive_with_no_values_proc_stored_procedure_name, "vault_sensitive_with_no_values_proc");

typedef struct vault_sensitive_with_no_values_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_sensitive_with_no_values_proc_row;

cql_int32 vault_sensitive_with_no_values_proc_get_id(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_values_proc_row *data = (vault_sensitive_with_no_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_sensitive_with_no_values_proc_get_name(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_values_proc_row *data = (vault_sensitive_with_no_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_sensitive_with_no_values_proc_get_title(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_values_proc_row *data = (vault_sensitive_with_no_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_sensitive_with_no_values_proc_get_type_is_null(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_values_proc_row *data = (vault_sensitive_with_no_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_sensitive_with_no_values_proc_get_type_value(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_values_proc_row *data = (vault_sensitive_with_no_values_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_sensitive_with_no_values_proc_data_types[vault_sensitive_with_no_values_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_ENCODED, // type
};

#define vault_sensitive_with_no_values_proc_refs_offset cql_offsetof(vault_sensitive_with_no_values_proc_row, name) // count = 2

static cql_uint16 vault_sensitive_with_no_values_proc_col_offsets[] = { 4,
  cql_offsetof(vault_sensitive_with_no_values_proc_row, id),
  cql_offsetof(vault_sensitive_with_no_values_proc_row, name),
  cql_offsetof(vault_sensitive_with_no_values_proc_row, title),
  cql_offsetof(vault_sensitive_with_no_values_proc_row, type)
};

cql_int32 vault_sensitive_with_no_values_proc_result_count(vault_sensitive_with_no_values_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_sensitive_with_no_values_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_sensitive_with_no_values_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_sensitive_with_no_values_proc, &vault_sensitive_with_no_values_proc_perf_index);
  cql_code rc = vault_sensitive_with_no_values_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_sensitive_with_no_values_proc_data_types,
    .col_offsets = vault_sensitive_with_no_values_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_sensitive_with_no_values_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_sensitive_with_no_values_proc_row),
    .crc = CRC_vault_sensitive_with_no_values_proc,
    .perf_index = &vault_sensitive_with_no_values_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_sensitive_with_no_values_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_sensitive_with_no_values_proc_data_types, vault_sensitive_with_no_values_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_sensitive_with_no_values_proc () (id INTEGER NOT NULL, name TEXT @SENSITIVE, title TEXT, type LONG_INT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_sensitive_with_no_values_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_union_all_table_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive
  UNION ALL
  SELECT *
    FROM vault_non_sensitive;
END;
*/

#define _PROC_ "vault_union_all_table_proc"
static int32_t vault_union_all_table_proc_perf_index;

cql_string_proc_name(vault_union_all_table_proc_stored_procedure_name, "vault_union_all_table_proc");

typedef struct vault_union_all_table_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_union_all_table_proc_row;

cql_int32 vault_union_all_table_proc_get_id(vault_union_all_table_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_union_all_table_proc_row *data = (vault_union_all_table_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_union_all_table_proc_get_name(vault_union_all_table_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_union_all_table_proc_row *data = (vault_union_all_table_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_union_all_table_proc_get_title(vault_union_all_table_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_union_all_table_proc_row *data = (vault_union_all_table_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_union_all_table_proc_get_type_is_null(vault_union_all_table_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_union_all_table_proc_row *data = (vault_union_all_table_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_union_all_table_proc_get_type_value(vault_union_all_table_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_union_all_table_proc_row *data = (vault_union_all_table_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_union_all_table_proc_data_types[vault_union_all_table_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64 | CQL_DATA_TYPE_ENCODED, // type
};

#define vault_union_all_table_proc_refs_offset cql_offsetof(vault_union_all_table_proc_row, name) // count = 2

static cql_uint16 vault_union_all_table_proc_col_offsets[] = { 4,
  cql_offsetof(vault_union_all_table_proc_row, id),
  cql_offsetof(vault_union_all_table_proc_row, name),
  cql_offsetof(vault_union_all_table_proc_row, title),
  cql_offsetof(vault_union_all_table_proc_row, type)
};

cql_int32 vault_union_all_table_proc_result_count(vault_union_all_table_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_union_all_table_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_union_all_table_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_union_all_table_proc, &vault_union_all_table_proc_perf_index);
  cql_code rc = vault_union_all_table_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_union_all_table_proc_data_types,
    .col_offsets = vault_union_all_table_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_union_all_table_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_union_all_table_proc_row),
    .crc = CRC_vault_union_all_table_proc,
    .perf_index = &vault_union_all_table_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_union_all_table_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_union_all_table_proc_data_types, vault_union_all_table_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_union_all_table_proc () (id INTEGER NOT NULL, name TEXT @SENSITIVE, title TEXT, type LONG_INT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_union_all_table_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_sensitive "
    "UNION ALL "
    "SELECT id, name, title, type "
      "FROM vault_non_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=alias_name)
CREATE PROC vault_alias_column_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_alias_column_proc"
static int32_t vault_alias_column_proc_perf_index;

cql_string_proc_name(vault_alias_column_proc_stored_procedure_name, "vault_alias_column_proc");

typedef struct vault_alias_column_proc_row {
  cql_string_ref _Nullable alias_name;
} vault_alias_column_proc_row;

cql_string_ref _Nullable vault_alias_column_proc_get_alias_name(vault_alias_column_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_alias_column_proc_row *data = (vault_alias_column_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].alias_name;
}

uint8_t vault_alias_column_proc_data_types[vault_alias_column_proc_data_types_count] = {
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // alias_name
};

#define vault_alias_column_proc_refs_offset cql_offsetof(vault_alias_column_proc_row, alias_name) // count = 1

static cql_uint16 vault_alias_column_proc_col_offsets[] = { 1,
  cql_offsetof(vault_alias_column_proc_row, alias_name)
};

cql_int32 vault_alias_column_proc_result_count(vault_alias_column_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_alias_column_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_alias_column_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_alias_column_proc, &vault_alias_column_proc_perf_index);
  cql_code rc = vault_alias_column_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_alias_column_proc_data_types,
    .col_offsets = vault_alias_column_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = vault_alias_column_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_alias_column_proc_row),
    .crc = CRC_vault_alias_column_proc,
    .perf_index = &vault_alias_column_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_alias_column_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_alias_column_proc_data_types, vault_alias_column_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_alias_column_proc () (alias_name TEXT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_alias_column_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT name "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=alias_name)
CREATE PROC vault_alias_column_name_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_alias_column_name_proc"
static int32_t vault_alias_column_name_proc_perf_index;

cql_string_proc_name(vault_alias_column_name_proc_stored_procedure_name, "vault_alias_column_name_proc");

typedef struct vault_alias_column_name_proc_row {
  cql_string_ref _Nullable alias_name;
} vault_alias_column_name_proc_row;

cql_string_ref _Nullable vault_alias_column_name_proc_get_alias_name(vault_alias_column_name_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_alias_column_name_proc_row *data = (vault_alias_column_name_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].alias_name;
}

uint8_t vault_alias_column_name_proc_data_types[vault_alias_column_name_proc_data_types_count] = {
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // alias_name
};

#define vault_alias_column_name_proc_refs_offset cql_offsetof(vault_alias_column_name_proc_row, alias_name) // count = 1

static cql_uint16 vault_alias_column_name_proc_col_offsets[] = { 1,
  cql_offsetof(vault_alias_column_name_proc_row, alias_name)
};

cql_int32 vault_alias_column_name_proc_result_count(vault_alias_column_name_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_alias_column_name_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_alias_column_name_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_alias_column_name_proc, &vault_alias_column_name_proc_perf_index);
  cql_code rc = vault_alias_column_name_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_alias_column_name_proc_data_types,
    .col_offsets = vault_alias_column_name_proc_col_offsets,
    .refs_count = 1,
    .refs_offset = vault_alias_column_name_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_alias_column_name_proc_row),
    .crc = CRC_vault_alias_column_name_proc,
    .perf_index = &vault_alias_column_name_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_alias_column_name_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_alias_column_name_proc_data_types, vault_alias_column_name_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_alias_column_name_proc () (alias_name TEXT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_alias_column_name_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT name "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT name
    FROM vault_mixed_sensitive;
  FETCH c;
END;
*/

#define _PROC_ "vault_cursor_proc"
// export: DECLARE PROC vault_cursor_proc () USING TRANSACTION;

typedef struct vault_cursor_proc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_string_ref _Nullable name;
} vault_cursor_proc_C_row;

#define vault_cursor_proc_C_refs_offset cql_offsetof(vault_cursor_proc_C_row, name) // count = 1
CQL_WARN_UNUSED cql_code vault_cursor_proc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  vault_cursor_proc_C_row C = { ._refs_count_ = 1, ._refs_offset_ = vault_cursor_proc_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT name "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 1,
                 CQL_DATA_TYPE_STRING, &C.name);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=(title, (id, name)))
CREATE PROC vault_sensitive_with_context_and_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_sensitive_with_context_and_sensitive_columns_proc"
static int32_t vault_sensitive_with_context_and_sensitive_columns_proc_perf_index;

cql_string_proc_name(vault_sensitive_with_context_and_sensitive_columns_proc_stored_procedure_name, "vault_sensitive_with_context_and_sensitive_columns_proc");

typedef struct vault_sensitive_with_context_and_sensitive_columns_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_sensitive_with_context_and_sensitive_columns_proc_row;

cql_int32 vault_sensitive_with_context_and_sensitive_columns_proc_get_id(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_sensitive_with_context_and_sensitive_columns_proc_get_name(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_sensitive_with_context_and_sensitive_columns_proc_get_title(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_sensitive_with_context_and_sensitive_columns_proc_get_type_is_null(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_sensitive_with_context_and_sensitive_columns_proc_get_type_value(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_sensitive_with_context_and_sensitive_columns_proc_data_types[vault_sensitive_with_context_and_sensitive_columns_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64, // type
};

#define vault_sensitive_with_context_and_sensitive_columns_proc_refs_offset cql_offsetof(vault_sensitive_with_context_and_sensitive_columns_proc_row, name) // count = 2

static cql_uint16 vault_sensitive_with_context_and_sensitive_columns_proc_col_offsets[] = { 4,
  cql_offsetof(vault_sensitive_with_context_and_sensitive_columns_proc_row, id),
  cql_offsetof(vault_sensitive_with_context_and_sensitive_columns_proc_row, name),
  cql_offsetof(vault_sensitive_with_context_and_sensitive_columns_proc_row, title),
  cql_offsetof(vault_sensitive_with_context_and_sensitive_columns_proc_row, type)
};

cql_int32 vault_sensitive_with_context_and_sensitive_columns_proc_result_count(vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_sensitive_columns_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_sensitive_with_context_and_sensitive_columns_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_sensitive_with_context_and_sensitive_columns_proc, &vault_sensitive_with_context_and_sensitive_columns_proc_perf_index);
  cql_code rc = vault_sensitive_with_context_and_sensitive_columns_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_sensitive_with_context_and_sensitive_columns_proc_data_types,
    .col_offsets = vault_sensitive_with_context_and_sensitive_columns_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_sensitive_with_context_and_sensitive_columns_proc_refs_offset,
    .encode_context_index = 2,
    .rowsize = sizeof(vault_sensitive_with_context_and_sensitive_columns_proc_row),
    .crc = CRC_vault_sensitive_with_context_and_sensitive_columns_proc,
    .perf_index = &vault_sensitive_with_context_and_sensitive_columns_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_sensitive_with_context_and_sensitive_columns_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_sensitive_with_context_and_sensitive_columns_proc_data_types, vault_sensitive_with_context_and_sensitive_columns_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_sensitive_with_context_and_sensitive_columns_proc () (id INTEGER NOT NULL, name TEXT @SENSITIVE, title TEXT, type LONG_INT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=((id, name)))
CREATE PROC vault_sensitive_with_no_context_and_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
*/

#define _PROC_ "vault_sensitive_with_no_context_and_sensitive_columns_proc"
static int32_t vault_sensitive_with_no_context_and_sensitive_columns_proc_perf_index;

cql_string_proc_name(vault_sensitive_with_no_context_and_sensitive_columns_proc_stored_procedure_name, "vault_sensitive_with_no_context_and_sensitive_columns_proc");

typedef struct vault_sensitive_with_no_context_and_sensitive_columns_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_sensitive_with_no_context_and_sensitive_columns_proc_row;

cql_int32 vault_sensitive_with_no_context_and_sensitive_columns_proc_get_id(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_no_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_sensitive_with_no_context_and_sensitive_columns_proc_get_name(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_no_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_sensitive_with_no_context_and_sensitive_columns_proc_get_title(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_no_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_sensitive_with_no_context_and_sensitive_columns_proc_get_type_is_null(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_no_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_sensitive_with_no_context_and_sensitive_columns_proc_get_type_value(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_no_context_and_sensitive_columns_proc_row *data = (vault_sensitive_with_no_context_and_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_sensitive_with_no_context_and_sensitive_columns_proc_data_types[vault_sensitive_with_no_context_and_sensitive_columns_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_ENCODED, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64, // type
};

#define vault_sensitive_with_no_context_and_sensitive_columns_proc_refs_offset cql_offsetof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row, name) // count = 2

static cql_uint16 vault_sensitive_with_no_context_and_sensitive_columns_proc_col_offsets[] = { 4,
  cql_offsetof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row, id),
  cql_offsetof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row, name),
  cql_offsetof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row, title),
  cql_offsetof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row, type)
};

cql_int32 vault_sensitive_with_no_context_and_sensitive_columns_proc_result_count(vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_sensitive_with_no_context_and_sensitive_columns_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_sensitive_with_no_context_and_sensitive_columns_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_sensitive_with_no_context_and_sensitive_columns_proc, &vault_sensitive_with_no_context_and_sensitive_columns_proc_perf_index);
  cql_code rc = vault_sensitive_with_no_context_and_sensitive_columns_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_sensitive_with_no_context_and_sensitive_columns_proc_data_types,
    .col_offsets = vault_sensitive_with_no_context_and_sensitive_columns_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_sensitive_with_no_context_and_sensitive_columns_proc_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(vault_sensitive_with_no_context_and_sensitive_columns_proc_row),
    .crc = CRC_vault_sensitive_with_no_context_and_sensitive_columns_proc,
    .perf_index = &vault_sensitive_with_no_context_and_sensitive_columns_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_sensitive_with_no_context_and_sensitive_columns_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_sensitive_with_no_context_and_sensitive_columns_proc_data_types, vault_sensitive_with_no_context_and_sensitive_columns_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_sensitive_with_no_context_and_sensitive_columns_proc () (id INTEGER NOT NULL, name TEXT @SENSITIVE, title TEXT, type LONG_INT @SENSITIVE);
CQL_WARN_UNUSED cql_code vault_sensitive_with_no_context_and_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_mixed_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:vault_sensitive=(title, (id, name)))
CREATE PROC vault_sensitive_with_context_and_no_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_non_sensitive;
END;
*/

#define _PROC_ "vault_sensitive_with_context_and_no_sensitive_columns_proc"
static int32_t vault_sensitive_with_context_and_no_sensitive_columns_proc_perf_index;

cql_string_proc_name(vault_sensitive_with_context_and_no_sensitive_columns_proc_stored_procedure_name, "vault_sensitive_with_context_and_no_sensitive_columns_proc");

typedef struct vault_sensitive_with_context_and_no_sensitive_columns_proc_row {
  cql_int32 id;
  cql_nullable_int64 type;
  cql_string_ref _Nullable name;
  cql_string_ref _Nullable title;
} vault_sensitive_with_context_and_no_sensitive_columns_proc_row;

cql_int32 vault_sensitive_with_context_and_no_sensitive_columns_proc_get_id(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_no_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_no_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable vault_sensitive_with_context_and_no_sensitive_columns_proc_get_name(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_no_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_no_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_string_ref _Nullable vault_sensitive_with_context_and_no_sensitive_columns_proc_get_title(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_no_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_no_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].title;
}

cql_bool vault_sensitive_with_context_and_no_sensitive_columns_proc_get_type_is_null(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_no_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_no_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int64 vault_sensitive_with_context_and_no_sensitive_columns_proc_get_type_value(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set, cql_int32 row) {
  vault_sensitive_with_context_and_no_sensitive_columns_proc_row *data = (vault_sensitive_with_context_and_no_sensitive_columns_proc_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

uint8_t vault_sensitive_with_context_and_no_sensitive_columns_proc_data_types[vault_sensitive_with_context_and_no_sensitive_columns_proc_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_STRING, // title
  CQL_DATA_TYPE_INT64, // type
};

#define vault_sensitive_with_context_and_no_sensitive_columns_proc_refs_offset cql_offsetof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row, name) // count = 2

static cql_uint16 vault_sensitive_with_context_and_no_sensitive_columns_proc_col_offsets[] = { 4,
  cql_offsetof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row, id),
  cql_offsetof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row, name),
  cql_offsetof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row, title),
  cql_offsetof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row, type)
};

cql_int32 vault_sensitive_with_context_and_no_sensitive_columns_proc_result_count(vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_no_sensitive_columns_proc_fetch_results(sqlite3 *_Nonnull _db_, vault_sensitive_with_context_and_no_sensitive_columns_proc_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_vault_sensitive_with_context_and_no_sensitive_columns_proc, &vault_sensitive_with_context_and_no_sensitive_columns_proc_perf_index);
  cql_code rc = vault_sensitive_with_context_and_no_sensitive_columns_proc(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = vault_sensitive_with_context_and_no_sensitive_columns_proc_data_types,
    .col_offsets = vault_sensitive_with_context_and_no_sensitive_columns_proc_col_offsets,
    .refs_count = 2,
    .refs_offset = vault_sensitive_with_context_and_no_sensitive_columns_proc_refs_offset,
    .encode_context_index = 2,
    .rowsize = sizeof(vault_sensitive_with_context_and_no_sensitive_columns_proc_row),
    .crc = CRC_vault_sensitive_with_context_and_no_sensitive_columns_proc,
    .perf_index = &vault_sensitive_with_context_and_no_sensitive_columns_proc_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

void vault_sensitive_with_context_and_no_sensitive_columns_proc_set_encoding(cql_int32 col, cql_bool encode) {
  return cql_set_encoding(vault_sensitive_with_context_and_no_sensitive_columns_proc_data_types, vault_sensitive_with_context_and_no_sensitive_columns_proc_data_types_count, col, encode);
}

// export: DECLARE PROC vault_sensitive_with_context_and_no_sensitive_columns_proc () (id INTEGER NOT NULL, name TEXT, title TEXT, type LONG_INT);
CQL_WARN_UNUSED cql_code vault_sensitive_with_context_and_no_sensitive_columns_proc(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, title, type "
      "FROM vault_non_sensitive");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:base_fragment=frag_test)
CREATE PROC baseline ()
BEGIN
  WITH
  frag_test (id) AS (SELECT 1 AS id)
  SELECT *
    FROM frag_test;
END;
*/

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:extension_fragment=frag_test)
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC ext ()
BEGIN
  WITH
  frag_test (id) AS (SELECT 1 AS id),
  ext (id, f2) AS (SELECT frag_test.*, f2
    FROM frag_test
    LEFT OUTER JOIN ext_test_table ON f1 = id)
  SELECT *
    FROM ext;
END;
*/

cql_int32 ext_get_id(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return frag_test_get_id(result_set, row);
}

cql_bool ext_get_f2_is_null(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f2_is_null(result_set, row);
}

cql_int32 ext_get_f2_value(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f2_value(result_set, row);
}

cql_int32 ext_result_count(frag_test_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:extension_fragment=frag_test)
CREATE PROC ext2 ()
BEGIN
  WITH
  frag_test (id) AS (SELECT 1 AS id),
  ext2 (id, f3) AS (SELECT frag_test.*, f3
    FROM frag_test
    LEFT OUTER JOIN ext_test_table ON f1 = id)
  SELECT *
    FROM ext2;
END;
*/

cql_int32 ext2_get_id(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return frag_test_get_id(result_set, row);
}

cql_bool ext2_get_f3_is_null(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f3_is_null(result_set, row);
}

cql_int32 ext2_get_f3_value(frag_test_result_set_ref _Nonnull result_set, cql_int32 row) {
  return __PRIVATE__frag_test_get_f3_value(result_set, row);
}

cql_int32 ext2_result_count(frag_test_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

// The statement ending at line XXXX

/*
CREATE PROC try_boxing (OUT result OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET result FROM CURSOR C;
END;
*/

#define _PROC_ "try_boxing"
// export: DECLARE PROC try_boxing (OUT result OBJECT<bar CURSOR>) USING TRANSACTION;
CQL_WARN_UNUSED cql_code try_boxing(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable *_Nonnull result) {
  cql_contract_argument_notnull((void *)result, 1);

  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_object_ref C_object_ = NULL;
  cql_bool _C_has_row_ = 0;

  *(void **)result = NULL; // set out arg to non-garbage
  C_stmt = NULL;
  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  cql_object_release(C_object_);
  C_object_ = cql_box_stmt(C_stmt);
  cql_set_object_ref(result, C_object_);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_object_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC try_unboxing (boxed_cursor OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR boxed_cursor;
  FETCH C;
END;
*/

#define _PROC_ "try_unboxing"
// export: DECLARE PROC try_unboxing (boxed_cursor OBJECT<bar CURSOR>) USING TRANSACTION;

typedef struct try_unboxing_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} try_unboxing_C_row;

#define try_unboxing_C_refs_offset cql_offsetof(try_unboxing_C_row, name) // count = 1
CQL_WARN_UNUSED cql_code try_unboxing(sqlite3 *_Nonnull _db_, cql_object_ref _Nullable boxed_cursor) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  cql_object_ref C_object_ = NULL;
  try_unboxing_C_row C = { ._refs_count_ = 1, ._refs_offset_ = try_unboxing_C_refs_offset };

  C_stmt = cql_unbox_stmt(boxed_cursor);
  cql_set_object_ref(&C_object_, boxed_cursor);
  _rc_ = sqlite3_step(C_stmt);
  C._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, C_stmt, 5,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.id,
                 CQL_DATA_TYPE_STRING, &C.name,
                 CQL_DATA_TYPE_INT64, &C.rate,
                 CQL_DATA_TYPE_INT32, &C.type,
                 CQL_DATA_TYPE_DOUBLE, &C.size);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_object_release(C_object_);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_int_notnull ()
BEGIN
  DECLARE x INTEGER NOT NULL;
  SET x := CAST(3.2 AS INTEGER);
END;
*/

#define _PROC_ "local_cast_int_notnull"
// export: DECLARE PROC local_cast_int_notnull ();
void local_cast_int_notnull(void) {
  cql_int32 x = 0;

  x = ((cql_int32)(3.2));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_int ()
BEGIN
  DECLARE x INTEGER;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS INTEGER);
END;
*/

#define _PROC_ "local_cast_int"
// export: DECLARE PROC local_cast_int ();
void local_cast_int(void) {
  cql_nullable_int32 x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_int32)(r.value)));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_long_notnull ()
BEGIN
  DECLARE x LONG_INT NOT NULL;
  SET x := CAST(3.2 AS LONG_INT);
END;
*/

#define _PROC_ "local_cast_long_notnull"
// export: DECLARE PROC local_cast_long_notnull ();
void local_cast_long_notnull(void) {
  cql_int64 x = 0;

  x = ((cql_int64)(3.2));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_long ()
BEGIN
  DECLARE x LONG_INT;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS LONG_INT);
END;
*/

#define _PROC_ "local_cast_long"
// export: DECLARE PROC local_cast_long ();
void local_cast_long(void) {
  cql_nullable_int64 x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_int64)(r.value)));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_real_notnull ()
BEGIN
  DECLARE x REAL NOT NULL;
  SET x := CAST(3 AS REAL);
END;
*/

#define _PROC_ "local_cast_real_notnull"
// export: DECLARE PROC local_cast_real_notnull ();
void local_cast_real_notnull(void) {
  cql_double x = 0;

  x = ((cql_double)(3));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_real ()
BEGIN
  DECLARE x REAL;
  DECLARE r INTEGER;
  SET r := nullable(3);
  SET x := CAST(r AS REAL);
END;
*/

#define _PROC_ "local_cast_real"
// export: DECLARE PROC local_cast_real ();
void local_cast_real(void) {
  cql_nullable_double x;
  cql_set_null(x);
  cql_nullable_int32 r;
  cql_set_null(r);

  cql_set_notnull(r, 3);
  cql_set_nullable(x, r.is_null, ((cql_double)(r.value)));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_bool_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  SET x := CAST(3.2 AS BOOL);
END;
*/

#define _PROC_ "local_cast_bool_notnull"
// export: DECLARE PROC local_cast_bool_notnull ();
void local_cast_bool_notnull(void) {
  cql_bool x = 0;

  x = ((cql_bool)!!(3.2));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_bool ()
BEGIN
  DECLARE x BOOL;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS BOOL);
END;
*/

#define _PROC_ "local_cast_bool"
// export: DECLARE PROC local_cast_bool ();
void local_cast_bool(void) {
  cql_nullable_bool x;
  cql_set_null(x);
  cql_nullable_double r;
  cql_set_null(r);

  cql_set_notnull(r, 3.2);
  cql_set_nullable(x, r.is_null, ((cql_bool)!!(r.value)));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_notnull ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1;
  DECLARE x REAL NOT NULL;
  SET x := CAST(b AS REAL);
END;
*/

#define _PROC_ "local_cast_from_bool_notnull"
// export: DECLARE PROC local_cast_from_bool_notnull ();
void local_cast_from_bool_notnull(void) {
  cql_bool b = 0;
  cql_double x = 0;

  b = 1;
  x = ((cql_double)!!(b));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x REAL;
  SET x := CAST(b AS REAL);
END;
*/

#define _PROC_ "local_cast_from_bool"
// export: DECLARE PROC local_cast_from_bool ();
void local_cast_from_bool(void) {
  cql_nullable_bool b;
  cql_set_null(b);
  cql_nullable_double x;
  cql_set_null(x);

  cql_set_notnull(b, 1);
  cql_set_nullable(x, b.is_null, ((cql_double)!!(b.value)));

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_no_op_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  DECLARE b BOOL NOT NULL;
  SET b := 1;
  SET x := CAST(b AS BOOL);
END;
*/

#define _PROC_ "local_cast_from_bool_no_op_notnull"
// export: DECLARE PROC local_cast_from_bool_no_op_notnull ();
void local_cast_from_bool_no_op_notnull(void) {
  cql_bool x = 0;
  cql_bool b = 0;

  b = 1;
  x = b;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC local_cast_from_bool_no_op ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x BOOL;
  SET x := CAST(b AS BOOL);
END;
*/

#define _PROC_ "local_cast_from_bool_no_op"
// export: DECLARE PROC local_cast_from_bool_no_op ();
void local_cast_from_bool_no_op(void) {
  cql_nullable_bool b;
  cql_set_null(b);
  cql_nullable_bool x;
  cql_set_null(x);

  cql_set_notnull(b, 1);
  cql_set_nullable(x, b.is_null, b.value);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    DECLARE X INTEGER;
  END;
END;
*/

#define _PROC_ "base_proc_savepoint"
// export: DECLARE PROC base_proc_savepoint () USING TRANSACTION;
CQL_WARN_UNUSED cql_code base_proc_savepoint(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_int32 X;
  cql_set_null(X);

  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_8; }
    goto catch_end_8;
  }
  catch_start_8: {
    int32_t _rc_thrown_1 = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_1);
    goto cql_cleanup;
  }
  catch_end_8:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint_commit_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      COMMIT RETURN;
    END IF;
  END;
END;
*/

#define _PROC_ "base_proc_savepoint_commit_return"
// export: DECLARE PROC base_proc_savepoint_commit_return () USING TRANSACTION;
CQL_WARN_UNUSED cql_code base_proc_savepoint_commit_return(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_commit_return");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    if (1) {
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_commit_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_9; }
      _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
      goto cql_cleanup; // return
    }
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_9; }
    goto catch_end_9;
  }
  catch_start_9: {
    int32_t _rc_thrown_1 = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_1);
    goto cql_cleanup;
  }
  catch_end_9:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC base_proc_savepoint_rollback_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    END IF;
  END;
END;
*/

#define _PROC_ "base_proc_savepoint_rollback_return"
// export: DECLARE PROC base_proc_savepoint_rollback_return () USING TRANSACTION;
CQL_WARN_UNUSED cql_code base_proc_savepoint_rollback_return(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_rollback_return");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    if (1) {
      _rc_ = cql_exec(_db_,
        "ROLLBACK TO base_proc_savepoint_rollback_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_rollback_return");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
      _rc_ = SQLITE_OK; // clean up any SQLITE_ROW value or other non-error
      goto cql_cleanup; // return
    }
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_10; }
    goto catch_end_10;
  }
  catch_start_10: {
    int32_t _rc_thrown_1 = _rc_;
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = cql_best_error(_rc_thrown_1);
    goto cql_cleanup;
  }
  catch_end_10:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE x INTEGER NOT NULL;
*/
cql_int32 x = 0;

// The statement ending at line XXXX

/*
CREATE PROC window1 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window1"
static int32_t window1_perf_index;

cql_string_proc_name(window1_stored_procedure_name, "window1");

typedef struct window1_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window1_row;

cql_bool window1_get_month_is_null(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window1_get_month_value(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window1_get_amount_is_null(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window1_get_amount_value(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window1_get_SalesMovingAverage_is_null(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window1_get_SalesMovingAverage_value(window1_result_set_ref _Nonnull result_set, cql_int32 row) {
  window1_row *data = (window1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window1_data_types[window1_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window1_col_offsets[] = { 3,
  cql_offsetof(window1_row, month),
  cql_offsetof(window1_row, amount),
  cql_offsetof(window1_row, SalesMovingAverage)
};

cql_int32 window1_result_count(window1_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window1_fetch_results(sqlite3 *_Nonnull _db_, window1_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window1, &window1_perf_index);
  cql_code rc = window1(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window1_data_types,
    .col_offsets = window1_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window1_row),
    .crc = CRC_window1,
    .perf_index = &window1_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window1 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window1(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window2 ()
BEGIN
  SELECT month, amount, 
    SUM(amount) OVER (ORDER BY month) AS RunningTotal
    FROM SalesInfo;
END;
*/

#define _PROC_ "window2"
static int32_t window2_perf_index;

cql_string_proc_name(window2_stored_procedure_name, "window2");

typedef struct window2_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double RunningTotal;
} window2_row;

cql_bool window2_get_month_is_null(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window2_get_month_value(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window2_get_amount_is_null(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window2_get_amount_value(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window2_get_RunningTotal_is_null(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].RunningTotal.is_null;
}

cql_double window2_get_RunningTotal_value(window2_result_set_ref _Nonnull result_set, cql_int32 row) {
  window2_row *data = (window2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].RunningTotal.value;
}

uint8_t window2_data_types[window2_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // RunningTotal
};

static cql_uint16 window2_col_offsets[] = { 3,
  cql_offsetof(window2_row, month),
  cql_offsetof(window2_row, amount),
  cql_offsetof(window2_row, RunningTotal)
};

cql_int32 window2_result_count(window2_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window2_fetch_results(sqlite3 *_Nonnull _db_, window2_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window2, &window2_perf_index);
  cql_code rc = window2(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window2_data_types,
    .col_offsets = window2_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window2_row),
    .crc = CRC_window2,
    .perf_index = &window2_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window2 () (month INTEGER, amount REAL, RunningTotal REAL);
CQL_WARN_UNUSED cql_code window2(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "SUM(amount) OVER (ORDER BY month) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window3 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window3"
static int32_t window3_perf_index;

cql_string_proc_name(window3_stored_procedure_name, "window3");

typedef struct window3_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window3_row;

cql_bool window3_get_month_is_null(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window3_get_month_value(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window3_get_amount_is_null(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window3_get_amount_value(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window3_get_SalesMovingAverage_is_null(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window3_get_SalesMovingAverage_value(window3_result_set_ref _Nonnull result_set, cql_int32 row) {
  window3_row *data = (window3_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window3_data_types[window3_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window3_col_offsets[] = { 3,
  cql_offsetof(window3_row, month),
  cql_offsetof(window3_row, amount),
  cql_offsetof(window3_row, SalesMovingAverage)
};

cql_int32 window3_result_count(window3_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window3_fetch_results(sqlite3 *_Nonnull _db_, window3_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window3, &window3_perf_index);
  cql_code rc = window3(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window3_data_types,
    .col_offsets = window3_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window3_row),
    .crc = CRC_window3,
    .perf_index = &window3_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window3 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window3(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window4 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window4"
static int32_t window4_perf_index;

cql_string_proc_name(window4_stored_procedure_name, "window4");

typedef struct window4_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window4_row;

cql_bool window4_get_month_is_null(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window4_get_month_value(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window4_get_amount_is_null(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window4_get_amount_value(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window4_get_SalesMovingAverage_is_null(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window4_get_SalesMovingAverage_value(window4_result_set_ref _Nonnull result_set, cql_int32 row) {
  window4_row *data = (window4_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window4_data_types[window4_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window4_col_offsets[] = { 3,
  cql_offsetof(window4_row, month),
  cql_offsetof(window4_row, amount),
  cql_offsetof(window4_row, SalesMovingAverage)
};

cql_int32 window4_result_count(window4_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window4_fetch_results(sqlite3 *_Nonnull _db_, window4_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window4, &window4_perf_index);
  cql_code rc = window4(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window4_data_types,
    .col_offsets = window4_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window4_row),
    .crc = CRC_window4,
    .perf_index = &window4_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window4 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window4(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window5 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window5"
static int32_t window5_perf_index;

cql_string_proc_name(window5_stored_procedure_name, "window5");

typedef struct window5_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window5_row;

cql_bool window5_get_month_is_null(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window5_get_month_value(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window5_get_amount_is_null(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window5_get_amount_value(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window5_get_SalesMovingAverage_is_null(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window5_get_SalesMovingAverage_value(window5_result_set_ref _Nonnull result_set, cql_int32 row) {
  window5_row *data = (window5_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window5_data_types[window5_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window5_col_offsets[] = { 3,
  cql_offsetof(window5_row, month),
  cql_offsetof(window5_row, amount),
  cql_offsetof(window5_row, SalesMovingAverage)
};

cql_int32 window5_result_count(window5_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window5_fetch_results(sqlite3 *_Nonnull _db_, window5_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window5, &window5_perf_index);
  cql_code rc = window5(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window5_data_types,
    .col_offsets = window5_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window5_row),
    .crc = CRC_window5,
    .perf_index = &window5_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window5 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window5(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window6 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window6"
static int32_t window6_perf_index;

cql_string_proc_name(window6_stored_procedure_name, "window6");

typedef struct window6_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window6_row;

cql_bool window6_get_month_is_null(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window6_get_month_value(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window6_get_amount_is_null(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window6_get_amount_value(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window6_get_SalesMovingAverage_is_null(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window6_get_SalesMovingAverage_value(window6_result_set_ref _Nonnull result_set, cql_int32 row) {
  window6_row *data = (window6_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window6_data_types[window6_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window6_col_offsets[] = { 3,
  cql_offsetof(window6_row, month),
  cql_offsetof(window6_row, amount),
  cql_offsetof(window6_row, SalesMovingAverage)
};

cql_int32 window6_result_count(window6_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window6_fetch_results(sqlite3 *_Nonnull _db_, window6_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window6, &window6_perf_index);
  cql_code rc = window6(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window6_data_types,
    .col_offsets = window6_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window6_row),
    .crc = CRC_window6,
    .perf_index = &window6_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window6 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window6(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window7 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window7"
static int32_t window7_perf_index;

cql_string_proc_name(window7_stored_procedure_name, "window7");

typedef struct window7_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window7_row;

cql_bool window7_get_month_is_null(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window7_get_month_value(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window7_get_amount_is_null(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window7_get_amount_value(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window7_get_SalesMovingAverage_is_null(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window7_get_SalesMovingAverage_value(window7_result_set_ref _Nonnull result_set, cql_int32 row) {
  window7_row *data = (window7_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window7_data_types[window7_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window7_col_offsets[] = { 3,
  cql_offsetof(window7_row, month),
  cql_offsetof(window7_row, amount),
  cql_offsetof(window7_row, SalesMovingAverage)
};

cql_int32 window7_result_count(window7_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window7_fetch_results(sqlite3 *_Nonnull _db_, window7_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window7, &window7_perf_index);
  cql_code rc = window7(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window7_data_types,
    .col_offsets = window7_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window7_row),
    .crc = CRC_window7,
    .perf_index = &window7_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window7 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window7(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window8 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window8"
static int32_t window8_perf_index;

cql_string_proc_name(window8_stored_procedure_name, "window8");

typedef struct window8_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window8_row;

cql_bool window8_get_month_is_null(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window8_get_month_value(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window8_get_amount_is_null(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window8_get_amount_value(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window8_get_SalesMovingAverage_is_null(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window8_get_SalesMovingAverage_value(window8_result_set_ref _Nonnull result_set, cql_int32 row) {
  window8_row *data = (window8_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window8_data_types[window8_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window8_col_offsets[] = { 3,
  cql_offsetof(window8_row, month),
  cql_offsetof(window8_row, amount),
  cql_offsetof(window8_row, SalesMovingAverage)
};

cql_int32 window8_result_count(window8_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window8_fetch_results(sqlite3 *_Nonnull _db_, window8_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window8, &window8_perf_index);
  cql_code rc = window8(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window8_data_types,
    .col_offsets = window8_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window8_row),
    .crc = CRC_window8,
    .perf_index = &window8_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window8 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window8(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window9 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window9"
static int32_t window9_perf_index;

cql_string_proc_name(window9_stored_procedure_name, "window9");

typedef struct window9_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window9_row;

cql_bool window9_get_month_is_null(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window9_get_month_value(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window9_get_amount_is_null(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window9_get_amount_value(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window9_get_SalesMovingAverage_is_null(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window9_get_SalesMovingAverage_value(window9_result_set_ref _Nonnull result_set, cql_int32 row) {
  window9_row *data = (window9_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window9_data_types[window9_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window9_col_offsets[] = { 3,
  cql_offsetof(window9_row, month),
  cql_offsetof(window9_row, amount),
  cql_offsetof(window9_row, SalesMovingAverage)
};

cql_int32 window9_result_count(window9_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window9_fetch_results(sqlite3 *_Nonnull _db_, window9_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window9, &window9_perf_index);
  cql_code rc = window9(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window9_data_types,
    .col_offsets = window9_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window9_row),
    .crc = CRC_window9,
    .perf_index = &window9_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window9 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window9(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window10 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window10"
static int32_t window10_perf_index;

cql_string_proc_name(window10_stored_procedure_name, "window10");

typedef struct window10_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window10_row;

cql_bool window10_get_month_is_null(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window10_get_month_value(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window10_get_amount_is_null(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window10_get_amount_value(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window10_get_SalesMovingAverage_is_null(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window10_get_SalesMovingAverage_value(window10_result_set_ref _Nonnull result_set, cql_int32 row) {
  window10_row *data = (window10_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window10_data_types[window10_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window10_col_offsets[] = { 3,
  cql_offsetof(window10_row, month),
  cql_offsetof(window10_row, amount),
  cql_offsetof(window10_row, SalesMovingAverage)
};

cql_int32 window10_result_count(window10_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window10_fetch_results(sqlite3 *_Nonnull _db_, window10_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window10, &window10_perf_index);
  cql_code rc = window10(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window10_data_types,
    .col_offsets = window10_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window10_row),
    .crc = CRC_window10,
    .perf_index = &window10_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window10 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window10(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window11 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window11"
static int32_t window11_perf_index;

cql_string_proc_name(window11_stored_procedure_name, "window11");

typedef struct window11_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window11_row;

cql_bool window11_get_month_is_null(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window11_get_month_value(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window11_get_amount_is_null(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window11_get_amount_value(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window11_get_SalesMovingAverage_is_null(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window11_get_SalesMovingAverage_value(window11_result_set_ref _Nonnull result_set, cql_int32 row) {
  window11_row *data = (window11_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window11_data_types[window11_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window11_col_offsets[] = { 3,
  cql_offsetof(window11_row, month),
  cql_offsetof(window11_row, amount),
  cql_offsetof(window11_row, SalesMovingAverage)
};

cql_int32 window11_result_count(window11_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window11_fetch_results(sqlite3 *_Nonnull _db_, window11_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window11, &window11_perf_index);
  cql_code rc = window11(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window11_data_types,
    .col_offsets = window11_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window11_row),
    .crc = CRC_window11,
    .perf_index = &window11_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window11 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window11(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window12 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window12"
static int32_t window12_perf_index;

cql_string_proc_name(window12_stored_procedure_name, "window12");

typedef struct window12_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window12_row;

cql_bool window12_get_month_is_null(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window12_get_month_value(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window12_get_amount_is_null(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window12_get_amount_value(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window12_get_SalesMovingAverage_is_null(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window12_get_SalesMovingAverage_value(window12_result_set_ref _Nonnull result_set, cql_int32 row) {
  window12_row *data = (window12_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window12_data_types[window12_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window12_col_offsets[] = { 3,
  cql_offsetof(window12_row, month),
  cql_offsetof(window12_row, amount),
  cql_offsetof(window12_row, SalesMovingAverage)
};

cql_int32 window12_result_count(window12_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window12_fetch_results(sqlite3 *_Nonnull _db_, window12_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window12, &window12_perf_index);
  cql_code rc = window12(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window12_data_types,
    .col_offsets = window12_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window12_row),
    .crc = CRC_window12,
    .perf_index = &window12_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window12 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window12(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window13 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window13"
static int32_t window13_perf_index;

cql_string_proc_name(window13_stored_procedure_name, "window13");

typedef struct window13_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window13_row;

cql_bool window13_get_month_is_null(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window13_get_month_value(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window13_get_amount_is_null(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window13_get_amount_value(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window13_get_SalesMovingAverage_is_null(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window13_get_SalesMovingAverage_value(window13_result_set_ref _Nonnull result_set, cql_int32 row) {
  window13_row *data = (window13_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window13_data_types[window13_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window13_col_offsets[] = { 3,
  cql_offsetof(window13_row, month),
  cql_offsetof(window13_row, amount),
  cql_offsetof(window13_row, SalesMovingAverage)
};

cql_int32 window13_result_count(window13_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window13_fetch_results(sqlite3 *_Nonnull _db_, window13_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window13, &window13_perf_index);
  cql_code rc = window13(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window13_data_types,
    .col_offsets = window13_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window13_row),
    .crc = CRC_window13,
    .perf_index = &window13_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window13 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window13(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window14 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window14"
static int32_t window14_perf_index;

cql_string_proc_name(window14_stored_procedure_name, "window14");

typedef struct window14_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window14_row;

cql_bool window14_get_month_is_null(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window14_get_month_value(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window14_get_amount_is_null(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window14_get_amount_value(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window14_get_SalesMovingAverage_is_null(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window14_get_SalesMovingAverage_value(window14_result_set_ref _Nonnull result_set, cql_int32 row) {
  window14_row *data = (window14_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window14_data_types[window14_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window14_col_offsets[] = { 3,
  cql_offsetof(window14_row, month),
  cql_offsetof(window14_row, amount),
  cql_offsetof(window14_row, SalesMovingAverage)
};

cql_int32 window14_result_count(window14_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window14_fetch_results(sqlite3 *_Nonnull _db_, window14_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window14, &window14_perf_index);
  cql_code rc = window14(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window14_data_types,
    .col_offsets = window14_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window14_row),
    .crc = CRC_window14,
    .perf_index = &window14_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window14 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window14(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window15 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window15"
static int32_t window15_perf_index;

cql_string_proc_name(window15_stored_procedure_name, "window15");

typedef struct window15_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window15_row;

cql_bool window15_get_month_is_null(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window15_get_month_value(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window15_get_amount_is_null(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window15_get_amount_value(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window15_get_SalesMovingAverage_is_null(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window15_get_SalesMovingAverage_value(window15_result_set_ref _Nonnull result_set, cql_int32 row) {
  window15_row *data = (window15_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window15_data_types[window15_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window15_col_offsets[] = { 3,
  cql_offsetof(window15_row, month),
  cql_offsetof(window15_row, amount),
  cql_offsetof(window15_row, SalesMovingAverage)
};

cql_int32 window15_result_count(window15_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window15_fetch_results(sqlite3 *_Nonnull _db_, window15_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window15, &window15_perf_index);
  cql_code rc = window15(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window15_data_types,
    .col_offsets = window15_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window15_row),
    .crc = CRC_window15,
    .perf_index = &window15_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window15 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window15(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC window16 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (GROUPS CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
*/

#define _PROC_ "window16"
static int32_t window16_perf_index;

cql_string_proc_name(window16_stored_procedure_name, "window16");

typedef struct window16_row {
  cql_nullable_int32 month;
  cql_nullable_double amount;
  cql_nullable_double SalesMovingAverage;
} window16_row;

cql_bool window16_get_month_is_null(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.is_null;
}

cql_int32 window16_get_month_value(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].month.value;
}

cql_bool window16_get_amount_is_null(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.is_null;
}

cql_double window16_get_amount_value(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].amount.value;
}

cql_bool window16_get_SalesMovingAverage_is_null(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.is_null;
}

cql_double window16_get_SalesMovingAverage_value(window16_result_set_ref _Nonnull result_set, cql_int32 row) {
  window16_row *data = (window16_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].SalesMovingAverage.value;
}

uint8_t window16_data_types[window16_data_types_count] = {
  CQL_DATA_TYPE_INT32, // month
  CQL_DATA_TYPE_DOUBLE, // amount
  CQL_DATA_TYPE_DOUBLE, // SalesMovingAverage
};

static cql_uint16 window16_col_offsets[] = { 3,
  cql_offsetof(window16_row, month),
  cql_offsetof(window16_row, amount),
  cql_offsetof(window16_row, SalesMovingAverage)
};

cql_int32 window16_result_count(window16_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code window16_fetch_results(sqlite3 *_Nonnull _db_, window16_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_window16, &window16_perf_index);
  cql_code rc = window16(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = window16_data_types,
    .col_offsets = window16_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(window16_row),
    .crc = CRC_window16,
    .perf_index = &window16_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC window16 () (month INTEGER, amount REAL, SalesMovingAverage REAL);
CQL_WARN_UNUSED cql_code window16(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT month, amount,  "
      "AVG(amount) OVER (GROUPS CURRENT ROW) "
      "FROM SalesInfo");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC emit_rc (OUT result_code INTEGER NOT NULL)
BEGIN
  SET result_code := @RC;
END;
*/

#define _PROC_ "emit_rc"
// export: DECLARE PROC emit_rc (OUT result_code INTEGER NOT NULL) USING TRANSACTION;
CQL_WARN_UNUSED cql_code emit_rc(sqlite3 *_Nonnull _db_, cql_int32 *_Nonnull result_code) {
  cql_contract_argument_notnull((void *)result_code, 1);

  cql_code _rc_ = SQLITE_OK;
  *result_code = 0; // set out arg to non-garbage
  *result_code = SQLITE_OK;
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC rc_test ()
BEGIN
  LET err := @RC;
  LET e0 := @RC;
  BEGIN TRY
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      SET err := @RC;
      LET e1 := @RC;
      BEGIN TRY
        LET e2 := @RC;
        CREATE TABLE whatever_anything(
          id INTEGER
        );
      END TRY;
      BEGIN CATCH
        LET e3 := @RC;
        SET err := @RC;
        THROW;
      END CATCH;
      LET e4 := @RC;
    END CATCH;
  END TRY;
  BEGIN CATCH
    LET e5 := @RC;
    CALL printf("Error %d\n", err);
  END CATCH;
  LET e6 := @RC;
END;
*/

#define _PROC_ "rc_test"
// export: DECLARE PROC rc_test () USING TRANSACTION;
CQL_WARN_UNUSED cql_code rc_test(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_int32 err = 0;
  cql_int32 e0 = 0;
  cql_int32 e1 = 0;
  cql_int32 e2 = 0;
  cql_int32 e3 = 0;
  cql_int32 e4 = 0;
  cql_int32 e5 = 0;
  cql_int32 e6 = 0;

  err = SQLITE_OK;
  e0 = SQLITE_OK;
  // try
  {
    // try
    {
      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( "
          "id INTEGER "
        ")");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_12; }
      goto catch_end_12;
    }
    catch_start_12: {
      int32_t _rc_thrown_1 = _rc_;
      err = _rc_thrown_1;
      e1 = _rc_thrown_1;
      // try
      {
        e2 = _rc_thrown_1;
        _rc_ = cql_exec(_db_,
          "CREATE TABLE whatever_anything( "
            "id INTEGER "
          ")");
        if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_13; }
        goto catch_end_13;
      }
      catch_start_13: {
        int32_t _rc_thrown_2 = _rc_;
        e3 = _rc_thrown_2;
        err = _rc_thrown_2;
        _rc_ = cql_best_error(_rc_thrown_2);
        goto catch_start_11;
      }
      catch_end_13:;
      e4 = _rc_thrown_1;
    }
    catch_end_12:;
    goto catch_end_11;
  }
  catch_start_11: {
    int32_t _rc_thrown_3 = _rc_;
    e5 = _rc_thrown_3;
    printf("Error %d\n", err);
  }
  catch_end_11:;
  e6 = SQLITE_OK;
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC rc_test_lazy1 ()
BEGIN
  BEGIN TRY
    CREATE TABLE whatever_anything(
      id INTEGER
    );
  END TRY;
  BEGIN CATCH
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      THROW;
    END CATCH;
  END CATCH;
END;
*/

#define _PROC_ "rc_test_lazy1"
// export: DECLARE PROC rc_test_lazy1 () USING TRANSACTION;
CQL_WARN_UNUSED cql_code rc_test_lazy1(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  // try
  {
    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( "
        "id INTEGER "
      ")");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_14; }
    goto catch_end_14;
  }
  catch_start_14: {
    // try
    {
      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( "
          "id INTEGER "
        ")");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_15; }
      goto catch_end_15;
    }
    catch_start_15: {
      int32_t _rc_thrown_2 = _rc_;
      _rc_ = cql_best_error(_rc_thrown_2);
      goto cql_cleanup;
    }
    catch_end_15:;
  }
  catch_end_14:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC rc_test_lazy2 ()
BEGIN
  BEGIN TRY
    CREATE TABLE whatever_anything(
      id INTEGER
    );
  END TRY;
  BEGIN CATCH
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      LET err := @RC;
    END CATCH;
  END CATCH;
END;
*/

#define _PROC_ "rc_test_lazy2"
// export: DECLARE PROC rc_test_lazy2 () USING TRANSACTION;
CQL_WARN_UNUSED cql_code rc_test_lazy2(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_int32 err = 0;

  // try
  {
    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( "
        "id INTEGER "
      ")");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_16; }
    goto catch_end_16;
  }
  catch_start_16: {
    // try
    {
      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( "
          "id INTEGER "
        ")");
      if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_17; }
      goto catch_end_17;
    }
    catch_start_17: {
      int32_t _rc_thrown_2 = _rc_;
      err = _rc_thrown_2;
    }
    catch_end_17:;
  }
  catch_end_16:;
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC virtual_table_creator ()
BEGIN
  CREATE VIRTUAL TABLE virt_table USING virt_module (ARGUMENTS FOLLOWING) AS (
    id INTEGER,
    t TEXT
  );
END;
*/

#define _PROC_ "virtual_table_creator"
// export: DECLARE PROC virtual_table_creator () USING TRANSACTION;
CQL_WARN_UNUSED cql_code virtual_table_creator(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE virt_table USING virt_module ( "
      "id INTEGER, "
      "t TEXT)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_arg_cursor (x INTEGER NOT NULL, OUT y INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_arg_cursor ARGUMENTS;
  FETCH C(x, y) FROM VALUES(1, 1);
  CALL out_arg_cursor(C.x, C.y);
END;
*/

#define _PROC_ "out_arg_cursor"
// export: DECLARE PROC out_arg_cursor (x INTEGER NOT NULL, OUT y INTEGER NOT NULL);

typedef struct out_arg_cursor_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 x;
  cql_int32 y;
} out_arg_cursor_C_row;
void out_arg_cursor(cql_int32 x, cql_int32 *_Nonnull y) {
  cql_contract_argument_notnull((void *)y, 2);

  out_arg_cursor_C_row C = { 0 };

  *y = 0; // set out arg to non-garbage
  C._has_row_ = 1;
  C.x = 1;
  C.y = 1;
  out_arg_cursor(C.x, &C.y);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC make_virt_table ()
BEGIN
  CREATE VIRTUAL TABLE v1 USING m1 AS (
    id INTEGER
  );
  CREATE VIRTUAL TABLE v2 USING m2 (x) AS (
    id INTEGER
  );
  CREATE VIRTUAL TABLE v3 USING m2 (ARGUMENTS FOLLOWING) AS (
    id INTEGER
  );
END;
*/

#define _PROC_ "make_virt_table"
// export: DECLARE PROC make_virt_table () USING TRANSACTION;
CQL_WARN_UNUSED cql_code make_virt_table(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v1 USING m1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v2 USING m2 (x)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v3 USING m2 ( "
      "id INTEGER)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC virtual1 ()
BEGIN
  SELECT *
    FROM virtual_with_hidden;
END;
*/

#define _PROC_ "virtual1"
static int32_t virtual1_perf_index;

cql_string_proc_name(virtual1_stored_procedure_name, "virtual1");

typedef struct virtual1_row {
  cql_int32 vx;
  cql_nullable_int32 vy;
} virtual1_row;

cql_int32 virtual1_get_vx(virtual1_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual1_row *data = (virtual1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vx;
}

cql_bool virtual1_get_vy_is_null(virtual1_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual1_row *data = (virtual1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vy.is_null;
}

cql_int32 virtual1_get_vy_value(virtual1_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual1_row *data = (virtual1_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vy.value;
}

uint8_t virtual1_data_types[virtual1_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // vx
  CQL_DATA_TYPE_INT32, // vy
};

static cql_uint16 virtual1_col_offsets[] = { 2,
  cql_offsetof(virtual1_row, vx),
  cql_offsetof(virtual1_row, vy)
};

cql_int32 virtual1_result_count(virtual1_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code virtual1_fetch_results(sqlite3 *_Nonnull _db_, virtual1_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_virtual1, &virtual1_perf_index);
  cql_code rc = virtual1(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = virtual1_data_types,
    .col_offsets = virtual1_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(virtual1_row),
    .crc = CRC_virtual1,
    .perf_index = &virtual1_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC virtual1 () (vx INTEGER NOT NULL, vy INTEGER);
CQL_WARN_UNUSED cql_code virtual1(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT vy "
      "FROM virtual_with_hidden");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC virtual2 ()
BEGIN
  SELECT vx, vy
    FROM virtual_with_hidden
    WHERE vx = 2;
END;
*/

#define _PROC_ "virtual2"
static int32_t virtual2_perf_index;

cql_string_proc_name(virtual2_stored_procedure_name, "virtual2");

typedef struct virtual2_row {
  cql_int32 vx;
  cql_nullable_int32 vy;
} virtual2_row;

cql_int32 virtual2_get_vx(virtual2_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual2_row *data = (virtual2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vx;
}

cql_bool virtual2_get_vy_is_null(virtual2_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual2_row *data = (virtual2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vy.is_null;
}

cql_int32 virtual2_get_vy_value(virtual2_result_set_ref _Nonnull result_set, cql_int32 row) {
  virtual2_row *data = (virtual2_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].vy.value;
}

uint8_t virtual2_data_types[virtual2_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // vx
  CQL_DATA_TYPE_INT32, // vy
};

static cql_uint16 virtual2_col_offsets[] = { 2,
  cql_offsetof(virtual2_row, vx),
  cql_offsetof(virtual2_row, vy)
};

cql_int32 virtual2_result_count(virtual2_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code virtual2_fetch_results(sqlite3 *_Nonnull _db_, virtual2_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_virtual2, &virtual2_perf_index);
  cql_code rc = virtual2(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = virtual2_data_types,
    .col_offsets = virtual2_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(virtual2_row),
    .crc = CRC_virtual2,
    .perf_index = &virtual2_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC virtual2 () (vx INTEGER NOT NULL, vy INTEGER);
CQL_WARN_UNUSED cql_code virtual2(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT vx, vy "
      "FROM virtual_with_hidden "
      "WHERE vx = 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
CREATE PROC private_proc (OUT x INTEGER)
BEGIN
  SET x := 1;
END;
*/

#define _PROC_ "private_proc"
// private: DECLARE PROC private_proc (OUT x INTEGER);
static void private_proc(cql_nullable_int32 *_Nonnull x) {
  cql_set_null(*x); // set out arg to non-garbage
  cql_set_notnull(*x, 1);

}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
CREATE PROC private_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
*/

#define _PROC_ "private_out_union_fetch_results"
static int32_t private_out_union_perf_index;

cql_string_proc_name(private_out_union_stored_procedure_name, "private_out_union");

uint8_t private_out_union_data_types[private_out_union_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a_field
};

static cql_uint16 private_out_union_col_offsets[] = { 1,
  cql_offsetof(private_out_union_row, a_field)
};

cql_int32 private_out_union_result_count(private_out_union_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info private_out_union_info = {
  .rc = SQLITE_OK,
  .data_types = private_out_union_data_types,
  .col_offsets = private_out_union_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(private_out_union_row),
  .crc = CRC_private_out_union,
  .perf_index = &private_out_union_perf_index,
};
// private: DECLARE PROC private_out_union () OUT UNION (a_field INTEGER NOT NULL);

typedef struct private_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} private_out_union_C_row;
static void private_out_union_fetch_results(private_out_union_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  private_out_union_C_row C = { 0 };

  cql_profile_start(CRC_private_out_union, &private_out_union_perf_index);
  C._has_row_ = 1;
  C.a_field = 1;
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));

  cql_results_from_data(SQLITE_OK, &_rows_, &private_out_union_info, (cql_result_set_ref *)_result_set_);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_private_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL private_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
*/

#define _PROC_ "use_private_out_union"
// export: DECLARE PROC use_private_out_union () USING TRANSACTION;

typedef struct use_private_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} use_private_out_union_C_row;
CQL_WARN_UNUSED cql_code use_private_out_union(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  private_out_union_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  use_private_out_union_C_row C = { 0 };

  private_out_union_fetch_results(&C_result_set_);
  C_row_num_ = C_row_count_ = -1;
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  for (;;) {
    C_row_num_++;
    C._has_row_ = C_row_num_ < C_row_count_;
    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.a_field);
    if (!C._has_row_) break;
    printf("%d\n", C.a_field);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:suppress_getters)
CREATE PROC no_getters_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
*/

#define _PROC_ "no_getters_out_union_fetch_results"
static int32_t no_getters_out_union_perf_index;

cql_string_proc_name(no_getters_out_union_stored_procedure_name, "no_getters_out_union");

uint8_t no_getters_out_union_data_types[no_getters_out_union_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a_field
};

static cql_uint16 no_getters_out_union_col_offsets[] = { 1,
  cql_offsetof(no_getters_out_union_row, a_field)
};

cql_int32 no_getters_out_union_result_count(no_getters_out_union_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info no_getters_out_union_info = {
  .rc = SQLITE_OK,
  .data_types = no_getters_out_union_data_types,
  .col_offsets = no_getters_out_union_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(no_getters_out_union_row),
  .crc = CRC_no_getters_out_union,
  .perf_index = &no_getters_out_union_perf_index,
};
// export: DECLARE PROC no_getters_out_union () OUT UNION (a_field INTEGER NOT NULL);

typedef struct no_getters_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} no_getters_out_union_C_row;
void no_getters_out_union_fetch_results(no_getters_out_union_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  no_getters_out_union_C_row C = { 0 };

  cql_profile_start(CRC_no_getters_out_union, &no_getters_out_union_perf_index);
  C._has_row_ = 1;
  C.a_field = 1;
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));

  cql_results_from_data(SQLITE_OK, &_rows_, &no_getters_out_union_info, (cql_result_set_ref *)_result_set_);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_no_getters_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL no_getters_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
*/

#define _PROC_ "use_no_getters_out_union"
// export: DECLARE PROC use_no_getters_out_union () USING TRANSACTION;

typedef struct use_no_getters_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} use_no_getters_out_union_C_row;
CQL_WARN_UNUSED cql_code use_no_getters_out_union(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  no_getters_out_union_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  use_no_getters_out_union_C_row C = { 0 };

  no_getters_out_union_fetch_results(&C_result_set_);
  C_row_num_ = C_row_count_ = -1;
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  for (;;) {
    C_row_num_++;
    C._has_row_ = C_row_num_ < C_row_count_;
    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.a_field);
    if (!C._has_row_) break;
    printf("%d\n", C.a_field);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC suppress_results_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
*/

#define _PROC_ "suppress_results_out_union_fetch_results"
static int32_t suppress_results_out_union_perf_index;

cql_string_proc_name(suppress_results_out_union_stored_procedure_name, "suppress_results_out_union");

uint8_t suppress_results_out_union_data_types[suppress_results_out_union_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // a_field
};

static cql_uint16 suppress_results_out_union_col_offsets[] = { 1,
  cql_offsetof(suppress_results_out_union_row, a_field)
};

cql_int32 suppress_results_out_union_result_count(suppress_results_out_union_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}
cql_fetch_info suppress_results_out_union_info = {
  .rc = SQLITE_OK,
  .data_types = suppress_results_out_union_data_types,
  .col_offsets = suppress_results_out_union_col_offsets,
  .encode_context_index = -1,
  .rowsize = sizeof(suppress_results_out_union_row),
  .crc = CRC_suppress_results_out_union,
  .perf_index = &suppress_results_out_union_perf_index,
};
// export: DECLARE PROC suppress_results_out_union () OUT UNION (a_field INTEGER NOT NULL);

typedef struct suppress_results_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} suppress_results_out_union_C_row;
void suppress_results_out_union_fetch_results(suppress_results_out_union_result_set_ref _Nullable *_Nonnull _result_set_) {
  cql_bytebuf _rows_;
  cql_bytebuf_open(&_rows_);
  *_result_set_ = NULL;
  suppress_results_out_union_C_row C = { 0 };

  cql_profile_start(CRC_suppress_results_out_union, &suppress_results_out_union_perf_index);
  C._has_row_ = 1;
  C.a_field = 1;
  cql_retain_row(C);
  if (C._has_row_) cql_bytebuf_append(&_rows_, (const void *)&C, sizeof(C));

  cql_results_from_data(SQLITE_OK, &_rows_, &suppress_results_out_union_info, (cql_result_set_ref *)_result_set_);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_suppress_results_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL suppress_results_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
*/

#define _PROC_ "use_suppress_results_out_union"
// export: DECLARE PROC use_suppress_results_out_union () USING TRANSACTION;

typedef struct use_suppress_results_out_union_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 a_field;
} use_suppress_results_out_union_C_row;
CQL_WARN_UNUSED cql_code use_suppress_results_out_union(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  suppress_results_out_union_result_set_ref C_result_set_ = NULL;
  cql_int32 C_row_num_ = 0;
  cql_int32 C_row_count_ = 0;
  use_suppress_results_out_union_C_row C = { 0 };

  suppress_results_out_union_fetch_results(&C_result_set_);
  C_row_num_ = C_row_count_ = -1;
  C_row_count_ = cql_result_set_get_count((cql_result_set_ref)C_result_set_);
  for (;;) {
    C_row_num_++;
    C._has_row_ = C_row_num_ < C_row_count_;
    cql_copyoutrow(NULL, (cql_result_set_ref)C_result_set_, C_row_num_, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.a_field);
    if (!C._has_row_) break;
    printf("%d\n", C.a_field);
  }
  _rc_ = SQLITE_OK;

  cql_object_release(C_result_set_);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
CREATE PROC private_result (OUT x INTEGER)
BEGIN
  SELECT 1 AS x;
END;
*/

#define _PROC_ "private_result"
// private: DECLARE PROC private_result (OUT x INTEGER) (x INTEGER NOT NULL);
static CQL_WARN_UNUSED cql_code private_result(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_nullable_int32 *_Nonnull x) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_set_null(*x); // set out arg to non-garbage
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
DECLARE PROC private_fwd_ref (x INTEGER NOT NULL);
*/
static void private_fwd_ref(cql_int32 x);


// The statement ending at line XXXX

/*
CREATE PROC set_out_arg_ref_test (OUT x TEXT)
BEGIN
END;
*/

#define _PROC_ "set_out_arg_ref_test"
// export: DECLARE PROC set_out_arg_ref_test (OUT x TEXT);
void set_out_arg_ref_test(cql_string_ref _Nullable *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  *(void **)x = NULL; // set out arg to non-garbage

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC set_out_arg_null_test (OUT x INTEGER)
BEGIN
END;
*/

#define _PROC_ "set_out_arg_null_test"
// export: DECLARE PROC set_out_arg_null_test (OUT x INTEGER);
void set_out_arg_null_test(cql_nullable_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  cql_set_null(*x); // set out arg to non-garbage

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC set_out_arg_notnull_test (OUT x INTEGER NOT NULL)
BEGIN
END;
*/

#define _PROC_ "set_out_arg_notnull_test"
// export: DECLARE PROC set_out_arg_notnull_test (OUT x INTEGER NOT NULL);
void set_out_arg_notnull_test(cql_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  *x = 0; // set out arg to non-garbage

}
#undef _PROC_
global_cursor2_row global_cursor2 = { ._refs_count_ = 1, ._refs_offset_ = global_cursor2_refs_offset };

// The statement ending at line XXXX

/*
CREATE PROC early_close_cursor ()
BEGIN
  CLOSE global_cursor;
  CLOSE global_cursor2;
END;
*/

#define _PROC_ "early_close_cursor"
// export: DECLARE PROC early_close_cursor () USING TRANSACTION;
CQL_WARN_UNUSED cql_code early_close_cursor(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_finalize_stmt(&global_cursor_stmt);
  cql_teardown_row(global_cursor2);
  _rc_ = SQLITE_OK;

  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC various_lets ()
BEGIN
  LET r := 1.0;
  LET i := 1;
  LET l := 1L;
  LET t := "T";
  LET nl := nullable(~2L);
  LET ni := nullable(2 + 2);
  LET nr := nullable(2.0);
  LET nt := nullable("NT");
  LET sl := sensitive(~3L);
  LET si := sensitive(3 + 3);
  LET sr := sensitive(3.0);
  LET st := sensitive("ST");
END;
*/

#define _PROC_ "various_lets"
// export: DECLARE PROC various_lets ();
void various_lets(void) {
  cql_double r = 0;
  cql_int32 i = 0;
  cql_int64 l = 0;
  cql_string_ref t = NULL;
  cql_nullable_int64 nl;
  cql_set_null(nl);
  cql_nullable_int32 ni;
  cql_set_null(ni);
  cql_nullable_double nr;
  cql_set_null(nr);
  cql_string_ref nt = NULL;
  cql_int64 sl = 0;
  cql_int32 si = 0;
  cql_double sr = 0;
  cql_string_ref st = NULL;

  r = 1.0;
  i = 1;
  l = _64(1);
  cql_set_string_ref(&t, _literal_14_T_various_lets);
  cql_set_notnull(nl, (~_64(2)));
  cql_set_notnull(ni, (2 + 2));
  cql_set_notnull(nr, 2.0);
  cql_set_string_ref(&nt, _literal_15_NT_various_lets);
  sl = (~_64(3));
  si = (3 + 3);
  sr = 3.0;
  cql_set_string_ref(&st, _literal_16_ST_various_lets);

  cql_string_release(t);
  cql_string_release(nt);
  cql_string_release(st);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC try_catch_rc ()
BEGIN
  DECLARE C CURSOR FOR SELECT 'foo' AS extra2
    FROM bar;
  BEGIN TRY
    FETCH C;
  END TRY;
  BEGIN CATCH
  END CATCH;
END;
*/

#define _PROC_ "try_catch_rc"
// export: DECLARE PROC try_catch_rc () USING TRANSACTION;

typedef struct try_catch_rc_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_string_ref _Nonnull extra2;
} try_catch_rc_C_row;

#define try_catch_rc_C_refs_offset cql_offsetof(try_catch_rc_C_row, extra2) // count = 1
CQL_WARN_UNUSED cql_code try_catch_rc(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  try_catch_rc_C_row C = { ._refs_count_ = 1, ._refs_offset_ = try_catch_rc_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT 'foo' "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  // try
  {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.extra2);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto catch_start_18; }
    goto catch_end_18;
  }
  catch_start_18: {
  }
  catch_end_18:;
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE PROC out2_proc (x INTEGER, OUT y INTEGER NOT NULL, OUT z INTEGER NOT NULL);
*/

// The statement ending at line XXXX

/*
CREATE PROC out_decl_test (x INTEGER)
BEGIN
  DECLARE OUT CALL out2_proc(x, u, v);
  DECLARE OUT CALL out2_proc(x, u, v);
END;
*/

#define _PROC_ "out_decl_test"
// export: DECLARE PROC out_decl_test (x INTEGER);
void out_decl_test(cql_nullable_int32 x) {
  cql_int32 u = 0;
  cql_int32 v = 0;

  out2_proc(x, &u, &v);
  out2_proc(x, &u, &v);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_decl_loop_test (x INTEGER)
BEGIN
  WHILE 1
  BEGIN
    DECLARE OUT CALL out2_proc(x, u, v);
    DECLARE OUT CALL out2_proc(x, u, v);
  END;
END;
*/

#define _PROC_ "out_decl_loop_test"
// export: DECLARE PROC out_decl_loop_test (x INTEGER);
void out_decl_loop_test(cql_nullable_int32 x) {
  cql_int32 u = 0;
  cql_int32 v = 0;

  for (;;) {
  if (!(1)) break;
    out2_proc(x, &u, &v);
    out2_proc(x, &u, &v);
  }

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC binary_ops_with_null ()
BEGIN
  LET add0 := NULL + 42;
  LET add1 := 42 + NULL;
  LET bin_and0 := NULL & 42;
  LET bin_and1 := 42 & NULL;
  LET bin_or0 := NULL | 42;
  LET bin_or1 := 42 | NULL;
  LET div0 := NULL / 42;
  LET div1 := 42 / NULL;
  LET ge0 := NULL >= 42;
  LET ge1 := 42 >= NULL;
  LET gt0 := NULL > 42;
  LET gt1 := 42 > NULL;
  LET le0 := NULL <= 42;
  LET le1 := 42 <= NULL;
  LET like0 := NULL LIKE "foo";
  LET like1 := "foo" LIKE NULL;
  LET lshift0 := NULL << 42;
  LET lshift1 := 42 << NULL;
  LET lt0 := NULL < 42;
  LET lt1 := 42 < NULL;
  LET mod0 := NULL % 42;
  LET mod1 := 42 % NULL;
  LET mul0 := NULL * 42;
  LET mul1 := 42 * NULL;
  LET not_like0 := NULL NOT LIKE "foo";
  LET not_like1 := "foo" NOT LIKE NULL;
  LET rshift0 := NULL >> 42;
  LET rshift1 := 42 >> NULL;
  LET sub0 := NULL - 42;
  LET sub1 := 42 - NULL;
END;
*/

#define _PROC_ "binary_ops_with_null"
// export: DECLARE PROC binary_ops_with_null ();
void binary_ops_with_null(void) {
  cql_nullable_int32 add0;
  cql_set_null(add0);
  cql_nullable_int32 add1;
  cql_set_null(add1);
  cql_nullable_int32 bin_and0;
  cql_set_null(bin_and0);
  cql_nullable_int32 bin_and1;
  cql_set_null(bin_and1);
  cql_nullable_int32 bin_or0;
  cql_set_null(bin_or0);
  cql_nullable_int32 bin_or1;
  cql_set_null(bin_or1);
  cql_nullable_int32 div0;
  cql_set_null(div0);
  cql_nullable_int32 div1;
  cql_set_null(div1);
  cql_nullable_bool ge0;
  cql_set_null(ge0);
  cql_nullable_bool ge1;
  cql_set_null(ge1);
  cql_nullable_bool gt0;
  cql_set_null(gt0);
  cql_nullable_bool gt1;
  cql_set_null(gt1);
  cql_nullable_bool le0;
  cql_set_null(le0);
  cql_nullable_bool le1;
  cql_set_null(le1);
  cql_nullable_bool like0;
  cql_set_null(like0);
  cql_nullable_bool like1;
  cql_set_null(like1);
  cql_nullable_int32 lshift0;
  cql_set_null(lshift0);
  cql_nullable_int32 lshift1;
  cql_set_null(lshift1);
  cql_nullable_bool lt0;
  cql_set_null(lt0);
  cql_nullable_bool lt1;
  cql_set_null(lt1);
  cql_nullable_int32 mod0;
  cql_set_null(mod0);
  cql_nullable_int32 mod1;
  cql_set_null(mod1);
  cql_nullable_int32 mul0;
  cql_set_null(mul0);
  cql_nullable_int32 mul1;
  cql_set_null(mul1);
  cql_nullable_bool not_like0;
  cql_set_null(not_like0);
  cql_nullable_bool not_like1;
  cql_set_null(not_like1);
  cql_nullable_int32 rshift0;
  cql_set_null(rshift0);
  cql_nullable_int32 rshift1;
  cql_set_null(rshift1);
  cql_nullable_int32 sub0;
  cql_set_null(sub0);
  cql_nullable_int32 sub1;
  cql_set_null(sub1);

  cql_set_null(add0);
  cql_set_null(add1);
  cql_set_null(bin_and0);
  cql_set_null(bin_and1);
  cql_set_null(bin_or0);
  cql_set_null(bin_or1);
  cql_set_null(div0);
  cql_set_null(div1);
  cql_set_null(ge0);
  cql_set_null(ge1);
  cql_set_null(gt0);
  cql_set_null(gt1);
  cql_set_null(le0);
  cql_set_null(le1);
  cql_set_null(like0);
  cql_set_null(like1);
  cql_set_null(lshift0);
  cql_set_null(lshift1);
  cql_set_null(lt0);
  cql_set_null(lt1);
  cql_set_null(mod0);
  cql_set_null(mod1);
  cql_set_null(mul0);
  cql_set_null(mul1);
  cql_set_null(not_like0);
  cql_set_null(not_like1);
  cql_set_null(rshift0);
  cql_set_null(rshift1);
  cql_set_null(sub0);
  cql_set_null(sub1);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC uses_throw ()
BEGIN
  THROW;
END;
*/

#define _PROC_ "uses_throw"
// export: DECLARE PROC uses_throw () USING TRANSACTION;
CQL_WARN_UNUSED cql_code uses_throw(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  _rc_ = cql_best_error(SQLITE_OK);
  goto cql_cleanup;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC uses_ifnull_throw (x INTEGER)
BEGIN
  LET y := ifnull_throw(x);
END;
*/

#define _PROC_ "uses_ifnull_throw"
// export: DECLARE PROC uses_ifnull_throw (x INTEGER) USING TRANSACTION;
CQL_WARN_UNUSED cql_code uses_ifnull_throw(sqlite3 *_Nonnull _db_, cql_nullable_int32 x) {
  cql_code _rc_ = SQLITE_OK;
  cql_int32 y = 0;

  if (x.is_null) {
    _rc_ = SQLITE_ERROR;
    goto cql_cleanup;
  }
  y = x.value;
  _rc_ = SQLITE_OK;

cql_cleanup:
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_object (o OBJECT NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_object ARGUMENTS;
  FETCH C(o) FROM VALUES(o);
  OUT C;
END;
*/

#define _PROC_ "out_object"

#define out_object_refs_offset cql_offsetof(out_object_row, o) // count = 1
static int32_t out_object_perf_index;

cql_string_proc_name(out_object_stored_procedure_name, "out_object");

cql_object_ref _Nonnull out_object_get_o(out_object_result_set_ref _Nonnull result_set) {
  out_object_row *data = (out_object_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->o;
}

uint8_t out_object_data_types[out_object_data_types_count] = {
  CQL_DATA_TYPE_OBJECT | CQL_DATA_TYPE_NOT_NULL, // o
};

static cql_uint16 out_object_col_offsets[] = { 1,
  cql_offsetof(out_object_row, o)
};

cql_int32 out_object_result_count(out_object_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void out_object_fetch_results( out_object_result_set_ref _Nullable *_Nonnull result_set, cql_object_ref _Nonnull o) {
  cql_profile_start(CRC_out_object, &out_object_perf_index);
  *result_set = NULL;
  out_object_row *row = (out_object_row *)calloc(1, sizeof(out_object_row));
  out_object(o, row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = out_object_data_types,
    .col_offsets = out_object_col_offsets,
    .refs_count = 1,
    .refs_offset = out_object_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(out_object_row),
    .crc = CRC_out_object,
    .perf_index = &out_object_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC out_object (o OBJECT NOT NULL) OUT (o OBJECT NOT NULL);

typedef struct out_object_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_object_ref _Nonnull o;
} out_object_C_row;

#define out_object_C_refs_offset cql_offsetof(out_object_C_row, o) // count = 1
void out_object(cql_object_ref _Nonnull o, out_object_row *_Nonnull _result_) {
  cql_contract_argument_notnull((void *)o, 1);

  memset(_result_, 0, sizeof(*_result_));
  out_object_C_row C = { ._refs_count_ = 1, ._refs_offset_ = out_object_C_refs_offset };

  C._has_row_ = 1;
  cql_set_object_ref(&C.o, o);
  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = out_object_refs_offset;
  cql_set_object_ref(&_result_->o, C.o);

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC exercise_contracts (a INTEGER, b INTEGER NOT NULL, c TEXT, d TEXT NOT NULL, e BLOB, f BLOB NOT NULL, g OBJECT, h OBJECT NOT NULL, OUT i INTEGER, OUT j INTEGER NOT NULL, OUT k TEXT, OUT l TEXT NOT NULL, INOUT m INTEGER, INOUT n INTEGER NOT NULL, INOUT o TEXT, INOUT p TEXT NOT NULL)
BEGIN
  SET l := "text";
END;
*/

#define _PROC_ "exercise_contracts"
// export: DECLARE PROC exercise_contracts (a INTEGER, b INTEGER NOT NULL, c TEXT, d TEXT NOT NULL, e BLOB, f BLOB NOT NULL, g OBJECT, h OBJECT NOT NULL, OUT i INTEGER, OUT j INTEGER NOT NULL, OUT k TEXT, OUT l TEXT NOT NULL, INOUT m INTEGER, INOUT n INTEGER NOT NULL, INOUT o TEXT, INOUT p TEXT NOT NULL);
void exercise_contracts(cql_nullable_int32 a, cql_int32 b, cql_string_ref _Nullable c, cql_string_ref _Nonnull d, cql_blob_ref _Nullable e, cql_blob_ref _Nonnull f, cql_object_ref _Nullable g, cql_object_ref _Nonnull h, cql_nullable_int32 *_Nonnull i, cql_int32 *_Nonnull j, cql_string_ref _Nullable *_Nonnull k, cql_string_ref _Nullable *_Nonnull l, cql_nullable_int32 *_Nonnull m, cql_int32 *_Nonnull n, cql_string_ref _Nullable *_Nonnull o, cql_string_ref _Nonnull *_Nonnull p) {
  cql_contract_argument_notnull((void *)d, 4);
  cql_contract_argument_notnull((void *)f, 6);
  cql_contract_argument_notnull((void *)h, 8);
  cql_contract_argument_notnull((void *)i, 9);
  cql_contract_argument_notnull((void *)j, 10);
  cql_contract_argument_notnull((void *)k, 11);
  cql_contract_argument_notnull((void *)l, 12);
  cql_contract_argument_notnull((void *)m, 13);
  cql_contract_argument_notnull((void *)n, 14);
  cql_contract_argument_notnull((void *)o, 15);
  cql_contract_argument_notnull_when_dereferenced((void *)p, 16);

  cql_set_null(*i); // set out arg to non-garbage
  *j = 0; // set out arg to non-garbage
  *(void **)k = NULL; // set out arg to non-garbage
  *(void **)l = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*l, _literal_1_text_);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC public_proc_with_a_contract (t TEXT NOT NULL)
BEGIN
END;
*/

#define _PROC_ "public_proc_with_a_contract"
// export: DECLARE PROC public_proc_with_a_contract (t TEXT NOT NULL);
void public_proc_with_a_contract(cql_string_ref _Nonnull t) {
  cql_contract_argument_notnull((void *)t, 1);


}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
CREATE PROC private_proc_without_a_contract (t TEXT NOT NULL)
BEGIN
END;
*/

#define _PROC_ "private_proc_without_a_contract"
// private: DECLARE PROC private_proc_without_a_contract (t TEXT NOT NULL);
static void private_proc_without_a_contract(cql_string_ref _Nonnull t) {

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC result_set_proc_with_contract_in_fetch_results (t TEXT NOT NULL)
BEGIN
  SELECT *
    FROM bar;
END;
*/

#define _PROC_ "result_set_proc_with_contract_in_fetch_results"
static int32_t result_set_proc_with_contract_in_fetch_results_perf_index;

cql_string_proc_name(result_set_proc_with_contract_in_fetch_results_stored_procedure_name, "result_set_proc_with_contract_in_fetch_results");

typedef struct result_set_proc_with_contract_in_fetch_results_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} result_set_proc_with_contract_in_fetch_results_row;

cql_int32 result_set_proc_with_contract_in_fetch_results_get_id(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable result_set_proc_with_contract_in_fetch_results_get_name(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool result_set_proc_with_contract_in_fetch_results_get_rate_is_null(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 result_set_proc_with_contract_in_fetch_results_get_rate_value(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool result_set_proc_with_contract_in_fetch_results_get_type_is_null(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 result_set_proc_with_contract_in_fetch_results_get_type_value(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool result_set_proc_with_contract_in_fetch_results_get_size_is_null(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double result_set_proc_with_contract_in_fetch_results_get_size_value(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set, cql_int32 row) {
  result_set_proc_with_contract_in_fetch_results_row *data = (result_set_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t result_set_proc_with_contract_in_fetch_results_data_types[result_set_proc_with_contract_in_fetch_results_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define result_set_proc_with_contract_in_fetch_results_refs_offset cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, name) // count = 1

static cql_uint16 result_set_proc_with_contract_in_fetch_results_col_offsets[] = { 5,
  cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, id),
  cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, name),
  cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, rate),
  cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, type),
  cql_offsetof(result_set_proc_with_contract_in_fetch_results_row, size)
};

cql_int32 result_set_proc_with_contract_in_fetch_results_result_count(result_set_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code result_set_proc_with_contract_in_fetch_results_fetch_results(sqlite3 *_Nonnull _db_, result_set_proc_with_contract_in_fetch_results_result_set_ref _Nullable *_Nonnull result_set, cql_string_ref _Nonnull t) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_result_set_proc_with_contract_in_fetch_results, &result_set_proc_with_contract_in_fetch_results_perf_index);
  cql_code rc = result_set_proc_with_contract_in_fetch_results(_db_, &stmt, t);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = result_set_proc_with_contract_in_fetch_results_data_types,
    .col_offsets = result_set_proc_with_contract_in_fetch_results_col_offsets,
    .refs_count = 1,
    .refs_offset = result_set_proc_with_contract_in_fetch_results_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(result_set_proc_with_contract_in_fetch_results_row),
    .crc = CRC_result_set_proc_with_contract_in_fetch_results,
    .perf_index = &result_set_proc_with_contract_in_fetch_results_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC result_set_proc_with_contract_in_fetch_results (t TEXT NOT NULL) (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code result_set_proc_with_contract_in_fetch_results(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_string_ref _Nonnull t) {
  cql_contract_argument_notnull((void *)t, 1);

  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC out_proc_with_contract_in_fetch_results (t TEXT NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE bar;
  OUT C;
END;
*/

#define _PROC_ "out_proc_with_contract_in_fetch_results"

#define out_proc_with_contract_in_fetch_results_refs_offset cql_offsetof(out_proc_with_contract_in_fetch_results_row, name) // count = 1
static int32_t out_proc_with_contract_in_fetch_results_perf_index;

cql_string_proc_name(out_proc_with_contract_in_fetch_results_stored_procedure_name, "out_proc_with_contract_in_fetch_results");

cql_int32 out_proc_with_contract_in_fetch_results_get_id(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->id;
}

cql_string_ref _Nullable out_proc_with_contract_in_fetch_results_get_name(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->name;
}

cql_bool out_proc_with_contract_in_fetch_results_get_rate_is_null(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.is_null;
}

cql_int64 out_proc_with_contract_in_fetch_results_get_rate_value(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->rate.value;
}

cql_bool out_proc_with_contract_in_fetch_results_get_type_is_null(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.is_null;
}

cql_int32 out_proc_with_contract_in_fetch_results_get_type_value(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->type.value;
}

cql_bool out_proc_with_contract_in_fetch_results_get_size_is_null(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.is_null;
}

cql_double out_proc_with_contract_in_fetch_results_get_size_value(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  out_proc_with_contract_in_fetch_results_row *data = (out_proc_with_contract_in_fetch_results_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data->size.value;
}

uint8_t out_proc_with_contract_in_fetch_results_data_types[out_proc_with_contract_in_fetch_results_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

static cql_uint16 out_proc_with_contract_in_fetch_results_col_offsets[] = { 5,
  cql_offsetof(out_proc_with_contract_in_fetch_results_row, id),
  cql_offsetof(out_proc_with_contract_in_fetch_results_row, name),
  cql_offsetof(out_proc_with_contract_in_fetch_results_row, rate),
  cql_offsetof(out_proc_with_contract_in_fetch_results_row, type),
  cql_offsetof(out_proc_with_contract_in_fetch_results_row, size)
};

cql_int32 out_proc_with_contract_in_fetch_results_result_count(out_proc_with_contract_in_fetch_results_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

void out_proc_with_contract_in_fetch_results_fetch_results( out_proc_with_contract_in_fetch_results_result_set_ref _Nullable *_Nonnull result_set, cql_string_ref _Nonnull t) {
  cql_profile_start(CRC_out_proc_with_contract_in_fetch_results, &out_proc_with_contract_in_fetch_results_perf_index);
  *result_set = NULL;
  out_proc_with_contract_in_fetch_results_row *row = (out_proc_with_contract_in_fetch_results_row *)calloc(1, sizeof(out_proc_with_contract_in_fetch_results_row));
  out_proc_with_contract_in_fetch_results(t, row);
  cql_fetch_info info = {
    .rc = SQLITE_OK,
    .data_types = out_proc_with_contract_in_fetch_results_data_types,
    .col_offsets = out_proc_with_contract_in_fetch_results_col_offsets,
    .refs_count = 1,
    .refs_offset = out_proc_with_contract_in_fetch_results_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(out_proc_with_contract_in_fetch_results_row),
    .crc = CRC_out_proc_with_contract_in_fetch_results,
    .perf_index = &out_proc_with_contract_in_fetch_results_perf_index,
  };
  cql_one_row_result(&info, (char *)row, row->_has_row_, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC out_proc_with_contract_in_fetch_results (t TEXT NOT NULL) OUT (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);

typedef struct out_proc_with_contract_in_fetch_results_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} out_proc_with_contract_in_fetch_results_C_row;

#define out_proc_with_contract_in_fetch_results_C_refs_offset cql_offsetof(out_proc_with_contract_in_fetch_results_C_row, name) // count = 1
void out_proc_with_contract_in_fetch_results(cql_string_ref _Nonnull t, out_proc_with_contract_in_fetch_results_row *_Nonnull _result_) {
  cql_contract_argument_notnull((void *)t, 1);

  memset(_result_, 0, sizeof(*_result_));
  out_proc_with_contract_in_fetch_results_C_row C = { ._refs_count_ = 1, ._refs_offset_ = out_proc_with_contract_in_fetch_results_C_refs_offset };

  _result_->_has_row_ = C._has_row_;
  _result_->_refs_count_ = 1;
  _result_->_refs_offset_ = out_proc_with_contract_in_fetch_results_refs_offset;
  _result_->id = C.id;
  cql_set_string_ref(&_result_->name, C.name);
  _result_->rate = C.rate;
  _result_->type = C.type;
  _result_->size = C.size;

  cql_teardown_row(C);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC nullability_improvements_are_erased_for_sql ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    SELECT a + 1 AS b;
  END IF;
END;
*/

#define _PROC_ "nullability_improvements_are_erased_for_sql"
static int32_t nullability_improvements_are_erased_for_sql_perf_index;

cql_string_proc_name(nullability_improvements_are_erased_for_sql_stored_procedure_name, "nullability_improvements_are_erased_for_sql");

typedef struct nullability_improvements_are_erased_for_sql_row {
  cql_int32 b;
} nullability_improvements_are_erased_for_sql_row;

cql_int32 nullability_improvements_are_erased_for_sql_get_b(nullability_improvements_are_erased_for_sql_result_set_ref _Nonnull result_set, cql_int32 row) {
  nullability_improvements_are_erased_for_sql_row *data = (nullability_improvements_are_erased_for_sql_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].b;
}

uint8_t nullability_improvements_are_erased_for_sql_data_types[nullability_improvements_are_erased_for_sql_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // b
};

static cql_uint16 nullability_improvements_are_erased_for_sql_col_offsets[] = { 1,
  cql_offsetof(nullability_improvements_are_erased_for_sql_row, b)
};

cql_int32 nullability_improvements_are_erased_for_sql_result_count(nullability_improvements_are_erased_for_sql_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code nullability_improvements_are_erased_for_sql_fetch_results(sqlite3 *_Nonnull _db_, nullability_improvements_are_erased_for_sql_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_nullability_improvements_are_erased_for_sql, &nullability_improvements_are_erased_for_sql_perf_index);
  cql_code rc = nullability_improvements_are_erased_for_sql(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = nullability_improvements_are_erased_for_sql_data_types,
    .col_offsets = nullability_improvements_are_erased_for_sql_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(nullability_improvements_are_erased_for_sql_row),
    .crc = CRC_nullability_improvements_are_erased_for_sql,
    .perf_index = &nullability_improvements_are_erased_for_sql_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC nullability_improvements_are_erased_for_sql () (b INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code nullability_improvements_are_erased_for_sql(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_nullable_int32 a;
  cql_set_null(a);

  if (!a.is_null) {
    _rc_ = cql_prepare(_db_, _result_stmt,
      "SELECT ? + 1");
    cql_multibind(&_rc_, _db_, _result_stmt, 1,
                  CQL_DATA_TYPE_INT32, &a);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC nullability_improvements_do_not_change_access ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    LET b := a;
    SET a := 0;
  END IF;
END;
*/

#define _PROC_ "nullability_improvements_do_not_change_access"
// export: DECLARE PROC nullability_improvements_do_not_change_access ();
void nullability_improvements_do_not_change_access(void) {
  cql_nullable_int32 a;
  cql_set_null(a);
  cql_int32 b = 0;

  if (!a.is_null) {
    b = a.value;
    cql_set_notnull(a, 0);
  }

}
#undef _PROC_
cql_bool true_test = 0;
cql_bool false_test = 0;

// The statement ending at line XXXX

/*
CREATE PROC BigFormat ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM big_data;
  LOOP FETCH C
  BEGIN
    LET s := printf('f1:%s|f2:%s|f3:%s|f4:%s|f5:%s|f6:%s|f7:%s|f8:%s|f9:%s|f10:%s|f11:%s|f12:%s|f13:%s|f14:%s|f15:%s|f16:%s|f17:%s|f18:%s|f19:%s|f20:%s|f21:%s|f22:%s|f23:%s|f24:%s|f25:%s|f26:%s|f27:%s|f28:%s|f29:%s|f30:%s|f31:%s|f32:%s|f33:%s|f34:%s|f35:%s|f36:%s|f38:%s|f39:%s|f40:%s|f41:%s|f42:%s|f43:%s|f44:%s|f45:%s|f46:%s|f47:%s|f48:%s|f49:%s|f50:%s|f51:%s|f52:%s|f53:%s|f54:%s|f55:%s|f56:%s|f57:%s|f58:%s|f59:%s|f60:%s|f61:%s|f62:%s|f63:%s|f64:%s|f65:%s|f66:%s|f67:%s|f68:%s|f69:%s|f70:%s|f71:%s|f72:%s|f73:%s|f74:%s|f75:%s', CASE WHEN nullable(C.f1) IS NULL THEN 'null'
    ELSE printf('%lld', C.f1)
    END, CASE WHEN nullable(C.f2) IS NULL THEN 'null'
    ELSE printf('%d', C.f2)
    END, CASE WHEN C.f3 IS NULL THEN 'null'
    ELSE printf('%s', C.f3)
    END, CASE WHEN nullable(C.f4) IS NULL THEN 'null'
    ELSE printf('%s', C.f4)
    END, CASE WHEN C.f5 IS NULL THEN 'null'
    ELSE printf('%s', C.f5)
    END, CASE WHEN C.f6 IS NULL THEN 'null'
    ELSE printf('%s', C.f6)
    END, CASE WHEN C.f7 IS NULL THEN 'null'
    ELSE printf('%lld', C.f7)
    END, CASE WHEN nullable(C.f8) IS NULL THEN 'null'
    ELSE printf('%lld', C.f8)
    END, CASE WHEN nullable(C.f9) IS NULL THEN 'null'
    ELSE printf('%lld', C.f9)
    END, CASE WHEN nullable(C.f10) IS NULL THEN 'null'
    ELSE printf('%lld', C.f10)
    END, CASE WHEN nullable(C.f11) IS NULL THEN 'null'
    ELSE printf('%lld', C.f11)
    END, CASE WHEN C.f12 IS NULL THEN 'null'
    ELSE printf('%s', C.f12)
    END, CASE WHEN nullable(C.f13) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f13 AS INTEGER))
    END, CASE WHEN C.f14 IS NULL THEN 'null'
    ELSE printf('%lld', C.f14)
    END, CASE WHEN C.f15 IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f15 AS INTEGER))
    END, CASE WHEN nullable(C.f16) IS NULL THEN 'null'
    ELSE printf('%d', C.f16)
    END, CASE WHEN nullable(C.f17) IS NULL THEN 'null'
    ELSE printf('%d', C.f17)
    END, CASE WHEN C.f18 IS NULL THEN 'null'
    ELSE printf('%s', C.f18)
    END, CASE WHEN C.f19 IS NULL THEN 'null'
    ELSE printf('%d', C.f19)
    END, CASE WHEN C.f20 IS NULL THEN 'null'
    ELSE printf('%s', C.f20)
    END, CASE WHEN C.f21 IS NULL THEN 'null'
    ELSE printf('%d', C.f21)
    END, CASE WHEN C.f22 IS NULL THEN 'null'
    ELSE printf('%s', C.f22)
    END, CASE WHEN C.f23 IS NULL THEN 'null'
    ELSE printf('%d', C.f23)
    END, CASE WHEN nullable(C.f24) IS NULL THEN 'null'
    ELSE printf('%lld', C.f24)
    END, CASE WHEN C.f25 IS NULL THEN 'null'
    ELSE printf('%s', C.f25)
    END, CASE WHEN nullable(C.f26) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f26 AS INTEGER))
    END, CASE WHEN nullable(C.f27) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f27 AS INTEGER))
    END, CASE WHEN nullable(C.f28) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f28 AS INTEGER))
    END, CASE WHEN C.f29 IS NULL THEN 'null'
    ELSE printf('%s', C.f29)
    END, CASE WHEN C.f30 IS NULL THEN 'null'
    ELSE printf('%s', C.f30)
    END, CASE WHEN C.f31 IS NULL THEN 'null'
    ELSE printf('%s', C.f31)
    END, CASE WHEN C.f32 IS NULL THEN 'null'
    ELSE printf('%d', C.f32)
    END, CASE WHEN C.f33 IS NULL THEN 'null'
    ELSE printf('%lld', C.f33)
    END, CASE WHEN C.f34 IS NULL THEN 'null'
    ELSE printf('%d', C.f34)
    END, CASE WHEN C.f35 IS NULL THEN 'null'
    ELSE printf('%s', C.f35)
    END, CASE WHEN C.f36 IS NULL THEN 'null'
    ELSE printf('%s', C.f36)
    END, CASE WHEN nullable(C.f38) IS NULL THEN 'null'
    ELSE printf('%lld', C.f38)
    END, CASE WHEN C.f39 IS NULL THEN 'null'
    ELSE printf('%lld', C.f39)
    END, CASE WHEN C.f40 IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f40 AS INTEGER))
    END, CASE WHEN nullable(C.f41) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f41 AS INTEGER))
    END, CASE WHEN C.f42 IS NULL THEN 'null'
    ELSE printf('%s', C.f42)
    END, CASE WHEN C.f43 IS NULL THEN 'null'
    ELSE printf('%s', C.f43)
    END, CASE WHEN C.f44 IS NULL THEN 'null'
    ELSE printf('%lld', C.f44)
    END, CASE WHEN nullable(C.f45) IS NULL THEN 'null'
    ELSE printf('%d', CAST(C.f45 AS INTEGER))
    END, CASE WHEN C.f46 IS NULL THEN 'null'
    ELSE printf('%lld', C.f46)
    END, CASE WHEN nullable(C.f47) IS NULL THEN 'null'
    ELSE printf('%d', C.f47)
    END, CASE WHEN C.f48 IS NULL THEN 'null'
    ELSE printf('%s', C.f48)
    END, CASE WHEN C.f49 IS NULL THEN 'null'
    ELSE printf('%lld', C.f49)
    END, CASE WHEN C.f50 IS NULL THEN 'null'
    ELSE printf('%s', C.f50)
    END, CASE WHEN C.f51 IS NULL THEN 'null'
    ELSE printf('%s', C.f51)
    END, CASE WHEN C.f52 IS NULL THEN 'null'
    ELSE printf('%lld', C.f52)
    END, CASE WHEN nullable(C.f53) IS NULL THEN 'null'
    ELSE printf('%d', C.f53)
    END, CASE WHEN C.f54 IS NULL THEN 'null'
    ELSE printf('%s', C.f54)
    END, CASE WHEN nullable(C.f55) IS NULL THEN 'null'
    ELSE printf('%lld', C.f55)
    END, CASE WHEN nullable(C.f56) IS NULL THEN 'null'
    ELSE printf('%lld', C.f56)
    END, CASE WHEN C.f57 IS NULL THEN 'null'
    ELSE printf('%s', C.f57)
    END, CASE WHEN C.f58 IS NULL THEN 'null'
    ELSE printf('%s', C.f58)
    END, CASE WHEN C.f59 IS NULL THEN 'null'
    ELSE printf('%d', C.f59)
    END, CASE WHEN C.f60 IS NULL THEN 'null'
    ELSE printf('%s', C.f60)
    END, CASE WHEN C.f61 IS NULL THEN 'null'
    ELSE printf('%d', C.f61)
    END, CASE WHEN C.f62 IS NULL THEN 'null'
    ELSE printf('%lld', C.f62)
    END, CASE WHEN C.f63 IS NULL THEN 'null'
    ELSE printf('%lld', C.f63)
    END, CASE WHEN C.f64 IS NULL THEN 'null'
    ELSE printf('%d', C.f64)
    END, CASE WHEN nullable(C.f65) IS NULL THEN 'null'
    ELSE printf('%lld', C.f65)
    END, CASE WHEN nullable(C.f66) IS NULL THEN 'null'
    ELSE printf('%d', C.f66)
    END, CASE WHEN nullable(C.f67) IS NULL THEN 'null'
    ELSE printf('%d', C.f67)
    END, CASE WHEN C.f68 IS NULL THEN 'null'
    ELSE printf('%d', C.f68)
    END, CASE WHEN C.f69 IS NULL THEN 'null'
    ELSE printf('%s', C.f69)
    END, CASE WHEN C.f70 IS NULL THEN 'null'
    ELSE printf('%f', C.f70)
    END, CASE WHEN C.f71 IS NULL THEN 'null'
    ELSE printf('%lld', C.f71)
    END, CASE WHEN C.f72 IS NULL THEN 'null'
    ELSE printf('%d', C.f72)
    END, CASE WHEN C.f73 IS NULL THEN 'null'
    ELSE printf('%d', C.f73)
    END, CASE WHEN C.f74 IS NULL THEN 'null'
    ELSE printf('%lld', C.f74)
    END, CASE WHEN C.f75 IS NULL THEN 'null'
    ELSE printf('%d', C.f75)
    END);
  END;
END;
*/

#define _PROC_ "BigFormat"
// export: DECLARE PROC BigFormat () USING TRANSACTION;

typedef struct BigFormat_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int64 f1;
  cql_int32 f2;
  cql_nullable_int64 f7;
  cql_int64 f8;
  cql_int64 f9;
  cql_int64 f10;
  cql_int64 f11;
  cql_bool f13;
  cql_nullable_int64 f14;
  cql_nullable_bool f15;
  cql_int32 f16;
  cql_int32 f17;
  cql_nullable_int32 f19;
  cql_nullable_int32 f21;
  cql_nullable_int32 f23;
  cql_int64 f24;
  cql_bool f26;
  cql_bool f27;
  cql_bool f28;
  cql_nullable_int32 f32;
  cql_nullable_int64 f33;
  cql_nullable_int32 f34;
  cql_int64 f38;
  cql_nullable_int64 f39;
  cql_nullable_bool f40;
  cql_bool f41;
  cql_nullable_int64 f44;
  cql_bool f45;
  cql_nullable_int64 f46;
  cql_int32 f47;
  cql_nullable_int64 f49;
  cql_nullable_int64 f52;
  cql_int32 f53;
  cql_int64 f55;
  cql_int64 f56;
  cql_nullable_int32 f59;
  cql_nullable_int32 f61;
  cql_nullable_int64 f62;
  cql_nullable_int64 f63;
  cql_nullable_int32 f64;
  cql_int64 f65;
  cql_int32 f66;
  cql_int32 f67;
  cql_nullable_int32 f68;
  cql_nullable_double f70;
  cql_nullable_int64 f71;
  cql_nullable_int32 f72;
  cql_nullable_int32 f73;
  cql_nullable_int64 f74;
  cql_nullable_int32 f75;
  cql_string_ref _Nullable f3;
  cql_string_ref _Nonnull f4;
  cql_string_ref _Nullable f5;
  cql_string_ref _Nullable f6;
  cql_string_ref _Nullable f12;
  cql_string_ref _Nullable f18;
  cql_string_ref _Nullable f20;
  cql_string_ref _Nullable f22;
  cql_string_ref _Nullable f25;
  cql_string_ref _Nullable f29;
  cql_string_ref _Nullable f30;
  cql_string_ref _Nullable f31;
  cql_string_ref _Nullable f35;
  cql_string_ref _Nullable f36;
  cql_string_ref _Nullable f42;
  cql_string_ref _Nullable f43;
  cql_string_ref _Nullable f48;
  cql_string_ref _Nullable f50;
  cql_string_ref _Nullable f51;
  cql_string_ref _Nullable f54;
  cql_string_ref _Nullable f57;
  cql_string_ref _Nullable f58;
  cql_string_ref _Nullable f60;
  cql_string_ref _Nullable f69;
} BigFormat_C_row;

#define BigFormat_C_refs_offset cql_offsetof(BigFormat_C_row, f3) // count = 24
CQL_WARN_UNUSED cql_code BigFormat(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  BigFormat_C_row C = { ._refs_count_ = 24, ._refs_offset_ = BigFormat_C_refs_offset };
  cql_string_ref _tmp_text_1 = NULL;
  cql_string_ref _tmp_text_2 = NULL;
  cql_string_ref _tmp_text_3 = NULL;
  cql_string_ref _tmp_text_4 = NULL;
  cql_string_ref _tmp_text_5 = NULL;
  cql_string_ref _tmp_text_6 = NULL;
  cql_string_ref _tmp_text_7 = NULL;
  cql_string_ref _tmp_text_8 = NULL;
  cql_string_ref _tmp_text_9 = NULL;
  cql_string_ref _tmp_text_10 = NULL;
  cql_string_ref _tmp_text_11 = NULL;
  cql_string_ref _tmp_text_12 = NULL;
  cql_string_ref _tmp_text_13 = NULL;
  cql_string_ref _tmp_text_14 = NULL;
  cql_string_ref _tmp_text_15 = NULL;
  cql_string_ref _tmp_text_16 = NULL;
  cql_string_ref _tmp_text_17 = NULL;
  cql_string_ref _tmp_text_18 = NULL;
  cql_string_ref _tmp_text_19 = NULL;
  cql_string_ref _tmp_text_20 = NULL;
  cql_string_ref _tmp_text_21 = NULL;
  cql_string_ref _tmp_text_22 = NULL;
  cql_string_ref _tmp_text_23 = NULL;
  cql_string_ref _tmp_text_24 = NULL;
  cql_string_ref _tmp_text_25 = NULL;
  cql_string_ref _tmp_text_26 = NULL;
  cql_string_ref _tmp_text_27 = NULL;
  cql_string_ref _tmp_text_28 = NULL;
  cql_string_ref _tmp_text_29 = NULL;
  cql_string_ref _tmp_text_30 = NULL;
  cql_string_ref _tmp_text_31 = NULL;
  cql_string_ref _tmp_text_32 = NULL;
  cql_string_ref _tmp_text_33 = NULL;
  cql_string_ref _tmp_text_34 = NULL;
  cql_string_ref _tmp_text_35 = NULL;
  cql_string_ref _tmp_text_36 = NULL;
  cql_string_ref _tmp_text_37 = NULL;
  cql_string_ref _tmp_text_38 = NULL;
  cql_string_ref _tmp_text_39 = NULL;
  cql_string_ref _tmp_text_40 = NULL;
  cql_string_ref _tmp_text_41 = NULL;
  cql_string_ref _tmp_text_42 = NULL;
  cql_string_ref _tmp_text_43 = NULL;
  cql_string_ref _tmp_text_44 = NULL;
  cql_string_ref _tmp_text_45 = NULL;
  cql_string_ref _tmp_text_46 = NULL;
  cql_string_ref _tmp_text_47 = NULL;
  cql_string_ref _tmp_text_48 = NULL;
  cql_string_ref _tmp_text_49 = NULL;
  cql_string_ref _tmp_text_50 = NULL;
  cql_string_ref _tmp_text_51 = NULL;
  cql_string_ref _tmp_text_52 = NULL;
  cql_string_ref _tmp_text_53 = NULL;
  cql_string_ref _tmp_text_54 = NULL;
  cql_string_ref _tmp_text_55 = NULL;
  cql_string_ref _tmp_text_56 = NULL;
  cql_string_ref _tmp_text_57 = NULL;
  cql_string_ref _tmp_text_58 = NULL;
  cql_string_ref _tmp_text_59 = NULL;
  cql_string_ref _tmp_text_60 = NULL;
  cql_string_ref _tmp_text_61 = NULL;
  cql_string_ref _tmp_text_62 = NULL;
  cql_string_ref _tmp_text_63 = NULL;
  cql_string_ref _tmp_text_64 = NULL;
  cql_string_ref _tmp_text_65 = NULL;
  cql_string_ref _tmp_text_66 = NULL;
  cql_string_ref _tmp_text_67 = NULL;
  cql_string_ref _tmp_text_68 = NULL;
  cql_string_ref _tmp_text_69 = NULL;
  cql_string_ref _tmp_text_70 = NULL;
  cql_string_ref _tmp_text_71 = NULL;
  cql_string_ref _tmp_text_72 = NULL;
  cql_string_ref _tmp_text_73 = NULL;
  cql_string_ref _tmp_text_74 = NULL;
  cql_string_ref _tmp_text_75 = NULL;
  cql_string_ref s = NULL;

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28, f29, f30, f31, f32, f33, f34, f35, f36, f38, f39, f40, f41, f42, f43, f44, f45, f46, f47, f48, f49, f50, f51, f52, f53, f54, f55, f56, f57, f58, f59, f60, f61, f62, f63, f64, f65, f66, f67, f68, f69, f70, f71, f72, f73, f74, f75 "
      "FROM big_data");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 74,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f1,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f2,
                   CQL_DATA_TYPE_STRING, &C.f3,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.f4,
                   CQL_DATA_TYPE_STRING, &C.f5,
                   CQL_DATA_TYPE_STRING, &C.f6,
                   CQL_DATA_TYPE_INT64, &C.f7,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f8,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f9,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f10,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f11,
                   CQL_DATA_TYPE_STRING, &C.f12,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f13,
                   CQL_DATA_TYPE_INT64, &C.f14,
                   CQL_DATA_TYPE_BOOL, &C.f15,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f16,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f17,
                   CQL_DATA_TYPE_STRING, &C.f18,
                   CQL_DATA_TYPE_INT32, &C.f19,
                   CQL_DATA_TYPE_STRING, &C.f20,
                   CQL_DATA_TYPE_INT32, &C.f21,
                   CQL_DATA_TYPE_STRING, &C.f22,
                   CQL_DATA_TYPE_INT32, &C.f23,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f24,
                   CQL_DATA_TYPE_STRING, &C.f25,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f26,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f27,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f28,
                   CQL_DATA_TYPE_STRING, &C.f29,
                   CQL_DATA_TYPE_STRING, &C.f30,
                   CQL_DATA_TYPE_STRING, &C.f31,
                   CQL_DATA_TYPE_INT32, &C.f32,
                   CQL_DATA_TYPE_INT64, &C.f33,
                   CQL_DATA_TYPE_INT32, &C.f34,
                   CQL_DATA_TYPE_STRING, &C.f35,
                   CQL_DATA_TYPE_STRING, &C.f36,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f38,
                   CQL_DATA_TYPE_INT64, &C.f39,
                   CQL_DATA_TYPE_BOOL, &C.f40,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f41,
                   CQL_DATA_TYPE_STRING, &C.f42,
                   CQL_DATA_TYPE_STRING, &C.f43,
                   CQL_DATA_TYPE_INT64, &C.f44,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BOOL, &C.f45,
                   CQL_DATA_TYPE_INT64, &C.f46,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f47,
                   CQL_DATA_TYPE_STRING, &C.f48,
                   CQL_DATA_TYPE_INT64, &C.f49,
                   CQL_DATA_TYPE_STRING, &C.f50,
                   CQL_DATA_TYPE_STRING, &C.f51,
                   CQL_DATA_TYPE_INT64, &C.f52,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f53,
                   CQL_DATA_TYPE_STRING, &C.f54,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f55,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f56,
                   CQL_DATA_TYPE_STRING, &C.f57,
                   CQL_DATA_TYPE_STRING, &C.f58,
                   CQL_DATA_TYPE_INT32, &C.f59,
                   CQL_DATA_TYPE_STRING, &C.f60,
                   CQL_DATA_TYPE_INT32, &C.f61,
                   CQL_DATA_TYPE_INT64, &C.f62,
                   CQL_DATA_TYPE_INT64, &C.f63,
                   CQL_DATA_TYPE_INT32, &C.f64,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT64, &C.f65,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f66,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.f67,
                   CQL_DATA_TYPE_INT32, &C.f68,
                   CQL_DATA_TYPE_STRING, &C.f69,
                   CQL_DATA_TYPE_DOUBLE, &C.f70,
                   CQL_DATA_TYPE_INT64, &C.f71,
                   CQL_DATA_TYPE_INT32, &C.f72,
                   CQL_DATA_TYPE_INT32, &C.f73,
                   CQL_DATA_TYPE_INT64, &C.f74,
                   CQL_DATA_TYPE_INT32, &C.f75);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C._has_row_) break;
    {
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_1, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f1);
        cql_string_release(_tmp_text_2);
        _tmp_text_2 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_1, _tmp_text_2);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_2, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f2);
        cql_string_release(_tmp_text_3);
        _tmp_text_3 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_2, _tmp_text_3);
    } while (0);
    do {
      if (!C.f3) {
        cql_set_string_ref(&_tmp_text_3, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_6, C.f3);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_6);
      cql_free_cstr(_cstr_6, C.f3);
        cql_string_release(_tmp_text_4);
        _tmp_text_4 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_3, _tmp_text_4);
    } while (0);
    do {
      if (!C.f4) {
        cql_set_string_ref(&_tmp_text_4, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_8, C.f4);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_8);
      cql_free_cstr(_cstr_8, C.f4);
        cql_string_release(_tmp_text_5);
        _tmp_text_5 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_4, _tmp_text_5);
    } while (0);
    do {
      if (!C.f5) {
        cql_set_string_ref(&_tmp_text_5, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_10, C.f5);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_10);
      cql_free_cstr(_cstr_10, C.f5);
        cql_string_release(_tmp_text_6);
        _tmp_text_6 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_5, _tmp_text_6);
    } while (0);
    do {
      if (!C.f6) {
        cql_set_string_ref(&_tmp_text_6, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_12, C.f6);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_12);
      cql_free_cstr(_cstr_12, C.f6);
        cql_string_release(_tmp_text_7);
        _tmp_text_7 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_6, _tmp_text_7);
    } while (0);
    do {
      if (C.f7.is_null) {
        cql_set_string_ref(&_tmp_text_7, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f7.value);
        cql_string_release(_tmp_text_8);
        _tmp_text_8 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_7, _tmp_text_8);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_8, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f8);
        cql_string_release(_tmp_text_9);
        _tmp_text_9 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_8, _tmp_text_9);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_9, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f9);
        cql_string_release(_tmp_text_10);
        _tmp_text_10 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_9, _tmp_text_10);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_10, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f10);
        cql_string_release(_tmp_text_11);
        _tmp_text_11 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_10, _tmp_text_11);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_11, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f11);
        cql_string_release(_tmp_text_12);
        _tmp_text_12 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_11, _tmp_text_12);
    } while (0);
    do {
      if (!C.f12) {
        cql_set_string_ref(&_tmp_text_12, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_19, C.f12);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_19);
      cql_free_cstr(_cstr_19, C.f12);
        cql_string_release(_tmp_text_13);
        _tmp_text_13 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_12, _tmp_text_13);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_13, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f13)));
        cql_string_release(_tmp_text_14);
        _tmp_text_14 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_13, _tmp_text_14);
    } while (0);
    do {
      if (C.f14.is_null) {
        cql_set_string_ref(&_tmp_text_14, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f14.value);
        cql_string_release(_tmp_text_15);
        _tmp_text_15 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_14, _tmp_text_15);
    } while (0);
    do {
      if (C.f15.is_null) {
        cql_set_string_ref(&_tmp_text_15, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f15.value)));
        cql_string_release(_tmp_text_16);
        _tmp_text_16 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_15, _tmp_text_16);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_16, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f16);
        cql_string_release(_tmp_text_17);
        _tmp_text_17 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_16, _tmp_text_17);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_17, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f17);
        cql_string_release(_tmp_text_18);
        _tmp_text_18 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_17, _tmp_text_18);
    } while (0);
    do {
      if (!C.f18) {
        cql_set_string_ref(&_tmp_text_18, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_26, C.f18);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_26);
      cql_free_cstr(_cstr_26, C.f18);
        cql_string_release(_tmp_text_19);
        _tmp_text_19 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_18, _tmp_text_19);
    } while (0);
    do {
      if (C.f19.is_null) {
        cql_set_string_ref(&_tmp_text_19, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f19.value);
        cql_string_release(_tmp_text_20);
        _tmp_text_20 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_19, _tmp_text_20);
    } while (0);
    do {
      if (!C.f20) {
        cql_set_string_ref(&_tmp_text_20, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_29, C.f20);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_29);
      cql_free_cstr(_cstr_29, C.f20);
        cql_string_release(_tmp_text_21);
        _tmp_text_21 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_20, _tmp_text_21);
    } while (0);
    do {
      if (C.f21.is_null) {
        cql_set_string_ref(&_tmp_text_21, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f21.value);
        cql_string_release(_tmp_text_22);
        _tmp_text_22 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_21, _tmp_text_22);
    } while (0);
    do {
      if (!C.f22) {
        cql_set_string_ref(&_tmp_text_22, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_32, C.f22);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_32);
      cql_free_cstr(_cstr_32, C.f22);
        cql_string_release(_tmp_text_23);
        _tmp_text_23 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_22, _tmp_text_23);
    } while (0);
    do {
      if (C.f23.is_null) {
        cql_set_string_ref(&_tmp_text_23, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f23.value);
        cql_string_release(_tmp_text_24);
        _tmp_text_24 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_23, _tmp_text_24);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_24, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f24);
        cql_string_release(_tmp_text_25);
        _tmp_text_25 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_24, _tmp_text_25);
    } while (0);
    do {
      if (!C.f25) {
        cql_set_string_ref(&_tmp_text_25, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_36, C.f25);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_36);
      cql_free_cstr(_cstr_36, C.f25);
        cql_string_release(_tmp_text_26);
        _tmp_text_26 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_25, _tmp_text_26);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_26, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f26)));
        cql_string_release(_tmp_text_27);
        _tmp_text_27 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_26, _tmp_text_27);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_27, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f27)));
        cql_string_release(_tmp_text_28);
        _tmp_text_28 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_27, _tmp_text_28);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_28, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f28)));
        cql_string_release(_tmp_text_29);
        _tmp_text_29 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_28, _tmp_text_29);
    } while (0);
    do {
      if (!C.f29) {
        cql_set_string_ref(&_tmp_text_29, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_41, C.f29);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_41);
      cql_free_cstr(_cstr_41, C.f29);
        cql_string_release(_tmp_text_30);
        _tmp_text_30 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_29, _tmp_text_30);
    } while (0);
    do {
      if (!C.f30) {
        cql_set_string_ref(&_tmp_text_30, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_43, C.f30);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_43);
      cql_free_cstr(_cstr_43, C.f30);
        cql_string_release(_tmp_text_31);
        _tmp_text_31 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_30, _tmp_text_31);
    } while (0);
    do {
      if (!C.f31) {
        cql_set_string_ref(&_tmp_text_31, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_45, C.f31);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_45);
      cql_free_cstr(_cstr_45, C.f31);
        cql_string_release(_tmp_text_32);
        _tmp_text_32 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_31, _tmp_text_32);
    } while (0);
    do {
      if (C.f32.is_null) {
        cql_set_string_ref(&_tmp_text_32, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f32.value);
        cql_string_release(_tmp_text_33);
        _tmp_text_33 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_32, _tmp_text_33);
    } while (0);
    do {
      if (C.f33.is_null) {
        cql_set_string_ref(&_tmp_text_33, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f33.value);
        cql_string_release(_tmp_text_34);
        _tmp_text_34 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_33, _tmp_text_34);
    } while (0);
    do {
      if (C.f34.is_null) {
        cql_set_string_ref(&_tmp_text_34, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f34.value);
        cql_string_release(_tmp_text_35);
        _tmp_text_35 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_34, _tmp_text_35);
    } while (0);
    do {
      if (!C.f35) {
        cql_set_string_ref(&_tmp_text_35, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_50, C.f35);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_50);
      cql_free_cstr(_cstr_50, C.f35);
        cql_string_release(_tmp_text_36);
        _tmp_text_36 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_35, _tmp_text_36);
    } while (0);
    do {
      if (!C.f36) {
        cql_set_string_ref(&_tmp_text_36, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_52, C.f36);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_52);
      cql_free_cstr(_cstr_52, C.f36);
        cql_string_release(_tmp_text_37);
        _tmp_text_37 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_36, _tmp_text_37);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_37, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f38);
        cql_string_release(_tmp_text_38);
        _tmp_text_38 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_37, _tmp_text_38);
    } while (0);
    do {
      if (C.f39.is_null) {
        cql_set_string_ref(&_tmp_text_38, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f39.value);
        cql_string_release(_tmp_text_39);
        _tmp_text_39 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_38, _tmp_text_39);
    } while (0);
    do {
      if (C.f40.is_null) {
        cql_set_string_ref(&_tmp_text_39, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f40.value)));
        cql_string_release(_tmp_text_40);
        _tmp_text_40 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_39, _tmp_text_40);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_40, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f41)));
        cql_string_release(_tmp_text_41);
        _tmp_text_41 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_40, _tmp_text_41);
    } while (0);
    do {
      if (!C.f42) {
        cql_set_string_ref(&_tmp_text_41, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_58, C.f42);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_58);
      cql_free_cstr(_cstr_58, C.f42);
        cql_string_release(_tmp_text_42);
        _tmp_text_42 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_41, _tmp_text_42);
    } while (0);
    do {
      if (!C.f43) {
        cql_set_string_ref(&_tmp_text_42, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_60, C.f43);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_60);
      cql_free_cstr(_cstr_60, C.f43);
        cql_string_release(_tmp_text_43);
        _tmp_text_43 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_42, _tmp_text_43);
    } while (0);
    do {
      if (C.f44.is_null) {
        cql_set_string_ref(&_tmp_text_43, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f44.value);
        cql_string_release(_tmp_text_44);
        _tmp_text_44 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_43, _tmp_text_44);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_44, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", ((cql_int32)!!(C.f45)));
        cql_string_release(_tmp_text_45);
        _tmp_text_45 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_44, _tmp_text_45);
    } while (0);
    do {
      if (C.f46.is_null) {
        cql_set_string_ref(&_tmp_text_45, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f46.value);
        cql_string_release(_tmp_text_46);
        _tmp_text_46 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_45, _tmp_text_46);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_46, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f47);
        cql_string_release(_tmp_text_47);
        _tmp_text_47 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_46, _tmp_text_47);
    } while (0);
    do {
      if (!C.f48) {
        cql_set_string_ref(&_tmp_text_47, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_66, C.f48);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_66);
      cql_free_cstr(_cstr_66, C.f48);
        cql_string_release(_tmp_text_48);
        _tmp_text_48 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_47, _tmp_text_48);
    } while (0);
    do {
      if (C.f49.is_null) {
        cql_set_string_ref(&_tmp_text_48, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f49.value);
        cql_string_release(_tmp_text_49);
        _tmp_text_49 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_48, _tmp_text_49);
    } while (0);
    do {
      if (!C.f50) {
        cql_set_string_ref(&_tmp_text_49, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_69, C.f50);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_69);
      cql_free_cstr(_cstr_69, C.f50);
        cql_string_release(_tmp_text_50);
        _tmp_text_50 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_49, _tmp_text_50);
    } while (0);
    do {
      if (!C.f51) {
        cql_set_string_ref(&_tmp_text_50, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_71, C.f51);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_71);
      cql_free_cstr(_cstr_71, C.f51);
        cql_string_release(_tmp_text_51);
        _tmp_text_51 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_50, _tmp_text_51);
    } while (0);
    do {
      if (C.f52.is_null) {
        cql_set_string_ref(&_tmp_text_51, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f52.value);
        cql_string_release(_tmp_text_52);
        _tmp_text_52 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_51, _tmp_text_52);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_52, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f53);
        cql_string_release(_tmp_text_53);
        _tmp_text_53 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_52, _tmp_text_53);
    } while (0);
    do {
      if (!C.f54) {
        cql_set_string_ref(&_tmp_text_53, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_75, C.f54);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_75);
      cql_free_cstr(_cstr_75, C.f54);
        cql_string_release(_tmp_text_54);
        _tmp_text_54 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_53, _tmp_text_54);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_54, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f55);
        cql_string_release(_tmp_text_55);
        _tmp_text_55 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_54, _tmp_text_55);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_55, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f56);
        cql_string_release(_tmp_text_56);
        _tmp_text_56 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_55, _tmp_text_56);
    } while (0);
    do {
      if (!C.f57) {
        cql_set_string_ref(&_tmp_text_56, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_79, C.f57);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_79);
      cql_free_cstr(_cstr_79, C.f57);
        cql_string_release(_tmp_text_57);
        _tmp_text_57 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_56, _tmp_text_57);
    } while (0);
    do {
      if (!C.f58) {
        cql_set_string_ref(&_tmp_text_57, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_81, C.f58);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_81);
      cql_free_cstr(_cstr_81, C.f58);
        cql_string_release(_tmp_text_58);
        _tmp_text_58 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_57, _tmp_text_58);
    } while (0);
    do {
      if (C.f59.is_null) {
        cql_set_string_ref(&_tmp_text_58, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f59.value);
        cql_string_release(_tmp_text_59);
        _tmp_text_59 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_58, _tmp_text_59);
    } while (0);
    do {
      if (!C.f60) {
        cql_set_string_ref(&_tmp_text_59, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_84, C.f60);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_84);
      cql_free_cstr(_cstr_84, C.f60);
        cql_string_release(_tmp_text_60);
        _tmp_text_60 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_59, _tmp_text_60);
    } while (0);
    do {
      if (C.f61.is_null) {
        cql_set_string_ref(&_tmp_text_60, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f61.value);
        cql_string_release(_tmp_text_61);
        _tmp_text_61 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_60, _tmp_text_61);
    } while (0);
    do {
      if (C.f62.is_null) {
        cql_set_string_ref(&_tmp_text_61, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f62.value);
        cql_string_release(_tmp_text_62);
        _tmp_text_62 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_61, _tmp_text_62);
    } while (0);
    do {
      if (C.f63.is_null) {
        cql_set_string_ref(&_tmp_text_62, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f63.value);
        cql_string_release(_tmp_text_63);
        _tmp_text_63 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_62, _tmp_text_63);
    } while (0);
    do {
      if (C.f64.is_null) {
        cql_set_string_ref(&_tmp_text_63, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f64.value);
        cql_string_release(_tmp_text_64);
        _tmp_text_64 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_63, _tmp_text_64);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_64, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f65);
        cql_string_release(_tmp_text_65);
        _tmp_text_65 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_64, _tmp_text_65);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_65, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f66);
        cql_string_release(_tmp_text_66);
        _tmp_text_66 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_65, _tmp_text_66);
    } while (0);
    do {
      if (0) {
        cql_set_string_ref(&_tmp_text_66, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f67);
        cql_string_release(_tmp_text_67);
        _tmp_text_67 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_66, _tmp_text_67);
    } while (0);
    do {
      if (C.f68.is_null) {
        cql_set_string_ref(&_tmp_text_67, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f68.value);
        cql_string_release(_tmp_text_68);
        _tmp_text_68 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_67, _tmp_text_68);
    } while (0);
    do {
      if (!C.f69) {
        cql_set_string_ref(&_tmp_text_68, _literal_18_null_BigFormat);
        break;
      }
      {
      cql_alloc_cstr(_cstr_94, C.f69);
        char *_printf_result = sqlite3_mprintf("%s", _cstr_94);
      cql_free_cstr(_cstr_94, C.f69);
        cql_string_release(_tmp_text_69);
        _tmp_text_69 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_68, _tmp_text_69);
    } while (0);
    do {
      if (C.f70.is_null) {
        cql_set_string_ref(&_tmp_text_69, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%f", C.f70.value);
        cql_string_release(_tmp_text_70);
        _tmp_text_70 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_69, _tmp_text_70);
    } while (0);
    do {
      if (C.f71.is_null) {
        cql_set_string_ref(&_tmp_text_70, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f71.value);
        cql_string_release(_tmp_text_71);
        _tmp_text_71 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_70, _tmp_text_71);
    } while (0);
    do {
      if (C.f72.is_null) {
        cql_set_string_ref(&_tmp_text_71, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f72.value);
        cql_string_release(_tmp_text_72);
        _tmp_text_72 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_71, _tmp_text_72);
    } while (0);
    do {
      if (C.f73.is_null) {
        cql_set_string_ref(&_tmp_text_72, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f73.value);
        cql_string_release(_tmp_text_73);
        _tmp_text_73 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_72, _tmp_text_73);
    } while (0);
    do {
      if (C.f74.is_null) {
        cql_set_string_ref(&_tmp_text_73, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%lld", C.f74.value);
        cql_string_release(_tmp_text_74);
        _tmp_text_74 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_73, _tmp_text_74);
    } while (0);
    do {
      if (C.f75.is_null) {
        cql_set_string_ref(&_tmp_text_74, _literal_18_null_BigFormat);
        break;
      }
      {
        char *_printf_result = sqlite3_mprintf("%d", C.f75.value);
        cql_string_release(_tmp_text_75);
        _tmp_text_75 = cql_string_ref_new(_printf_result);
        sqlite3_free(_printf_result);
      }
      cql_set_string_ref(&_tmp_text_74, _tmp_text_75);
    } while (0);
    cql_alloc_cstr(_cstr_4, _tmp_text_1);
    cql_alloc_cstr(_cstr_5, _tmp_text_2);
    cql_alloc_cstr(_cstr_7, _tmp_text_3);
    cql_alloc_cstr(_cstr_9, _tmp_text_4);
    cql_alloc_cstr(_cstr_11, _tmp_text_5);
    cql_alloc_cstr(_cstr_13, _tmp_text_6);
    cql_alloc_cstr(_cstr_14, _tmp_text_7);
    cql_alloc_cstr(_cstr_15, _tmp_text_8);
    cql_alloc_cstr(_cstr_16, _tmp_text_9);
    cql_alloc_cstr(_cstr_17, _tmp_text_10);
    cql_alloc_cstr(_cstr_18, _tmp_text_11);
    cql_alloc_cstr(_cstr_20, _tmp_text_12);
    cql_alloc_cstr(_cstr_21, _tmp_text_13);
    cql_alloc_cstr(_cstr_22, _tmp_text_14);
    cql_alloc_cstr(_cstr_23, _tmp_text_15);
    cql_alloc_cstr(_cstr_24, _tmp_text_16);
    cql_alloc_cstr(_cstr_25, _tmp_text_17);
    cql_alloc_cstr(_cstr_27, _tmp_text_18);
    cql_alloc_cstr(_cstr_28, _tmp_text_19);
    cql_alloc_cstr(_cstr_30, _tmp_text_20);
    cql_alloc_cstr(_cstr_31, _tmp_text_21);
    cql_alloc_cstr(_cstr_33, _tmp_text_22);
    cql_alloc_cstr(_cstr_34, _tmp_text_23);
    cql_alloc_cstr(_cstr_35, _tmp_text_24);
    cql_alloc_cstr(_cstr_37, _tmp_text_25);
    cql_alloc_cstr(_cstr_38, _tmp_text_26);
    cql_alloc_cstr(_cstr_39, _tmp_text_27);
    cql_alloc_cstr(_cstr_40, _tmp_text_28);
    cql_alloc_cstr(_cstr_42, _tmp_text_29);
    cql_alloc_cstr(_cstr_44, _tmp_text_30);
    cql_alloc_cstr(_cstr_46, _tmp_text_31);
    cql_alloc_cstr(_cstr_47, _tmp_text_32);
    cql_alloc_cstr(_cstr_48, _tmp_text_33);
    cql_alloc_cstr(_cstr_49, _tmp_text_34);
    cql_alloc_cstr(_cstr_51, _tmp_text_35);
    cql_alloc_cstr(_cstr_53, _tmp_text_36);
    cql_alloc_cstr(_cstr_54, _tmp_text_37);
    cql_alloc_cstr(_cstr_55, _tmp_text_38);
    cql_alloc_cstr(_cstr_56, _tmp_text_39);
    cql_alloc_cstr(_cstr_57, _tmp_text_40);
    cql_alloc_cstr(_cstr_59, _tmp_text_41);
    cql_alloc_cstr(_cstr_61, _tmp_text_42);
    cql_alloc_cstr(_cstr_62, _tmp_text_43);
    cql_alloc_cstr(_cstr_63, _tmp_text_44);
    cql_alloc_cstr(_cstr_64, _tmp_text_45);
    cql_alloc_cstr(_cstr_65, _tmp_text_46);
    cql_alloc_cstr(_cstr_67, _tmp_text_47);
    cql_alloc_cstr(_cstr_68, _tmp_text_48);
    cql_alloc_cstr(_cstr_70, _tmp_text_49);
    cql_alloc_cstr(_cstr_72, _tmp_text_50);
    cql_alloc_cstr(_cstr_73, _tmp_text_51);
    cql_alloc_cstr(_cstr_74, _tmp_text_52);
    cql_alloc_cstr(_cstr_76, _tmp_text_53);
    cql_alloc_cstr(_cstr_77, _tmp_text_54);
    cql_alloc_cstr(_cstr_78, _tmp_text_55);
    cql_alloc_cstr(_cstr_80, _tmp_text_56);
    cql_alloc_cstr(_cstr_82, _tmp_text_57);
    cql_alloc_cstr(_cstr_83, _tmp_text_58);
    cql_alloc_cstr(_cstr_85, _tmp_text_59);
    cql_alloc_cstr(_cstr_86, _tmp_text_60);
    cql_alloc_cstr(_cstr_87, _tmp_text_61);
    cql_alloc_cstr(_cstr_88, _tmp_text_62);
    cql_alloc_cstr(_cstr_89, _tmp_text_63);
    cql_alloc_cstr(_cstr_90, _tmp_text_64);
    cql_alloc_cstr(_cstr_91, _tmp_text_65);
    cql_alloc_cstr(_cstr_92, _tmp_text_66);
    cql_alloc_cstr(_cstr_93, _tmp_text_67);
    cql_alloc_cstr(_cstr_95, _tmp_text_68);
    cql_alloc_cstr(_cstr_96, _tmp_text_69);
    cql_alloc_cstr(_cstr_97, _tmp_text_70);
    cql_alloc_cstr(_cstr_98, _tmp_text_71);
    cql_alloc_cstr(_cstr_99, _tmp_text_72);
    cql_alloc_cstr(_cstr_100, _tmp_text_73);
    cql_alloc_cstr(_cstr_101, _tmp_text_74);
      char *_printf_result = sqlite3_mprintf("f1:%s|f2:%s|f3:%s|f4:%s|f5:%s|f6:%s|f7:%s|f8:%s|f9:%s|f10:%s|f11:%s|f12:%s|f13:%s|f14:%s|f15:%s|f16:%s|f17:%s|f18:%s|f19:%s|f20:%s|f21:%s|f22:%s|f23:%s|f24:%s|f25:%s|f26:%s|f27:%s|f28:%s|f29:%s|f30:%s|f31:%s|f32:%s|f33:%s|f34:%s|f35:%s|f36:%s|f38:%s|f39:%s|f40:%s|f41:%s|f42:%s|f43:%s|f44:%s|f45:%s|f46:%s|f47:%s|f48:%s|f49:%s|f50:%s|f51:%s|f52:%s|f53:%s|f54:%s|f55:%s|f56:%s|f57:%s|f58:%s|f59:%s|f60:%s|f61:%s|f62:%s|f63:%s|f64:%s|f65:%s|f66:%s|f67:%s|f68:%s|f69:%s|f70:%s|f71:%s|f72:%s|f73:%s|f74:%s|f75:%s", _cstr_4, _cstr_5, _cstr_7, _cstr_9, _cstr_11, _cstr_13, _cstr_14, _cstr_15, _cstr_16, _cstr_17, _cstr_18, _cstr_20, _cstr_21, _cstr_22, _cstr_23, _cstr_24, _cstr_25, _cstr_27, _cstr_28, _cstr_30, _cstr_31, _cstr_33, _cstr_34, _cstr_35, _cstr_37, _cstr_38, _cstr_39, _cstr_40, _cstr_42, _cstr_44, _cstr_46, _cstr_47, _cstr_48, _cstr_49, _cstr_51, _cstr_53, _cstr_54, _cstr_55, _cstr_56, _cstr_57, _cstr_59, _cstr_61, _cstr_62, _cstr_63, _cstr_64, _cstr_65, _cstr_67, _cstr_68, _cstr_70, _cstr_72, _cstr_73, _cstr_74, _cstr_76, _cstr_77, _cstr_78, _cstr_80, _cstr_82, _cstr_83, _cstr_85, _cstr_86, _cstr_87, _cstr_88, _cstr_89, _cstr_90, _cstr_91, _cstr_92, _cstr_93, _cstr_95, _cstr_96, _cstr_97, _cstr_98, _cstr_99, _cstr_100, _cstr_101);
    cql_free_cstr(_cstr_4, _tmp_text_1);
    cql_free_cstr(_cstr_5, _tmp_text_2);
    cql_free_cstr(_cstr_7, _tmp_text_3);
    cql_free_cstr(_cstr_9, _tmp_text_4);
    cql_free_cstr(_cstr_11, _tmp_text_5);
    cql_free_cstr(_cstr_13, _tmp_text_6);
    cql_free_cstr(_cstr_14, _tmp_text_7);
    cql_free_cstr(_cstr_15, _tmp_text_8);
    cql_free_cstr(_cstr_16, _tmp_text_9);
    cql_free_cstr(_cstr_17, _tmp_text_10);
    cql_free_cstr(_cstr_18, _tmp_text_11);
    cql_free_cstr(_cstr_20, _tmp_text_12);
    cql_free_cstr(_cstr_21, _tmp_text_13);
    cql_free_cstr(_cstr_22, _tmp_text_14);
    cql_free_cstr(_cstr_23, _tmp_text_15);
    cql_free_cstr(_cstr_24, _tmp_text_16);
    cql_free_cstr(_cstr_25, _tmp_text_17);
    cql_free_cstr(_cstr_27, _tmp_text_18);
    cql_free_cstr(_cstr_28, _tmp_text_19);
    cql_free_cstr(_cstr_30, _tmp_text_20);
    cql_free_cstr(_cstr_31, _tmp_text_21);
    cql_free_cstr(_cstr_33, _tmp_text_22);
    cql_free_cstr(_cstr_34, _tmp_text_23);
    cql_free_cstr(_cstr_35, _tmp_text_24);
    cql_free_cstr(_cstr_37, _tmp_text_25);
    cql_free_cstr(_cstr_38, _tmp_text_26);
    cql_free_cstr(_cstr_39, _tmp_text_27);
    cql_free_cstr(_cstr_40, _tmp_text_28);
    cql_free_cstr(_cstr_42, _tmp_text_29);
    cql_free_cstr(_cstr_44, _tmp_text_30);
    cql_free_cstr(_cstr_46, _tmp_text_31);
    cql_free_cstr(_cstr_47, _tmp_text_32);
    cql_free_cstr(_cstr_48, _tmp_text_33);
    cql_free_cstr(_cstr_49, _tmp_text_34);
    cql_free_cstr(_cstr_51, _tmp_text_35);
    cql_free_cstr(_cstr_53, _tmp_text_36);
    cql_free_cstr(_cstr_54, _tmp_text_37);
    cql_free_cstr(_cstr_55, _tmp_text_38);
    cql_free_cstr(_cstr_56, _tmp_text_39);
    cql_free_cstr(_cstr_57, _tmp_text_40);
    cql_free_cstr(_cstr_59, _tmp_text_41);
    cql_free_cstr(_cstr_61, _tmp_text_42);
    cql_free_cstr(_cstr_62, _tmp_text_43);
    cql_free_cstr(_cstr_63, _tmp_text_44);
    cql_free_cstr(_cstr_64, _tmp_text_45);
    cql_free_cstr(_cstr_65, _tmp_text_46);
    cql_free_cstr(_cstr_67, _tmp_text_47);
    cql_free_cstr(_cstr_68, _tmp_text_48);
    cql_free_cstr(_cstr_70, _tmp_text_49);
    cql_free_cstr(_cstr_72, _tmp_text_50);
    cql_free_cstr(_cstr_73, _tmp_text_51);
    cql_free_cstr(_cstr_74, _tmp_text_52);
    cql_free_cstr(_cstr_76, _tmp_text_53);
    cql_free_cstr(_cstr_77, _tmp_text_54);
    cql_free_cstr(_cstr_78, _tmp_text_55);
    cql_free_cstr(_cstr_80, _tmp_text_56);
    cql_free_cstr(_cstr_82, _tmp_text_57);
    cql_free_cstr(_cstr_83, _tmp_text_58);
    cql_free_cstr(_cstr_85, _tmp_text_59);
    cql_free_cstr(_cstr_86, _tmp_text_60);
    cql_free_cstr(_cstr_87, _tmp_text_61);
    cql_free_cstr(_cstr_88, _tmp_text_62);
    cql_free_cstr(_cstr_89, _tmp_text_63);
    cql_free_cstr(_cstr_90, _tmp_text_64);
    cql_free_cstr(_cstr_91, _tmp_text_65);
    cql_free_cstr(_cstr_92, _tmp_text_66);
    cql_free_cstr(_cstr_93, _tmp_text_67);
    cql_free_cstr(_cstr_95, _tmp_text_68);
    cql_free_cstr(_cstr_96, _tmp_text_69);
    cql_free_cstr(_cstr_97, _tmp_text_70);
    cql_free_cstr(_cstr_98, _tmp_text_71);
    cql_free_cstr(_cstr_99, _tmp_text_72);
    cql_free_cstr(_cstr_100, _tmp_text_73);
    cql_free_cstr(_cstr_101, _tmp_text_74);
      cql_string_release(s);
      s = cql_string_ref_new(_printf_result);
      sqlite3_free(_printf_result);
    }
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  cql_string_release(s);
  cql_string_release(_tmp_text_1);
  cql_string_release(_tmp_text_2);
  cql_string_release(_tmp_text_3);
  cql_string_release(_tmp_text_4);
  cql_string_release(_tmp_text_5);
  cql_string_release(_tmp_text_6);
  cql_string_release(_tmp_text_7);
  cql_string_release(_tmp_text_8);
  cql_string_release(_tmp_text_9);
  cql_string_release(_tmp_text_10);
  cql_string_release(_tmp_text_11);
  cql_string_release(_tmp_text_12);
  cql_string_release(_tmp_text_13);
  cql_string_release(_tmp_text_14);
  cql_string_release(_tmp_text_15);
  cql_string_release(_tmp_text_16);
  cql_string_release(_tmp_text_17);
  cql_string_release(_tmp_text_18);
  cql_string_release(_tmp_text_19);
  cql_string_release(_tmp_text_20);
  cql_string_release(_tmp_text_21);
  cql_string_release(_tmp_text_22);
  cql_string_release(_tmp_text_23);
  cql_string_release(_tmp_text_24);
  cql_string_release(_tmp_text_25);
  cql_string_release(_tmp_text_26);
  cql_string_release(_tmp_text_27);
  cql_string_release(_tmp_text_28);
  cql_string_release(_tmp_text_29);
  cql_string_release(_tmp_text_30);
  cql_string_release(_tmp_text_31);
  cql_string_release(_tmp_text_32);
  cql_string_release(_tmp_text_33);
  cql_string_release(_tmp_text_34);
  cql_string_release(_tmp_text_35);
  cql_string_release(_tmp_text_36);
  cql_string_release(_tmp_text_37);
  cql_string_release(_tmp_text_38);
  cql_string_release(_tmp_text_39);
  cql_string_release(_tmp_text_40);
  cql_string_release(_tmp_text_41);
  cql_string_release(_tmp_text_42);
  cql_string_release(_tmp_text_43);
  cql_string_release(_tmp_text_44);
  cql_string_release(_tmp_text_45);
  cql_string_release(_tmp_text_46);
  cql_string_release(_tmp_text_47);
  cql_string_release(_tmp_text_48);
  cql_string_release(_tmp_text_49);
  cql_string_release(_tmp_text_50);
  cql_string_release(_tmp_text_51);
  cql_string_release(_tmp_text_52);
  cql_string_release(_tmp_text_53);
  cql_string_release(_tmp_text_54);
  cql_string_release(_tmp_text_55);
  cql_string_release(_tmp_text_56);
  cql_string_release(_tmp_text_57);
  cql_string_release(_tmp_text_58);
  cql_string_release(_tmp_text_59);
  cql_string_release(_tmp_text_60);
  cql_string_release(_tmp_text_61);
  cql_string_release(_tmp_text_62);
  cql_string_release(_tmp_text_63);
  cql_string_release(_tmp_text_64);
  cql_string_release(_tmp_text_65);
  cql_string_release(_tmp_text_66);
  cql_string_release(_tmp_text_67);
  cql_string_release(_tmp_text_68);
  cql_string_release(_tmp_text_69);
  cql_string_release(_tmp_text_70);
  cql_string_release(_tmp_text_71);
  cql_string_release(_tmp_text_72);
  cql_string_release(_tmp_text_73);
  cql_string_release(_tmp_text_74);
  cql_string_release(_tmp_text_75);
  return _rc_;
}
#undef _PROC_
cql_int32 sign_val_int = 0;
cql_nullable_int32 sign_val_nullable;
cql_int32 abs_val_int = 0;
cql_nullable_int32 abs_val_nullable;
cql_int64 abs_val_long = 0;
cql_double abs_val_real = 0;
cql_bool abs_val_bool = 0;

// The statement ending at line XXXX

/*
CREATE PROC ltor_proc_int_not_null (a INTEGER NOT NULL, b INTEGER NOT NULL, OUT c INTEGER NOT NULL)
BEGIN
END;
*/

#define _PROC_ "ltor_proc_int_not_null"
// export: DECLARE PROC ltor_proc_int_not_null (a INTEGER NOT NULL, b INTEGER NOT NULL, OUT c INTEGER NOT NULL);
void ltor_proc_int_not_null(cql_int32 a, cql_int32 b, cql_int32 *_Nonnull c) {
  cql_contract_argument_notnull((void *)c, 3);

  *c = 0; // set out arg to non-garbage

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC ltor_proc_int (a INTEGER, b INTEGER, OUT c INTEGER)
BEGIN
END;
*/

#define _PROC_ "ltor_proc_int"
// export: DECLARE PROC ltor_proc_int (a INTEGER, b INTEGER, OUT c INTEGER);
void ltor_proc_int(cql_nullable_int32 a, cql_nullable_int32 b, cql_nullable_int32 *_Nonnull c) {
  cql_contract_argument_notnull((void *)c, 3);

  cql_set_null(*c); // set out arg to non-garbage

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC ltor_proc_text_not_null (a TEXT NOT NULL, b TEXT NOT NULL, OUT c TEXT NOT NULL)
BEGIN
  SET c := "text";
END;
*/

#define _PROC_ "ltor_proc_text_not_null"
// export: DECLARE PROC ltor_proc_text_not_null (a TEXT NOT NULL, b TEXT NOT NULL, OUT c TEXT NOT NULL);
void ltor_proc_text_not_null(cql_string_ref _Nonnull a, cql_string_ref _Nonnull b, cql_string_ref _Nullable *_Nonnull c) {
  cql_contract_argument_notnull((void *)a, 1);
  cql_contract_argument_notnull((void *)b, 2);
  cql_contract_argument_notnull((void *)c, 3);

  *(void **)c = NULL; // set out arg to non-garbage
  cql_set_string_ref(&*c, _literal_1_text_);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC ltor_proc_text (a TEXT, b TEXT, OUT c TEXT)
BEGIN
END;
*/

#define _PROC_ "ltor_proc_text"
// export: DECLARE PROC ltor_proc_text (a TEXT, b TEXT, OUT c TEXT);
void ltor_proc_text(cql_string_ref _Nullable a, cql_string_ref _Nullable b, cql_string_ref _Nullable *_Nonnull c) {
  cql_contract_argument_notnull((void *)c, 3);

  *(void **)c = NULL; // set out arg to non-garbage

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC arguments_are_evaluated_left_to_right ()
BEGIN
  LET a := ltor_proc_int_not_null(ltor_proc_int_not_null(1, 2), ltor_proc_int_not_null(3, 4));
  LET b := ltor_proc_int(ltor_proc_int(1, 2), ltor_proc_int(3, 4));
  LET c := ltor_proc_text_not_null(ltor_proc_text_not_null("1", "2"), ltor_proc_text_not_null("3", "4"));
  LET d := ltor_proc_text(ltor_proc_text("1", "2"), ltor_proc_text("3", "4"));
  LET e := ltor_func_int_not_null(ltor_func_int_not_null(1, 2), ltor_func_int_not_null(3, 4));
  LET f := ltor_func_int(ltor_func_int(1, 2), ltor_func_int(3, 4));
  LET g := ltor_func_text_not_null(ltor_func_text_not_null("1", "2"), ltor_func_text_not_null("3", "4"));
  LET h := ltor_func_text(ltor_func_text("1", "2"), ltor_func_text("3", "4"));
END;
*/

#define _PROC_ "arguments_are_evaluated_left_to_right"
// export: DECLARE PROC arguments_are_evaluated_left_to_right ();
void arguments_are_evaluated_left_to_right(void) {
  cql_int32 _tmp_int_1 = 0;
  cql_int32 _tmp_int_2 = 0;
  cql_int32 a = 0;
  cql_nullable_int32 _tmp_n_int_1;
  cql_set_null(_tmp_n_int_1);
  cql_nullable_int32 _tmp_n_int_2;
  cql_set_null(_tmp_n_int_2);
  cql_nullable_int32 _tmp_n_int_3;
  cql_set_null(_tmp_n_int_3);
  cql_nullable_int32 _tmp_n_int_4;
  cql_set_null(_tmp_n_int_4);
  cql_nullable_int32 b;
  cql_set_null(b);
  cql_string_ref _tmp_text_1 = NULL;
  cql_string_ref _tmp_text_2 = NULL;
  cql_string_ref c = NULL;
  cql_string_ref _tmp_n_text_1 = NULL;
  cql_string_ref _tmp_n_text_2 = NULL;
  cql_string_ref d = NULL;
  cql_int32 e = 0;
  cql_nullable_int32 f;
  cql_set_null(f);
  cql_string_ref g = NULL;
  cql_string_ref h = NULL;

  ltor_proc_int_not_null(1, 2, &_tmp_int_1);
  ltor_proc_int_not_null(3, 4, &_tmp_int_2);
  ltor_proc_int_not_null(_tmp_int_1, _tmp_int_2, &a);
  cql_set_notnull(_tmp_n_int_2, 1);
  cql_set_notnull(_tmp_n_int_3, 2);
  ltor_proc_int(_tmp_n_int_2, _tmp_n_int_3, &_tmp_n_int_1);
  cql_set_notnull(_tmp_n_int_3, 3);
  cql_set_notnull(_tmp_n_int_4, 4);
  ltor_proc_int(_tmp_n_int_3, _tmp_n_int_4, &_tmp_n_int_2);
  ltor_proc_int(_tmp_n_int_1, _tmp_n_int_2, &b);
  cql_set_string_ref(&_tmp_text_1, NULL);
  ltor_proc_text_not_null(_literal_19_arguments_are_evaluated_left_to_right, _literal_20_arguments_are_evaluated_left_to_right, &_tmp_text_1);
  cql_set_string_ref(&_tmp_text_2, NULL);
  ltor_proc_text_not_null(_literal_21_arguments_are_evaluated_left_to_right, _literal_22_arguments_are_evaluated_left_to_right, &_tmp_text_2);
  cql_set_string_ref(&c, NULL);
  ltor_proc_text_not_null(_tmp_text_1, _tmp_text_2, &c);
  cql_set_string_ref(&_tmp_n_text_1, NULL);
  ltor_proc_text(_literal_19_arguments_are_evaluated_left_to_right, _literal_20_arguments_are_evaluated_left_to_right, &_tmp_n_text_1);
  cql_set_string_ref(&_tmp_n_text_2, NULL);
  ltor_proc_text(_literal_21_arguments_are_evaluated_left_to_right, _literal_22_arguments_are_evaluated_left_to_right, &_tmp_n_text_2);
  cql_set_string_ref(&d, NULL);
  ltor_proc_text(_tmp_n_text_1, _tmp_n_text_2, &d);
  _tmp_int_1 = ltor_func_int_not_null(1, 2);
  _tmp_int_2 = ltor_func_int_not_null(3, 4);
  e = ltor_func_int_not_null(_tmp_int_1, _tmp_int_2);
  cql_set_notnull(_tmp_n_int_2, 1);
  cql_set_notnull(_tmp_n_int_3, 2);
  _tmp_n_int_1 = ltor_func_int(_tmp_n_int_2, _tmp_n_int_3);
  cql_set_notnull(_tmp_n_int_3, 3);
  cql_set_notnull(_tmp_n_int_4, 4);
  _tmp_n_int_2 = ltor_func_int(_tmp_n_int_3, _tmp_n_int_4);
  f = ltor_func_int(_tmp_n_int_1, _tmp_n_int_2);
  cql_set_string_ref(&_tmp_text_1, ltor_func_text_not_null(_literal_19_arguments_are_evaluated_left_to_right, _literal_20_arguments_are_evaluated_left_to_right));
  cql_set_string_ref(&_tmp_text_2, ltor_func_text_not_null(_literal_21_arguments_are_evaluated_left_to_right, _literal_22_arguments_are_evaluated_left_to_right));
  cql_set_string_ref(&g, ltor_func_text_not_null(_tmp_text_1, _tmp_text_2));
  cql_set_string_ref(&_tmp_n_text_1, ltor_func_text(_literal_19_arguments_are_evaluated_left_to_right, _literal_20_arguments_are_evaluated_left_to_right));
  cql_set_string_ref(&_tmp_n_text_2, ltor_func_text(_literal_21_arguments_are_evaluated_left_to_right, _literal_22_arguments_are_evaluated_left_to_right));
  cql_set_string_ref(&h, ltor_func_text(_tmp_n_text_1, _tmp_n_text_2));

  cql_string_release(c);
  cql_string_release(_tmp_text_1);
  cql_string_release(_tmp_text_2);
  cql_string_release(d);
  cql_string_release(_tmp_n_text_1);
  cql_string_release(_tmp_n_text_2);
  cql_string_release(g);
  cql_string_release(h);
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC f1 (OUT x INTEGER NOT NULL)
BEGIN
  SET x := 5;
END;
*/

#define _PROC_ "f1"
// export: DECLARE PROC f1 (OUT x INTEGER NOT NULL);
void f1(cql_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  *x = 0; // set out arg to non-garbage
  *x = 5;

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC f2 (OUT x INTEGER)
BEGIN
  SET x := 5;
END;
*/

#define _PROC_ "f2"
// export: DECLARE PROC f2 (OUT x INTEGER);
void f2(cql_nullable_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 1);

  cql_set_null(*x); // set out arg to non-garbage
  cql_set_notnull(*x, 5);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC f3 (y INTEGER, OUT x INTEGER)
BEGIN
  SET x := y;
END;
*/

#define _PROC_ "f3"
// export: DECLARE PROC f3 (y INTEGER, OUT x INTEGER);
void f3(cql_nullable_int32 y, cql_nullable_int32 *_Nonnull x) {
  cql_contract_argument_notnull((void *)x, 2);

  cql_set_null(*x); // set out arg to non-garbage
  cql_set_nullable(*x, y.is_null, y.value);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC multi_call_temp_reuse ()
BEGIN
  LET q := f1() + f1() + f1();
  LET r := f2() + f2() + f2();
  LET s := f3(0) + f3(1) + f3(2);
END;
*/

#define _PROC_ "multi_call_temp_reuse"
// export: DECLARE PROC multi_call_temp_reuse ();
void multi_call_temp_reuse(void) {
  cql_int32 _tmp_int_2 = 0;
  cql_int32 _tmp_int_3 = 0;
  cql_int32 _tmp_int_4 = 0;
  cql_int32 q = 0;
  cql_nullable_int32 _tmp_n_int_2;
  cql_set_null(_tmp_n_int_2);
  cql_nullable_int32 _tmp_n_int_3;
  cql_set_null(_tmp_n_int_3);
  cql_nullable_int32 _tmp_n_int_1;
  cql_set_null(_tmp_n_int_1);
  cql_nullable_int32 r;
  cql_set_null(r);
  cql_nullable_int32 _tmp_n_int_4;
  cql_set_null(_tmp_n_int_4);
  cql_nullable_int32 s;
  cql_set_null(s);

  f1(&_tmp_int_2);
  f1(&_tmp_int_3);
  f1(&_tmp_int_4);
  q = _tmp_int_2 + _tmp_int_3 + _tmp_int_4;
  f2(&_tmp_n_int_2);
  f2(&_tmp_n_int_3);
  cql_combine_nullables(_tmp_n_int_1, _tmp_n_int_2.is_null, _tmp_n_int_3.is_null, _tmp_n_int_2.value + _tmp_n_int_3.value);
  f2(&_tmp_n_int_2);
  cql_combine_nullables(r, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);
  cql_set_notnull(_tmp_n_int_3, 0);
  f3(_tmp_n_int_3, &_tmp_n_int_2);
  cql_set_notnull(_tmp_n_int_4, 1);
  f3(_tmp_n_int_4, &_tmp_n_int_3);
  cql_combine_nullables(_tmp_n_int_1, _tmp_n_int_2.is_null, _tmp_n_int_3.is_null, _tmp_n_int_2.value + _tmp_n_int_3.value);
  cql_set_notnull(_tmp_n_int_3, 2);
  f3(_tmp_n_int_3, &_tmp_n_int_2);
  cql_combine_nullables(s, _tmp_n_int_1.is_null, _tmp_n_int_2.is_null, _tmp_n_int_1.value + _tmp_n_int_2.value);

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC sensitive_function_is_a_no_op ()
BEGIN
  LET x := sensitive("hello");
  SELECT sensitive("hello") AS y;
END;
*/

#define _PROC_ "sensitive_function_is_a_no_op"
static int32_t sensitive_function_is_a_no_op_perf_index;

cql_string_proc_name(sensitive_function_is_a_no_op_stored_procedure_name, "sensitive_function_is_a_no_op");

typedef struct sensitive_function_is_a_no_op_row {
  cql_string_ref _Nonnull y;
} sensitive_function_is_a_no_op_row;

cql_string_ref _Nonnull sensitive_function_is_a_no_op_get_y(sensitive_function_is_a_no_op_result_set_ref _Nonnull result_set, cql_int32 row) {
  sensitive_function_is_a_no_op_row *data = (sensitive_function_is_a_no_op_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].y;
}

uint8_t sensitive_function_is_a_no_op_data_types[sensitive_function_is_a_no_op_data_types_count] = {
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // y
};

#define sensitive_function_is_a_no_op_refs_offset cql_offsetof(sensitive_function_is_a_no_op_row, y) // count = 1

static cql_uint16 sensitive_function_is_a_no_op_col_offsets[] = { 1,
  cql_offsetof(sensitive_function_is_a_no_op_row, y)
};

cql_int32 sensitive_function_is_a_no_op_result_count(sensitive_function_is_a_no_op_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code sensitive_function_is_a_no_op_fetch_results(sqlite3 *_Nonnull _db_, sensitive_function_is_a_no_op_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_sensitive_function_is_a_no_op, &sensitive_function_is_a_no_op_perf_index);
  cql_code rc = sensitive_function_is_a_no_op(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = sensitive_function_is_a_no_op_data_types,
    .col_offsets = sensitive_function_is_a_no_op_col_offsets,
    .refs_count = 1,
    .refs_offset = sensitive_function_is_a_no_op_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(sensitive_function_is_a_no_op_row),
    .crc = CRC_sensitive_function_is_a_no_op,
    .perf_index = &sensitive_function_is_a_no_op_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC sensitive_function_is_a_no_op () (y TEXT NOT NULL @SENSITIVE);
CQL_WARN_UNUSED cql_code sensitive_function_is_a_no_op(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_string_ref x = NULL;

  cql_set_string_ref(&x, _literal_23_hello_sensitive_function_is_a_no_op);
  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT 'hello'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_string_release(x);
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC and_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT)
BEGIN
  IF a > b AND (a < c OR c IS NULL) THEN
    SET c := a;
  END IF;
END;
*/

#define _PROC_ "and_preserves_temps"
// export: DECLARE PROC and_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT);
void and_preserves_temps(cql_nullable_int64 a, cql_nullable_int64 b, cql_nullable_int64 c) {
  cql_nullable_bool _tmp_n_bool_1;
  cql_set_null(_tmp_n_bool_1);
  cql_nullable_bool _tmp_n_bool_3;
  cql_set_null(_tmp_n_bool_3);
  cql_nullable_bool _tmp_n_bool_2;
  cql_set_null(_tmp_n_bool_2);
  cql_nullable_bool _tmp_n_bool_0;
  cql_set_null(_tmp_n_bool_0);

  cql_combine_nullables(_tmp_n_bool_1, a.is_null, b.is_null, a.value > b.value);
  if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_3, a.is_null, c.is_null, a.value < c.value);
    if (cql_is_nullable_true(_tmp_n_bool_3.is_null, _tmp_n_bool_3.value)) {
      cql_set_notnull(_tmp_n_bool_2, 1);
    }
    else {
      if (c.is_null) {
        cql_set_notnull(_tmp_n_bool_2, 1);
      }
      else {
        cql_set_nullable(_tmp_n_bool_2, _tmp_n_bool_3.is_null, 0);
      }
    }
    if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 1);
    }
  }
  if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
    cql_set_nullable(c, a.is_null, a.value);
  }

}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC or_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT)
BEGIN
  IF c < 0 OR a > c AND b > c THEN
    SET c := a;
  END IF;
END;
*/

#define _PROC_ "or_preserves_temps"
// export: DECLARE PROC or_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT);
void or_preserves_temps(cql_nullable_int64 a, cql_nullable_int64 b, cql_nullable_int64 c) {
  cql_nullable_bool _tmp_n_bool_1;
  cql_set_null(_tmp_n_bool_1);
  cql_nullable_bool _tmp_n_bool_3;
  cql_set_null(_tmp_n_bool_3);
  cql_nullable_bool _tmp_n_bool_4;
  cql_set_null(_tmp_n_bool_4);
  cql_nullable_bool _tmp_n_bool_2;
  cql_set_null(_tmp_n_bool_2);
  cql_nullable_bool _tmp_n_bool_0;
  cql_set_null(_tmp_n_bool_0);

  cql_set_nullable(_tmp_n_bool_1, c.is_null, c.value < 0);
  if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_3, a.is_null, c.is_null, a.value > c.value);
    if (cql_is_nullable_false(_tmp_n_bool_3.is_null, _tmp_n_bool_3.value)) {
      cql_set_notnull(_tmp_n_bool_2, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_4, b.is_null, c.is_null, b.value > c.value);
      if (cql_is_nullable_false(_tmp_n_bool_4.is_null, _tmp_n_bool_4.value)) {
        cql_set_notnull(_tmp_n_bool_2, 0);
      }
      else {
        cql_combine_nullables(_tmp_n_bool_2, _tmp_n_bool_3.is_null, _tmp_n_bool_4.is_null, 1);
      }
    }
    if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 0);
    }
  }
  if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
    cql_set_nullable(c, a.is_null, a.value);
  }

}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag ()
BEGIN
  SELECT 1234 AS shared_something;
END;
*/

// The statement ending at line XXXX

/*
CREATE PROC foo ()
BEGIN
  WITH
  shared_frag (shared_something) AS (CALL shared_frag())
  SELECT *
    FROM shared_frag;
END;
*/

#define _PROC_ "foo"
static int32_t foo_perf_index;

cql_string_proc_name(foo_stored_procedure_name, "foo");

typedef struct foo_row {
  cql_int32 shared_something;
} foo_row;

cql_int32 foo_get_shared_something(foo_result_set_ref _Nonnull result_set, cql_int32 row) {
  foo_row *data = (foo_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].shared_something;
}

uint8_t foo_data_types[foo_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // shared_something
};

static cql_uint16 foo_col_offsets[] = { 1,
  cql_offsetof(foo_row, shared_something)
};

cql_int32 foo_result_count(foo_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code foo_fetch_results(sqlite3 *_Nonnull _db_, foo_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_foo, &foo_perf_index);
  cql_code rc = foo(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = foo_data_types,
    .col_offsets = foo_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(foo_row),
    .crc = CRC_foo,
    .perf_index = &foo_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC foo () (shared_something INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code foo(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare_var(_db_, _result_stmt,
    3, NULL,
  "WITH "
    "shared_frag (shared_something) AS (",
  "SELECT 1234",
  ") "
    "SELECT shared_something "
      "FROM shared_frag"
  );
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_conditional (x INTEGER NOT NULL)
BEGIN
  IF x = 1 THEN
    SELECT x AS x;
  ELSE IF x = 2 THEN
    SELECT x + x AS x;
  ELSE
    SELECT x + x + x AS x;
  END IF;
END;
*/

// The statement ending at line XXXX

/*
CREATE PROC shared_conditional_user (x INTEGER NOT NULL)
BEGIN
  WITH
  some_cte (id) AS (SELECT x),
  shared_conditional (x) AS (CALL shared_conditional(1))
  SELECT bar.*
    FROM bar
    INNER JOIN some_cte ON x = 5;
END;
*/

#define _PROC_ "shared_conditional_user"
static int32_t shared_conditional_user_perf_index;

cql_string_proc_name(shared_conditional_user_stored_procedure_name, "shared_conditional_user");

typedef struct shared_conditional_user_row {
  cql_int32 id;
  cql_nullable_int64 rate;
  cql_nullable_int32 type;
  cql_nullable_double size;
  cql_string_ref _Nullable name;
} shared_conditional_user_row;

cql_int32 shared_conditional_user_get_id(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].id;
}

cql_string_ref _Nullable shared_conditional_user_get_name(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].name;
}

cql_bool shared_conditional_user_get_rate_is_null(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.is_null;
}

cql_int64 shared_conditional_user_get_rate_value(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].rate.value;
}

cql_bool shared_conditional_user_get_type_is_null(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.is_null;
}

cql_int32 shared_conditional_user_get_type_value(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].type.value;
}

cql_bool shared_conditional_user_get_size_is_null(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.is_null;
}

cql_double shared_conditional_user_get_size_value(shared_conditional_user_result_set_ref _Nonnull result_set, cql_int32 row) {
  shared_conditional_user_row *data = (shared_conditional_user_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].size.value;
}

uint8_t shared_conditional_user_data_types[shared_conditional_user_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // id
  CQL_DATA_TYPE_STRING, // name
  CQL_DATA_TYPE_INT64, // rate
  CQL_DATA_TYPE_INT32, // type
  CQL_DATA_TYPE_DOUBLE, // size
};

#define shared_conditional_user_refs_offset cql_offsetof(shared_conditional_user_row, name) // count = 1

static cql_uint16 shared_conditional_user_col_offsets[] = { 5,
  cql_offsetof(shared_conditional_user_row, id),
  cql_offsetof(shared_conditional_user_row, name),
  cql_offsetof(shared_conditional_user_row, rate),
  cql_offsetof(shared_conditional_user_row, type),
  cql_offsetof(shared_conditional_user_row, size)
};

cql_int32 shared_conditional_user_result_count(shared_conditional_user_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code shared_conditional_user_fetch_results(sqlite3 *_Nonnull _db_, shared_conditional_user_result_set_ref _Nullable *_Nonnull result_set, cql_int32 x) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_shared_conditional_user, &shared_conditional_user_perf_index);
  cql_code rc = shared_conditional_user(_db_, &stmt, x);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = shared_conditional_user_data_types,
    .col_offsets = shared_conditional_user_col_offsets,
    .refs_count = 1,
    .refs_offset = shared_conditional_user_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(shared_conditional_user_row),
    .crc = CRC_shared_conditional_user,
    .perf_index = &shared_conditional_user_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC shared_conditional_user (x INTEGER NOT NULL) (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL);
CQL_WARN_UNUSED cql_code shared_conditional_user(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt, cql_int32 x) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_int32 _p1_x_ = 0;
  char _preds_1[5];
  char _vpreds_1[8];

  memset(&_preds_1[0], 0, sizeof(_preds_1));
  memset(&_vpreds_1[0], 0, sizeof(_vpreds_1));
  _p1_x_ = 1;
  _preds_1[0] = 1;
  _vpreds_1[0] = 1; // pred 0 known to be 1
  if (_p1_x_ == 1) {
    _preds_1[1] = 1;
    _vpreds_1[1] = 1; // pred 1 known to be 1
  }
  else {
    if (_p1_x_ == 2) {
      _preds_1[2] = 1;
      _vpreds_1[2] = 1; // pred 2 known to be 1
      _vpreds_1[3] = 1; // pred 2 known to be 1
    }
    else {
      _preds_1[3] = 1;
      _vpreds_1[4] = 1; // pred 3 known to be 1
      _vpreds_1[5] = 1; // pred 3 known to be 1
      _vpreds_1[6] = 1; // pred 3 known to be 1
    }
  }
  _preds_1[4] = 1;
  _vpreds_1[7] = 1; // pred 0 known to be 1
  _rc_ = cql_prepare_var(_db_, _result_stmt,
    5, _preds_1,
  "WITH "
    "some_cte (id) AS (SELECT ?), "
    "shared_conditional (x) AS (",
  "SELECT ?",
  "SELECT ? + ?",
  "SELECT ? + ? + ?",
  ") "
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size "
      "FROM bar "
      "INNER JOIN some_cte ON ? = 5"
  );
  cql_multibind_var(&_rc_, _db_, _result_stmt, 8, _vpreds_1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, x,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, x);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:shared_fragment)
CREATE PROC nested_shared_proc (x_ INTEGER NOT NULL)
BEGIN
  IF x_ <= 5 THEN
    WITH
    shared_conditional (x) AS (CALL shared_conditional(1))
    SELECT *
      FROM shared_conditional
      WHERE x_ = 5;
  ELSE
    SELECT x_ AS x;
  END IF;
END;
*/

// The statement ending at line XXXX

/*
CREATE PROC nested_shared_stuff ()
BEGIN
  WITH
  nested_shared_proc (x) AS (CALL nested_shared_proc(1))
  SELECT *
    FROM nested_shared_proc;
END;
*/

#define _PROC_ "nested_shared_stuff"
static int32_t nested_shared_stuff_perf_index;

cql_string_proc_name(nested_shared_stuff_stored_procedure_name, "nested_shared_stuff");

typedef struct nested_shared_stuff_row {
  cql_int32 x;
} nested_shared_stuff_row;

cql_int32 nested_shared_stuff_get_x(nested_shared_stuff_result_set_ref _Nonnull result_set, cql_int32 row) {
  nested_shared_stuff_row *data = (nested_shared_stuff_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t nested_shared_stuff_data_types[nested_shared_stuff_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 nested_shared_stuff_col_offsets[] = { 1,
  cql_offsetof(nested_shared_stuff_row, x)
};

cql_int32 nested_shared_stuff_result_count(nested_shared_stuff_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code nested_shared_stuff_fetch_results(sqlite3 *_Nonnull _db_, nested_shared_stuff_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_nested_shared_stuff, &nested_shared_stuff_perf_index);
  cql_code rc = nested_shared_stuff(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = nested_shared_stuff_data_types,
    .col_offsets = nested_shared_stuff_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(nested_shared_stuff_row),
    .crc = CRC_nested_shared_stuff,
    .perf_index = &nested_shared_stuff_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC nested_shared_stuff () (x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code nested_shared_stuff(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_int32 _p1_x__ = 0;
  cql_int32 _p2_x_ = 0;
  char _preds_1[8];
  char _vpreds_1[8];

  memset(&_preds_1[0], 0, sizeof(_preds_1));
  memset(&_vpreds_1[0], 0, sizeof(_vpreds_1));
  _p1_x__ = 1;
  _preds_1[0] = 1;
  if (_p1_x__ <= 5) {
    _preds_1[1] = 1;
    _p2_x_ = 1;
    if (_p2_x_ == 1) {
      _preds_1[2] = 1;
      _vpreds_1[0] = 1; // pred 2 known to be 1
    }
    else {
      if (_p2_x_ == 2) {
        _preds_1[3] = 1;
        _vpreds_1[1] = 1; // pred 3 known to be 1
        _vpreds_1[2] = 1; // pred 3 known to be 1
      }
      else {
        _preds_1[4] = 1;
        _vpreds_1[3] = 1; // pred 4 known to be 1
        _vpreds_1[4] = 1; // pred 4 known to be 1
        _vpreds_1[5] = 1; // pred 4 known to be 1
      }
    }
    _preds_1[5] = _preds_1[1];
    _vpreds_1[6] = _preds_1[1];
  }
  else {
    _preds_1[6] = 1;
    _vpreds_1[7] = 1; // pred 6 known to be 1
  }
  _preds_1[7] = 1;
  _rc_ = cql_prepare_var(_db_, _result_stmt,
    8, _preds_1,
  "WITH "
    "nested_shared_proc (x) AS (",
  "WITH "
    "shared_conditional (x) AS (",
  "SELECT ?",
  "SELECT ? + ?",
  "SELECT ? + ? + ?",
  ") "
    "SELECT x "
      "FROM shared_conditional "
      "WHERE ? = 5",
  "SELECT ?",
  ") "
    "SELECT x "
      "FROM nested_shared_proc"
  );
  cql_multibind_var(&_rc_, _db_, _result_stmt, 8, _vpreds_1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x__,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x__);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC use_nested_select_shared_frag_form ()
BEGIN
  SELECT *
    FROM (CALL nested_shared_proc(1));
END;
*/

#define _PROC_ "use_nested_select_shared_frag_form"
static int32_t use_nested_select_shared_frag_form_perf_index;

cql_string_proc_name(use_nested_select_shared_frag_form_stored_procedure_name, "use_nested_select_shared_frag_form");

typedef struct use_nested_select_shared_frag_form_row {
  cql_int32 x;
} use_nested_select_shared_frag_form_row;

cql_int32 use_nested_select_shared_frag_form_get_x(use_nested_select_shared_frag_form_result_set_ref _Nonnull result_set, cql_int32 row) {
  use_nested_select_shared_frag_form_row *data = (use_nested_select_shared_frag_form_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].x;
}

uint8_t use_nested_select_shared_frag_form_data_types[use_nested_select_shared_frag_form_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // x
};

static cql_uint16 use_nested_select_shared_frag_form_col_offsets[] = { 1,
  cql_offsetof(use_nested_select_shared_frag_form_row, x)
};

cql_int32 use_nested_select_shared_frag_form_result_count(use_nested_select_shared_frag_form_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code use_nested_select_shared_frag_form_fetch_results(sqlite3 *_Nonnull _db_, use_nested_select_shared_frag_form_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_use_nested_select_shared_frag_form, &use_nested_select_shared_frag_form_perf_index);
  cql_code rc = use_nested_select_shared_frag_form(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = use_nested_select_shared_frag_form_data_types,
    .col_offsets = use_nested_select_shared_frag_form_col_offsets,
    .encode_context_index = -1,
    .rowsize = sizeof(use_nested_select_shared_frag_form_row),
    .crc = CRC_use_nested_select_shared_frag_form,
    .perf_index = &use_nested_select_shared_frag_form_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

// export: DECLARE PROC use_nested_select_shared_frag_form () (x INTEGER NOT NULL);
CQL_WARN_UNUSED cql_code use_nested_select_shared_frag_form(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_int32 _p1_x__ = 0;
  cql_int32 _p2_x_ = 0;
  char _preds_1[10];
  char _vpreds_1[8];

  memset(&_preds_1[0], 0, sizeof(_preds_1));
  memset(&_vpreds_1[0], 0, sizeof(_vpreds_1));
  _p1_x__ = 1;
  _preds_1[0] = 1;
  _preds_1[1] = 1;
  if (_p1_x__ <= 5) {
    _preds_1[2] = 1;
    _p2_x_ = 1;
    if (_p2_x_ == 1) {
      _preds_1[3] = 1;
      _vpreds_1[0] = 1; // pred 3 known to be 1
    }
    else {
      if (_p2_x_ == 2) {
        _preds_1[4] = 1;
        _vpreds_1[1] = 1; // pred 4 known to be 1
        _vpreds_1[2] = 1; // pred 4 known to be 1
      }
      else {
        _preds_1[5] = 1;
        _vpreds_1[3] = 1; // pred 5 known to be 1
        _vpreds_1[4] = 1; // pred 5 known to be 1
        _vpreds_1[5] = 1; // pred 5 known to be 1
      }
    }
    _preds_1[6] = _preds_1[2];
    _vpreds_1[6] = _preds_1[2];
  }
  else {
    _preds_1[7] = 1;
    _vpreds_1[7] = 1; // pred 7 known to be 1
  }
  _preds_1[8] = 1;
  _preds_1[9] = 1;
  _rc_ = cql_prepare_var(_db_, _result_stmt,
    10, _preds_1,
  "SELECT x "
      "FROM (",
  "WITH _ns_(x) AS (",
  "WITH "
    "shared_conditional (x) AS (",
  "SELECT ?",
  "SELECT ? + ?",
  "SELECT ? + ? + ?",
  ") "
    "SELECT x "
      "FROM shared_conditional "
      "WHERE ? = 5",
  "SELECT ?",
  ") SELECT * FROM _ns_",
  ")"
  );
  cql_multibind_var(&_rc_, _db_, _result_stmt, 8, _vpreds_1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p2_x_,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x__,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, _p1_x__);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
@ATTRIBUTE(cql:private)
CREATE PROC simple_shared_frag ()
BEGIN
  SELECT *
    FROM (CALL shared_frag());
END;
*/

#define _PROC_ "simple_shared_frag"
// private: DECLARE PROC simple_shared_frag () (shared_something INTEGER NOT NULL);
static CQL_WARN_UNUSED cql_code simple_shared_frag(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  _rc_ = cql_prepare_var(_db_, _result_stmt,
    5, NULL,
  "SELECT shared_something "
      "FROM (",
  "WITH _ns_(shared_something) AS (",
  "SELECT 1234",
  ") SELECT * FROM _ns_",
  ")"
  );
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// The statement ending at line XXXX

/*
CREATE PROC slash_star_and_star_slash ()
BEGIN
  LET x := "/+  +/";
END;
*/

#define _PROC_ "slash_star_and_star_slash"
// export: DECLARE PROC slash_star_and_star_slash ();
void slash_star_and_star_slash(void) {
  cql_string_ref x = NULL;

  cql_set_string_ref(&x, _literal_24_slash_star_and_star_slash);

  cql_string_release(x);
}
#undef _PROC_
cql_int32 this_is_the_end = 0;

// The statement ending at line XXXX

/*
CREATE PROC end_proc ()
BEGIN
END;
*/

#define _PROC_ "end_proc"
// export: DECLARE PROC end_proc ();
void end_proc(void) {

}
#undef _PROC_

// The statement ending at line XXXX

/*
DECLARE end_marker INTEGER;
*/
cql_nullable_int32 end_marker;
#define _PROC_ cql_startup

cql_code cql_startup(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_nullable_bool _tmp_n_bool_1;
  cql_nullable_bool _tmp_n_bool_0;
  cql_nullable_double _tmp_n_double_1;
  cql_nullable_double _tmp_n_double_2;
  cql_nullable_double _tmp_n_double_3;
  cql_int32 _tmp_int_1 = 0;
  cql_nullable_int32 _tmp_n_int_2;
  cql_int32 _tmp_int_2 = 0;
  cql_nullable_int32 _tmp_n_int_3;
  cql_bool _tmp_bool_0 = 0;
  cql_nullable_int32 _tmp_n_int_0;
  cql_nullable_bool _tmp_n_bool_2;
  cql_nullable_int64 _tmp_n_int64_1;
  cql_nullable_int32 _tmp_n_int_1;
  cql_nullable_int64 _tmp_n_int64_2;
  cql_string_ref _tmp_text_0 = NULL;
  cql_object_ref _tmp_n_object_1 = NULL;
  cql_object_ref _tmp_object_1 = NULL;
  cql_object_ref _tmp_n_object_0 = NULL;
  cql_blob_ref _tmp_n_blob_1 = NULL;
  cql_blob_ref _tmp_blob_1 = NULL;
  cql_blob_ref _tmp_blob_0 = NULL;
  cql_string_ref _tmp_n_text_1 = NULL;
  cql_int64 _tmp_int64_2 = 0;
  cql_double _tmp_double_2 = 0;
  cql_bool _tmp_bool_1 = 0;

  // The statement ending at line XXXX

  /*
  SET t2 := "text";
  */
  cql_set_string_ref(&t2, _literal_1_text_);

  // The statement ending at line XXXX

  /*
  SET i2 := 1;
  */
  i2 = 1;

  // The statement ending at line XXXX

  /*
  SET i1_nullable := 88;
  */
  cql_set_notnull(i1_nullable, 88);

  // The statement ending at line XXXX

  /*
  SET i1_nullable := NULL;
  */
  cql_set_null(i1_nullable);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i1_nullable;
  */
  cql_set_nullable(i0_nullable, i1_nullable.is_null, i1_nullable.value);

  // The statement ending at line XXXX

  /*
  SET t0_nullable := NULL;
  */
  cql_set_string_ref(&t0_nullable, NULL);

  // The statement ending at line XXXX

  /*
  SET t0_nullable := t2;
  */
  cql_set_string_ref(&t0_nullable, t2);

  // The statement ending at line XXXX

  /*
  SET t0_nullable := NULL;
  */
  cql_set_string_ref(&t0_nullable, NULL);

  // The statement ending at line XXXX

  /*
  SET i2 := - -1;
  */
  i2 = - - 1;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := -i2;
  */
  cql_set_notnull(i0_nullable, - i2);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := -NULL;
  */
  cql_set_null(i0_nullable);

  // The statement ending at line XXXX

  /*
  SET i1_nullable := -i0_nullable;
  */
  cql_set_nullable(i1_nullable, i0_nullable.is_null, - i0_nullable.value);

  // The statement ending at line XXXX

  /*
  SET r0_nullable := 2.2;
  */
  cql_set_notnull(r0_nullable, 2.2);

  // The statement ending at line XXXX

  /*
  SET r0_nullable := NULL;
  */
  cql_set_null(r0_nullable);

  // The statement ending at line XXXX

  /*
  SET r2 := 3.5;
  */
  r2 = 3.5;

  // The statement ending at line XXXX

  /*
  SET i1_nullable := NOT NOT i0_nullable;
  */
  cql_set_nullable(_tmp_n_bool_1, i0_nullable.is_null, ! i0_nullable.value);
  cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, ! _tmp_n_bool_1.value);
  cql_set_nullable(i1_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := NOT NOT b2;
  */
  i2 = ! ! b2;

  // The statement ending at line XXXX

  /*
  SET i2 := 1 * 3 + 5;
  */
  i2 = 1 * 3 + 5;

  // The statement ending at line XXXX

  /*
  SET r0_nullable := r0_nullable * i1_nullable;
  */
  cql_combine_nullables(r0_nullable, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);

  // The statement ending at line XXXX

  /*
  SET r0_nullable := r0_nullable * i2;
  */
  cql_set_nullable(r0_nullable, r0_nullable.is_null, r0_nullable.value * i2);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := 12 * i1_nullable;
  */
  cql_set_nullable(i0_nullable, i1_nullable.is_null, 12 * i1_nullable.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := NULL * i1_nullable;
  */
  cql_set_null(i0_nullable);

  // The statement ending at line XXXX

  /*
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i1_nullable;
  */
  cql_combine_nullables(_tmp_n_double_1, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(_tmp_n_double_2, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(r0_nullable, _tmp_n_double_1.is_null, _tmp_n_double_2.is_null, _tmp_n_double_1.value + _tmp_n_double_2.value);

  // The statement ending at line XXXX

  /*
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i0_nullable + r0_nullable;
  */
  cql_combine_nullables(_tmp_n_double_2, r0_nullable.is_null, i1_nullable.is_null, r0_nullable.value * i1_nullable.value);
  cql_combine_nullables(_tmp_n_double_3, r0_nullable.is_null, i0_nullable.is_null, r0_nullable.value * i0_nullable.value);
  cql_combine_nullables(_tmp_n_double_1, _tmp_n_double_2.is_null, _tmp_n_double_3.is_null, _tmp_n_double_2.value + _tmp_n_double_3.value);
  cql_combine_nullables(r0_nullable, _tmp_n_double_1.is_null, r0_nullable.is_null, _tmp_n_double_1.value + r0_nullable.value);

  // The statement ending at line XXXX

  /*
  SET t2 := "This is a \" \\ test '' \n \" ";
  */
  cql_set_string_ref(&t2, _literal_2_This_is_a_test_);

  // The statement ending at line XXXX

  /*
  CALL printf("Hello, world\n");
  */
  printf("Hello, world\n");

  // The statement ending at line XXXX

  /*
  SET i2 := r2 AND l2;
  */
  i2 = r2 && l2;

  // The statement ending at line XXXX

  /*
  SET i2 := coalesce(side_effect1(), 7) AND coalesce(side_effect2(), 5);
  */
  do {
    _tmp_n_int_2 = side_effect1();
    if (!_tmp_n_int_2.is_null) {
      _tmp_int_1 = _tmp_n_int_2.value;
      break;
    }
    _tmp_int_1 = 7;
  } while (0);
  if (!(_tmp_int_1)) {
    _tmp_bool_0 = 0;
  }
  else {
    do {
      _tmp_n_int_3 = side_effect2();
      if (!_tmp_n_int_3.is_null) {
        _tmp_int_2 = _tmp_n_int_3.value;
        break;
      }
      _tmp_int_2 = 5;
    } while (0);
    _tmp_bool_0 = !!(_tmp_int_2);
  }
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := NULL AND NULL;
  */
  cql_set_null(_tmp_n_bool_0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i0_nullable AND i1_nullable;
  */
  if (cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (cql_is_nullable_false(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := NULL AND i1_nullable;
  */
  if (0) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (cql_is_nullable_false(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i0_nullable AND NULL;
  */
  if (cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (0) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := r2 OR l2;
  */
  i2 = r2 || l2;

  // The statement ending at line XXXX

  /*
  SET i2 := coalesce(side_effect1(), 7) OR coalesce(side_effect2(), 5);
  */
  do {
    _tmp_n_int_2 = side_effect1();
    if (!_tmp_n_int_2.is_null) {
      _tmp_int_1 = _tmp_n_int_2.value;
      break;
    }
    _tmp_int_1 = 7;
  } while (0);
  if (_tmp_int_1) {
    _tmp_bool_0 = 1;
  }
  else {
    do {
      _tmp_n_int_3 = side_effect2();
      if (!_tmp_n_int_3.is_null) {
        _tmp_int_2 = _tmp_n_int_3.value;
        break;
      }
      _tmp_int_2 = 5;
    } while (0);
    _tmp_bool_0 = !!(_tmp_int_2);
  }
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := NULL OR NULL;
  */
  cql_set_null(_tmp_n_bool_0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i0_nullable OR i1_nullable;
  */
  if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := NULL OR i1_nullable;
  */
  if (0) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i0_nullable OR NULL;
  */
  if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_null(_tmp_n_bool_0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := NULL IS NULL;
  */
  i2 = 1;

  // The statement ending at line XXXX

  /*
  SET i2 := i0_nullable + i1_nullable IS NULL;
  */
  cql_combine_nullables(_tmp_n_int_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value + i1_nullable.value);
  i2 = _tmp_n_int_0.is_null;

  // The statement ending at line XXXX

  /*
  SET i2 := NULL IS NOT NULL;
  */
  i2 = !1;

  // The statement ending at line XXXX

  /*
  SET i2 := i0_nullable + i1_nullable IS NOT NULL;
  */
  cql_combine_nullables(_tmp_n_int_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value + i1_nullable.value);
  i2 = !_tmp_n_int_0.is_null;

  // The statement ending at line XXXX

  /*
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable = i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  */
  if (1) {
    i2 = 1;
  }
  else {
    cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, i0_nullable.value == i1_nullable.value);
    if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
      i2 = 2;
    }
    else {
      i2 = 3;
    }
  }

  // The statement ending at line XXXX

  /*
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable OR i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  */
  if (1) {
    i2 = 1;
  }
  else {
    if (cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      if (cql_is_nullable_true(i1_nullable.is_null, i1_nullable.value)) {
        cql_set_notnull(_tmp_n_bool_0, 1);
      }
      else {
        cql_combine_nullables(_tmp_n_bool_0, i0_nullable.is_null, i1_nullable.is_null, 0);
      }
    }
    if (cql_is_nullable_true(_tmp_n_bool_0.is_null, _tmp_n_bool_0.value)) {
      i2 = 2;
    }
    else {
      i2 = 3;
    }
  }

  // The statement ending at line XXXX

  /*
  SET b2 := BETWEEN REWRITE _between_0_ := 1 CHECK (_between_0_ >= 0 AND _between_0_ <= 3);
  */
  _between_0_ = 1;
  b2 = _between_0_ >= 0 && _between_0_ <= 3;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := BETWEEN REWRITE _between_1_ := i1_nullable CHECK (_between_1_ >= i0_nullable AND _between_1_ <= r2);
  */
  cql_set_nullable(_between_1_, i1_nullable.is_null, i1_nullable.value);
  cql_combine_nullables(_tmp_n_bool_1, _between_1_.is_null, i0_nullable.is_null, _between_1_.value >= i0_nullable.value);
  if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_set_nullable(_tmp_n_bool_2, _between_1_.is_null, _between_1_.value <= r2);
    if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := BETWEEN REWRITE _between_2_ := i1_nullable CHECK (_between_2_ >= r2 AND _between_2_ <= i0_nullable);
  */
  cql_set_nullable(_between_2_, i1_nullable.is_null, i1_nullable.value);
  cql_set_nullable(_tmp_n_bool_1, _between_2_.is_null, _between_2_.value >= r2);
  if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_2, _between_2_.is_null, i0_nullable.is_null, _between_2_.value <= i0_nullable.value);
    if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 1);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := BETWEEN REWRITE _between_3_ := 1 CHECK (_between_3_ < 0 OR _between_3_ > 3);
  */
  _between_3_ = 1;
  b2 = _between_3_ < 0 || _between_3_ > 3;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := BETWEEN REWRITE _between_4_ := i1_nullable CHECK (_between_4_ < i0_nullable OR _between_4_ > r2);
  */
  cql_set_nullable(_between_4_, i1_nullable.is_null, i1_nullable.value);
  cql_combine_nullables(_tmp_n_bool_1, _between_4_.is_null, i0_nullable.is_null, _between_4_.value < i0_nullable.value);
  if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_set_nullable(_tmp_n_bool_2, _between_4_.is_null, _between_4_.value > r2);
    if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := BETWEEN REWRITE _between_5_ := i1_nullable CHECK (_between_5_ < r2 OR _between_5_ > i0_nullable);
  */
  cql_set_nullable(_between_5_, i1_nullable.is_null, i1_nullable.value);
  cql_set_nullable(_tmp_n_bool_1, _between_5_.is_null, _between_5_.value < r2);
  if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_2, _between_5_.is_null, i0_nullable.is_null, _between_5_.value > i0_nullable.value);
    if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_combine_nullables(_tmp_n_bool_0, _tmp_n_bool_1.is_null, _tmp_n_bool_2.is_null, 0);
    }
  }
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET longint_var := (l0_nullable + l1_nullable) * 5;
  */
  cql_combine_nullables(_tmp_n_int64_1, l0_nullable.is_null, l1_nullable.is_null, l0_nullable.value + l1_nullable.value);
  cql_set_nullable(longint_var, _tmp_n_int64_1.is_null, _tmp_n_int64_1.value * 5);

  // The statement ending at line XXXX

  /*
  DECLARE foo_cursor CURSOR FOR SELECT id, i2
    FROM foo
    WHERE id = i0_nullable;
  */
  _rc_ = cql_prepare(_db_, &foo_cursor_stmt,
    "SELECT id, ? "
      "FROM foo "
      "WHERE id = ?");
  cql_multibind(&_rc_, _db_, &foo_cursor_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, i2,
                CQL_DATA_TYPE_INT32, &i0_nullable);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  FETCH foo_cursor INTO i0_nullable, i2;
  */
  _rc_ = sqlite3_step(foo_cursor_stmt);
  _foo_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, foo_cursor_stmt, 2,
                 CQL_DATA_TYPE_INT32, &i0_nullable,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &i2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  DECLARE basic_cursor CURSOR FOR SELECT 1, 2.5;
  */
  _rc_ = cql_prepare(_db_, &basic_cursor_stmt,
    "SELECT 1, 2.5");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  FETCH basic_cursor INTO col1, col2;
  */
  _rc_ = sqlite3_step(basic_cursor_stmt);
  _basic_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, basic_cursor_stmt, 2,
                 CQL_DATA_TYPE_INT32, &col1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_DOUBLE, &col2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  CLOSE basic_cursor;
  */
  cql_finalize_stmt(&basic_cursor_stmt);

  // The statement ending at line XXXX

  /*
  SET arg1 := 7;
  */
  arg1 = 7;

  // The statement ending at line XXXX

  /*
  SET arg2 := 11;
  */
  arg2 = 11;

  // The statement ending at line XXXX

  /*
  DECLARE exchange_cursor CURSOR FOR SELECT arg2, arg1;
  */
  _rc_ = cql_prepare(_db_, &exchange_cursor_stmt,
    "SELECT ?, ?");
  cql_multibind(&_rc_, _db_, &exchange_cursor_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, arg2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, arg1);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  FETCH exchange_cursor INTO arg1, arg2;
  */
  _rc_ = sqlite3_step(exchange_cursor_stmt);
  _exchange_cursor_has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, exchange_cursor_stmt, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &arg1,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &arg2);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  CLOSE exchange_cursor;
  */
  cql_finalize_stmt(&exchange_cursor_stmt);

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT i2 + 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ? + 1");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    i2 = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := ( SELECT i0_nullable + 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ? + 1");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_INT32, &i0_nullable);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_int32(_temp_stmt, 0, &i0_nullable);
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  DELETE FROM bar WHERE name LIKE '\\ " \n';
  */
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\\\\ \" \\n'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET i2 := CASE WHEN 1 THEN 100
  WHEN 2 THEN 200
  WHEN NULL THEN 500
  ELSE 300
  END;
  */
  do {
    if (1) {
      i2 = 100;
      break;
    }
    if (2) {
      i2 = 200;
      break;
    }
    i2 = 300;
  } while (0);

  // The statement ending at line XXXX

  /*
  SET i2 := 3 IN (1, 2, NULL, 4);
  */
  do {
    _tmp_int_1 = 3;
    _tmp_bool_0 = 1;
    if (_tmp_int_1 == 1) break;
    if (_tmp_int_1 == 2) break;
    if (_tmp_int_1 == 4) break;
    _tmp_bool_0 = 0;
  } while (0);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i1_nullable IN (1, 2, NULL, b0_nullable);
  */
  do {
    cql_set_nullable(_tmp_n_int_1, i1_nullable.is_null, i1_nullable.value);
    if (_tmp_n_int_1.is_null) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (_tmp_n_int_1.value == 1) break;
    if (_tmp_n_int_1.value == 2) break;
    if (cql_is_nullable_true(b0_nullable.is_null, _tmp_n_int_1.value == b0_nullable.value)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := 3 NOT IN (1, 2, NULL, 4);
  */
  do {
    _tmp_int_1 = 3;
    _tmp_bool_0 = 0;
    if (_tmp_int_1 == 1) break;
    if (_tmp_int_1 == 2) break;
    if (_tmp_int_1 == 4) break;
    _tmp_bool_0 = 1;
  } while (0);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i0_nullable := i1_nullable NOT IN (1, 2, NULL, b0_nullable);
  */
  do {
    cql_set_nullable(_tmp_n_int_1, i1_nullable.is_null, i1_nullable.value);
    if (_tmp_n_int_1.is_null) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (_tmp_n_int_1.value == 1) break;
    if (_tmp_n_int_1.value == 2) break;
    if (cql_is_nullable_true(b0_nullable.is_null, _tmp_n_int_1.value == b0_nullable.value)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(i0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := BETWEEN REWRITE _between_6_ := 'b' CHECK (_between_6_ >= 'a' AND _between_6_ <= 'c');
  */
  cql_set_string_ref(&_between_6_, _literal_3_b_);
  b2 = cql_string_compare(_between_6_, _literal_4_a_) >= 0 && cql_string_compare(_between_6_, _literal_5_c_) <= 0;

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_7_ := 'b' CHECK (_between_7_ >= 'a' AND _between_7_ <= t0_nullable);
  */
  cql_set_string_ref(&_between_7_, _literal_3_b_);
  if (!(cql_string_compare(_between_7_, _literal_4_a_) >= 0)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_2, !_between_7_, !t0_nullable, cql_string_compare(_between_7_, t0_nullable) <= 0);
    if (cql_is_nullable_false(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_8_ := 'b' CHECK (_between_8_ >= t0_nullable AND _between_8_ <= 'c');
  */
  cql_set_string_ref(&_between_8_, _literal_3_b_);
  cql_combine_nullables(_tmp_n_bool_1, !_between_8_, !t0_nullable, cql_string_compare(_between_8_, t0_nullable) >= 0);
  if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (!(cql_string_compare(_between_8_, _literal_5_c_) <= 0)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_9_ := 'b' CHECK (_between_9_ >= NULL AND _between_9_ <= 'c');
  */
  cql_set_string_ref(&_between_9_, _literal_3_b_);
  cql_set_null(_tmp_n_bool_1);
  if (cql_is_nullable_false(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 0);
  }
  else {
    if (!(cql_string_compare(_between_9_, _literal_5_c_) <= 0)) {
      cql_set_notnull(_tmp_n_bool_0, 0);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 1);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := BETWEEN REWRITE _between_10_ := 'b' CHECK (_between_10_ < 'a' OR _between_10_ > 'c');
  */
  cql_set_string_ref(&_between_10_, _literal_3_b_);
  b2 = cql_string_compare(_between_10_, _literal_4_a_) < 0 || cql_string_compare(_between_10_, _literal_5_c_) > 0;

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_11_ := 'b' CHECK (_between_11_ < 'a' OR _between_11_ > t0_nullable);
  */
  cql_set_string_ref(&_between_11_, _literal_3_b_);
  if (cql_string_compare(_between_11_, _literal_4_a_) < 0) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    cql_combine_nullables(_tmp_n_bool_2, !_between_11_, !t0_nullable, cql_string_compare(_between_11_, t0_nullable) > 0);
    if (cql_is_nullable_true(_tmp_n_bool_2.is_null, _tmp_n_bool_2.value)) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_2.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_12_ := 'b' CHECK (_between_12_ < t0_nullable OR _between_12_ > 'c');
  */
  cql_set_string_ref(&_between_12_, _literal_3_b_);
  cql_combine_nullables(_tmp_n_bool_1, !_between_12_, !t0_nullable, cql_string_compare(_between_12_, t0_nullable) < 0);
  if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_string_compare(_between_12_, _literal_5_c_) > 0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := BETWEEN REWRITE _between_13_ := 'b' CHECK (_between_13_ < NULL OR _between_13_ > 'c');
  */
  cql_set_string_ref(&_between_13_, _literal_3_b_);
  cql_set_null(_tmp_n_bool_1);
  if (cql_is_nullable_true(_tmp_n_bool_1.is_null, _tmp_n_bool_1.value)) {
    cql_set_notnull(_tmp_n_bool_0, 1);
  }
  else {
    if (cql_string_compare(_between_13_, _literal_5_c_) > 0) {
      cql_set_notnull(_tmp_n_bool_0, 1);
    }
    else {
      cql_set_nullable(_tmp_n_bool_0, _tmp_n_bool_1.is_null, 0);
    }
  }
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := ifnull(i0_nullable, 3);
  */
  do {
    if (!i0_nullable.is_null) {
      i2 = i0_nullable.value;
      break;
    }
    i2 = 3;
  } while (0);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := ifnull(i0_nullable, i1_nullable);
  */
  do {
    if (!i0_nullable.is_null) {
      cql_set_notnull(i0_nullable, i0_nullable.value);
      break;
    }
    cql_set_nullable(i0_nullable, i1_nullable.is_null, i1_nullable.value);
  } while (0);

  // The statement ending at line XXXX

  /*
  CALL copy_int(i0_nullable, i1_nullable);
  */
  copy_int(i0_nullable, &i1_nullable);

  // The statement ending at line XXXX

  /*
  SET s := printf('%d and %d', 1, 2);
  */
  {
    char *_printf_result = sqlite3_mprintf("%d and %d", 1, 2);
    cql_string_release(s);
    s = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }

  // The statement ending at line XXXX

  /*
  SET s := printf('%d and %d', 3, 4);
  */
  {
    char *_printf_result = sqlite3_mprintf("%d and %d", 3, 4);
    cql_string_release(s);
    s = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }

  // The statement ending at line XXXX

  /*
  SET s := printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', CAST(5 AS LONG_INT), CAST(nullable(5) AS LONG_INT), CAST(TRUE AS LONG_INT), 0L, CAST(FALSE AS INTEGER), 0, 6L, 7, 0.0, 0.0, NULL, CAST(8 AS REAL));
  */
  {
  cql_set_notnull(_tmp_n_int64_2, ((cql_int64)(5)));
    char *_printf_result = sqlite3_mprintf("%lld %lld %lld %llu %d %d %llu %d %f %f %s %f", ((cql_int64)(5)), _tmp_n_int64_2.value, ((cql_int64)!!(1)), _64(0), ((cql_int32)!!(0)), 0, _64(6), 7, 0.0, 0.0, NULL, ((cql_double)(8)));
    cql_string_release(s);
    s = cql_string_ref_new(_printf_result);
    sqlite3_free(_printf_result);
  }

  // The statement ending at line XXXX

  /*
  SET s := ( SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, nullable(5), TRUE, NULL, FALSE, NULL, 6L, 7, 0.0, NULL, NULL, 8) );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, 5, 1, NULL, 0, NULL, 6, 7, 0.0, NULL, NULL, 8)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_string_ref(_temp_stmt, 0, &s);
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET S := 'x';
  */
  cql_set_string_ref(&s, _literal_6_x_);

  // The statement ending at line XXXX

  /*
  LET result := simple_func(2);
  */
  cql_set_notnull(_tmp_n_int_1, 2);
  result = simple_func(_tmp_n_int_1);

  // The statement ending at line XXXX

  /*
  SET result := simple_func(simple_func(1));
  */
  cql_set_notnull(_tmp_n_int_2, 1);
  _tmp_n_int_1 = simple_func(_tmp_n_int_2);
  result = simple_func(_tmp_n_int_1);

  // The statement ending at line XXXX

  /*
  SET text_result := text_func(123, 456);
  */
  cql_set_notnull(_tmp_n_int_1, 123);
  cql_set_string_ref(&_tmp_text_0, text_func(_tmp_n_int_1, 456));
  cql_set_string_ref(&text_result, _tmp_text_0);

  // The statement ending at line XXXX

  /*
  SET obj_var := NULL;
  */
  cql_set_object_ref(&obj_var, NULL);

  // The statement ending at line XXXX

  /*
  SET obj_var2 := obj_notnull_func();
  */
  cql_set_object_ref(&obj_var2, obj_notnull_func());

  // The statement ending at line XXXX

  /*
  SET obj_var := obj_var2;
  */
  cql_set_object_ref(&obj_var, obj_var2);

  // The statement ending at line XXXX

  /*
  SET obj_var := NULL;
  */
  cql_set_object_ref(&obj_var, NULL);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := obj_var = obj_var;
  */
  cql_combine_nullables(b0_nullable, !obj_var, !obj_var, obj_var == obj_var);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := obj_var IN (obj_var, obj_var);
  */
  do {
    cql_set_object_ref(&_tmp_n_object_1, obj_var);
    if (!_tmp_n_object_1) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) break;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := obj_var2 IN (obj_var2, obj_var2);
  */
  do {
    cql_set_object_ref(&_tmp_object_1, obj_var2);
    _tmp_bool_0 = 1;
    if (_tmp_object_1 == obj_var2) break;
    if (_tmp_object_1 == obj_var2) break;
    _tmp_bool_0 = 0;
  } while (0);
  b2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET b0_nullable := obj_var NOT IN (obj_var, obj_var);
  */
  do {
    cql_set_object_ref(&_tmp_n_object_1, obj_var);
    if (!_tmp_n_object_1) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) break;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := obj_var2 NOT IN (obj_var2, obj_var2);
  */
  do {
    cql_set_object_ref(&_tmp_object_1, obj_var2);
    _tmp_bool_0 = 0;
    if (_tmp_object_1 == obj_var2) break;
    if (_tmp_object_1 == obj_var2) break;
    _tmp_bool_0 = 1;
  } while (0);
  b2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := CASE obj_var WHEN obj_var THEN 1
  ELSE 2
  END;
  */
  do {
      cql_set_object_ref(&_tmp_n_object_1, obj_var);
      if (!_tmp_n_object_1) goto case_else_1;
    if (cql_is_nullable_true(!obj_var, _tmp_n_object_1 == obj_var)) {
      i2 = 1;
      break;
    }
    case_else_1:
    i2 = 2;
  } while (0);

  // The statement ending at line XXXX

  /*
  SET obj_var := CASE 1 WHEN 1 THEN obj_var2
  ELSE NULL
  END;
  */
  do {
      _tmp_int_1 = 1;
    if (_tmp_int_1 == 1) {
      cql_set_object_ref(&obj_var, obj_var2);
      break;
    }
    cql_set_object_ref(&obj_var, NULL);
  } while (0);

  // The statement ending at line XXXX

  /*
  SET obj_var := obj_func();
  */
  cql_set_object_ref(&obj_var, obj_func());

  // The statement ending at line XXXX

  /*
  SET obj_var := obj_func_create();
  */
  cql_object_release(obj_var);
  obj_var = obj_func_create();

  // The statement ending at line XXXX

  /*
  SET text_result := text_func_create();
  */
  cql_string_release(text_result);
  text_result = text_func_create();

  // The statement ending at line XXXX

  /*
  SET obj_var2 := ifnull_crash(obj_func());
  */
  cql_set_object_ref(&_tmp_n_object_0, obj_func());
  cql_invariant(!!_tmp_n_object_0);
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);

  // The statement ending at line XXXX

  /*
  SET obj_var2 := ifnull_crash(obj_func());
  */
  cql_set_object_ref(&_tmp_n_object_0, obj_func());
  cql_invariant(!!_tmp_n_object_0);
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);

  // The statement ending at line XXXX

  /*
  SET obj_var2 := ifnull_throw(obj_func());
  */
  cql_set_object_ref(&_tmp_n_object_0, obj_func());
  if (!_tmp_n_object_0) {
    _rc_ = SQLITE_ERROR;
    goto cql_cleanup;
  }
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);

  // The statement ending at line XXXX

  /*
  SET obj_var2 := ifnull_crash(obj_func_create());
  */
  cql_object_release(_tmp_n_object_0);
  _tmp_n_object_0 = obj_func_create();
  cql_invariant(!!_tmp_n_object_0);
  cql_set_object_ref(&obj_var2, _tmp_n_object_0);

  // The statement ending at line XXXX

  /*
  SET i2 := ifnull_crash(i0_nullable);
  */
  cql_invariant(!i0_nullable.is_null);
  i2 = i0_nullable.value;

  // The statement ending at line XXXX

  /*
  SET i2 := ifnull_throw(i0_nullable);
  */
  if (i0_nullable.is_null) {
    _rc_ = SQLITE_ERROR;
    goto cql_cleanup;
  }
  i2 = i0_nullable.value;

  // The statement ending at line XXXX

  /*
  INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5);
  */
  _rc_ = cql_exec(_db_,
    "INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  INSERT INTO foo DEFAULT VALUES;
  */
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo DEFAULT VALUES");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET b2 := ( SELECT EXISTS (SELECT *
    FROM bar) );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT EXISTS (SELECT * "
      "FROM bar)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    b2 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  DECLARE expanded_select CURSOR FOR SELECT *
    FROM bar;
  */
  _rc_ = cql_prepare(_db_, &expanded_select_stmt,
    "SELECT id, name, rate, type, size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  DECLARE table_expanded_select CURSOR FOR SELECT bar.*
    FROM bar;
  */
  _rc_ = cql_prepare(_db_, &table_expanded_select_stmt,
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET l2 := 3147483647L;
  */
  l2 = _64(3147483647);

  // The statement ending at line XXXX

  /*
  SET l2 := 3147483647L;
  */
  l2 = _64(3147483647);

  // The statement ending at line XXXX

  /*
  SET blob_var2 := blob_notnull_func();
  */
  cql_set_blob_ref(&blob_var2, blob_notnull_func());

  // The statement ending at line XXXX

  /*
  SET blob_var := NULL;
  */
  cql_set_blob_ref(&blob_var, NULL);

  // The statement ending at line XXXX

  /*
  SET blob_var := blob_var2;
  */
  cql_set_blob_ref(&blob_var, blob_var2);

  // The statement ending at line XXXX

  /*
  SET blob_var := NULL;
  */
  cql_set_blob_ref(&blob_var, NULL);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var = blob_var;
  */
  cql_combine_nullables(b0_nullable, !blob_var, !blob_var, cql_blob_equal(blob_var, blob_var));

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var IS NULL;
  */
  cql_set_notnull(b0_nullable, !blob_var);

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var <> blob_var;
  */
  cql_combine_nullables(b0_nullable, !blob_var, !blob_var, !cql_blob_equal(blob_var, blob_var));

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var <> blob_var;
  */
  cql_combine_nullables(b0_nullable, !blob_var, !blob_var, !cql_blob_equal(blob_var, blob_var));

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var IS blob_var;
  */
  cql_set_notnull(b0_nullable, cql_blob_equal(blob_var, blob_var));

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var IS NOT blob_var;
  */
  cql_set_notnull(b0_nullable, !cql_blob_equal(blob_var, blob_var));

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var IN (blob_var, blob_var);
  */
  do {
    cql_set_blob_ref(&_tmp_n_blob_1, blob_var);
    if (!_tmp_n_blob_1) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 1);
    if (cql_blob_equal(_tmp_n_blob_1, blob_var)) break;
    if (cql_blob_equal(_tmp_n_blob_1, blob_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 0);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := blob_var2 IN (blob_var, blob_var2);
  */
  do {
    cql_set_blob_ref(&_tmp_blob_1, blob_var2);
    _tmp_bool_0 = 1;
    if (cql_blob_equal(_tmp_blob_1, blob_var)) break;
    if (cql_blob_equal(_tmp_blob_1, blob_var2)) break;
    _tmp_bool_0 = 0;
  } while (0);
  b2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET b0_nullable := blob_var NOT IN (blob_var, blob_var);
  */
  do {
    cql_set_blob_ref(&_tmp_n_blob_1, blob_var);
    if (!_tmp_n_blob_1) {    
      cql_set_null(_tmp_n_bool_0);
      break;
    }
    cql_set_notnull(_tmp_n_bool_0, 0);
    if (cql_blob_equal(_tmp_n_blob_1, blob_var)) break;
    if (cql_blob_equal(_tmp_n_blob_1, blob_var)) break;
    cql_set_notnull(_tmp_n_bool_0, 1);
  } while (0);
  cql_set_nullable(b0_nullable, _tmp_n_bool_0.is_null, _tmp_n_bool_0.value);

  // The statement ending at line XXXX

  /*
  SET b2 := blob_var2 NOT IN (blob_var, blob_var2);
  */
  do {
    cql_set_blob_ref(&_tmp_blob_1, blob_var2);
    _tmp_bool_0 = 0;
    if (cql_blob_equal(_tmp_blob_1, blob_var)) break;
    if (cql_blob_equal(_tmp_blob_1, blob_var2)) break;
    _tmp_bool_0 = 1;
  } while (0);
  b2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := CASE blob_var WHEN blob_var THEN 1
  ELSE 2
  END;
  */
  do {
      cql_set_blob_ref(&_tmp_n_blob_1, blob_var);
      if (!_tmp_n_blob_1) goto case_else_2;
    if (cql_is_nullable_true(!blob_var, _tmp_n_blob_1 == blob_var)) {
      i2 = 1;
      break;
    }
    case_else_2:
    i2 = 2;
  } while (0);

  // The statement ending at line XXXX

  /*
  SET blob_var := CASE 1 WHEN 1 THEN blob_var2
  ELSE NULL
  END;
  */
  do {
      _tmp_int_1 = 1;
    if (_tmp_int_1 == 1) {
      cql_set_blob_ref(&blob_var, blob_var2);
      break;
    }
    cql_set_blob_ref(&blob_var, NULL);
  } while (0);

  // The statement ending at line XXXX

  /*
  SET blob_var := blob_func();
  */
  cql_set_blob_ref(&blob_var, blob_func());

  // The statement ending at line XXXX

  /*
  SET blob_var := blob_func_create();
  */
  cql_blob_release(blob_var);
  blob_var = blob_func_create();

  // The statement ending at line XXXX

  /*
  SET blob_var := ( SELECT b_nullable
    FROM blob_table
    WHERE blob_id = 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT b_nullable "
      "FROM blob_table "
      "WHERE blob_id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_blob_ref(_temp_stmt, 0, &blob_var);
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET blob_var := ( SELECT b_notnull
    FROM blob_table
    WHERE blob_id = 1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT b_notnull "
      "FROM blob_table "
      "WHERE blob_id = 1");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_blob_ref(_temp_stmt, 0, &_tmp_blob_0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_blob_ref(&blob_var, _tmp_blob_0);

  // The statement ending at line XXXX

  /*
  SET blob_var_notnull := blob_notnull_func();
  */
  cql_set_blob_ref(&blob_var_notnull, blob_notnull_func());

  // The statement ending at line XXXX

  /*
  INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, blob_var, blob_var_notnull);
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, ?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_BLOB, blob_var,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_BLOB, blob_var_notnull);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET obj_var := CASE WHEN 1 THEN obj_var
  END;
  */
  do {
    if (1) {
      break;
    }
    cql_set_object_ref(&obj_var, NULL);
  } while (0);

  // The statement ending at line XXXX

  /*
  SET i2 := outparm_test();
  */
  _rc_ = outparm_test(_db_, &i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET i2 := compute(compute(1));
  */
  compute(1, &_tmp_int_1);
  compute(_tmp_int_1, &i2);

  // The statement ending at line XXXX

  /*
  SET i2 := dml_compute(dml_compute(1));
  */
  _rc_ = dml_compute(_db_, 1, &_tmp_int_1);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = dml_compute(_db_, _tmp_int_1, &i2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) VALUES(ifnull(( SELECT a
    FROM x ), 0));
  */
  _rc_ = cql_exec(_db_,
    "WITH "
    "x (a) AS (SELECT 111) "
    "INSERT INTO foo(id) VALUES(ifnull(( SELECT a "
      "FROM x ), 0))");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET r2 := ( SELECT SqlUserFunc(123) );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT SqlUserFunc(123)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    r2 = sqlite3_column_double(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  DECLARE global_cursor CURSOR FOR SELECT 1 AS a, 2 AS b;
  */
  _rc_ = cql_prepare(_db_, &global_cursor_stmt,
    "SELECT 1, 2");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  FETCH global_cursor;
  */
  _rc_ = sqlite3_step(global_cursor_stmt);
  global_cursor._has_row_ = _rc_ == SQLITE_ROW;
  cql_multifetch(_rc_, global_cursor_stmt, 2,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &global_cursor.a,
                 CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &global_cursor.b);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET i2 := 'x' LIKE 'y';
  */
  i2 = cql_string_like(_literal_6_x_, _literal_11_y_) == 0;

  // The statement ending at line XXXX

  /*
  SET i2 := 'x' NOT LIKE 'y';
  */
  i2 = cql_string_like(_literal_6_x_, _literal_11_y_) != 0;

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT 'x' LIKE 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' LIKE 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT 'x' NOT LIKE 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' NOT LIKE 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT 'x' MATCH 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' MATCH 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT 'x' GLOB 'y' );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT 'x' GLOB 'y'");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    _tmp_bool_0 = sqlite3_column_int(_temp_stmt, 0) != 0;
  cql_finalize_stmt(&_temp_stmt);
  i2 = _tmp_bool_0;

  // The statement ending at line XXXX

  /*
  SET i2 := 1 << 2 | 1 << 4 & 1 >> 8;
  */
  i2 = ((1 << 2 | 1) << 4 & 1) >> 8;

  // The statement ending at line XXXX

  /*
  SET i2 := 1 << 2 | (1 << 4) & (1 >> 8);
  */
  i2 = (1 << 2 | 1 << 4) & 1 >> 8;

  // The statement ending at line XXXX

  /*
  SET i2 := 1 << 2 | (1 << 4 & (1 >> 8));
  */
  i2 = 1 << 2 | 1 << 4 & 1 >> 8;

  // The statement ending at line XXXX

  /*
  SET i2 := 1 | ~i2;
  */
  i2 = 1 | ~ i2;

  // The statement ending at line XXXX

  /*
  WITH
  some_cte (id) AS (SELECT 1 AS id)
  INSERT INTO bar(id) VALUES(ifnull(( SELECT id
    FROM some_cte ), 0)) @DUMMY_SEED(1337);
  */
  _seed_ = 1337;
  _rc_ = cql_exec(_db_,
    "WITH "
    "some_cte (id) AS (SELECT 1 AS id) "
    "INSERT INTO bar(id) VALUES(ifnull(( SELECT id "
      "FROM some_cte ), 0))");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  INSERT INTO bar(id) VALUES(1) @DUMMY_SEED(1338)
  ON CONFLICT (id) DO UPDATE
  SET id = 10;
  */
  _seed_ = 1338;
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id) VALUES(1) "
    "ON CONFLICT (id) DO UPDATE "
    "SET id = 10");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET l0_nullable := cql_get_blob_size(( SELECT blob_var ));
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT ?");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                CQL_DATA_TYPE_BLOB, blob_var);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_blob_ref(_temp_stmt, 0, &_tmp_n_blob_1);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_nullable(l0_nullable, !_tmp_n_blob_1, cql_get_blob_size(_tmp_n_blob_1));

  // The statement ending at line XXXX

  /*
  SET l2 := cql_get_blob_size(blob_var2);
  */
  l2 = cql_get_blob_size(blob_var2);

  // The statement ending at line XXXX

  /*
  SET x := 1 * (4 / 3);
  */
  x = 1 * (4 / 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 * 2 / 3;
  */
  x = 1 * 2 / 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 + 2 / 3;
  */
  x = 1 + 2 / 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 + (2 - 3);
  */
  x = 1 + (2 - 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 + 2 * 3;
  */
  x = 1 + 2 * 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 * (2 + 3);
  */
  x = 1 * (2 + 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 - (2 + 3);
  */
  x = 1 - (2 + 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 - (2 - 3);
  */
  x = 1 - (2 - 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 - 2 - (2 - 3);
  */
  x = 1 - 2 - (2 - 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 - 2 - (2 - 3);
  */
  x = 1 - 2 - (2 - 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 / 2 / 3;
  */
  x = 1 / 2 / 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 / (4 / 3);
  */
  x = 1 / (4 / 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 / 2;
  */
  x = 1 / 2;

  // The statement ending at line XXXX

  /*
  SET x := 1 * 2 * (3 * 4);
  */
  x = 1 * 2 * (3 * 4);

  // The statement ending at line XXXX

  /*
  SET x := 1 * 2 * (3 * 4);
  */
  x = 1 * 2 * (3 * 4);

  // The statement ending at line XXXX

  /*
  SET x := 1 | 2 & 3;
  */
  x = (1 | 2) & 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 | (2 & 3);
  */
  x = 1 | 2 & 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 | 2 | 3;
  */
  x = 1 | 2 | 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 | (2 | 3);
  */
  x = 1 | (2 | 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 | (3 + 4 | 5);
  */
  x = 1 | (3 + 4 | 5);

  // The statement ending at line XXXX

  /*
  SET x := 1 | 3 + (4 | 5);
  */
  x = 1 | 3 + (4 | 5);

  // The statement ending at line XXXX

  /*
  SET x := (1 | 3) + (4 | 5);
  */
  x = (1 | 3) + (4 | 5);

  // The statement ending at line XXXX

  /*
  SET x := (1 + 2) * 5;
  */
  x = (1 + 2) * 5;

  // The statement ending at line XXXX

  /*
  SET x := 1 + 2 - 1;
  */
  x = 1 + 2 - 1;

  // The statement ending at line XXXX

  /*
  SET x := 1 << 2 | 3;
  */
  x = 1 << 2 | 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 << (2 | 3);
  */
  x = 1 << (2 | 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 | (2 << 3);
  */
  x = 1 | 2 << 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 << (2 << 3);
  */
  x = 1 << (2 << 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 < (2 > 3);
  */
  x = 1 < (2 > 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 << (2 >> 3);
  */
  x = 1 << (2 >> 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 | (2 | 3);
  */
  x = 1 | (2 | 3);

  // The statement ending at line XXXX

  /*
  SET x := 1 | 2 | 3;
  */
  x = 1 | 2 | 3;

  // The statement ending at line XXXX

  /*
  SET x := 1 = 2 <> 3;
  */
  x = 1 == (2 != 3);

  // The statement ending at line XXXX

  /*
  INSERT INTO virtual_with_hidden(vy) VALUES(1);
  */
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vy) VALUES(1)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  INSERT INTO virtual_with_hidden(vx, vy) VALUES(1, 2);
  */
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vx, vy) VALUES(1, 2)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }

  // The statement ending at line XXXX

  /*
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING -1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT type "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (_rc_ == SQLITE_ROW) {
    cql_column_nullable_int32(_temp_stmt, 0, &_tmp_n_int_1);
    cql_set_nullable(i0_nullable, _tmp_n_int_1.is_null, _tmp_n_int_1.value);
  }
  else {
    cql_set_notnull(i0_nullable, - 1);
  }
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING THROW );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT type "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    cql_column_nullable_int32(_temp_stmt, 0, &_tmp_n_int_0);
  cql_finalize_stmt(&_temp_stmt);
  cql_set_nullable(i0_nullable, _tmp_n_int_0.is_null, _tmp_n_int_0.value);

  // The statement ending at line XXXX

  /*
  SET i2 := ( SELECT type
    FROM bar IF NOTHING OR NULL -1 );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT type "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (_rc_ == SQLITE_ROW) {
    cql_column_nullable_int32(_temp_stmt, 0, &_tmp_n_int_1);
  }
  if (_rc_ == SQLITE_DONE || _tmp_n_int_1.is_null) {
    i2 = - 1;
  } else { 
    i2 = _tmp_n_int_1.value;
  }
  _rc_ = SQLITE_OK;
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET t0_nullable := ( SELECT name
    FROM bar IF NOTHING "" );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT name "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (_rc_ == SQLITE_ROW) {
    cql_column_nullable_string_ref(_temp_stmt, 0, &_tmp_n_text_1);
    cql_set_string_ref(&t0_nullable, _tmp_n_text_1);
  }
  else {
    cql_set_string_ref(&t0_nullable, _literal_12_);
  }
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SET t2 := ( SELECT name
    FROM bar IF NOTHING OR NULL "garbonzo" );
  */
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT name "
      "FROM bar");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  if (_rc_ == SQLITE_ROW) {
    cql_column_nullable_string_ref(_temp_stmt, 0, &_tmp_n_text_1);
  }
  if (_rc_ == SQLITE_DONE || !_tmp_n_text_1) {
    cql_set_string_ref(&t2, _literal_13_garbonzo_);
  } else { 
    cql_set_string_ref(&t2, _tmp_n_text_1);
  }
  _rc_ = SQLITE_OK;
  cql_finalize_stmt(&_temp_stmt);

  // The statement ending at line XXXX

  /*
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
    ELSE
      SET i2 := 50;
  END;
  */
  switch (i2) {
    case 1:
    case 3:
      i2 = 30;
      break;

    case 4:
      i2 = 40;
      break;

    case 5:
      break;

    default:
      i2 = 50;
      break;
  }

  // The statement ending at line XXXX

  /*
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  */
  switch (i2) {
    case 1:
    case 3:
      i2 = 30;
      break;

    case 4:
      i2 = 40;
      break;
  }

  // The statement ending at line XXXX

  /*
  SWITCH l2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  */
  switch (l2) {
    case _64(1):
    case _64(3):
      i2 = 30;
      break;

    case _64(4):
      i2 = 40;
      break;
  }

  // The statement ending at line XXXX

  /*
  SWITCH i2
    WHEN 1, 2, 3 THEN NOTHING
    ELSE
      SET i2 := 123;
  END;
  */
  switch (i2) {
    case 1:
    case 2:
    case 3:
      break;

    default:
      i2 = 123;
      break;
  }

  // The statement ending at line XXXX

  /*
  SWITCH i2
    WHEN 1 THEN
      IF i2 THEN
        LEAVE;
      END IF;
      SET i2 := 999;
    ELSE
      SET i2 := 1;
  END;
  */
  switch (i2) {
    case 1:
      if (i2) {
        break;
      }
      i2 = 999;
      break;

    default:
      i2 = 1;
      break;
  }

  // The statement ending at line XXXX

  /*
  LET true_test := 1 IS TRUE;
  */
  true_test = !!(1);

  // The statement ending at line XXXX

  /*
  LET false_test := 0 IS FALSE;
  */
  false_test = !(0);

  // The statement ending at line XXXX

  /*
  SET true_test := i0_nullable IS TRUE;
  */
  true_test = cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value);

  // The statement ending at line XXXX

  /*
  SET false_test := i0_nullable IS FALSE;
  */
  false_test = cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value);

  // The statement ending at line XXXX

  /*
  SET true_test := 1 IS NOT TRUE;
  */
  true_test = !(1);

  // The statement ending at line XXXX

  /*
  SET false_test := 0 IS NOT FALSE;
  */
  false_test = !!(0);

  // The statement ending at line XXXX

  /*
  SET true_test := i0_nullable IS NOT TRUE;
  */
  true_test = !cql_is_nullable_true(i0_nullable.is_null, i0_nullable.value);

  // The statement ending at line XXXX

  /*
  SET false_test := i0_nullable IS NOT FALSE;
  */
  false_test = !cql_is_nullable_false(i0_nullable.is_null, i0_nullable.value);

  // The statement ending at line XXXX

  /*
  LET sign_val_int := sign(-2);
  */
  _tmp_int_2 = - 2;
  sign_val_int = ((_tmp_int_2 > 0) - (_tmp_int_2 < 0));

  // The statement ending at line XXXX

  /*
  LET sign_val_nullable := sign(nullable(-2));
  */
  cql_set_notnull(_tmp_n_int_2, (-2));
  cql_set_nullable(sign_val_nullable, _tmp_n_int_2.is_null, ((_tmp_n_int_2.value > 0) - (_tmp_n_int_2.value < 0)));

  // The statement ending at line XXXX

  /*
  LET abs_val_int := abs(-2);
  */
  _tmp_int_2 = - 2;
  abs_val_int = abs(_tmp_int_2);

  // The statement ending at line XXXX

  /*
  LET abs_val_nullable := abs(nullable(-2));
  */
  cql_set_notnull(_tmp_n_int_2, (-2));
  cql_set_nullable(abs_val_nullable, _tmp_n_int_2.is_null, abs(_tmp_n_int_2.value));

  // The statement ending at line XXXX

  /*
  LET abs_val_long := abs(-2L);
  */
  _tmp_int64_2 = - _64(2);
  abs_val_long = labs(_tmp_int64_2);

  // The statement ending at line XXXX

  /*
  LET abs_val_real := abs(-2.0);
  */
  _tmp_double_2 = - 2.0;
  abs_val_real = fabs(_tmp_double_2);

  // The statement ending at line XXXX

  /*
  LET abs_val_bool := abs(TRUE);
  */
  _tmp_bool_1 = 1;
  abs_val_bool = !!_tmp_bool_1;

  // The statement ending at line XXXX

  /*
  SET abs_val_nullable := abs(NULL);
  */
  cql_set_null(abs_val_nullable);

  // The statement ending at line XXXX

  /*
  LET this_is_the_end := 0xf00d;
  */
  this_is_the_end = 0xf00d;

cql_cleanup:
  cql_string_release(t0_nullable);
  cql_string_release(t2);
  cql_finalize_stmt(&foo_cursor_stmt);
  cql_finalize_stmt(&basic_cursor_stmt);
  cql_finalize_stmt(&exchange_cursor_stmt);
  cql_finalize_stmt(&_temp_stmt);
  cql_string_release(_between_6_);
  cql_string_release(_between_7_);
  cql_string_release(_between_8_);
  cql_string_release(_between_9_);
  cql_string_release(_between_10_);
  cql_string_release(_between_11_);
  cql_string_release(_between_12_);
  cql_string_release(_between_13_);
  cql_string_release(s);
  cql_string_release(text_result);
  cql_string_release(_tmp_text_0);
  cql_object_release(obj_var);
  cql_object_release(obj_var2);
  cql_object_release(_tmp_n_object_1);
  cql_object_release(_tmp_object_1);
  cql_object_release(_tmp_n_object_0);
  cql_finalize_stmt(&expanded_select_stmt);
  cql_finalize_stmt(&table_expanded_select_stmt);
  cql_blob_release(blob_var);
  cql_blob_release(blob_var2);
  cql_blob_release(_tmp_n_blob_1);
  cql_blob_release(_tmp_blob_1);
  cql_blob_release(_tmp_blob_0);
  cql_blob_release(blob_var_notnull);
  cql_finalize_stmt(&global_cursor_stmt);
  cql_string_release(_tmp_n_text_1);
  cql_teardown_row(global_cursor2);
  return _rc_;
}

#undef _PROC_
#pragma clang diagnostic pop
