
require("cqlrt")


-- The statement ending at line XXXX

--[[
DECLARE i0_nullable INTEGER;
--]]
local i0_nullable

-- The statement ending at line XXXX

--[[
DECLARE i1_nullable INTEGER;
--]]
local i1_nullable

-- The statement ending at line XXXX

--[[
DECLARE r0_nullable REAL;
--]]
local r0_nullable

-- The statement ending at line XXXX

--[[
DECLARE l0_nullable LONG_INT;
--]]
local l0_nullable

-- The statement ending at line XXXX

--[[
DECLARE l1_nullable LONG_INT;
--]]
local l1_nullable

-- The statement ending at line XXXX

--[[
DECLARE b0_nullable BOOL;
--]]
local b0_nullable

-- The statement ending at line XXXX

--[[
DECLARE t0_nullable TEXT;
--]]
local t0_nullable

-- The statement ending at line XXXX

--[[
DECLARE i2 INTEGER NOT NULL;
--]]
local i2 = 0

-- The statement ending at line XXXX

--[[
DECLARE r2 REAL NOT NULL;
--]]
local r2 = 0.0

-- The statement ending at line XXXX

--[[
DECLARE l2 LONG_INT NOT NULL;
--]]
local l2 = 0

-- The statement ending at line XXXX

--[[
DECLARE b2 BOOL NOT NULL;
--]]
local b2 = false

-- The statement ending at line XXXX

--[[
DECLARE t2 TEXT NOT NULL;
--]]
local t2

-- The statement ending at line XXXX

--[[
CREATE PROC test (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    CALL puts('true');
  END IF;
END;
--]]

function test(i)
  cql_contract_argument_notnull(i, 1)

  if cql_to_bool(i) then
    puts("true")
  end

end

-- The statement ending at line XXXX

--[[
CREATE PROC proc_with_return_guard (a INTEGER)
BEGIN
  IF a IS NOT NULL THEN
    RETURN;
  END IF;
  LET x := a;
END;
--]]

function proc_with_return_guard(a)
  local x

  if a ~= nil then
    goto cql_cleanup -- return
  end
  x = a

::cql_cleanup::
end
local _between_0_ = 0
local _between_1_
local _between_2_
local _between_3_ = 0
local _between_4_
local _between_5_

-- The statement ending at line XXXX

--[[
CREATE PROC out_test (OUT i INTEGER NOT NULL, OUT ii INTEGER)
BEGIN
  SET i := i2;
  SET ii := i0_nullable;
END;
--]]

function out_test()
  local i = 0
  local ii

  i = i2
  ii = i0_nullable

  return i, ii
end

-- The statement ending at line XXXX

--[[
DECLARE longint_var LONG_INT;
--]]
local longint_var
local foo_cursor_stmt = nil
local foo_cursor = { _has_row_ = false }
local foo_cursor_fields_ = { "id", "i2" }
local foo_cursor_types_ = "II"

-- The statement ending at line XXXX

--[[
DECLARE col1 INTEGER;
--]]
local col1

-- The statement ending at line XXXX

--[[
DECLARE col2 REAL NOT NULL;
--]]
local col2 = 0.0
local basic_cursor_stmt = nil
local basic_cursor = { _has_row_ = false }
local basic_cursor_fields_ = { "_anon0", "_anon1" }
local basic_cursor_types_ = "ID"

-- The statement ending at line XXXX

--[[
DECLARE arg1 INTEGER NOT NULL;
--]]
local arg1 = 0

-- The statement ending at line XXXX

--[[
DECLARE arg2 INTEGER NOT NULL;
--]]
local arg2 = 0
local exchange_cursor_stmt = nil
local exchange_cursor = { _has_row_ = false }
local exchange_cursor_fields_ = { "arg2", "arg1" }
local exchange_cursor_types_ = "II"
local _temp_stmt = nil

-- The statement ending at line XXXX

--[[
CREATE PROC outparm_test (OUT foo INTEGER NOT NULL)
BEGIN
  SET foo := 1;
  DELETE FROM bar WHERE id = foo;
END;
--]]

function outparm_test(_db_)
  local _rc_ = CQL_OK
  local foo = 0
  local _temp_stmt = nil

  foo = 1
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "DELETE FROM bar WHERE id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", {foo})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_, foo
end

-- The statement ending at line XXXX

--[[
CREATE PROC throwing ()
BEGIN
  BEGIN TRY
    DELETE FROM bar;
  END TRY;
  BEGIN CATCH
    CALL printf("error\n");
    THROW;
  END CATCH;
END;
--]]

function throwing(_db_)
  local _rc_ = CQL_OK
  -- try

    _rc_ = cql_exec(_db_,
      "DELETE FROM bar")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_1; end
    goto catch_end_1

  ::catch_start_1:: 
  do
    local _rc_thrown_1 = _rc_
    printf("error\n")
    _rc_ = cql_best_error(_rc_thrown_1)
    goto cql_cleanup
  end

  ::catch_end_1::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end
local _between_6_
local _between_7_
local _between_8_
local _between_9_
local _between_10_
local _between_11_
local _between_12_
local _between_13_

-- The statement ending at line XXXX

--[[
CREATE PROC with_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function with_result_set(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_result_set_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_result_set(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC select_from_view ()
BEGIN
  SELECT id, type
    FROM baz;
END;
--]]

function select_from_view(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, type FROM baz")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function select_from_view_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = select_from_view(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Ii", { "id", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC make_view ()
BEGIN
  CREATE VIEW MyView AS
  SELECT 1 AS f1, 2 AS f2, 3 AS f3;
END;
--]]

function make_view(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIEW MyView AS SELECT 1 AS f1, 2 AS f2, 3 AS f3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC make_index ()
BEGIN
  CREATE INDEX index_1 ON bar (id);
END;
--]]

function make_index(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE INDEX index_1 ON bar (id)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC get_data (name_ TEXT NOT NULL, id_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM bar
    WHERE id = id_ AND name = name_;
END;
--]]

function get_data(_db_, name_, id_)
  cql_contract_argument_notnull(name_, 1)
  cql_contract_argument_notnull(id_, 2)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar WHERE id = ? AND name = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "IS", {id_, name_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function get_data_fetch_results(_db_, name_, id_)
  local result_set = nil
  local _rc_
  _rc_, stmt = get_data(_db_, name_, id_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC easy_fetch ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  FETCH C;
  CALL printf("%d %s\n", C.id, C.name);
  DECLARE C2 CURSOR FOR SELECT *
    FROM bar
    WHERE C AND id = C.id;
END;
--]]

function easy_fetch(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"
  local C2_stmt = nil
  local C2 = { _has_row_ = false }
  local C2_fields_ = { "id", "name", "rate", "type", "size" }
  local C2_types_ = "Islid"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  printf("%d %s\n", C.id, C.name)
  _rc_, C2_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar WHERE ? AND id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, C2_stmt, "FI", {C._has_row_, C.id})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  cql_finalize_stmt(C2_stmt)
  C2_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC copy_int (a INTEGER, OUT b INTEGER)
BEGIN
  SET b := a;
END;
--]]

function copy_int(a)
  local b

  b = a

  return b
end

-- The statement ending at line XXXX

--[[
CREATE PROC insert_rowid_reader ()
BEGIN
  DECLARE row LONG_INT;
  SET row := last_insert_rowid();
END;
--]]

function insert_rowid_reader(_db_)
  local _rc_ = CQL_OK
  local row

  row = cql_last_insert_rowid(_db_)
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC changes_reader ()
BEGIN
  DECLARE ct INTEGER;
  SET ct := changes();
END;
--]]

function changes_reader(_db_)
  local _rc_ = CQL_OK
  local ct

  ct = cql_changes(_db_)
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE s TEXT NOT NULL;
--]]
local s

-- The statement ending at line XXXX

--[[
DECLARE PROC xyzzy (id INTEGER) (A INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC xyzzy_test ()
BEGIN
  DECLARE xyzzy_cursor CURSOR FOR CALL xyzzy(1);
END;
--]]

function xyzzy_test(_db_)
  local _rc_ = CQL_OK
  local xyzzy_cursor_stmt = nil
  local xyzzy_cursor = { _has_row_ = false }
  local xyzzy_cursor_fields_ = { "A" }
  local xyzzy_cursor_types_ = "I"

  _rc_, xyzzy_cursor_stmt = xyzzy(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(xyzzy_cursor_stmt)
  xyzzy_cursor_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC plugh (id INTEGER);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC complex_return ()
BEGIN
  SELECT TRUE AS _bool, 2 AS _integer, CAST(3 AS LONG_INT) AS _longint, 3.0 AS _real, 'xyz' AS _text, CAST(NULL AS BOOL) AS _nullable_bool;
END;
--]]

function complex_return(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, CAST(3 AS LONG_INT), 3.0, 'xyz', NULL")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function complex_return_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = complex_return(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "FILDSf", { "_bool", "_integer", "_longint", "_real", "_text", "_nullable_bool" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC hierarchical_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
--]]

function hierarchical_query(_db_, rate_, limit_, offset_)
  cql_contract_argument_notnull(rate_, 1)
  cql_contract_argument_notnull(limit_, 2)
  cql_contract_argument_notnull(offset_, 3)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id FROM foo WHERE id IN (SELECT id FROM bar WHERE rate = ? ORDER BY name LIMIT ? OFFSET ?) ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "LII", {rate_, limit_, offset_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function hierarchical_query_fetch_results(_db_, rate_, limit_, offset_)
  local result_set = nil
  local _rc_
  _rc_, stmt = hierarchical_query(_db_, rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "id" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC hierarchical_unmatched_query (rate_ LONG_INT NOT NULL, limit_ INTEGER NOT NULL, offset_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM foo
    WHERE id NOT IN (SELECT id
    FROM bar
    WHERE rate = rate_
  ORDER BY name
  LIMIT limit_
  OFFSET offset_)
  ORDER BY id;
END;
--]]

function hierarchical_unmatched_query(_db_, rate_, limit_, offset_)
  cql_contract_argument_notnull(rate_, 1)
  cql_contract_argument_notnull(limit_, 2)
  cql_contract_argument_notnull(offset_, 3)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id FROM foo WHERE id NOT IN (SELECT id FROM bar WHERE rate = ? ORDER BY name LIMIT ? OFFSET ?) ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _result_stmt, "LII", {rate_, limit_, offset_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function hierarchical_unmatched_query_fetch_results(_db_, rate_, limit_, offset_)
  local result_set = nil
  local _rc_
  _rc_, stmt = hierarchical_unmatched_query(_db_, rate_, limit_, offset_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "id" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC union_select ()
BEGIN
  SELECT 1 AS A
  UNION
  SELECT 2 AS A;
END;
--]]

function union_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 UNION SELECT 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_select_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_select(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "A" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC union_all_select ()
BEGIN
  SELECT 1 AS A
  UNION ALL
  SELECT 2 AS A;
END;
--]]

function union_all_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 UNION ALL SELECT 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_all_select_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_all_select(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "A" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC union_all_with_nullable ()
BEGIN
  SELECT nullable('foo') AS name
  UNION ALL
  SELECT name
    FROM bar;
END;
--]]

function union_all_with_nullable(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 'foo' UNION ALL SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function union_all_with_nullable_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = union_all_with_nullable(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC with_stmt_using_cursor ()
BEGIN
  DECLARE C CURSOR FOR WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
  FETCH C;
END;
--]]

function with_stmt_using_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b", "c" }
  local C_types_ = "III"

  _rc_, C_stmt = cql_prepare(_db_, 
    "WITH X (a, b, c) AS (SELECT 1, 2, 3) SELECT a, b, c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC with_stmt ()
BEGIN
  WITH
  X (a, b, c) AS (SELECT 1, 2, 3)
  SELECT *
    FROM X;
END;
--]]

function with_stmt(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "WITH X (a, b, c) AS (SELECT 1, 2, 3) SELECT a, b, c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_stmt_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_stmt(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "a", "b", "c" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC with_recursive_stmt ()
BEGIN
  WITH RECURSIVE
  X (a, b, c) AS (SELECT 1, 2, 3
  UNION ALL
  SELECT 4, 5, 6)
  SELECT *
    FROM X;
END;
--]]

function with_recursive_stmt(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "WITH RECURSIVE X (a, b, c) AS (SELECT 1, 2, 3 UNION ALL SELECT 4, 5, 6) SELECT a, b, c FROM X")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function with_recursive_stmt_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = with_recursive_stmt(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "a", "b", "c" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC parent_proc ()
BEGIN
  SELECT 1 AS one, 2 AS two, 3 AS three;
END;
--]]

function parent_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, 3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function parent_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = parent_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "one", "two", "three" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC parent_proc_child ()
BEGIN
  SELECT 4 AS four, 5 AS five, 6 AS six;
END;
--]]

function parent_proc_child(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 4, 5, 6")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function parent_proc_child_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = parent_proc_child(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "four", "five", "six" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC outint_nullable (OUT output INTEGER, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
--]]

function outint_nullable(_db_)
  local _rc_ = CQL_OK
  local output
  local result = false
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "_anon0" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  output = C._anon0
  result = C._has_row_
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, output, result
end

-- The statement ending at line XXXX

--[[
CREATE PROC outint_notnull (OUT output INTEGER NOT NULL, OUT result BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR FOR SELECT 1;
  FETCH C INTO output;
  SET result := C;
END;
--]]

function outint_notnull(_db_)
  local _rc_ = CQL_OK
  local output = 0
  local result = false
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "_anon0" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  output = C._anon0
  result = C._has_row_
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, output, result
end
local result

-- The statement ending at line XXXX

--[[
DECLARE text_result TEXT;
--]]
local text_result

-- The statement ending at line XXXX

--[[
DECLARE obj_var OBJECT;
--]]
local obj_var

-- The statement ending at line XXXX

--[[
DECLARE obj_var2 OBJECT NOT NULL;
--]]
local obj_var2

-- The statement ending at line XXXX

--[[
CREATE PROC obj_proc (OUT an_object OBJECT)
BEGIN
  SET an_object := NULL;
END;
--]]

function obj_proc()
  local an_object

  an_object = nil

  return an_object
end

-- The statement ending at line XXXX

--[[
CREATE PROC cursor_with_object (object_ OBJECT)
BEGIN
  DECLARE C CURSOR LIKE cursor_with_object ARGUMENTS;
  FETCH C(object_) FROM VALUES(object_);
  OUT C;
END;
--]]

function cursor_with_object(object_)
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "object_" }
  local C_types_ = "o"

  C._has_row_ = true
  C.object_ = object_
  _result_ = cql_clone_row(C)

  return _result_
end

function cursor_with_object_fetch_results(object_)
  local result_set = nil
  _result_ = cursor_with_object(object_)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL)
BEGIN
  SET o := coalesce(i, -1);
END;
--]]

function unused_temp(i)
  local o = 0

  repeat
    if i ~= nil then
      o = i
      break
    end
    o = - 1
  until true

  return o
end

-- The statement ending at line XXXX

--[[
@ECHO lua, "local Garbonzo -- a chick pea\n";
--]]
local Garbonzo -- a chick pea

-- The statement ending at line XXXX

--[[
@ECHO lua, "--/'\a\b\f\t\v'\r\n";
--]]
--/'	'

-- The statement ending at line XXXX

--[[
CREATE PROC echo_test ()
BEGIN
  DECLARE s TEXT;
  SET s := "before echo";
  @ECHO lua, "s = \"omg echo\"\n";
  SET s := "after echo";
END;
--]]

function echo_test()
  local s

  s = "before echo"
  s = "omg echo"
  s = "after echo"

end

-- The statement ending at line XXXX

--[[
CREATE PROC insert_values (id_ INTEGER NOT NULL, type_ INTEGER)
BEGIN
  INSERT INTO bar(id, type) VALUES(id_, type_);
END;
--]]

function insert_values(_db_, id_, type_)
  cql_contract_argument_notnull(id_, 1)

  local _rc_ = CQL_OK
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO bar(id, type) VALUES(?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "Ii", {id_, type_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC alter_table_test ()
BEGIN
  ALTER TABLE bar ADD COLUMN size REAL;
END;
--]]

function alter_table_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "ALTER TABLE bar ADD COLUMN size REAL")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC drop_table_test ()
BEGIN
  DROP TABLE IF EXISTS bar;
END;
--]]

function drop_table_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP TABLE IF EXISTS bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;
--]]

function uses_proc_for_result(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  cql_finalize_stmt(_result_stmt)
  _result_stmt = nil
  _rc_, _result_stmt = with_result_set(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function uses_proc_for_result_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = uses_proc_for_result(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end

local expanded_select_stmt = nil
local expanded_select = { _has_row_ = false }
local expanded_select_fields_ = { "id", "name", "rate", "type", "size" }
local expanded_select_types_ = "Islid"
local table_expanded_select_stmt = nil
local table_expanded_select = { _has_row_ = false }
local table_expanded_select_fields_ = { "id", "name", "rate", "type", "size" }
local table_expanded_select_types_ = "Islid"

-- The statement ending at line XXXX

--[[
CREATE PROC index_dropper ()
BEGIN
  DROP INDEX index_1;
END;
--]]

function index_dropper(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP INDEX index_1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC misc_dml_proc ()
BEGIN
  INSERT INTO foo(id) VALUES(NULL);
  INSERT INTO foo(id) VALUES(NULL);
  UPDATE bar
  SET name = 'bar'
    WHERE name = 'baz';
  DELETE FROM foo WHERE id = 1;
END;
--]]

function misc_dml_proc(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) VALUES(NULL)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "UPDATE bar SET name = 'bar' WHERE name = 'baz'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM foo WHERE id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC dummy_user ()
BEGIN
  INSERT INTO bar(id, name, rate, type, size) VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;
--]]

function dummy_user(_db_)
  local _rc_ = CQL_OK
  local _seed_ = 0
  local _temp_stmt = nil

  _seed_ = 123
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO bar(id, name, rate, type, size) VALUES(?, printf('name_%d', ?), ?, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "IIIII", {_seed_, _seed_, _seed_, _seed_, _seed_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC proc_with_out_arg (OUT foo TEXT)
BEGIN
  SET foo := 'x';
END;
--]]

function proc_with_out_arg()
  local foo

  foo = "x"

  return foo
end

-- The statement ending at line XXXX

--[[
CREATE PROC calls_out_proc (OUT foo TEXT)
BEGIN
  SET foo := 'x';
  DECLARE bar TEXT;
  CALL proc_with_out_arg(foo);
  CALL proc_with_out_arg(bar);
END;
--]]

function calls_out_proc()
  local foo
  local bar

  foo = "x"
  foo = proc_with_out_arg()
  bar = proc_with_out_arg()

  return foo
end

-- The statement ending at line XXXX

--[[
DECLARE blob_var BLOB;
--]]
local blob_var

-- The statement ending at line XXXX

--[[
DECLARE blob_var2 BLOB NOT NULL;
--]]
local blob_var2

-- The statement ending at line XXXX

--[[
CREATE PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;
--]]

function blob_proc()
  local a_blob

  a_blob = nil

  return a_blob
end

-- The statement ending at line XXXX

--[[
DECLARE blob_var_notnull BLOB NOT NULL;
--]]
local blob_var_notnull

-- The statement ending at line XXXX

--[[
CREATE PROC blob_returner ()
BEGIN
  SELECT *
    FROM blob_table;
END;
--]]

function blob_returner(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT blob_id, b_notnull, b_nullable FROM blob_table")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function blob_returner_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = blob_returner(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "IBb", { "blob_id", "b_notnull", "b_nullable" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC voidproc ()
BEGIN
  DECLARE unused INTEGER;
END;
--]]

function voidproc()
  local unused


end

-- The statement ending at line XXXX

--[[
CREATE PROC out_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT bar.*, 'xyzzy' AS extra1, 'plugh' AS extra2
    FROM bar;
  FETCH C;
  OUT C;
END;
--]]

function out_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size, 'xyzzy', 'plugh' FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(C)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _result_
end

function out_cursor_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC read_cursor_proc ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;
--]]

function read_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC declare_cursor_then_fetch_from_proc ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
END;
--]]

function declare_cursor_then_fetch_from_proc(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "extra1", "extra2" }
  local C_types_ = "IslidSS"

  _rc_, C = out_cursor_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC fetcher_proc () OUT (a INTEGER, b TEXT);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC totally_void_proc ();
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC dml_compute (IN a_ INTEGER NOT NULL, OUT b_ INTEGER NOT NULL) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC dml_user (OUT a_ INTEGER NOT NULL)
BEGIN
  SET a_ := dml_compute(1);
END;
--]]

function dml_user(_db_)
  local _rc_ = CQL_OK
  local a_ = 0

  _rc_, a_ = dml_compute(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, a_
end

-- The statement ending at line XXXX

--[[
CREATE PROC thread_theme_info_list (thread_key_ LONG_INT NOT NULL)
BEGIN
  SELECT *
    FROM (SELECT thread_key
    FROM threads) AS T;
END;
--]]

function thread_theme_info_list(_db_, thread_key_)
  cql_contract_argument_notnull(thread_key_, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT thread_key FROM (SELECT thread_key FROM threads) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function thread_theme_info_list_fetch_results(_db_, thread_key_)
  local result_set = nil
  local _rc_
  _rc_, stmt = thread_theme_info_list(_db_, thread_key_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "L", { "thread_key" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC fetch_values_dummy ()
BEGIN
  DECLARE C CURSOR LIKE SELECT *
    FROM bar;
  FETCH C(id, name, rate, type, size) FROM VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
--]]

function fetch_values_dummy()
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"
  local _tmp_text_0
  local _seed_ = 0

  _seed_ = 123
  C._has_row_ = true
  C.id = _seed_
  _tmp_text_0 = cql_printf("name_%d", _seed_)
  C.name = _tmp_text_0
  C.rate = _seed_
  C.type = _seed_
  C.size = cql_to_float(_seed_)

end

-- The statement ending at line XXXX

--[[
CREATE PROC fetch_values_extended ()
BEGIN
  DECLARE C CURSOR LIKE (id INTEGER NOT NULL, name TEXT, rate LONG_INT, type INTEGER, size REAL, xx REAL, yy TEXT);
  FETCH C(id, name, rate, type, size, xx, yy) FROM VALUES(_seed_, printf('name_%d', _seed_), _seed_, _seed_, _seed_, _seed_, printf('yy_%d', _seed_)) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;
--]]

function fetch_values_extended()
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size", "xx", "yy" }
  local C_types_ = "Islidds"
  local _tmp_text_0
  local _tmp_text_1
  local _seed_ = 0

  _seed_ = 123
  C._has_row_ = true
  C.id = _seed_
  _tmp_text_0 = cql_printf("name_%d", _seed_)
  C.name = _tmp_text_0
  C.rate = _seed_
  C.type = _seed_
  C.size = cql_to_float(_seed_)
  C.xx = cql_to_float(_seed_)
  _tmp_text_1 = cql_printf("yy_%d", _seed_)
  C.yy = _tmp_text_1

end

-- The statement ending at line XXXX

--[[
CREATE PROC c_literal (OUT x TEXT)
BEGIN
  SET x := "\"Testing\" \\''";
END;
--]]

function c_literal()
  local x

  x = "\"Testing\" \\''"

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC no_cleanup_label_needed_proc ()
BEGIN
  BEGIN TRY
    DECLARE C CURSOR FOR SELECT 1 AS N;
    FETCH C;
  END TRY;
  BEGIN CATCH
    DECLARE x INTEGER;
  END CATCH;
END;
--]]

function no_cleanup_label_needed_proc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "N" }
  local C_types_ = "I"
  local x

  -- try

    _rc_, C_stmt = cql_prepare(_db_, 
      "SELECT 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_2; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto catch_start_2; end
    goto catch_end_2

  ::catch_start_2:: 
  do
  end

  ::catch_end_2::
  _rc_ = CQL_OK

  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC no_code_after_catch ()
BEGIN
  BEGIN TRY
    @ATTRIBUTE(foo)
    DECLARE x INTEGER;
  END TRY;
  BEGIN CATCH
    @ATTRIBUTE(bar)
    DECLARE y INTEGER;
  END CATCH;
END;
--]]

function no_code_after_catch(_db_)
  local _rc_ = CQL_OK
  local x
  local y

  -- try

    goto catch_end_3


  do
  end

  ::catch_end_3::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_no_db ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  FETCH C(A, B) FROM VALUES(3, 12);
  OUT C;
END;
--]]

function out_no_db()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A", "B" }
  local C_types_ = "ID"

  C._has_row_ = true
  C.A = 3
  C.B = cql_to_float(12)
  _result_ = cql_clone_row(C)

  return _result_
end

function out_no_db_fetch_results()
  local result_set = nil
  _result_ = out_no_db()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC declare_cursor_like_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2.5 AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C1(A, B) FROM VALUES(3, 12);
  OUT C1;
END;
--]]

function declare_cursor_like_cursor()
  local _result_ = nil
  local C0 = { _has_row_ = false }
  local C0_fields_ = { "A", "B" }
  local C0_types_ = "ID"
  local C1 = { _has_row_ = false }
  local C1_fields_ = { "A", "B" }
  local C1_types_ = "ID"

  C1._has_row_ = true
  C1.A = 3
  C1.B = cql_to_float(12)
  _result_ = cql_clone_row(C1)

  return _result_
end

function declare_cursor_like_cursor_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_cursor()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC declare_cursor_like_proc ()
BEGIN
  DECLARE C CURSOR LIKE fetcher_proc;
  OUT C;
END;
--]]

function declare_cursor_like_proc()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b" }
  local C_types_ = "is"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_proc_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_proc()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC declare_cursor_like_table ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  OUT C;
END;
--]]

function declare_cursor_like_table()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_table_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_table()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC declare_cursor_like_view ()
BEGIN
  DECLARE C CURSOR LIKE MyView;
  OUT C;
END;
--]]

function declare_cursor_like_view()
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "f1", "f2", "f3" }
  local C_types_ = "III"

  _result_ = cql_clone_row(C)

  return _result_
end

function declare_cursor_like_view_fetch_results()
  local result_set = nil
  _result_ = declare_cursor_like_view()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC weird_quoting ()
BEGIN
  DELETE FROM bar WHERE name LIKE "\n\n";
  DELETE FROM bar WHERE name = ' '' \n '' \';
  DELETE FROM bar WHERE name <> "'";
  DELETE FROM bar WHERE name >= '\';
END;
--]]

function weird_quoting(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\n\n'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name = ' '' \\n '' \\'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name <> ''''")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name >= '\\'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC long_auto_table_maker ()
BEGIN
  CREATE TABLE long_int_autoinc(
    id LONG_INT PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );
END;
--]]

function long_auto_table_maker(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE TABLE long_int_autoinc( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT )")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC blob_out (OUT x BLOB);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC blob_call1 ()
BEGIN
  DECLARE b BLOB;
  CALL blob_out(b);
END;
--]]

function blob_call1()
  local b

  b = blob_out()

end

-- The statement ending at line XXXX

--[[
CREATE PROC blob_call2 ()
BEGIN
  DECLARE b BLOB;
  SET b := blob_out();
END;
--]]

function blob_call2()
  local b

  b = blob_out()

end

-- The statement ending at line XXXX

--[[
CREATE PROC blob_no_else ()
BEGIN
  DECLARE b BLOB;
  DECLARE b1 BLOB;
  SET b := CASE b WHEN b THEN b1
  END;
END;
--]]

function blob_no_else()
  local b
  local b1
  local _tmp_n_blob_1

  repeat
    _tmp_n_blob_1 = b
    if _tmp_n_blob_1 == nil then goto case_else_3 end
    if _tmp_n_blob_1 == b then
      b = b1
      break
    end
    ::case_else_3::
    b = nil
  until true

end

-- The statement ending at line XXXX

--[[
CREATE PROC with_inserter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) SELECT *
    FROM x;
END;
--]]

function with_inserter(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS (SELECT 111) INSERT INTO foo(id) SELECT a FROM x")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC multi_rewrite (blob_id_ INTEGER NOT NULL, b_notnull_ BLOB NOT NULL, b_nullable_ BLOB, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT, type_ INTEGER, size_ REAL, OUT out_arg INTEGER NOT NULL)
BEGIN
  INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(blob_id_, b_notnull_, b_nullable_);
  SET out_arg := 1;
END;
--]]

function multi_rewrite(_db_, blob_id_, b_notnull_, b_nullable_, id_, name_, rate_, type_, size_)
  cql_contract_argument_notnull(blob_id_, 1)
  cql_contract_argument_notnull(b_notnull_, 2)
  cql_contract_argument_notnull(id_, 4)

  local _rc_ = CQL_OK
  local out_arg = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO blob_table(blob_id, b_notnull, b_nullable) VALUES(?, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "IBb", {blob_id_, b_notnull_, b_nullable_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  out_arg = 1
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_, out_arg
end

-- The statement ending at line XXXX

--[[
CREATE PROC fetch_to_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, "foo" AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0(A, B) FROM VALUES(2, "bar");
  FETCH C1(A, B) FROM VALUES(C0.A, C0.B);
  OUT C1;
END;
--]]

function fetch_to_cursor_from_cursor()
  local _result_ = nil
  local C0 = { _has_row_ = false }
  local C0_fields_ = { "A", "B" }
  local C0_types_ = "IS"
  local C1 = { _has_row_ = false }
  local C1_fields_ = { "A", "B" }
  local C1_types_ = "IS"

  C0._has_row_ = true
  C0.A = 2
  C0.B = "bar"
  C1._has_row_ = true
  C1.A = C0.A
  C1.B = C0.B
  _result_ = cql_clone_row(C1)

  return _result_
end

function fetch_to_cursor_from_cursor_fetch_results()
  local result_set = nil
  _result_ = fetch_to_cursor_from_cursor()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC loop_statement_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.A);
  END;
END;
--]]

function loop_statement_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not C._has_row_ then break end
    printf("%d\n", C.A)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC loop_statement_not_auto_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A;
  DECLARE A_ INTEGER NOT NULL;
  LOOP FETCH C INTO A_
  BEGIN
    CALL printf("%d\n", A_);
  END;
END;
--]]

function loop_statement_not_auto_cursor(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "A" }
  local C_types_ = "I"
  local A_ = 0

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    A_ = C.A
    if not C._has_row_ then break end
    printf("%d\n", A_)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC simple_select ()
BEGIN
  SELECT 1 AS x;
END;
--]]

function simple_select(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
CREATE PROC call_in_loop ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    FETCH C;
  END;
END;
--]]

function call_in_loop(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
  if not(i < 5) then break end
    i = i + 1
    cql_finalize_stmt(C_stmt)
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC call_in_loop_with_nullable_condition ()
BEGIN
  DECLARE i INTEGER;
  SET i := nullable(0);
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    FETCH C;
  END;
END;
--]]

function call_in_loop_with_nullable_condition(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
  if not(cql_lt(i, 5)) then break end
    i = cql_add(i, 1)
    cql_finalize_stmt(C_stmt)
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC call_in_loop_boxed ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL simple_select();
    DECLARE box OBJECT<C CURSOR>;
    SET box FROM CURSOR C;
    DECLARE D CURSOR FOR box;
    FETCH D;
  END;
END;
--]]

function call_in_loop_boxed(_db_)
  local _rc_ = CQL_OK
  local i
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"
  local box
  local D_stmt = nil
  local D = { _has_row_ = false }
  local D_fields_ = { "x" }
  local D_types_ = "I"

  i = 0
  while true
  do
  if not(i < 5) then break end
    i = i + 1
    C_stmt = nil
    _rc_, C_stmt = simple_select(_db_)
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    box = C_stmt
    D_stmt = box
    -- step and fetch
    _rc_ = cql_multifetch(D_stmt, D, D_types_, D_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_helper ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x;
  FETCH C(x) FROM VALUES(1);
  OUT UNION C;
END;
--]]

function out_union_helper_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  C._has_row_ = true
  C.x = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_dml_helper ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  FETCH C;
  OUT UNION C;
END;
--]]

function out_union_dml_helper_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC call_out_union_in_loop ()
BEGIN
  DECLARE i INTEGER;
  SET i := 0;
  WHILE i < 5
  BEGIN
    SET i := i + 1;
    DECLARE C CURSOR FOR CALL out_union_helper();
    FETCH C;
  END;
END;
--]]

function call_out_union_in_loop(_db_)
  local _rc_ = CQL_OK
  local i
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  i = 0
  while true
  do
  if not(i < 5) then break end
    i = i + 1
    C_result_set_ = out_union_helper_fetch_results()
    C_row_num_ = 0
    C_row_count_ = #(C_result_set_)
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC forward_out_union ()
BEGIN
  CALL out_union_helper();
END;
--]]

function forward_out_union_fetch_results()
  local _result_set_ = {}
  _result_set_ = out_union_helper_fetch_results()

  return _result_set_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC extern_out_union_helper () OUT UNION (x INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC forward_out_union_extern ()
BEGIN
  CALL extern_out_union_helper();
END;
--]]

function forward_out_union_extern_fetch_results()
  local _result_set_ = {}
  _result_set_ = extern_out_union_helper_fetch_results()

  return _result_set_
end

-- The statement ending at line XXXX

--[[
CREATE PROC forward_out_union_dml ()
BEGIN
  CALL out_union_dml_helper();
END;
--]]

function forward_out_union_dml_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _result_set_ = {}
  _rc_, _result_set_ = out_union_dml_helper_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, _result_set_
end
local global_cursor_stmt = nil
local global_cursor = { _has_row_ = false }
local global_cursor_fields_ = { "a", "b" }
local global_cursor_types_ = "II"

-- The statement ending at line XXXX

--[[
CREATE PROC make_trigger ()
BEGIN
  CREATE TEMP TRIGGER IF NOT EXISTS trigger1
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;
--]]

function make_trigger(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE TEMP TRIGGER IF NOT EXISTS trigger1 BEFORE DELETE ON bar FOR EACH ROW WHEN old.id > 7 BEGIN SELECT old.id; END")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC is_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS 1;
  SET b := 'x' IS 'x';
  SET b := 'x' IS 'y';
  SET b := 1 + (3 IS 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS j;
END;
--]]

function is_test()
  local b = false
  local i
  local j

  b = 1 == 1
  b = "x" == "x"
  b = "x" == "y"
  b = cql_to_bool(1 + cql_to_num((3 == 4)))
  i = 1
  j = 2
  b = i == j

end

-- The statement ending at line XXXX

--[[
CREATE PROC is_blob ()
BEGIN
  DECLARE bl1 BLOB;
  DECLARE bl2 BLOB;
  DECLARE b BOOL NOT NULL;
  SET b := bl1 IS bl2;
  SET b := bl1 IS NOT bl2;
END;
--]]

function is_blob()
  local bl1
  local bl2
  local b = false

  b = cql_blob_is_eq(bl1, bl2)
  b = cql_blob_is_ne(bl1, bl2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC is_not_test ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1 IS NOT 1;
  SET b := 'x' IS NOT 'x';
  SET b := 'x' IS NOT 'y';
  SET b := 1 + (3 IS NOT 4);
  LET i := nullable(1);
  LET j := nullable(2);
  SET b := i IS NOT j;
END;
--]]

function is_not_test()
  local b = false
  local i
  local j

  b = 1 ~= 1
  b = "x" ~= "x"
  b = "x" ~= "y"
  b = cql_to_bool(1 + cql_to_num((3 ~= 4)))
  i = 1
  j = 2
  b = i ~= j

end

-- The statement ending at line XXXX

--[[
CREATE PROC in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL IN (1);
END;
--]]

function in_test(x)
  local b

  b = nil

  return b
end

-- The statement ending at line XXXX

--[[
CREATE PROC not_in_test (x INTEGER, OUT b BOOL)
BEGIN
  SET b := NULL NOT IN (1);
END;
--]]

function not_in_test(x)
  local b

  b = nil

  return b
end

-- The statement ending at line XXXX

--[[
CREATE PROC drop_trigger_test ()
BEGIN
  DROP TRIGGER IF EXISTS trigger1;
  DROP TRIGGER trigger1;
END;
--]]

function drop_trigger_test(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER IF EXISTS trigger1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "DROP TRIGGER trigger1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:identity=(id))
CREATE PROC simple_identity ()
BEGIN
  SELECT 1 AS id, 2 AS data;
END;
--]]

function simple_identity(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function simple_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = simple_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:identity=(col1, col2))
CREATE PROC complex_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;
--]]

function complex_identity(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2, 3")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function complex_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = complex_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "III", { "col1", "col2", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:identity=(id))
CREATE PROC out_cursor_identity ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 2 AS data;
  FETCH C;
  OUT C;
END;
--]]

function out_cursor_identity(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "data" }
  local C_types_ = "II"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(C)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _result_
end

function out_cursor_identity_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = out_cursor_identity(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC radioactive_proc ()
BEGIN
  SELECT *
    FROM radioactive;
END;
--]]

function radioactive_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, data FROM radioactive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function radioactive_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = radioactive_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Is", { "id", "data" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC with_deleter ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  DELETE FROM foo WHERE id IN (SELECT *
    FROM x);
END;
--]]

function with_deleter(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS (SELECT 111) DELETE FROM foo WHERE id IN (SELECT a FROM x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC with_updater ()
BEGIN
  WITH
  x (a) AS (SELECT 111)
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;
--]]

function with_updater(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS (SELECT 111) UPDATE bar SET name = 'xyzzy' WHERE id IN (SELECT a FROM x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodropper ()
BEGIN
  SELECT 1 AS a, 2 AS b;
END;
--]]

function autodropper(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function autodropper_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = autodropper(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "a", "b" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC simple_cursor_proc ()
BEGIN
  DECLARE A_CURSOR CURSOR LIKE SELECT 1 AS id;
  FETCH a_cursor(id) FROM VALUES(1);
  OUT a_cursor;
END;
--]]

function simple_cursor_proc()
  local _result_ = nil
  local A_CURSOR = { _has_row_ = false }
  local A_CURSOR_fields_ = { "id" }
  local A_CURSOR_types_ = "I"

  A_CURSOR._has_row_ = true
  A_CURSOR.id = 1
  _result_ = cql_clone_row(A_CURSOR)

  return _result_
end

function simple_cursor_proc_fetch_results()
  local result_set = nil
  _result_ = simple_cursor_proc()
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC redundant_cast ()
BEGIN
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
--]]

function redundant_cast(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT (5), T.xyzzy FROM (SELECT 1 AS xyzzy) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function redundant_cast_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = redundant_cast(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "plugh", "five" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC view_creator ()
BEGIN
  CREATE VIEW alias_preserved AS
  SELECT CAST(5 AS INTEGER) AS plugh, T.xyzzy AS five
    FROM (SELECT 1 AS xyzzy) AS T;
END;
--]]

function view_creator(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIEW alias_preserved AS SELECT (5) AS plugh, T.xyzzy AS five FROM (SELECT 1 AS xyzzy) AS T")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC settings_info ()
BEGIN
  DECLARE C CURSOR FOR SELECT SUM(A.unread_pending_thread_count) AS unread_pending_thread_count, SUM(A.switch_account_badge_count) AS switch_account_badge_count
    FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count
    FROM unread_pending_threads AS P
  UNION ALL
  SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count
    FROM switch_account_badges AS S) AS A;
END;
--]]

function settings_info(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "unread_pending_thread_count", "switch_account_badge_count" }
  local C_types_ = "ii"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT SUM(A.unread_pending_thread_count), SUM(A.switch_account_badge_count) FROM (SELECT P.unread_pending_thread_count AS unread_pending_thread_count, 0 AS switch_account_badge_count FROM unread_pending_threads AS P UNION ALL SELECT 0 AS unread_pending_thread_count, S.badge_count AS switch_account_badge_count FROM switch_account_badges AS S) AS A")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC top_level_select_alias_unused ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo;
END;
--]]

function top_level_select_alias_unused(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2 UNION ALL SELECT foo.id, 2 FROM foo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function top_level_select_alias_unused_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = top_level_select_alias_unused(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC top_level_select_alias_used_in_orderby ()
BEGIN
  SELECT 1 AS id, 2 AS x
  UNION ALL
  SELECT foo.id, 2 AS x
    FROM foo
  ORDER BY id;
END;
--]]

function top_level_select_alias_used_in_orderby(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1 AS id, 2 UNION ALL SELECT foo.id, 2 FROM foo ORDER BY id")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function top_level_select_alias_used_in_orderby_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = top_level_select_alias_used_in_orderby(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC use_with_select ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( WITH
  threads2 (count) AS (SELECT 1 AS foo)
  SELECT COUNT(*)
    FROM threads2 );
END;
--]]

function use_with_select(_db_)
  local _rc_ = CQL_OK
  local x
  local _tmp_int_0 = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "WITH threads2 (count) AS (SELECT 1) SELECT COUNT(*) FROM threads2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  x = _tmp_int_0
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM ReadFromRowset(rowset);
END;
--]]

function rowset_object_reader(_db_, rowset)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id" }
  local C_types_ = "i"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT id FROM ReadFromRowset(?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, C_stmt, "o", {rowset})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC upsert_do_something ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
--]]

function upsert_do_something(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo(id) SELECT id FROM bar WHERE 1 ON CONFLICT (id) DO UPDATE SET id = 10 WHERE id <> 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC with_upsert_form ()
BEGIN
  WITH
  names (id) AS (VALUES(1), (5), (3), (12))
  INSERT INTO foo(id) SELECT id
    FROM names
    WHERE 1
  ON CONFLICT (id) DO UPDATE
  SET id = 10
    WHERE id <> 10;
END;
--]]

function with_upsert_form(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "WITH names (id) AS (VALUES(1), (5), (3), (12)) INSERT INTO foo(id) SELECT id FROM names WHERE 1 ON CONFLICT (id) DO UPDATE SET id = 10 WHERE id <> 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC upsert_do_nothing (id_ INTEGER NOT NULL)
BEGIN
  INSERT INTO foo(id) VALUES(id_)
  ON CONFLICT DO NOTHING;
END;
--]]

function upsert_do_nothing(_db_, id_)
  cql_contract_argument_notnull(id_, 1)

  local _rc_ = CQL_OK
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO foo(id) VALUES(?) ON CONFLICT DO NOTHING")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", {id_})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end
local _seed_ = 0

-- The statement ending at line XXXX

--[[
DECLARE PROC p1 () OUT (id INTEGER NOT NULL, t TEXT);
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC p2 () OUT (id INTEGER NOT NULL, t TEXT) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC use_many_out_cursors ()
BEGIN
  DECLARE c1 CURSOR FETCH FROM CALL p1();
  DECLARE c2 CURSOR FETCH FROM CALL p2();
END;
--]]

function use_many_out_cursors(_db_)
  local _rc_ = CQL_OK
  local c1 = { _has_row_ = false }
  local c1_fields_ = { "id", "t" }
  local c1_types_ = "Is"
  local c2 = { _has_row_ = false }
  local c2_fields_ = { "id", "t" }
  local c2_types_ = "Is"

  c1 = p1()
  _rc_, c2 = p2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC fetch_many_times (arg BOOL NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE p1;
  IF arg = 1 THEN
    FETCH C FROM CALL p1();
  ELSE IF arg = 2 THEN
    FETCH C FROM CALL p2();
  ELSE
    FETCH C FROM CALL p1();
    FETCH C FROM CALL p2();
  END IF;
END;
--]]

function fetch_many_times(_db_, arg)
  cql_contract_argument_notnull(arg, 1)

  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "t" }
  local C_types_ = "Is"

  if cql_to_num(arg) == 1 then
    C = p1()
  else
    if cql_to_num(arg) == 2 then
      _rc_, C = p2(_db_)
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    else
      C = p1()
      _rc_, C = p2(_db_)
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_two ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, '2' AS y;
  FETCH C(x, y) FROM VALUES(1, "y");
  OUT UNION C;
  OUT UNION C;
END;
--]]

function out_union_two_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "IS"

  C._has_row_ = true
  C.x = 1
  C.y = "y"
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_two();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
--]]

function out_union_reader(_db_)
  local _rc_ = CQL_OK
  local c_result_set_ = nil
  local c_row_num_ = 0
  local c_row_count_ = 0
  local c = { _has_row_ = false }
  local c_fields_ = { "x", "y" }
  local c_types_ = "IS"

  c_result_set_ = out_union_two_fetch_results()
  c_row_num_ = 0
  c_row_count_ = #(c_result_set_)
  while true
  do
    c_row_num_ = c_row_num_ + 1
    if c_row_num_ <= c_row_count_ then
      c = c_result_set_[c_row_num_]
    else
      c = { _has_row_ = false }
    end
    if not c._has_row_ then break end
    printf("%d %s\n", c.x, c.y)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_from_select ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x, '2' AS y;
  FETCH C;
  OUT UNION C;
  OUT UNION C;
END;
--]]

function out_union_from_select_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "IS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, '2'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_dml_reader ()
BEGIN
  DECLARE c CURSOR FOR CALL out_union_from_select();
  LOOP FETCH C
  BEGIN
    CALL printf("%d %s\n", C.x, C.y);
  END;
END;
--]]

function out_union_dml_reader(_db_)
  local _rc_ = CQL_OK
  local c_result_set_ = nil
  local c_row_num_ = 0
  local c_row_count_ = 0
  local c = { _has_row_ = false }
  local c_fields_ = { "x", "y" }
  local c_types_ = "IS"

  _rc_, c_result_set_ = out_union_from_select_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  c_row_num_ = 0
  c_row_count_ = #(c_result_set_)
  while true
  do
    c_row_num_ = c_row_num_ + 1
    if c_row_num_ <= c_row_count_ then
      c = c_result_set_[c_row_num_]
    else
      c = { _has_row_ = false }
    end
    if not c._has_row_ then break end
    printf("%d %s\n", c.x, c.y)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE x CURSOR LIKE SELECT 1 AS x, 2 AS y;
  FETCH x(x, y) FROM VALUES(a, b);
  OUT UNION x;
END;
--]]

function out_union_values_fetch_results(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local _rows_ = {}
  local x = { _has_row_ = false }
  local x_fields_ = { "x", "y" }
  local x_types_ = "II"

  x._has_row_ = true
  x.x = a
  x.y = b
  if x._has_row_ then
    table.insert(_rows_, cql_clone_row(x))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC read_out_union_values (a INTEGER NOT NULL, b INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR FOR CALL out_union_values(a, b);
  FETCH C;
END;
--]]

function read_out_union_values(_db_, a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  C_result_set_ = out_union_values_fetch_results(a, b)
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  C_row_num_ = C_row_num_ + 1
  if C_row_num_ <= C_row_count_ then
    C = C_result_set_[C_row_num_]
  else
    C = { _has_row_ = false }
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC out_union_dml ()
BEGIN
  DECLARE x CURSOR FOR SELECT *
    FROM radioactive;
  FETCH x;
  OUT UNION x;
END;
--]]

function out_union_dml_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local x_stmt = nil
  local x = { _has_row_ = false }
  local x_fields_ = { "id", "data" }
  local x_types_ = "Is"

  _rc_, x_stmt = cql_prepare(_db_, 
    "SELECT id, data FROM radioactive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(x_stmt, x, x_types_, x_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if x._has_row_ then
    table.insert(_rows_, cql_clone_row(x))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(x_stmt)
  x_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC out_union_dml_for_call ()
BEGIN
  DECLARE C CURSOR FOR CALL out_union_dml();
  FETCH C;
END;
--]]

function out_union_dml_for_call(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "data" }
  local C_types_ = "Is"

  _rc_, C_result_set_ = out_union_dml_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  C_row_num_ = C_row_num_ + 1
  if C_row_num_ <= C_row_count_ then
    C = C_result_set_[C_row_num_]
  else
    C = { _has_row_ = false }
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC compound_select_expr ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
  LIMIT 1 );
END;
--]]

function compound_select_expr(_db_)
  local _rc_ = CQL_OK
  local x
  local _tmp_int_0 = 0
  local _temp_stmt = nil

  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 1 WHERE 0 UNION SELECT 2 LIMIT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  x = _tmp_int_0
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC window_function_invocation ()
BEGIN
  SELECT id, 
    row_number() OVER () AS row_num
    FROM foo;
END;
--]]

function window_function_invocation(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id,  row_number() OVER () FROM foo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window_function_invocation_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window_function_invocation(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "id", "row_num" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC update_cursor ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, 2 AS y;
  UPDATE CURSOR C(x) FROM VALUES(2);
END;
--]]

function update_cursor(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  if C._has_row_ then
    C.x = 2
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC out_union_with_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC out_union_no_dml (id INTEGER) OUT UNION (id INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC use_return ()
BEGIN
  BEGIN TRY
    SELECT 1 AS x;
  END TRY;
  BEGIN CATCH
    RETURN;
  END CATCH;
END;
--]]

function use_return(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  -- try

    _rc_, _result_stmt = cql_prepare(_db_, 
      "SELECT 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_4; end
    goto catch_end_4

  ::catch_start_4:: 
  do
    _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
    goto cql_cleanup -- return
  end

  ::catch_end_4::
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function use_return_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = use_return(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC use_return_no_error_flow ()
BEGIN
  IF 1 THEN
    RETURN;
  END IF;
END;
--]]

function use_return_no_error_flow()
  if true then
    goto cql_cleanup -- return
  end

::cql_cleanup::
end

-- The statement ending at line XXXX

--[[
CREATE PROC empty_proc ()
BEGIN
END;
--]]

function empty_proc()

end

-- The statement ending at line XXXX

--[[
CREATE PROC empty_blocks ()
BEGIN
  IF 1 THEN
  END IF;
  IF 2 THEN
  ELSE
  END IF;
  IF 3 THEN
  ELSE IF 4 THEN
  ELSE
  END IF;
  WHILE 1
  BEGIN
  END;
  DECLARE c CURSOR FOR SELECT 1 AS x;
  LOOP FETCH c
  BEGIN
  END;
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
END;
--]]

function empty_blocks(_db_)
  local _rc_ = CQL_OK
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "I"

  if true then
  end
  if cql_to_bool(2) then
  else
  end
  if cql_to_bool(3) then
  else
    if cql_to_bool(4) then
    else
    end
  end
  while true
  do
  if not(true) then break end
  end
  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not c._has_row_ then break end
  end
  -- try

    goto catch_end_5


  do
  end

  ::catch_end_5::
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC tail_catch ()
BEGIN
  BEGIN TRY
  END TRY;
  BEGIN CATCH
    BEGIN TRY
    END TRY;
    BEGIN CATCH
    END CATCH;
  END CATCH;
END;
--]]

function tail_catch(_db_)
  local _rc_ = CQL_OK
  -- try

    goto catch_end_6


  do
    -- try

      goto catch_end_7


    do
    end

    ::catch_end_7::
  end

  ::catch_end_6::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC pretty_print_with_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "it's high noon\r\n\f\b\t\v");
END;
--]]

function pretty_print_with_quote(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, 'it''s high noon\r\n\f\b\t\v')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC hex_quote ()
BEGIN
  INSERT INTO bar(id, name) VALUES(1, "\x01\x02\xa1\x1bg");
END;
--]]

function hex_quote(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id, name) VALUES(1, '\x01\x02\xa1\x1bg')")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:suppress_getters)
CREATE PROC lotsa_columns_no_getters ()
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function lotsa_columns_no_getters(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function lotsa_columns_no_getters_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = lotsa_columns_no_getters(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:generate_copy)
CREATE PROC sproc_with_copy ()
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function sproc_with_copy(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function sproc_with_copy_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = sproc_with_copy(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:emit_setters)
CREATE PROC emit_object_with_setters (o OBJECT NOT NULL, x OBJECT NOT NULL, i INTEGER NOT NULL, l LONG_INT NOT NULL, b BOOL NOT NULL, d REAL NOT NULL, t TEXT NOT NULL, bl BLOB NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE emit_object_with_setters ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES(o, x, i, l, b, d, t, bl);
  OUT C;
END;
--]]

function emit_object_with_setters(o, x, i, l, b, d, t, bl)
  cql_contract_argument_notnull(o, 1)
  cql_contract_argument_notnull(x, 2)
  cql_contract_argument_notnull(i, 3)
  cql_contract_argument_notnull(l, 4)
  cql_contract_argument_notnull(b, 5)
  cql_contract_argument_notnull(d, 6)
  cql_contract_argument_notnull(t, 7)
  cql_contract_argument_notnull(bl, 8)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o", "x", "i", "l", "b", "d", "t", "bl" }
  local C_types_ = "OOILFDSB"

  C._has_row_ = true
  C.o = o
  C.x = x
  C.i = i
  C.l = l
  C.b = b
  C.d = d
  C.t = t
  C.bl = bl
  _result_ = cql_clone_row(C)

  return _result_
end

function emit_object_with_setters_fetch_results(o, x, i, l, b, d, t, bl)
  local result_set = nil
  _result_ = emit_object_with_setters(o, x, i, l, b, d, t, bl)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:emit_setters)
CREATE PROC emit_setters_with_nullables (o OBJECT, x OBJECT, i INTEGER, l LONG_INT, b BOOL, d REAL, t TEXT, bl BLOB)
BEGIN
  DECLARE C CURSOR LIKE emit_setters_with_nullables ARGUMENTS;
  FETCH C(o, x, i, l, b, d, t, bl) FROM VALUES(o, x, i, l, b, d, t, bl);
  OUT C;
END;
--]]

function emit_setters_with_nullables(o, x, i, l, b, d, t, bl)
  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o", "x", "i", "l", "b", "d", "t", "bl" }
  local C_types_ = "ooilfdsb"

  C._has_row_ = true
  C.o = o
  C.x = x
  C.i = i
  C.l = l
  C.b = b
  C.d = d
  C.t = t
  C.bl = bl
  _result_ = cql_clone_row(C)

  return _result_
end

function emit_setters_with_nullables_fetch_results(o, x, i, l, b, d, t, bl)
  local result_set = nil
  _result_ = emit_setters_with_nullables(o, x, i, l, b, d, t, bl)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:emit_setters)
CREATE PROC no_out_with_setters ()
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function no_out_with_setters(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function no_out_with_setters_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = no_out_with_setters(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC lotsa_columns_no_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function lotsa_columns_no_result_set(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
CREATE PROC early_out_rc_cleared (OUT x INTEGER)
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  FETCH C;
  IF C THEN
    RETURN;
  END IF;
END;
--]]

function early_out_rc_cleared(_db_)
  local _rc_ = CQL_OK
  local x
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "I"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if C._has_row_ then
    _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
    goto cql_cleanup -- return
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_, x
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=(id, name))
@ATTRIBUTE(cql:custom_type_for_encoded_column)
CREATE PROC vault_sensitive_with_values_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_values_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_values_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_values_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=(id, name))
@ATTRIBUTE(cql:custom_type_for_encoded_column)
CREATE PROC vault_not_nullable_sensitive_with_values_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_not_nullable_sensitive;
END;
--]]

function vault_not_nullable_sensitive_with_values_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_not_nullable_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_not_nullable_sensitive_with_values_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_not_nullable_sensitive_with_values_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "ISSL", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_sensitive_mixed_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_mixed_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_mixed_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_mixed_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_union_all_table_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive
  UNION ALL
  SELECT *
    FROM vault_non_sensitive;
END;
--]]

function vault_union_all_table_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_sensitive UNION ALL SELECT id, name, title, type FROM vault_non_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_union_all_table_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_union_all_table_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=alias_name)
CREATE PROC vault_alias_column_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
--]]

function vault_alias_column_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_alias_column_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_alias_column_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "alias_name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=alias_name)
CREATE PROC vault_alias_column_name_proc ()
BEGIN
  SELECT name AS alias_name
    FROM vault_mixed_sensitive;
END;
--]]

function vault_alias_column_name_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_alias_column_name_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_alias_column_name_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "s", { "alias_name" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT name
    FROM vault_mixed_sensitive;
  FETCH c;
END;
--]]

function vault_cursor_proc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "name" }
  local C_types_ = "s"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT name FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=(title, (id, name)))
CREATE PROC vault_sensitive_with_context_and_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_context_and_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_context_and_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_context_and_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=((id, name)))
CREATE PROC vault_sensitive_with_no_context_and_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_mixed_sensitive;
END;
--]]

function vault_sensitive_with_no_context_and_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_mixed_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_no_context_and_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_no_context_and_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:vault_sensitive=(title, (id, name)))
CREATE PROC vault_sensitive_with_context_and_no_sensitive_columns_proc ()
BEGIN
  SELECT *
    FROM vault_non_sensitive;
END;
--]]

function vault_sensitive_with_context_and_no_sensitive_columns_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, title, type FROM vault_non_sensitive")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function vault_sensitive_with_context_and_no_sensitive_columns_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = vault_sensitive_with_context_and_no_sensitive_columns_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Issl", { "id", "name", "title", "type" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC try_boxing (OUT result OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET result FROM CURSOR C;
END;
--]]

function try_boxing(_db_)
  local _rc_ = CQL_OK
  local result
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  C_stmt = nil
  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  result = C_stmt
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, result
end

-- The statement ending at line XXXX

--[[
CREATE PROC try_unboxing (boxed_cursor OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR boxed_cursor;
  FETCH C;
END;
--]]

function try_unboxing(_db_, boxed_cursor)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  C_stmt = boxed_cursor
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_int_notnull ()
BEGIN
  DECLARE x INTEGER NOT NULL;
  SET x := CAST(3.2 AS INTEGER);
END;
--]]

function local_cast_int_notnull()
  local x = 0

  x = cql_to_integer(3.2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_int ()
BEGIN
  DECLARE x INTEGER;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS INTEGER);
END;
--]]

function local_cast_int()
  local x
  local r

  r = 3.2
  x = cql_to_integer(r)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_long_notnull ()
BEGIN
  DECLARE x LONG_INT NOT NULL;
  SET x := CAST(3.2 AS LONG_INT);
END;
--]]

function local_cast_long_notnull()
  local x = 0

  x = cql_to_integer(3.2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_long ()
BEGIN
  DECLARE x LONG_INT;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS LONG_INT);
END;
--]]

function local_cast_long()
  local x
  local r

  r = 3.2
  x = cql_to_integer(r)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_real_notnull ()
BEGIN
  DECLARE x REAL NOT NULL;
  SET x := CAST(3 AS REAL);
END;
--]]

function local_cast_real_notnull()
  local x = 0.0

  x = cql_to_float(3)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_real ()
BEGIN
  DECLARE x REAL;
  DECLARE r INTEGER;
  SET r := nullable(3);
  SET x := CAST(r AS REAL);
END;
--]]

function local_cast_real()
  local x
  local r

  r = 3
  x = cql_to_float(r)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_bool_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  SET x := CAST(3.2 AS BOOL);
END;
--]]

function local_cast_bool_notnull()
  local x = false

  x = cql_to_bool(3.2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_bool ()
BEGIN
  DECLARE x BOOL;
  DECLARE r REAL;
  SET r := nullable(3.2);
  SET x := CAST(r AS BOOL);
END;
--]]

function local_cast_bool()
  local x
  local r

  r = 3.2
  x = cql_to_bool(r)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_from_bool_notnull ()
BEGIN
  DECLARE b BOOL NOT NULL;
  SET b := 1;
  DECLARE x REAL NOT NULL;
  SET x := CAST(b AS REAL);
END;
--]]

function local_cast_from_bool_notnull()
  local b = false
  local x = 0.0

  b = true
  x = cql_to_float(b)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_from_bool ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x REAL;
  SET x := CAST(b AS REAL);
END;
--]]

function local_cast_from_bool()
  local b
  local x

  b = true
  x = cql_to_float(b)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_from_bool_no_op_notnull ()
BEGIN
  DECLARE x BOOL NOT NULL;
  DECLARE b BOOL NOT NULL;
  SET b := 0;
  SET x := CAST(b AS BOOL);
END;
--]]

function local_cast_from_bool_no_op_notnull()
  local x = false
  local b = false

  b = false
  x = (b)

end

-- The statement ending at line XXXX

--[[
CREATE PROC local_cast_from_bool_no_op ()
BEGIN
  DECLARE b BOOL;
  SET b := nullable(1);
  DECLARE x BOOL;
  SET x := CAST(b AS BOOL);
END;
--]]

function local_cast_from_bool_no_op()
  local b
  local x

  b = true
  x = (b)

end

-- The statement ending at line XXXX

--[[
CREATE PROC base_proc_savepoint ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    DECLARE X INTEGER;
  END;
END;
--]]

function base_proc_savepoint(_db_)
  local _rc_ = CQL_OK
  local X

  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_8; end
    goto catch_end_8

  ::catch_start_8:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    goto cql_cleanup
  end

  ::catch_end_8::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC base_proc_savepoint_commit_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      COMMIT RETURN;
    END IF;
  END;
END;
--]]

function base_proc_savepoint_commit_return(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_commit_return")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    if true then
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_commit_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_9; end
      _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
      goto cql_cleanup -- return
    end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_9; end
    goto catch_end_9

  ::catch_start_9:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_commit_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    goto cql_cleanup
  end

  ::catch_end_9::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC base_proc_savepoint_rollback_return ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    END IF;
  END;
END;
--]]

function base_proc_savepoint_rollback_return(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "SAVEPOINT base_proc_savepoint_rollback_return")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    if true then
      _rc_ = cql_exec(_db_,
        "ROLLBACK TO base_proc_savepoint_rollback_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
      _rc_ = cql_exec(_db_,
        "RELEASE base_proc_savepoint_rollback_return")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
      _rc_ = CQL_OK -- clean up any CQL_ROW value or other non-error
      goto cql_cleanup -- return
    end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_10; end
    goto catch_end_10

  ::catch_start_10:: 
  do
    local _rc_thrown_1 = _rc_
    _rc_ = cql_exec(_db_,
      "ROLLBACK TO base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_exec(_db_,
      "RELEASE base_proc_savepoint_rollback_return")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_best_error(_rc_thrown_1)
    goto cql_cleanup
  end

  ::catch_end_10::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE x INTEGER NOT NULL;
--]]
local x = 0

-- The statement ending at line XXXX

--[[
CREATE PROC window1 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window1(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window1_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window1(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window2 ()
BEGIN
  SELECT month, amount, 
    SUM(amount) OVER (ORDER BY month) AS RunningTotal
    FROM SalesInfo;
END;
--]]

function window2(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  SUM(amount) OVER (ORDER BY month) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window2_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "RunningTotal" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window3 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window3(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window3_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window3(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window4 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window4(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) FILTER (WHERE month = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window4_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window4(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window5 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window5(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 3 PRECEDING AND 4 FOLLOWING EXCLUDE CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window5_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window5(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window6 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window6(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 4 PRECEDING AND 5 FOLLOWING EXCLUDE GROUP) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window6_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window6(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window7 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window7(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 6 PRECEDING AND 7 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window7_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window7(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window8 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window8(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month RANGE BETWEEN 8 PRECEDING AND 9 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window8_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window8(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window9 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window9(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 10 PRECEDING AND 11 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window9_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window9(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window10 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window10(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND 12 FOLLOWING EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window10_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window10(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window11 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window11(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN 13 FOLLOWING AND 14 PRECEDING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window11_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window11(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window12 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window12(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window12_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window12(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window13 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window13(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window13_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window13(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window14 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window14(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window14_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window14(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window15 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window15(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (PARTITION BY month ORDER BY month GROUPS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE TIES) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window15_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window15(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC window16 ()
BEGIN
  SELECT month, amount, 
    AVG(amount) OVER (GROUPS CURRENT ROW) AS SalesMovingAverage
    FROM SalesInfo;
END;
--]]

function window16(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT month, amount,  AVG(amount) OVER (GROUPS CURRENT ROW) FROM SalesInfo")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function window16_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = window16(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "idd", { "month", "amount", "SalesMovingAverage" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC emit_rc (OUT result_code INTEGER NOT NULL)
BEGIN
  SET result_code := @RC;
END;
--]]

function emit_rc(_db_)
  local _rc_ = CQL_OK
  local result_code = 0

  result_code = CQL_OK
  _rc_ = CQL_OK

  return _rc_, result_code
end

-- The statement ending at line XXXX

--[[
CREATE PROC rc_test ()
BEGIN
  LET err := @RC;
  LET e0 := @RC;
  BEGIN TRY
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      SET err := @RC;
      LET e1 := @RC;
      BEGIN TRY
        LET e2 := @RC;
        CREATE TABLE whatever_anything(
          id INTEGER
        );
      END TRY;
      BEGIN CATCH
        LET e3 := @RC;
        SET err := @RC;
        THROW;
      END CATCH;
      LET e4 := @RC;
    END CATCH;
  END TRY;
  BEGIN CATCH
    LET e5 := @RC;
    CALL printf("Error %d\n", err);
  END CATCH;
  LET e6 := @RC;
END;
--]]

function rc_test(_db_)
  local _rc_ = CQL_OK
  local err = 0
  local e0 = 0
  local e1 = 0
  local e2 = 0
  local e3 = 0
  local e4 = 0
  local e5 = 0
  local e6 = 0

  err = CQL_OK
  e0 = CQL_OK
  -- try

    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_12; end
      goto catch_end_12

    ::catch_start_12:: 
    do
      local _rc_thrown_1 = _rc_
      err = _rc_thrown_1
      e1 = _rc_thrown_1
      -- try

        e2 = _rc_thrown_1
        _rc_ = cql_exec(_db_,
          "CREATE TABLE whatever_anything( id INTEGER )")
        if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_13; end
        goto catch_end_13

      ::catch_start_13:: 
      do
        local _rc_thrown_2 = _rc_
        e3 = _rc_thrown_2
        err = _rc_thrown_2
        _rc_ = cql_best_error(_rc_thrown_2)
        goto catch_start_11
      end

      ::catch_end_13::
      e4 = _rc_thrown_1
    end

    ::catch_end_12::
    goto catch_end_11

  ::catch_start_11:: 
  do
    local _rc_thrown_3 = _rc_
    e5 = _rc_thrown_3
    printf("Error %d\n", err)
  end

  ::catch_end_11::
  e6 = CQL_OK
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC rc_test_lazy1 ()
BEGIN
  BEGIN TRY
    CREATE TABLE whatever_anything(
      id INTEGER
    );
  END TRY;
  BEGIN CATCH
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      THROW;
    END CATCH;
  END CATCH;
END;
--]]

function rc_test_lazy1(_db_)
  local _rc_ = CQL_OK
  -- try

    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( id INTEGER )")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_14; end
    goto catch_end_14

  ::catch_start_14:: 
  do
    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_15; end
      goto catch_end_15

    ::catch_start_15:: 
    do
      local _rc_thrown_2 = _rc_
      _rc_ = cql_best_error(_rc_thrown_2)
      goto cql_cleanup
    end

    ::catch_end_15::
  end

  ::catch_end_14::
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC rc_test_lazy2 ()
BEGIN
  BEGIN TRY
    CREATE TABLE whatever_anything(
      id INTEGER
    );
  END TRY;
  BEGIN CATCH
    BEGIN TRY
      CREATE TABLE whatever_anything(
        id INTEGER
      );
    END TRY;
    BEGIN CATCH
      LET err := @RC;
    END CATCH;
  END CATCH;
END;
--]]

function rc_test_lazy2(_db_)
  local _rc_ = CQL_OK
  local err = 0

  -- try

    _rc_ = cql_exec(_db_,
      "CREATE TABLE whatever_anything( id INTEGER )")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_16; end
    goto catch_end_16

  ::catch_start_16:: 
  do
    -- try

      _rc_ = cql_exec(_db_,
        "CREATE TABLE whatever_anything( id INTEGER )")
      if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto catch_start_17; end
      goto catch_end_17

    ::catch_start_17:: 
    do
      local _rc_thrown_2 = _rc_
      err = _rc_thrown_2
    end

    ::catch_end_17::
  end

  ::catch_end_16::
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC virtual_table_creator ()
BEGIN
  CREATE VIRTUAL TABLE virt_table USING virt_module (ARGUMENTS FOLLOWING) AS (
    id INTEGER,
    t TEXT
  );
END;
--]]

function virtual_table_creator(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE virt_table USING virt_module ( id INTEGER, t TEXT)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_arg_cursor (x INTEGER NOT NULL, OUT y INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_arg_cursor ARGUMENTS;
  FETCH C(x, y) FROM VALUES(1, 1);
  CALL out_arg_cursor(C.x, C.y);
END;
--]]

function out_arg_cursor(x)
  cql_contract_argument_notnull(x, 1)

  local y = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "x", "y" }
  local C_types_ = "II"

  C._has_row_ = true
  C.x = 1
  C.y = 1
  C.y = out_arg_cursor(C.x)

  return y
end

-- The statement ending at line XXXX

--[[
CREATE PROC make_virt_table ()
BEGIN
  CREATE VIRTUAL TABLE v1 USING m1 AS (
    id INTEGER
  );
  CREATE VIRTUAL TABLE v2 USING m2 (x) AS (
    id INTEGER
  );
  CREATE VIRTUAL TABLE v3 USING m2 (ARGUMENTS FOLLOWING) AS (
    id INTEGER
  );
END;
--]]

function make_virt_table(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v1 USING m1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v2 USING m2 (x)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_exec(_db_,
    "CREATE VIRTUAL TABLE v3 USING m2 ( id INTEGER)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC virtual1 ()
BEGIN
  SELECT *
    FROM virtual_with_hidden;
END;
--]]

function virtual1(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vy FROM virtual_with_hidden")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function virtual1_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = virtual1(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Ii", { "vx", "vy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC virtual2 ()
BEGIN
  SELECT vx, vy
    FROM virtual_with_hidden
    WHERE vx = 2;
END;
--]]

function virtual2(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT vx, vy FROM virtual_with_hidden WHERE vx = 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function virtual2_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = virtual2(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Ii", { "vx", "vy" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
CREATE PROC private_proc (OUT x INTEGER)
BEGIN
  SET x := 1;
END;
--]]

function private_proc()
  local x

  x = 1

  return x
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
CREATE PROC private_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
--]]

function private_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC use_private_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL private_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_private_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = private_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:suppress_getters)
CREATE PROC no_getters_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
--]]

function no_getters_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC use_no_getters_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL no_getters_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_no_getters_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = no_getters_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:suppress_result_set)
CREATE PROC suppress_results_out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS a_field;
  FETCH C(a_field) FROM VALUES(1);
  OUT UNION C;
END;
--]]

function suppress_results_out_union_fetch_results()
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C._has_row_ = true
  C.a_field = 1
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end

  return _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC use_suppress_results_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL suppress_results_out_union();
  LOOP FETCH C
  BEGIN
    CALL printf("%d\n", C.a_field);
  END;
END;
--]]

function use_suppress_results_out_union(_db_)
  local _rc_ = CQL_OK
  local C_result_set_ = nil
  local C_row_num_ = 0
  local C_row_count_ = 0
  local C = { _has_row_ = false }
  local C_fields_ = { "a_field" }
  local C_types_ = "I"

  C_result_set_ = suppress_results_out_union_fetch_results()
  C_row_num_ = 0
  C_row_count_ = #(C_result_set_)
  while true
  do
    C_row_num_ = C_row_num_ + 1
    if C_row_num_ <= C_row_count_ then
      C = C_result_set_[C_row_num_]
    else
      C = { _has_row_ = false }
    end
    if not C._has_row_ then break end
    printf("%d\n", C.a_field)
  end
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
CREATE PROC private_result (OUT x INTEGER)
BEGIN
  SELECT 1 AS x;
END;
--]]

function private_result(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local x

  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt, x
end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
DECLARE PROC private_fwd_ref (x INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC set_out_arg_ref_test (OUT x TEXT)
BEGIN
END;
--]]

function set_out_arg_ref_test()
  local x


  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC set_out_arg_null_test (OUT x INTEGER)
BEGIN
END;
--]]

function set_out_arg_null_test()
  local x


  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC set_out_arg_notnull_test (OUT x INTEGER NOT NULL)
BEGIN
END;
--]]

function set_out_arg_notnull_test()
  local x = 0


  return x
end
local global_cursor2 = { _has_row_ = false }
local global_cursor2_fields_ = { "x" }
local global_cursor2_types_ = "S"

-- The statement ending at line XXXX

--[[
CREATE PROC early_close_cursor ()
BEGIN
  CLOSE global_cursor;
  CLOSE global_cursor2;
END;
--]]

function early_close_cursor(_db_)
  local _rc_ = CQL_OK
  cql_finalize_stmt(global_cursor_stmt)
  global_cursor_stmt = nil
  global_cursor = { _has_row_ = false }
  global_cursor2 = { _has_row_ = false }
  _rc_ = CQL_OK

  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC various_lets ()
BEGIN
  LET r := 1.0;
  LET i := 1;
  LET l := 1L;
  LET t := "T";
  LET nl := nullable(~2L);
  LET ni := nullable(2 + 2);
  LET nr := nullable(2.0);
  LET nt := nullable("NT");
  LET sl := sensitive(~3L);
  LET si := sensitive(3 + 3);
  LET sr := sensitive(3.0);
  LET st := sensitive("ST");
END;
--]]

function various_lets()
  local r = 0.0
  local i = 0
  local l = 0
  local t
  local nl
  local ni
  local nr
  local nt
  local sl = 0
  local si = 0
  local sr = 0.0
  local st

  r = 1.0
  i = 1
  l = 1
  t = "T"
  nl = (~2)
  ni = (2 + 2)
  nr = 2.0
  nt = "NT"
  sl = (~3)
  si = (3 + 3)
  sr = 3.0
  st = "ST"

end

-- The statement ending at line XXXX

--[[
CREATE PROC try_catch_rc ()
BEGIN
  DECLARE C CURSOR FOR SELECT 'foo' AS extra2
    FROM bar;
  BEGIN TRY
    FETCH C;
  END TRY;
  BEGIN CATCH
  END CATCH;
END;
--]]

function try_catch_rc(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "extra2" }
  local C_types_ = "S"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 'foo' FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- try

    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto catch_start_18; end
    goto catch_end_18

  ::catch_start_18:: 
  do
  end

  ::catch_end_18::
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC out2_proc (x INTEGER, OUT y INTEGER NOT NULL, OUT z INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC out_decl_test (x INTEGER)
BEGIN
  DECLARE OUT CALL out2_proc(x, u, v);
  DECLARE OUT CALL out2_proc(x, u, v);
END;
--]]

function out_decl_test(x)
  local u = 0
  local v = 0

  u, v = out2_proc(x)
  u, v = out2_proc(x)

end

-- The statement ending at line XXXX

--[[
CREATE PROC out_decl_loop_test (x INTEGER)
BEGIN
  WHILE 1
  BEGIN
    DECLARE OUT CALL out2_proc(x, u, v);
    DECLARE OUT CALL out2_proc(x, u, v);
  END;
END;
--]]

function out_decl_loop_test(x)
  local u = 0
  local v = 0

  while true
  do
  if not(true) then break end
    u, v = out2_proc(x)
    u, v = out2_proc(x)
  end

end

-- The statement ending at line XXXX

--[[
CREATE PROC binary_ops_with_null ()
BEGIN
  LET add0 := NULL + 42;
  LET add1 := 42 + NULL;
  LET bin_and0 := NULL & 42;
  LET bin_and1 := 42 & NULL;
  LET bin_or0 := NULL | 42;
  LET bin_or1 := 42 | NULL;
  LET div0 := NULL / 42;
  LET div1 := 42 / NULL;
  LET ge0 := NULL >= 42;
  LET ge1 := 42 >= NULL;
  LET gt0 := NULL > 42;
  LET gt1 := 42 > NULL;
  LET le0 := NULL <= 42;
  LET le1 := 42 <= NULL;
  LET like0 := NULL LIKE "foo";
  LET like1 := "foo" LIKE NULL;
  LET lshift0 := NULL << 42;
  LET lshift1 := 42 << NULL;
  LET lt0 := NULL < 42;
  LET lt1 := 42 < NULL;
  LET mod0 := NULL % 42;
  LET mod1 := 42 % NULL;
  LET mul0 := NULL * 42;
  LET mul1 := 42 * NULL;
  LET not_like0 := NULL NOT LIKE "foo";
  LET not_like1 := "foo" NOT LIKE NULL;
  LET rshift0 := NULL >> 42;
  LET rshift1 := 42 >> NULL;
  LET sub0 := NULL - 42;
  LET sub1 := 42 - NULL;
END;
--]]

function binary_ops_with_null()
  local add0
  local add1
  local bin_and0
  local bin_and1
  local bin_or0
  local bin_or1
  local div0
  local div1
  local ge0
  local ge1
  local gt0
  local gt1
  local le0
  local le1
  local like0
  local like1
  local lshift0
  local lshift1
  local lt0
  local lt1
  local mod0
  local mod1
  local mul0
  local mul1
  local not_like0
  local not_like1
  local rshift0
  local rshift1
  local sub0
  local sub1

  add0 = nil
  add1 = nil
  bin_and0 = nil
  bin_and1 = nil
  bin_or0 = nil
  bin_or1 = nil
  div0 = nil
  div1 = nil
  ge0 = nil
  ge1 = nil
  gt0 = nil
  gt1 = nil
  le0 = nil
  le1 = nil
  like0 = nil
  like1 = nil
  lshift0 = nil
  lshift1 = nil
  lt0 = nil
  lt1 = nil
  mod0 = nil
  mod1 = nil
  mul0 = nil
  mul1 = nil
  not_like0 = nil
  not_like1 = nil
  rshift0 = nil
  rshift1 = nil
  sub0 = nil
  sub1 = nil

end

-- The statement ending at line XXXX

--[[
CREATE PROC uses_throw ()
BEGIN
  THROW;
END;
--]]

function uses_throw(_db_)
  local _rc_ = CQL_OK
  _rc_ = cql_best_error(CQL_OK)
  goto cql_cleanup
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC uses_ifnull_throw (x INTEGER)
BEGIN
  LET y := ifnull_throw(x);
END;
--]]

function uses_ifnull_throw(_db_, x)
  local _rc_ = CQL_OK
  local y = 0

  if x == nil then
    _rc_ = CQL_ERROR
    goto cql_cleanup
  end
  y = x
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC out_object (o OBJECT NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_object ARGUMENTS;
  FETCH C(o) FROM VALUES(o);
  OUT C;
END;
--]]

function out_object(o)
  cql_contract_argument_notnull(o, 1)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "o" }
  local C_types_ = "O"

  C._has_row_ = true
  C.o = o
  _result_ = cql_clone_row(C)

  return _result_
end

function out_object_fetch_results(o)
  local result_set = nil
  _result_ = out_object(o)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC exercise_contracts (a INTEGER, b INTEGER NOT NULL, c TEXT, d TEXT NOT NULL, e BLOB, f BLOB NOT NULL, g OBJECT, h OBJECT NOT NULL, OUT i INTEGER, OUT j INTEGER NOT NULL, OUT k TEXT, OUT l TEXT NOT NULL, INOUT m INTEGER, INOUT n INTEGER NOT NULL, INOUT o TEXT, INOUT p TEXT NOT NULL)
BEGIN
  SET l := "text";
END;
--]]

function exercise_contracts(a, b, c, d, e, f, g, h, m, n, o, p)
  cql_contract_argument_notnull(b, 2)
  cql_contract_argument_notnull(d, 4)
  cql_contract_argument_notnull(f, 6)
  cql_contract_argument_notnull(h, 8)
  cql_contract_argument_notnull(n, 14)
  cql_contract_argument_notnull(p, 16)

  local i
  local j = 0
  local k
  local l

  l = "text"

  return i, j, k, l, m, n, o, p
end

-- The statement ending at line XXXX

--[[
CREATE PROC public_proc_with_a_contract (t TEXT NOT NULL)
BEGIN
END;
--]]

function public_proc_with_a_contract(t)
  cql_contract_argument_notnull(t, 1)


end

-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
CREATE PROC private_proc_without_a_contract (t TEXT NOT NULL)
BEGIN
END;
--]]

function private_proc_without_a_contract(t)

end

-- The statement ending at line XXXX

--[[
CREATE PROC result_set_proc_with_contract_in_fetch_results (t TEXT NOT NULL)
BEGIN
  SELECT *
    FROM bar;
END;
--]]

function result_set_proc_with_contract_in_fetch_results(_db_, t)
  cql_contract_argument_notnull(t, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function result_set_proc_with_contract_in_fetch_results_fetch_results(_db_, t)
  local result_set = nil
  local _rc_
  _rc_, stmt = result_set_proc_with_contract_in_fetch_results(_db_, t)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC out_proc_with_contract_in_fetch_results (t TEXT NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE bar;
  OUT C;
END;
--]]

function out_proc_with_contract_in_fetch_results(t)
  cql_contract_argument_notnull(t, 1)

  local _result_ = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name", "rate", "type", "size" }
  local C_types_ = "Islid"

  _result_ = cql_clone_row(C)

  return _result_
end

function out_proc_with_contract_in_fetch_results_fetch_results(t)
  local result_set = nil
  _result_ = out_proc_with_contract_in_fetch_results(t)
  result_set = { _result_ }

::cql_cleanup::
  return result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC nullability_improvements_are_erased_for_sql ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    SELECT a + 1 AS b;
  END IF;
END;
--]]

function nullability_improvements_are_erased_for_sql(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local a

  if a ~= nil then
    _rc_, _result_stmt = cql_prepare(_db_, 
      "SELECT ? + 1")
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _rc_ = cql_multibind(_db_, _result_stmt, "i", {a})
    if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function nullability_improvements_are_erased_for_sql_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = nullability_improvements_are_erased_for_sql(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "b" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC nullability_improvements_do_not_change_access ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    LET b := a;
    SET a := 0;
  END IF;
END;
--]]

function nullability_improvements_do_not_change_access()
  local a
  local b = 0

  if a ~= nil then
    b = a
    a = 0
  end

end
local true_test = false
local false_test = false

-- The statement ending at line XXXX

--[[
CREATE PROC BigFormat ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM big_data;
  LOOP FETCH C
  BEGIN
    LET s := cql_cursor_format(C);
  END;
END;
--]]

function BigFormat(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23", "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31", "f32", "f33", "f34", "f35", "f36", "f38", "f39", "f40", "f41", "f42", "f43", "f44", "f45", "f46", "f47", "f48", "f49", "f50", "f51", "f52", "f53", "f54", "f55", "f56", "f57", "f58", "f59", "f60", "f61", "f62", "f63", "f64", "f65", "f66", "f67", "f68", "f69", "f70", "f71", "f72", "f73", "f74", "f75" }
  local C_types_ = "LIsSsslLLLLsFlfIIsisisiLsFFFsssilissLlfFsslFlIslsslIsLLssisilliLIIisdliili"
  local s

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28, f29, f30, f31, f32, f33, f34, f35, f36, f38, f39, f40, f41, f42, f43, f44, f45, f46, f47, f48, f49, f50, f51, f52, f53, f54, f55, f56, f57, f58, f59, f60, f61, f62, f63, f64, f65, f66, f67, f68, f69, f70, f71, f72, f73, f74, f75 FROM big_data")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  while true
  do
    -- step and fetch
    _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
    if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    if not C._has_row_ then break end
    s = cql_cursor_format(C, C_types_, C_fields_)
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end
local sign_val_int = 0
local sign_val_nullable
local abs_val_int = 0
local abs_val_nullable
local abs_val_long = 0
local abs_val_real = 0.0
local abs_val_bool = false

-- The statement ending at line XXXX

--[[
CREATE PROC ltor_proc_int_not_null (a INTEGER NOT NULL, b INTEGER NOT NULL, OUT c INTEGER NOT NULL)
BEGIN
END;
--]]

function ltor_proc_int_not_null(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local c = 0


  return c
end

-- The statement ending at line XXXX

--[[
CREATE PROC ltor_proc_int (a INTEGER, b INTEGER, OUT c INTEGER)
BEGIN
END;
--]]

function ltor_proc_int(a, b)
  local c


  return c
end

-- The statement ending at line XXXX

--[[
CREATE PROC ltor_proc_text_not_null (a TEXT NOT NULL, b TEXT NOT NULL, OUT c TEXT NOT NULL)
BEGIN
  SET c := "text";
END;
--]]

function ltor_proc_text_not_null(a, b)
  cql_contract_argument_notnull(a, 1)
  cql_contract_argument_notnull(b, 2)

  local c

  c = "text"

  return c
end

-- The statement ending at line XXXX

--[[
CREATE PROC ltor_proc_text (a TEXT, b TEXT, OUT c TEXT)
BEGIN
END;
--]]

function ltor_proc_text(a, b)
  local c


  return c
end

-- The statement ending at line XXXX

--[[
CREATE PROC arguments_are_evaluated_left_to_right ()
BEGIN
  LET a := ltor_proc_int_not_null(ltor_proc_int_not_null(1, 2), ltor_proc_int_not_null(3, 4));
  LET b := ltor_proc_int(ltor_proc_int(1, 2), ltor_proc_int(3, 4));
  LET c := ltor_proc_text_not_null(ltor_proc_text_not_null("1", "2"), ltor_proc_text_not_null("3", "4"));
  LET d := ltor_proc_text(ltor_proc_text("1", "2"), ltor_proc_text("3", "4"));
  LET e := ltor_func_int_not_null(ltor_func_int_not_null(1, 2), ltor_func_int_not_null(3, 4));
  LET f := ltor_func_int(ltor_func_int(1, 2), ltor_func_int(3, 4));
  LET g := ltor_func_text_not_null(ltor_func_text_not_null("1", "2"), ltor_func_text_not_null("3", "4"));
  LET h := ltor_func_text(ltor_func_text("1", "2"), ltor_func_text("3", "4"));
END;
--]]

function arguments_are_evaluated_left_to_right()
  local _tmp_int_1 = 0
  local _tmp_int_2 = 0
  local a = 0
  local _tmp_n_int_1
  local _tmp_n_int_2
  local b
  local _tmp_text_1
  local _tmp_text_2
  local c
  local _tmp_n_text_1
  local _tmp_n_text_2
  local d
  local e = 0
  local f
  local g
  local h

  _tmp_int_1 = ltor_proc_int_not_null(1, 2)
  _tmp_int_2 = ltor_proc_int_not_null(3, 4)
  a = ltor_proc_int_not_null(_tmp_int_1, _tmp_int_2)
  _tmp_n_int_1 = ltor_proc_int(1, 2)
  _tmp_n_int_2 = ltor_proc_int(3, 4)
  b = ltor_proc_int(_tmp_n_int_1, _tmp_n_int_2)
  _tmp_text_1 = ltor_proc_text_not_null("1", "2")
  _tmp_text_2 = ltor_proc_text_not_null("3", "4")
  c = ltor_proc_text_not_null(_tmp_text_1, _tmp_text_2)
  _tmp_n_text_1 = ltor_proc_text("1", "2")
  _tmp_n_text_2 = ltor_proc_text("3", "4")
  d = ltor_proc_text(_tmp_n_text_1, _tmp_n_text_2)
  _tmp_int_1 = ltor_func_int_not_null(1, 2)
  _tmp_int_2 = ltor_func_int_not_null(3, 4)
  e = ltor_func_int_not_null(_tmp_int_1, _tmp_int_2)
  _tmp_n_int_1 = ltor_func_int(1, 2)
  _tmp_n_int_2 = ltor_func_int(3, 4)
  f = ltor_func_int(_tmp_n_int_1, _tmp_n_int_2)
  _tmp_text_1 = ltor_func_text_not_null("1", "2")
  _tmp_text_2 = ltor_func_text_not_null("3", "4")
  g = ltor_func_text_not_null(_tmp_text_1, _tmp_text_2)
  _tmp_n_text_1 = ltor_func_text("1", "2")
  _tmp_n_text_2 = ltor_func_text("3", "4")
  h = ltor_func_text(_tmp_n_text_1, _tmp_n_text_2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC f1 (OUT x INTEGER NOT NULL)
BEGIN
  SET x := 5;
END;
--]]

function f1()
  local x = 0

  x = 5

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC f2 (OUT x INTEGER)
BEGIN
  SET x := 5;
END;
--]]

function f2()
  local x

  x = 5

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC f3 (y INTEGER, OUT x INTEGER)
BEGIN
  SET x := y;
END;
--]]

function f3(y)
  local x

  x = y

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC multi_call_temp_reuse ()
BEGIN
  LET q := f1() + f1() + f1();
  LET r := f2() + f2() + f2();
  LET s := f3(0) + f3(1) + f3(2);
END;
--]]

function multi_call_temp_reuse()
  local _tmp_int_0 = 0
  local _tmp_int_1 = 0
  local _tmp_int_2 = 0
  local q = 0
  local _tmp_n_int_0
  local _tmp_n_int_1
  local _tmp_n_int_2
  local r
  local s

  _tmp_int_0 = f1()
  _tmp_int_1 = f1()
  _tmp_int_2 = f1()
  q = _tmp_int_0 + _tmp_int_1 + _tmp_int_2
  _tmp_n_int_0 = f2()
  _tmp_n_int_1 = f2()
  _tmp_n_int_2 = f2()
  r = cql_add(cql_add(_tmp_n_int_0, _tmp_n_int_1), _tmp_n_int_2)
  _tmp_n_int_0 = f3(0)
  _tmp_n_int_1 = f3(1)
  _tmp_n_int_2 = f3(2)
  s = cql_add(cql_add(_tmp_n_int_0, _tmp_n_int_1), _tmp_n_int_2)

end

-- The statement ending at line XXXX

--[[
CREATE PROC sensitive_function_is_a_no_op ()
BEGIN
  LET x := sensitive("hello");
  SELECT sensitive("hello") AS y;
END;
--]]

function sensitive_function_is_a_no_op(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local x

  x = "hello"
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 'hello'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function sensitive_function_is_a_no_op_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = sensitive_function_is_a_no_op(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "S", { "y" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC and_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT)
BEGIN
  IF a > b AND (a < c OR c IS NULL) THEN
    SET c := a;
  END IF;
END;
--]]

function and_preserves_temps(a, b, c)
  if cql_shortcircuit_and(cql_gt(a, b), function() return cql_shortcircuit_or(cql_lt(a, c), function() return c == nil end) end) then
    c = a
  end

end

-- The statement ending at line XXXX

--[[
CREATE PROC or_preserves_temps (a LONG_INT, b LONG_INT, c LONG_INT)
BEGIN
  IF c < 0 OR a > c AND b > c THEN
    SET c := a;
  END IF;
END;
--]]

function or_preserves_temps(a, b, c)
  if cql_shortcircuit_or(cql_lt(c, 0), function() return cql_shortcircuit_and(cql_gt(a, c), function() return cql_gt(b, c) end) end) then
    c = a
  end

end

-- The statement ending at line XXXX

--[[
CREATE PROC foo ()
BEGIN
  WITH
  shared_frag (shared_something) AS (CALL shared_frag())
  SELECT *
    FROM shared_frag;
END;
--]]

function foo(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    3, nil,
    {
    "WITH shared_frag (shared_something) AS (",
    "SELECT 1234",
    ") SELECT shared_something FROM shared_frag"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function foo_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = foo(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "shared_something" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC shared_conditional_user (x INTEGER NOT NULL)
BEGIN
  WITH
  some_cte (id) AS (SELECT x),
  shared_conditional (x) AS (CALL shared_conditional(1))
  SELECT bar.*
    FROM bar
    INNER JOIN some_cte ON x = 5;
END;
--]]

function shared_conditional_user(_db_, x)
  cql_contract_argument_notnull(x, 1)

  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x_ = 0
  local _preds_1  -- 5 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x_ = 1
  _preds_1[0] = true
  _vpreds_1[0] = true -- pred 0 known to be true
  if _p1_x_ == 1 then
    _preds_1[1] = true
    _vpreds_1[1] = true -- pred 1 known to be true
  else
    if _p1_x_ == 2 then
      _preds_1[2] = true
      _vpreds_1[2] = true -- pred 2 known to be true
      _vpreds_1[3] = true -- pred 2 known to be true
    else
      _preds_1[3] = true
      _vpreds_1[4] = true -- pred 3 known to be true
      _vpreds_1[5] = true -- pred 3 known to be true
      _vpreds_1[6] = true -- pred 3 known to be true
    end
  end
  _preds_1[4] = true
  _vpreds_1[7] = true -- pred 0 known to be true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    5, _preds_1,
    {
    "WITH some_cte (id) AS (SELECT ?), shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar INNER JOIN some_cte ON ? = 5"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", {x, _p1_x_, _p1_x_, _p1_x_, _p1_x_, _p1_x_, _p1_x_, x})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function shared_conditional_user_fetch_results(_db_, x)
  local result_set = nil
  local _rc_
  _rc_, stmt = shared_conditional_user(_db_, x)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "Islid", { "id", "name", "rate", "type", "size" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC nested_shared_stuff ()
BEGIN
  WITH
  nested_shared_proc (x) AS (CALL nested_shared_proc(1))
  SELECT *
    FROM nested_shared_proc;
END;
--]]

function nested_shared_stuff(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x__ = 0
  local _p2_x_ = 0
  local _preds_1  -- 8 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x__ = 1
  _preds_1[0] = true
  if _p1_x__ <= 5 then
    _preds_1[1] = true
    _p2_x_ = 1
    if _p2_x_ == 1 then
      _preds_1[2] = true
      _vpreds_1[0] = true -- pred 2 known to be true
    else
      if _p2_x_ == 2 then
        _preds_1[3] = true
        _vpreds_1[1] = true -- pred 3 known to be true
        _vpreds_1[2] = true -- pred 3 known to be true
      else
        _preds_1[4] = true
        _vpreds_1[3] = true -- pred 4 known to be true
        _vpreds_1[4] = true -- pred 4 known to be true
        _vpreds_1[5] = true -- pred 4 known to be true
      end
    end
    _preds_1[5] = _preds_1[1]
    _vpreds_1[6] = _preds_1[1]
  else
    _preds_1[6] = true
    _vpreds_1[7] = true -- pred 6 known to be true
  end
  _preds_1[7] = true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    8, _preds_1,
    {
    "WITH nested_shared_proc (x) AS (",
    "WITH shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT x FROM shared_conditional WHERE ? = 5",
    "SELECT ?",
    ") SELECT x FROM nested_shared_proc"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", {_p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p1_x__, _p1_x__})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function nested_shared_stuff_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = nested_shared_stuff(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
CREATE PROC use_nested_select_shared_frag_form ()
BEGIN
  SELECT *
    FROM (CALL nested_shared_proc(1));
END;
--]]

function use_nested_select_shared_frag_form(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  local _p1_x__ = 0
  local _p2_x_ = 0
  local _preds_1  -- 10 possible fragments
  local _vpreds_1 -- 8 possible bindings

  _preds_1 = {}
  _vpreds_1 = {}
  _p1_x__ = 1
  _preds_1[0] = true
  _preds_1[1] = true
  if _p1_x__ <= 5 then
    _preds_1[2] = true
    _p2_x_ = 1
    if _p2_x_ == 1 then
      _preds_1[3] = true
      _vpreds_1[0] = true -- pred 3 known to be true
    else
      if _p2_x_ == 2 then
        _preds_1[4] = true
        _vpreds_1[1] = true -- pred 4 known to be true
        _vpreds_1[2] = true -- pred 4 known to be true
      else
        _preds_1[5] = true
        _vpreds_1[3] = true -- pred 5 known to be true
        _vpreds_1[4] = true -- pred 5 known to be true
        _vpreds_1[5] = true -- pred 5 known to be true
      end
    end
    _preds_1[6] = _preds_1[2]
    _vpreds_1[6] = _preds_1[2]
  else
    _preds_1[7] = true
    _vpreds_1[7] = true -- pred 7 known to be true
  end
  _preds_1[8] = true
  _preds_1[9] = true
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    10, _preds_1,
    {
    "SELECT x FROM (",
    "WITH _ns_(x) AS (",
    "WITH shared_conditional (x) AS (",
    "SELECT ?",
    "SELECT ? + ?",
    "SELECT ? + ? + ?",
    ") SELECT x FROM shared_conditional WHERE ? = 5",
    "SELECT ?",
    ") SELECT * FROM _ns_",
    ")"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind_var(_db_, _result_stmt, 8, _vpreds_1, "IIIIIIII", {_p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p2_x_, _p1_x__, _p1_x__})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function use_nested_select_shared_frag_form_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = use_nested_select_shared_frag_form(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "I", { "x" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:private)
CREATE PROC simple_shared_frag ()
BEGIN
  SELECT *
    FROM (CALL shared_frag());
END;
--]]

function simple_shared_frag(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare_var(_db_, 
    5, nil,
    {
    "SELECT shared_something FROM (",
    "WITH _ns_(shared_something) AS (",
    "SELECT 1234",
    ") SELECT * FROM _ns_",
    ")"
    }
  )
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

-- The statement ending at line XXXX

--[[
CREATE PROC slash_star_and_star_slash ()
BEGIN
  LET x := "/*  */";
END;
--]]

function slash_star_and_star_slash()
  local x

  x = "/*  */"

end

-- The statement ending at line XXXX

--[[
CREATE PROC blob_serialization_test ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 'foo' AS name;
  FETCH C;
  DECLARE B BLOB<structured_storage>;
  SET B FROM CURSOR C;
  DECLARE D CURSOR LIKE C;
  FETCH D FROM BLOB B;
END;
--]]

function blob_serialization_test(_db_)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name" }
  local C_types_ = "IS"
  local B
  local D = { _has_row_ = false }
  local D_fields_ = { "id", "name" }
  local D_types_ = "IS"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 1, 'foo'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, B = cql_serialize_to_blob(C);
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, D = cql_deserialize_from_blob(B)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC deserialize_func ()
BEGIN
  DECLARE C CURSOR LIKE structured_storage;
  FETCH C FROM BLOB make_blob();
END;
--]]

function deserialize_func(_db_)
  local _rc_ = CQL_OK
  local C = { _has_row_ = false }
  local C_fields_ = { "id", "name" }
  local C_types_ = "IS"
  local _tmp_n_blob_0

  _tmp_n_blob_0 = make_blob()
  _rc_, C = cql_deserialize_from_blob(_tmp_n_blob_0)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC bigstuff ()
BEGIN
  LET big1 := 0x7fffffffffffffffL;
  LET big2 := 0x8000000000000000L;
  LET big3 := -9223372036854775808L;
  LET big4 := -9223372036854775808L;
  LET big5 := 9223372036854775807L;
  LET big6 := 9223372036854775807L;
END;
--]]

function bigstuff()
  local big1 = 0
  local big2 = 0
  local big3 = 0
  local big4 = 0
  local big5 = 0
  local big6 = 0

  big1 = 0x7fffffffffffffff
  big2 = 0x8000000000000000
  big3 = (-9223372036854775807 - 1)
  big4 = (-9223372036854775807 - 1)
  big5 = 9223372036854775807
  big6 = 9223372036854775807

end

-- The statement ending at line XXXX

--[[
CREATE PROC use_gr_cursor_for_serialization (OUT b BLOB<structured_storage>)
BEGIN
  SET b FROM CURSOR gr_blob_cursor;
END;
--]]

function use_gr_cursor_for_serialization(_db_)
  local _rc_ = CQL_OK
  local b

  _rc_, b = cql_serialize_to_blob(gr_blob_cursor);
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, b
end

-- The statement ending at line XXXX

--[[
CREATE PROC mutated_in_param_ref (x TEXT)
BEGIN
  SET x := 'hi';
END;
--]]

function mutated_in_param_ref(x)
  x = "hi"

end

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_proc () OUT (x INTEGER) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_proc () OUT (x INTEGER) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC some_redeclared_out_proc ()
BEGIN
  DECLARE c CURSOR FOR SELECT nullable(1) AS x;
  FETCH c;
  OUT c;
END;
--]]

function some_redeclared_out_proc(_db_)
  local _rc_ = CQL_OK
  local _result_ = nil
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "i"

  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _result_ = cql_clone_row(c)
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_, _result_
end

function some_redeclared_out_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, _result_ = some_redeclared_out_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
result_set = { _result_ }

::cql_cleanup::
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_union_proc () OUT UNION (x INTEGER) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
DECLARE PROC some_redeclared_out_union_proc () OUT UNION (x INTEGER) USING TRANSACTION;
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC some_redeclared_out_union_proc ()
BEGIN
  DECLARE c CURSOR FOR SELECT nullable(1) AS x;
  FETCH c;
  OUT UNION c;
END;
--]]

function some_redeclared_out_union_proc_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local c_stmt = nil
  local c = { _has_row_ = false }
  local c_fields_ = { "x" }
  local c_types_ = "i"

  _rc_, c_stmt = cql_prepare(_db_, 
    "SELECT 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(c_stmt, c, c_types_, c_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if c._has_row_ then
    table.insert(_rows_, cql_clone_row(c))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(c_stmt)
  c_stmt = nil
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
CREATE PROC external_cursor_caller ()
BEGIN
  DECLARE shape_storage CURSOR LIKE SELECT 1 AS x;
  LET result := external_cursor_func(shape_storage);
END;
--]]

function external_cursor_caller()
  local shape_storage = { _has_row_ = false }
  local shape_storage_fields_ = { "x" }
  local shape_storage_types_ = "I"
  local result

  result = external_cursor_func(shape_storage, shape_storage_types_, shape_storage_fields_)

end

-- The statement ending at line XXXX

--[[
CREATE PROC clobber1 (INOUT x TEXT)
BEGIN
  SET x := "xyzzy";
END;
--]]

function clobber1(x)
  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC clobber2 (OUT x TEXT)
BEGIN
  SET x := "xyzzy";
END;
--]]

function clobber2()
  local x

  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC mutated_in_arg1 (x TEXT)
BEGIN
  CALL clobber1(x);
END;
--]]

function mutated_in_arg1(x)
  x = clobber1(x)

end

-- The statement ending at line XXXX

--[[
CREATE PROC mutated_in_arg2 (x TEXT)
BEGIN
  CALL clobber2(x);
END;
--]]

function mutated_in_arg2(x)
  x = clobber2()

end

-- The statement ending at line XXXX

--[[
CREATE PROC mutated_in_arg3 (x TEXT)
BEGIN
  DECLARE C CURSOR FOR SELECT "x" AS x;
  FETCH C INTO x;
END;
--]]

function mutated_in_arg3(_db_, x)
  local _rc_ = CQL_OK
  local C_stmt = nil
  local C = { _has_row_ = false }
  local C_fields_ = { "x" }
  local C_types_ = "S"

  _rc_, C_stmt = cql_prepare(_db_, 
    "SELECT 'x'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  -- step and fetch
  _rc_ = cql_multifetch(C_stmt, C, C_types_, C_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  x = C.x
  _rc_ = CQL_OK

::cql_cleanup::
  cql_finalize_stmt(C_stmt)
  C_stmt = nil
  return _rc_
end

-- The statement ending at line XXXX

--[[
CREATE PROC mutated_not_null (INOUT x TEXT NOT NULL)
BEGIN
  SET x := 'xyzzy';
END;
--]]

function mutated_not_null(x)
  cql_contract_argument_notnull(x, 1)

  x = "xyzzy"

  return x
end

-- The statement ending at line XXXX

--[[
CREATE PROC simple_child_proc ()
BEGIN
  SELECT 1 AS x, 2 AS y;
END;
--]]

function simple_child_proc(_db_)
  local _rc_ = CQL_OK
  local _result_stmt = nil
  _rc_, _result_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = CQL_OK

::cql_cleanup::
  if _rc_ == CQL_OK and _result_stmt == nil then _rc_, _result_stmt = cql_no_rows_stmt(_db_) end
  return _rc_, _result_stmt
end

function simple_child_proc_fetch_results(_db_)
  local result_set = nil
  local _rc_
  _rc_, stmt = simple_child_proc(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, result_set = cql_fetch_all_rows(stmt, "II", { "x", "y" })

::cql_cleanup::
  cql_finalize_stmt(stmt)
  stmt = nil
  return _rc_, result_set
end


-- The statement ending at line XXXX

--[[
@ATTRIBUTE(cql:emit_setters)
CREATE PROC simple_container_proc ()
BEGIN
  DECLARE C CURSOR LIKE (a INTEGER, b INTEGER NOT NULL, c OBJECT<simple_child_proc SET>);
  FETCH C(a, b, c) FROM VALUES(1, 2, simple_child_proc());
  OUT UNION C;
END;
--]]

function simple_container_proc_fetch_results(_db_)
  local _rc_ = CQL_OK
  local _rows_ = {}
  local C = { _has_row_ = false }
  local C_fields_ = { "a", "b", "c" }
  local C_types_ = "iIo"
  local _tmp_object_0

  C._has_row_ = true
  C.a = 1
  C.b = 2
  _rc_, _tmp_object_0 = simple_child_proc_fetch_results(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  C.c = _tmp_object_0
  if C._has_row_ then
    table.insert(_rows_, cql_clone_row(C))
  end
  _rc_ = CQL_OK

::cql_cleanup::
  return _rc_, _rows_
end

-- The statement ending at line XXXX

--[[
DECLARE PROC num_arg (x INTEGER NOT NULL);
--]]

-- The statement ending at line XXXX

--[[
CREATE PROC call_num_with_bool ()
BEGIN
  CALL num_arg(TRUE);
END;
--]]

function call_num_with_bool()
  num_arg(1)

end

-- The statement ending at line XXXX

--[[
CREATE PROC big_switch_label (x LONG_INT NOT NULL)
BEGIN
  SWITCH x
    WHEN -9223372036854775808L THEN
      LET y := 0;
    WHEN 9223372036854775807L THEN
      LET z := 1;
  END;
END;
--]]

function big_switch_label(x)
  cql_contract_argument_notnull(x, 1)

  local _tmp_int64_0 = 0
  local y = 0
  local z = 0

  _tmp_int64_0 = x
  repeat
    if _tmp_int64_0 == (-9223372036854775807 - 1) then
      y = 0
      break
    end

    if _tmp_int64_0 == 9223372036854775807 then
      z = 1
      break
    end
  until true

end
local this_is_the_end = 0

-- The statement ending at line XXXX

--[[
CREATE PROC end_proc ()
BEGIN
END;
--]]

function end_proc()

end

-- The statement ending at line XXXX

--[[
DECLARE end_marker INTEGER;
--]]
local end_marker

function cql_startup(_db_)
  local _rc_ = CQL_OK
  local _tmp_int_0 = 0
  local _tmp_n_int_1
  local _tmp_int_1 = 0
  local _tmp_n_int_2
  local _tmp_bool_0 = false
  local _tmp_n_bool_0
  local _tmp_text_0
  local _tmp_n_object_1
  local _tmp_object_1
  local _tmp_n_object_0
  local _tmp_n_blob_1
  local _tmp_blob_1
  local _tmp_blob_0
  local _tmp_n_blob_0
  local _tmp_n_int_0
  local _tmp_n_text_1
  local _tmp_int64_0 = 0

  -- The statement ending at line XXXX

  --[[
  SET t2 := "text";
  --]]
  t2 = "text"

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1;
  --]]
  i2 = 1

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := 88;
  --]]
  i1_nullable = 88

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := NULL;
  --]]
  i1_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable;
  --]]
  i0_nullable = i1_nullable

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := NULL;
  --]]
  t0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := t2;
  --]]
  t0_nullable = t2

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := NULL;
  --]]
  t0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i2 := - -1;
  --]]
  i2 = - - 1

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := -i2;
  --]]
  i0_nullable = - i2

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := -NULL;
  --]]
  i0_nullable = cql_unary_uminus(nil)

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := -i0_nullable;
  --]]
  i1_nullable = cql_unary_uminus(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := 2.2;
  --]]
  r0_nullable = 2.2

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := NULL;
  --]]
  r0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET r2 := 3.5;
  --]]
  r2 = 3.5

  -- The statement ending at line XXXX

  --[[
  SET i1_nullable := NOT NOT i0_nullable;
  --]]
  i1_nullable = cql_to_num(cql_unary_not(cql_unary_not(cql_to_bool(i0_nullable))))

  -- The statement ending at line XXXX

  --[[
  SET i2 := NOT NOT b2;
  --]]
  i2 = cql_to_num(not not b2)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 * 3 + 5;
  --]]
  i2 = 1 * 3 + 5

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable;
  --]]
  r0_nullable = cql_mul(r0_nullable, i1_nullable)

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i2;
  --]]
  r0_nullable = cql_mul(r0_nullable, i2)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := 12 * i1_nullable;
  --]]
  i0_nullable = cql_mul(12, i1_nullable)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL * i1_nullable;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i1_nullable;
  --]]
  r0_nullable = cql_add(cql_mul(r0_nullable, i1_nullable), cql_mul(r0_nullable, i1_nullable))

  -- The statement ending at line XXXX

  --[[
  SET r0_nullable := r0_nullable * i1_nullable + r0_nullable * i0_nullable + r0_nullable;
  --]]
  r0_nullable = cql_add(cql_add(cql_mul(r0_nullable, i1_nullable), cql_mul(r0_nullable, i0_nullable)), r0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET t2 := "This is a \" \\ test '' \n \" ";
  --]]
  t2 = "This is a \" \\ test '' \n \" "

  -- The statement ending at line XXXX

  --[[
  CALL printf("Hello, world\n");
  --]]
  printf("Hello, world\n")

  -- The statement ending at line XXXX

  --[[
  SET i2 := r2 AND l2;
  --]]
  i2 = cql_to_num(cql_to_bool(r2) and cql_to_bool(l2))

  -- The statement ending at line XXXX

  --[[
  SET i2 := coalesce(side_effect1(), 7) AND coalesce(side_effect2(), 5);
  --]]
  repeat
    _tmp_n_int_1 = side_effect1()
    if _tmp_n_int_1 ~= nil then
      _tmp_int_0 = _tmp_n_int_1
      break
    end
    _tmp_int_0 = 7
  until true
  i2 = cql_to_num(cql_shortcircuit_and(_tmp_int_0,
  function()
  repeat
    _tmp_n_int_2 = side_effect2()
    if _tmp_n_int_2 ~= nil then
      _tmp_int_1 = _tmp_n_int_2
      break
    end
    _tmp_int_1 = 5
  until true

  return _tmp_int_1
  end
  ))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL AND NULL;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable AND i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(i0_nullable, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL AND i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(nil, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable AND NULL;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_and(i0_nullable, function() return nil end))

  -- The statement ending at line XXXX

  --[[
  SET i2 := r2 OR l2;
  --]]
  i2 = cql_to_num(cql_to_bool(r2) or cql_to_bool(l2))

  -- The statement ending at line XXXX

  --[[
  SET i2 := coalesce(side_effect1(), 7) OR coalesce(side_effect2(), 5);
  --]]
  repeat
    _tmp_n_int_1 = side_effect1()
    if _tmp_n_int_1 ~= nil then
      _tmp_int_0 = _tmp_n_int_1
      break
    end
    _tmp_int_0 = 7
  until true
  i2 = cql_to_num(cql_shortcircuit_or(_tmp_int_0,
  function()
  repeat
    _tmp_n_int_2 = side_effect2()
    if _tmp_n_int_2 ~= nil then
      _tmp_int_1 = _tmp_n_int_2
      break
    end
    _tmp_int_1 = 5
  until true

  return _tmp_int_1
  end
  ))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL OR NULL;
  --]]
  i0_nullable = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable OR i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(i0_nullable, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := NULL OR i1_nullable;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(nil, function() return i1_nullable end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i0_nullable OR NULL;
  --]]
  i0_nullable = cql_to_num(cql_shortcircuit_or(i0_nullable, function() return nil end))

  -- The statement ending at line XXXX

  --[[
  SET i2 := NULL IS NULL;
  --]]
  i2 = cql_to_num(nil == nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := i0_nullable + i1_nullable IS NULL;
  --]]
  i2 = cql_to_num(cql_add(i0_nullable, i1_nullable) == nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := NULL IS NOT NULL;
  --]]
  i2 = cql_to_num(nil ~= nil)

  -- The statement ending at line XXXX

  --[[
  SET i2 := i0_nullable + i1_nullable IS NOT NULL;
  --]]
  i2 = cql_to_num(cql_add(i0_nullable, i1_nullable) ~= nil)

  -- The statement ending at line XXXX

  --[[
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable = i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  --]]
  if true then
    i2 = 1
  else
    if cql_eq(i0_nullable, i1_nullable) then
      i2 = 2
    else
      i2 = 3
    end
  end

  -- The statement ending at line XXXX

  --[[
  IF 1 THEN
    SET i2 := 1;
  ELSE IF i0_nullable OR i1_nullable THEN
    SET i2 := 2;
  ELSE
    SET i2 := 3;
  END IF;
  --]]
  if true then
    i2 = 1
  else
    if cql_shortcircuit_or(i0_nullable, function() return i1_nullable end) then
      i2 = 2
    else
      i2 = 3
    end
  end

  -- The statement ending at line XXXX

  --[[
  SET b2 := BETWEEN REWRITE _between_0_ := 1 CHECK (_between_0_ >= 0 AND _between_0_ <= 3);
  --]]
  _between_0_ = 1
  b2 = _between_0_ >= 0 and _between_0_ <= 3

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := BETWEEN REWRITE _between_1_ := i1_nullable CHECK (_between_1_ >= i0_nullable AND _between_1_ <= r2);
  --]]
  _between_1_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_and(cql_ge(_between_1_, i0_nullable), function() return cql_le(_between_1_, r2) end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := BETWEEN REWRITE _between_2_ := i1_nullable CHECK (_between_2_ >= r2 AND _between_2_ <= i0_nullable);
  --]]
  _between_2_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_and(cql_ge(_between_2_, r2), function() return cql_le(_between_2_, i0_nullable) end))

  -- The statement ending at line XXXX

  --[[
  SET b2 := BETWEEN REWRITE _between_3_ := 1 CHECK (_between_3_ < 0 OR _between_3_ > 3);
  --]]
  _between_3_ = 1
  b2 = _between_3_ < 0 or _between_3_ > 3

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := BETWEEN REWRITE _between_4_ := i1_nullable CHECK (_between_4_ < i0_nullable OR _between_4_ > r2);
  --]]
  _between_4_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_or(cql_lt(_between_4_, i0_nullable), function() return cql_gt(_between_4_, r2) end))

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := BETWEEN REWRITE _between_5_ := i1_nullable CHECK (_between_5_ < r2 OR _between_5_ > i0_nullable);
  --]]
  _between_5_ = i1_nullable
  i0_nullable = cql_to_num(cql_shortcircuit_or(cql_lt(_between_5_, r2), function() return cql_gt(_between_5_, i0_nullable) end))

  -- The statement ending at line XXXX

  --[[
  SET longint_var := (l0_nullable + l1_nullable) * 5;
  --]]
  longint_var = cql_mul(cql_add(l0_nullable, l1_nullable), 5)

  -- The statement ending at line XXXX

  --[[
  DECLARE foo_cursor CURSOR FOR SELECT id, i2
    FROM foo
    WHERE id = i0_nullable;
  --]]
  _rc_, foo_cursor_stmt = cql_prepare(_db_, 
    "SELECT id, ? FROM foo WHERE id = ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, foo_cursor_stmt, "Ii", {i2, i0_nullable})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH foo_cursor INTO i0_nullable, i2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(foo_cursor_stmt, foo_cursor, foo_cursor_types_, foo_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  i0_nullable = foo_cursor.id
  i2 = foo_cursor.i2

  -- The statement ending at line XXXX

  --[[
  DECLARE basic_cursor CURSOR FOR SELECT 1, 2.5;
  --]]
  _rc_, basic_cursor_stmt = cql_prepare(_db_, 
    "SELECT 1, 2.5")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH basic_cursor INTO col1, col2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(basic_cursor_stmt, basic_cursor, basic_cursor_types_, basic_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  col1 = basic_cursor._anon0
  col2 = basic_cursor._anon1

  -- The statement ending at line XXXX

  --[[
  CLOSE basic_cursor;
  --]]
  cql_finalize_stmt(basic_cursor_stmt)
  basic_cursor_stmt = nil
  basic_cursor = { _has_row_ = false }

  -- The statement ending at line XXXX

  --[[
  SET arg1 := 7;
  --]]
  arg1 = 7

  -- The statement ending at line XXXX

  --[[
  SET arg2 := 11;
  --]]
  arg2 = 11

  -- The statement ending at line XXXX

  --[[
  DECLARE exchange_cursor CURSOR FOR SELECT arg2, arg1;
  --]]
  _rc_, exchange_cursor_stmt = cql_prepare(_db_, 
    "SELECT ?, ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, exchange_cursor_stmt, "II", {arg2, arg1})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH exchange_cursor INTO arg1, arg2;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(exchange_cursor_stmt, exchange_cursor, exchange_cursor_types_, exchange_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  arg1 = exchange_cursor.arg2
  arg2 = exchange_cursor.arg1

  -- The statement ending at line XXXX

  --[[
  CLOSE exchange_cursor;
  --]]
  cql_finalize_stmt(exchange_cursor_stmt)
  exchange_cursor_stmt = nil
  exchange_cursor = { _has_row_ = false }

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT i2 + 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ? + 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "I", {i2})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    i2 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT i0_nullable + 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ? + 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "i", {i0_nullable})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    i0_nullable = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  DELETE FROM bar WHERE name LIKE '\\ " \n';
  --]]
  _rc_ = cql_exec(_db_,
    "DELETE FROM bar WHERE name LIKE '\\\\ \" \\n'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE WHEN 1 THEN 100
  WHEN 2 THEN 200
  WHEN NULL THEN 500
  ELSE 300
  END;
  --]]
  repeat
    if true then
      i2 = 100
      break
    end
    if cql_to_bool(2) then
      i2 = 200
      break
    end
    i2 = 300
  until true

  -- The statement ending at line XXXX

  --[[
  SET i2 := 3 IN (1, 2, NULL, 4);
  --]]
  repeat
    _tmp_int_1 = 3
    _tmp_bool_0 = true
    if _tmp_int_1 == 1 then break end
    if _tmp_int_1 == 2 then break end
    if _tmp_int_1 == 4 then break end
    _tmp_bool_0 = false
  until true
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable IN (1, 2, NULL, b0_nullable);
  --]]
  repeat
    _tmp_n_int_1 = i1_nullable
    if _tmp_n_int_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if _tmp_n_int_1 == 1 then break end
    if _tmp_n_int_1 == 2 then break end
    if _tmp_n_int_1 == cql_to_num(b0_nullable) then break end
    _tmp_n_bool_0 = false
  until true
  i0_nullable = cql_to_num(_tmp_n_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 3 NOT IN (1, 2, NULL, 4);
  --]]
  repeat
    _tmp_int_1 = 3
    _tmp_bool_0 = false
    if _tmp_int_1 == 1 then break end
    if _tmp_int_1 == 2 then break end
    if _tmp_int_1 == 4 then break end
    _tmp_bool_0 = true
  until true
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := i1_nullable NOT IN (1, 2, NULL, b0_nullable);
  --]]
  repeat
    _tmp_n_int_1 = i1_nullable
    if _tmp_n_int_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if _tmp_n_int_1 == 1 then break end
    if _tmp_n_int_1 == 2 then break end
    if _tmp_n_int_1 == cql_to_num(b0_nullable) then break end
    _tmp_n_bool_0 = true
  until true
  i0_nullable = cql_to_num(_tmp_n_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET b2 := BETWEEN REWRITE _between_6_ := 'b' CHECK (_between_6_ >= 'a' AND _between_6_ <= 'c');
  --]]
  _between_6_ = "b"
  b2 = _between_6_ >= "a" and _between_6_ <= "c"

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_7_ := 'b' CHECK (_between_7_ >= 'a' AND _between_7_ <= t0_nullable);
  --]]
  _between_7_ = "b"
  b0_nullable = cql_shortcircuit_and(_between_7_ >= "a", function() return cql_le(_between_7_, t0_nullable) end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_8_ := 'b' CHECK (_between_8_ >= t0_nullable AND _between_8_ <= 'c');
  --]]
  _between_8_ = "b"
  b0_nullable = cql_shortcircuit_and(cql_ge(_between_8_, t0_nullable), function() return _between_8_ <= "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_9_ := 'b' CHECK (_between_9_ >= NULL AND _between_9_ <= 'c');
  --]]
  _between_9_ = "b"
  b0_nullable = cql_shortcircuit_and(nil, function() return _between_9_ <= "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b2 := BETWEEN REWRITE _between_10_ := 'b' CHECK (_between_10_ < 'a' OR _between_10_ > 'c');
  --]]
  _between_10_ = "b"
  b2 = _between_10_ < "a" or _between_10_ > "c"

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_11_ := 'b' CHECK (_between_11_ < 'a' OR _between_11_ > t0_nullable);
  --]]
  _between_11_ = "b"
  b0_nullable = cql_shortcircuit_or(_between_11_ < "a", function() return cql_gt(_between_11_, t0_nullable) end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_12_ := 'b' CHECK (_between_12_ < t0_nullable OR _between_12_ > 'c');
  --]]
  _between_12_ = "b"
  b0_nullable = cql_shortcircuit_or(cql_lt(_between_12_, t0_nullable), function() return _between_12_ > "c" end)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := BETWEEN REWRITE _between_13_ := 'b' CHECK (_between_13_ < NULL OR _between_13_ > 'c');
  --]]
  _between_13_ = "b"
  b0_nullable = cql_shortcircuit_or(nil, function() return _between_13_ > "c" end)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull(i0_nullable, 3);
  --]]
  repeat
    if i0_nullable ~= nil then
      i2 = i0_nullable
      break
    end
    i2 = 3
  until true

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ifnull(i0_nullable, i1_nullable);
  --]]
  repeat
    if i0_nullable ~= nil then
        break
    end
    i0_nullable = i1_nullable
  until true

  -- The statement ending at line XXXX

  --[[
  CALL copy_int(i0_nullable, i1_nullable);
  --]]
  i1_nullable = copy_int(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%d and %d', 1, 2);
  --]]
  s = cql_printf("%d and %d", 1, 2)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%d and %d', 3, 4);
  --]]
  s = cql_printf("%d and %d", 3, 4)

  -- The statement ending at line XXXX

  --[[
  SET s := printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', CAST(4 AS LONG_INT), CAST(nullable(5) AS LONG_INT), CAST(TRUE AS LONG_INT), 0L, CAST(FALSE AS INTEGER), 0, 6L, 7, 0.0, 0.0, NULL, CAST(8 AS REAL));
  --]]
  s = cql_printf("%lld %lld %lld %llu %d %d %llu %d %f %f %s %f", cql_to_integer(4), cql_to_integer(5), cql_to_integer(true), 0, cql_to_integer(false), 0, 6, 7, 0.0, 0.0, nil, cql_to_float(8))

  -- The statement ending at line XXXX

  --[[
  SET s := ( SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, nullable(5), TRUE, NULL, FALSE, NULL, 6L, 7, 0.0, NULL, NULL, 8) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT printf('%lld %lld %lld %llu %d %d %llu %d %f %f %s %f', 5, 5, 1, NULL, 0, NULL, 6, 7, 0.0, NULL, NULL, 8)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    s = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET S := 'x';
  --]]
  s = "x"

  -- The statement ending at line XXXX

  --[[
  LET result := simple_func(2);
  --]]
  result = simple_func(2)

  -- The statement ending at line XXXX

  --[[
  SET result := simple_func(simple_func(1));
  --]]
  _tmp_n_int_1 = simple_func(1)
  result = simple_func(_tmp_n_int_1)

  -- The statement ending at line XXXX

  --[[
  SET text_result := text_func(123, 456);
  --]]
  _tmp_text_0 = text_func(123, 456)
  text_result = _tmp_text_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var := NULL;
  --]]
  obj_var = nil

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := obj_notnull_func();
  --]]
  obj_var2 = obj_notnull_func()

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_var2;
  --]]
  obj_var = obj_var2

  -- The statement ending at line XXXX

  --[[
  SET obj_var := NULL;
  --]]
  obj_var = nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var = obj_var;
  --]]
  b0_nullable = cql_eq(obj_var, obj_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var IN (obj_var, obj_var);
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if _tmp_n_object_1 == obj_var then break end
    if _tmp_n_object_1 == obj_var then break end
    _tmp_n_bool_0 = false
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := obj_var2 IN (obj_var2, obj_var2);
  --]]
  repeat
    _tmp_object_1 = obj_var2
    _tmp_bool_0 = true
    if _tmp_object_1 == obj_var2 then break end
    if _tmp_object_1 == obj_var2 then break end
    _tmp_bool_0 = false
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := obj_var NOT IN (obj_var, obj_var);
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if _tmp_n_object_1 == obj_var then break end
    if _tmp_n_object_1 == obj_var then break end
    _tmp_n_bool_0 = true
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := obj_var2 NOT IN (obj_var2, obj_var2);
  --]]
  repeat
    _tmp_object_1 = obj_var2
    _tmp_bool_0 = false
    if _tmp_object_1 == obj_var2 then break end
    if _tmp_object_1 == obj_var2 then break end
    _tmp_bool_0 = true
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE obj_var WHEN obj_var THEN 1
  ELSE 2
  END;
  --]]
  repeat
    _tmp_n_object_1 = obj_var
    if _tmp_n_object_1 == nil then goto case_else_1 end
    if _tmp_n_object_1 == obj_var then
      i2 = 1
      break
    end
    ::case_else_1::
    i2 = 2
  until true

  -- The statement ending at line XXXX

  --[[
  SET obj_var := CASE 1 WHEN 1 THEN obj_var2
  ELSE NULL
  END;
  --]]
  repeat
    _tmp_int_1 = 1
    if _tmp_int_1 == 1 then
      obj_var = obj_var2
      break
    end
    obj_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_func();
  --]]
  obj_var = obj_func()

  -- The statement ending at line XXXX

  --[[
  SET obj_var := obj_func_create();
  --]]
  obj_var = obj_func_create()

  -- The statement ending at line XXXX

  --[[
  SET text_result := text_func_create();
  --]]
  text_result = text_func_create()

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_crash(obj_func());
  --]]
  _tmp_n_object_0 = obj_func()
  cql_invariant(_tmp_n_object_0 ~= nil)
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_throw(obj_func());
  --]]
  _tmp_n_object_0 = obj_func()
  if _tmp_n_object_0 == nil then
    _rc_ = CQL_ERROR
    goto cql_cleanup
  end
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET obj_var2 := ifnull_crash(obj_func_create());
  --]]
  _tmp_n_object_0 = obj_func_create()
  cql_invariant(_tmp_n_object_0 ~= nil)
  obj_var2 = _tmp_n_object_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull_crash(i0_nullable);
  --]]
  cql_invariant(i0_nullable ~= nil)
  i2 = i0_nullable

  -- The statement ending at line XXXX

  --[[
  SET i2 := ifnull_throw(i0_nullable);
  --]]
  if i0_nullable == nil then
    _rc_ = CQL_ERROR
    goto cql_cleanup
  end
  i2 = i0_nullable

  -- The statement ending at line XXXX

  --[[
  INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT OR REPLACE INTO bar(id, type) VALUES(1, 5)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO foo DEFAULT VALUES;
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO foo DEFAULT VALUES")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET b2 := ( SELECT EXISTS (SELECT *
    FROM bar) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT EXISTS (SELECT * FROM bar)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    b2 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  DECLARE expanded_select CURSOR FOR SELECT *
    FROM bar;
  --]]
  _rc_, expanded_select_stmt = cql_prepare(_db_, 
    "SELECT id, name, rate, type, size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  DECLARE table_expanded_select CURSOR FOR SELECT bar.*
    FROM bar;
  --]]
  _rc_, table_expanded_select_stmt = cql_prepare(_db_, 
    "SELECT bar.id, bar.name, bar.rate, bar.type, bar.size FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET l2 := 3147483647L;
  --]]
  l2 = 3147483647

  -- The statement ending at line XXXX

  --[[
  SET l2 := 3147483647L;
  --]]
  l2 = 3147483647

  -- The statement ending at line XXXX

  --[[
  SET blob_var2 := blob_notnull_func();
  --]]
  blob_var2 = blob_notnull_func()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := NULL;
  --]]
  blob_var = nil

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_var2;
  --]]
  blob_var = blob_var2

  -- The statement ending at line XXXX

  --[[
  SET blob_var := NULL;
  --]]
  blob_var = nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var = blob_var;
  --]]
  b0_nullable = cql_blob_eq(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS NULL;
  --]]
  b0_nullable = blob_var == nil

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var <> blob_var;
  --]]
  b0_nullable = cql_blob_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var <> blob_var;
  --]]
  b0_nullable = cql_blob_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS blob_var;
  --]]
  b0_nullable = cql_blob_is_eq(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IS NOT blob_var;
  --]]
  b0_nullable = cql_blob_is_ne(blob_var, blob_var)

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var IN (blob_var, blob_var);
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = true
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    _tmp_n_bool_0 = false
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := blob_var2 IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_blob_1 = blob_var2
    _tmp_bool_0 = true
    if cql_blob_eq(_tmp_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_blob_1, blob_var2) then break end
    _tmp_bool_0 = false
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b0_nullable := blob_var NOT IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then
      _tmp_n_bool_0 = nil
      break
    end
    _tmp_n_bool_0 = false
    if cql_blob_eq(_tmp_n_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_n_blob_1, blob_var2) then break end
    _tmp_n_bool_0 = true
  until true
  b0_nullable = _tmp_n_bool_0

  -- The statement ending at line XXXX

  --[[
  SET b2 := blob_var2 NOT IN (blob_var, blob_var2);
  --]]
  repeat
    _tmp_blob_1 = blob_var2
    _tmp_bool_0 = false
    if cql_blob_eq(_tmp_blob_1, blob_var) then break end
    if cql_blob_eq(_tmp_blob_1, blob_var2) then break end
    _tmp_bool_0 = true
  until true
  b2 = _tmp_bool_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := CASE blob_var WHEN blob_var THEN 1
  ELSE 2
  END;
  --]]
  repeat
    _tmp_n_blob_1 = blob_var
    if _tmp_n_blob_1 == nil then goto case_else_2 end
    if _tmp_n_blob_1 == blob_var then
      i2 = 1
      break
    end
    ::case_else_2::
    i2 = 2
  until true

  -- The statement ending at line XXXX

  --[[
  SET blob_var := CASE 1 WHEN 1 THEN blob_var2
  ELSE NULL
  END;
  --]]
  repeat
    _tmp_int_1 = 1
    if _tmp_int_1 == 1 then
      blob_var = blob_var2
      break
    end
    blob_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_func();
  --]]
  blob_var = blob_func()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := blob_func_create();
  --]]
  blob_var = blob_func_create()

  -- The statement ending at line XXXX

  --[[
  SET blob_var := ( SELECT b_nullable
    FROM blob_table
    WHERE blob_id = 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT b_nullable FROM blob_table WHERE blob_id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    blob_var = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET blob_var := ( SELECT b_notnull
    FROM blob_table
    WHERE blob_id = 1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT b_notnull FROM blob_table WHERE blob_id = 1")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_blob_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  blob_var = _tmp_blob_0

  -- The statement ending at line XXXX

  --[[
  SET blob_var_notnull := blob_notnull_func();
  --]]
  blob_var_notnull = blob_notnull_func()

  -- The statement ending at line XXXX

  --[[
  INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, blob_var, blob_var_notnull);
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "INSERT INTO blob_table(blob_id, b_nullable, b_notnull) VALUES(0, ?, ?)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "bB", {blob_var, blob_var_notnull})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET obj_var := CASE WHEN 1 THEN obj_var
  END;
  --]]
  repeat
    if true then
      break
    end
    obj_var = nil
  until true

  -- The statement ending at line XXXX

  --[[
  SET i2 := outparm_test();
  --]]
  _rc_, i2 = outparm_test(_db_)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := compute(compute(1));
  --]]
  _tmp_int_1 = compute(1)
  i2 = compute(_tmp_int_1)

  -- The statement ending at line XXXX

  --[[
  SET i2 := dml_compute(dml_compute(1));
  --]]
  _rc_, _tmp_int_1 = dml_compute(_db_, 1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_, i2 = dml_compute(_db_, _tmp_int_1)
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  WITH
  x (a) AS (SELECT 111)
  INSERT INTO foo(id) VALUES(ifnull(( SELECT a
    FROM x ), 0));
  --]]
  _rc_ = cql_exec(_db_,
    "WITH x (a) AS (SELECT 111) INSERT INTO foo(id) VALUES(ifnull(( SELECT a FROM x ), 0))")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET r2 := ( SELECT SqlUserFunc(123) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT SqlUserFunc(123)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    r2 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  DECLARE global_cursor CURSOR FOR SELECT 1 AS a, 2 AS b;
  --]]
  _rc_, global_cursor_stmt = cql_prepare(_db_, 
    "SELECT 1, 2")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  FETCH global_cursor;
  --]]
  -- step and fetch
  _rc_ = cql_multifetch(global_cursor_stmt, global_cursor, global_cursor_types_, global_cursor_fields_)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i2 := 'x' LIKE 'y';
  --]]
  i2 = cql_to_num(cql_like("x", "y"))

  -- The statement ending at line XXXX

  --[[
  SET i2 := 'x' NOT LIKE 'y';
  --]]
  i2 = cql_to_num(cql_not_like("x", "y"))

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' LIKE 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' LIKE 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' NOT LIKE 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' NOT LIKE 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' MATCH 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' MATCH 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT 'x' GLOB 'y' );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT 'x' GLOB 'y'")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_bool_0 = cql_to_bool(cql_get_value(_temp_stmt, 0))
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i2 = cql_to_num(_tmp_bool_0)

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | 1 << 4 & 1 >> 8;
  --]]
  i2 = ((1 << 2 | 1) << 4 & 1) >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | (1 << 4) & (1 >> 8);
  --]]
  i2 = (1 << 2 | 1 << 4) & 1 >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 << 2 | (1 << 4 & (1 >> 8));
  --]]
  i2 = 1 << 2 | 1 << 4 & 1 >> 8

  -- The statement ending at line XXXX

  --[[
  SET i2 := 1 | ~i2;
  --]]
  i2 = 1 | ~ i2

  -- The statement ending at line XXXX

  --[[
  WITH
  some_cte (id) AS (SELECT 1 AS id)
  INSERT INTO bar(id) VALUES(ifnull(( SELECT id
    FROM some_cte ), 0)) @DUMMY_SEED(1337);
  --]]
  _seed_ = 1337
  _rc_ = cql_exec(_db_,
    "WITH some_cte (id) AS (SELECT 1 AS id) INSERT INTO bar(id) VALUES(ifnull(( SELECT id FROM some_cte ), 0))")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO bar(id) VALUES(1) @DUMMY_SEED(1338)
  ON CONFLICT (id) DO UPDATE
  SET id = 10;
  --]]
  _seed_ = 1338
  _rc_ = cql_exec(_db_,
    "INSERT INTO bar(id) VALUES(1) ON CONFLICT (id) DO UPDATE SET id = 10")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET l0_nullable := cql_get_blob_size(( SELECT blob_var ));
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT ?")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_multibind(_db_, _temp_stmt, "b", {blob_var})
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_n_blob_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  l0_nullable = cql_get_blob_size(_tmp_n_blob_0)

  -- The statement ending at line XXXX

  --[[
  SET l2 := cql_get_blob_size(blob_var2);
  --]]
  l2 = cql_get_blob_size(blob_var2)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * (4 / 3);
  --]]
  x = 1 * (4 // 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 / 3;
  --]]
  x = 1 * 2 // 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 / 3;
  --]]
  x = 1 + 2 // 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + (2 - 3);
  --]]
  x = 1 + (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 * 3;
  --]]
  x = 1 + 2 * 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * (2 + 3);
  --]]
  x = 1 * (2 + 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - (2 + 3);
  --]]
  x = 1 - (2 + 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - (2 - 3);
  --]]
  x = 1 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - 2 - (2 - 3);
  --]]
  x = 1 - 2 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 - 2 - (2 - 3);
  --]]
  x = 1 - 2 - (2 - 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / 2 / 3;
  --]]
  x = 1 // 2 // 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / (4 / 3);
  --]]
  x = 1 // (4 // 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 / 2;
  --]]
  x = 1 // 2

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 * (3 * 4);
  --]]
  x = 1 * 2 * (3 * 4)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 * 2 * (3 * 4);
  --]]
  x = 1 * 2 * (3 * 4)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 & 3;
  --]]
  x = (1 | 2) & 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 & 3);
  --]]
  x = 1 | 2 & 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 | 3;
  --]]
  x = 1 | 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 | 3);
  --]]
  x = 1 | (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (3 + 4 | 5);
  --]]
  x = 1 | (3 + 4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 3 + (4 | 5);
  --]]
  x = 1 | 3 + (4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := (1 | 3) + (4 | 5);
  --]]
  x = (1 | 3) + (4 | 5)

  -- The statement ending at line XXXX

  --[[
  SET x := (1 + 2) * 5;
  --]]
  x = (1 + 2) * 5

  -- The statement ending at line XXXX

  --[[
  SET x := 1 + 2 - 1;
  --]]
  x = 1 + 2 - 1

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << 2 | 3;
  --]]
  x = 1 << 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 | 3);
  --]]
  x = 1 << (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 << 3);
  --]]
  x = 1 | 2 << 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 << 3);
  --]]
  x = 1 << (2 << 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 < (2 > 3);
  --]]
  x = cql_to_num(1 < cql_to_num((2 > 3)))

  -- The statement ending at line XXXX

  --[[
  SET x := 1 << (2 >> 3);
  --]]
  x = 1 << (2 >> 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | (2 | 3);
  --]]
  x = 1 | (2 | 3)

  -- The statement ending at line XXXX

  --[[
  SET x := 1 | 2 | 3;
  --]]
  x = 1 | 2 | 3

  -- The statement ending at line XXXX

  --[[
  SET x := 1 = 2 <> 3;
  --]]
  x = cql_to_num(1 == cql_to_num((2 ~= 3)))

  -- The statement ending at line XXXX

  --[[
  INSERT INTO virtual_with_hidden(vy) VALUES(1);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vy) VALUES(1)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  INSERT INTO virtual_with_hidden(vx, vy) VALUES(1, 2);
  --]]
  _rc_ = cql_exec(_db_,
    "INSERT INTO virtual_with_hidden(vx, vy) VALUES(1, 2)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING -1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_int_1 = cql_get_value(_temp_stmt, 0)
    i0_nullable = _tmp_n_int_1
  else
    i0_nullable = - 1
  end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET i0_nullable := ( SELECT type
    FROM bar IF NOTHING THROW );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_n_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  i0_nullable = _tmp_n_int_0

  -- The statement ending at line XXXX

  --[[
  SET i2 := ( SELECT type
    FROM bar IF NOTHING OR NULL -1 );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT type FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_int_1 = cql_get_value(_temp_stmt, 0)
  end
  if _rc_ == CQL_DONE or _tmp_n_int_1 == nil then
    i2 = - 1
  else
    i2 = _tmp_n_int_1
  end
  _rc_ = CQL_OK
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET t0_nullable := ( SELECT name
    FROM bar IF NOTHING "" );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_text_1 = cql_get_value(_temp_stmt, 0)
    t0_nullable = _tmp_n_text_1
  else
    t0_nullable = ""
  end
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SET t2 := ( SELECT name
    FROM bar IF NOTHING OR NULL "garbonzo" );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT name FROM bar")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW and _rc_ ~= CQL_DONE then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  if _rc_ == CQL_ROW then
    _tmp_n_text_1 = cql_get_value(_temp_stmt, 0)
  end
  if _rc_ == CQL_DONE or _tmp_n_text_1 == nil then
    t2 = "garbonzo"
  else
    t2 = _tmp_n_text_1
  end
  _rc_ = CQL_OK
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
    ELSE
      SET i2 := 50;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int_0 == 4 then
      i2 = 40
      break
    end

    if _tmp_int_0 == 5 then
      break
    end

    -- default
      i2 = 50
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4 THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int_0 == 4 then
      i2 = 40
      break
    end
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH l2
    WHEN 1, 3 THEN
      SET i2 := 30;
    WHEN 4L THEN
      SET i2 := 40;
    WHEN 5 THEN NOTHING
  END;
  --]]
  _tmp_int64_0 = l2
  repeat
    if _tmp_int64_0 == 1 or _tmp_int64_0 == 3 then
      i2 = 30
      break
    end

    if _tmp_int64_0 == 4 then
      i2 = 40
      break
    end
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1, 2, 3 THEN NOTHING
    ELSE
      SET i2 := 123;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 or _tmp_int_0 == 2 or _tmp_int_0 == 3 then
      break
    end

    -- default
      i2 = 123
  until true

  -- The statement ending at line XXXX

  --[[
  SWITCH i2
    WHEN 1 THEN
      IF i2 THEN
        LEAVE;
      END IF;
      SET i2 := 999;
    ELSE
      SET i2 := 1;
  END;
  --]]
  _tmp_int_0 = i2
  repeat
    if _tmp_int_0 == 1 then
      if cql_to_bool(i2) then
        break
      end
      i2 = 999
      break
    end

    -- default
      i2 = 1
  until true

  -- The statement ending at line XXXX

  --[[
  LET true_test := 1 IS TRUE;
  --]]
  true_test = (1 ~= 0)

  -- The statement ending at line XXXX

  --[[
  LET false_test := 0 IS FALSE;
  --]]
  false_test = (0 == 0)

  -- The statement ending at line XXXX

  --[[
  SET true_test := i0_nullable IS TRUE;
  --]]
  true_test = cql_is_true(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET false_test := i0_nullable IS FALSE;
  --]]
  false_test = cql_is_false(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET true_test := 1 IS NOT TRUE;
  --]]
  true_test = (1 == 0)

  -- The statement ending at line XXXX

  --[[
  SET false_test := 0 IS NOT FALSE;
  --]]
  false_test = (0 ~= 0)

  -- The statement ending at line XXXX

  --[[
  SET true_test := i0_nullable IS NOT TRUE;
  --]]
  true_test = cql_is_not_true(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  SET false_test := i0_nullable IS NOT FALSE;
  --]]
  false_test = cql_is_not_false(i0_nullable)

  -- The statement ending at line XXXX

  --[[
  LET sign_val_int := sign(-2);
  --]]
  sign_val_int = cql_unary_sign(- 2)

  -- The statement ending at line XXXX

  --[[
  LET sign_val_nullable := sign(nullable(-2));
  --]]
  sign_val_nullable = cql_unary_sign((-2))

  -- The statement ending at line XXXX

  --[[
  LET abs_val_int := abs(-2);
  --]]
  abs_val_int = cql_unary_abs(- 2)

  -- The statement ending at line XXXX

  --[[
  LET abs_val_nullable := abs(nullable(-2));
  --]]
  abs_val_nullable = cql_unary_abs((-2))

  -- The statement ending at line XXXX

  --[[
  LET abs_val_long := abs(-2L);
  --]]
  abs_val_long = cql_unary_abs(- 2)

  -- The statement ending at line XXXX

  --[[
  LET abs_val_real := abs(-2.0);
  --]]
  abs_val_real = cql_unary_abs(- 2.0)

  -- The statement ending at line XXXX

  --[[
  LET abs_val_bool := abs(TRUE);
  --]]
  abs_val_bool = cql_unary_abs(true)

  -- The statement ending at line XXXX

  --[[
  SET abs_val_nullable := abs(NULL);
  --]]
  abs_val_nullable = cql_unary_abs(nil)

  -- The statement ending at line XXXX

  --[[
  SET b2 := ( SELECT likely(1) );
  --]]
  _rc_, _temp_stmt = cql_prepare(_db_, 
    "SELECT likely(1)")
  if _rc_ ~= CQL_OK then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
  _rc_ = cql_step(_temp_stmt)
  if _rc_ ~= CQL_ROW then cql_error_trace(_rc_, _db_); goto cql_cleanup; end
    _tmp_int_0 = cql_get_value(_temp_stmt, 0)
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  b2 = cql_to_bool(_tmp_int_0)

  -- The statement ending at line XXXX

  --[[
  LET this_is_the_end := 0xf00d;
  --]]
  this_is_the_end = 0xf00d

::cql_cleanup::
  cql_finalize_stmt(foo_cursor_stmt)
  foo_cursor_stmt = nil
  cql_finalize_stmt(basic_cursor_stmt)
  basic_cursor_stmt = nil
  cql_finalize_stmt(exchange_cursor_stmt)
  exchange_cursor_stmt = nil
  cql_finalize_stmt(_temp_stmt)
  _temp_stmt = nil
  cql_finalize_stmt(expanded_select_stmt)
  expanded_select_stmt = nil
  cql_finalize_stmt(table_expanded_select_stmt)
  table_expanded_select_stmt = nil
  cql_finalize_stmt(global_cursor_stmt)
  global_cursor_stmt = nil
  return _rc_
end
