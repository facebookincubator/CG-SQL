{stmt_list}: err

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE bar(
  id INTEGER NOT NULL,
  name TEXT @CREATE(2),
  rate LONG_INT @CREATE(2)
);

  {create_table_stmt}: bar: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bar}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text @create(2)
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name name}
      |   | | {type_text}: text
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 2}
      | {col_key_list}
        | {col_def}: rate: longint @create(2)
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name rate}
            | | {type_long}: longint
            | {create_attr}: ok
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER
);

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
)
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE foo(
  id INTEGER
)
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0103: duplicate table/view name 'foo'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}: err
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  id INTEGER
);

Error at test/sem_test.sql:XXXX : in str : CQL0142: duplicate column name 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id: integer
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name id}
            | {type_int}: integer

The statement ending at line XXXX

SELECT ID
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name ID}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id, name
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE rate > 0;

  {select_stmt}: select: { id: integer notnull, name: text }
  | {select_core_list}: select: { id: integer notnull, name: text }
  | | {select_core}: select: { id: integer notnull, name: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
  |     | {select_expr_list}: select: { id: integer notnull, name: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {dot}: id: integer notnull
  |     | |   | {name T1}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: name: text
  |     |     | {name name}: name: text
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool
  |         | | {gt}: bool
  |         |   | {name rate}: rate: longint
  |         |   | {int 0}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM foo,
bar;

  {select_stmt}: select: { name: text }
  | {select_core_list}: select: { name: text }
  | | {select_core}: select: { name: text }
  |   | {select_expr_list_con}: select: { name: text }
  |     | {select_expr_list}: select: { name: text }
  |     | | {select_expr}: name: text
  |     |   | {name name}: name: text
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM foo AS T1,
bar AS T1,
bar AS T1;

Error at test/sem_test.sql:XXXX : in table_or_subquery_list : CQL0016: duplicate table name in join 'T1'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: err
  |       |   | {table_or_subquery}: TABLE { T1: bar }
  |       |   | | {name bar}: TABLE { T1: bar }
  |       |   | | {opt_as_alias}
  |       |   |   | {name T1}
  |       |   | {table_or_subquery_list}: TABLE { T1: bar }
  |       |     | {table_or_subquery}: TABLE { T1: bar }
  |       |       | {name bar}: TABLE { T1: bar }
  |       |       | {opt_as_alias}
  |       |         | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo,
bar;

Error at test/sem_test.sql:XXXX : in str : CQL0065: identifier is ambiguous 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name id}: err
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT not_found
  FROM foo,
bar;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'not_found'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name not_found}: err
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' + 'bar' + 3;

Error at test/sem_test.sql:XXXX : in str : CQL0007: left operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {add}: err
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | | {strlit 'bar'}: text notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' LIKE 'baz';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {like}: bool notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' NOT LIKE 'baz';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_like}: bool notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 LIKE 'baz';

Error at test/sem_test.sql:XXXX : in num : CQL0042: left operand must be a string in 'LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT LIKE 'baz';

Error at test/sem_test.sql:XXXX : in num : CQL0042: left operand must be a string in 'NOT LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_like}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' LIKE 2;

Error at test/sem_test.sql:XXXX : in num : CQL0043: right operand must be a string in 'LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' || 'baz';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' || 1;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1.0 || 'baz';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {dbl 1.0}: real notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 + 2.0;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {add}: real notnull
  |     |     | {int 1}: integer notnull
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 3 + 4;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {int 3}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id + 'foo'
  FROM foo AS T1;

Error at test/sem_test.sql:XXXX : in str : CQL0008: right operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {dot}: id: integer notnull
  |     |     | | {name T1}
  |     |     | | {name id}
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' + T1.id
  FROM foo AS T1;

Error at test/sem_test.sql:XXXX : in str : CQL0007: left operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {dot}: id: integer notnull
  |     |       | {name T1}
  |     |       | {name id}
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {and}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL OR 1;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {or}: bool
  |     |     | {null}: null
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL AND 1;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {and}: bool
  |     |     | {null}: null
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (1 = 2) + 1;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' AND 1;

Error at test/sem_test.sql:XXXX : in str : CQL0007: left operand cannot be a string in 'AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {and}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AND 'foo' OR 1;

Error at test/sem_test.sql:XXXX : in str : CQL0008: right operand cannot be a string in 'AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {or}: err
  |     |     | {and}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' < 1;

Error at test/sem_test.sql:XXXX : in lt : CQL0009: incompatible types in expression '<'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {lt}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 > 'foo';

Error at test/sem_test.sql:XXXX : in gt : CQL0012: incompatible types in expression '>'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {gt}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'baz' <> 'foo';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {ne}: bool notnull
  |     |     | {strlit 'baz'}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 > 'foo' > 2;

Error at test/sem_test.sql:XXXX : in gt : CQL0012: incompatible types in expression '>'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {gt}: err
  |     |     | {gt}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo LIKE 'bar';

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'foo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {name foo}: err
  |     |     | {strlit 'bar'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -1;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {uminus}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -'x';

Error at test/sem_test.sql:XXXX : in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {uminus}: err
  |     |     | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1.2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IS NULL;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is}: bool notnull
  |     |     | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IS 1.2;

Error at test/sem_test.sql:XXXX : in is : CQL0009: incompatible types in expression 'IS'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IS NOT NULL;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is_not}: bool notnull
  |     |     | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -(NOT 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {uminus}: err
  |     |     | {not}: err
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT -'x';

Error at test/sem_test.sql:XXXX : in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {uminus}: err
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -'x' IS NULL;

Error at test/sem_test.sql:XXXX : in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {uminus}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -(NOT 1);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {uminus}: integer notnull
  |     |     | {not}: bool notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -1.2;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {uminus}: real notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 * 2;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mul}: integer notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 3 - 4;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {sub}: integer notnull
  |     |     | {int 3}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 6 / 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {div}: integer notnull
  |     |     | {int 6}: integer notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 6 % 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mod}: integer notnull
  |     |     | {int 6}: integer notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 2 >= 1;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {ge}: bool notnull
  |     |     | {int 2}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 <= 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {le}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 2 = 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {int 2}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo,
bar;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS one, 2 AS two;

  {select_stmt}: select: { one: integer notnull, two: integer notnull }
  | {select_core_list}: select: { one: integer notnull, two: integer notnull }
  | | {select_core}: select: { one: integer notnull, two: integer notnull }
  |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
  |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
  |     | | {select_expr}: one: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name one}
  |     | | {select_expr_list}
  |     |   | {select_expr}: two: integer notnull
  |     |     | {int 2}: integer notnull
  |     |     | {opt_as_alias}
  |     |       | {name two}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *;

Error at test/sem_test.sql:XXXX : in star : CQL0052: select * cannot be used with no FROM clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 10 AS T
  WHERE T = 1;

  {select_stmt}: select: { T: integer notnull }
  | {select_core_list}: select: { T: integer notnull }
  | | {select_core}: select: { T: integer notnull }
  |   | {select_expr_list_con}: select: { T: integer notnull }
  |     | {select_expr_list}: select: { T: integer notnull }
  |     | | {select_expr}: T: integer notnull
  |     |   | {int 10}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name T}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {eq}: bool notnull
  |         |   | {name T}: T: integer notnull
  |         |   | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT c
  WHERE 1;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'c'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name c}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {opt_where}
  |         | | {int 1}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM goo;

Error at test/sem_test.sql:XXXX : in table_or_subquery : CQL0095: table/view not defined 'goo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name goo}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE big(
  l LONG_INT,
  r REAL
);

  {create_table_stmt}: big: { l: longint, r: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name big}
  | {col_key_list}
    | {col_def}: l: longint
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name l}
    |     | {type_long}: longint
    | {col_key_list}
      | {col_def}: r: real
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name r}
            | {type_real}: real

The statement ending at line XXXX

SELECT l
  FROM big;

  {select_stmt}: select: { l: longint }
  | {select_core_list}: select: { l: longint }
  | | {select_core}: select: { l: longint }
  |   | {select_expr_list_con}: select: { l: longint }
  |     | {select_expr_list}: select: { l: longint }
  |     | | {select_expr}: l: longint
  |     |   | {name l}: l: longint
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * 1
  FROM big;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {mul}: longint
  |     |     | {name l}: l: longint
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * (1 = 1)
  FROM big;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {mul}: longint
  |     |     | {name l}: l: longint
  |     |     | {eq}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * 2.0
  FROM big;

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {mul}: real
  |     |     | {name l}: l: longint
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL = 1;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {eq}: bool
  |     |     | {null}: null
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL = 'foo';

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {eq}: bool
  |     |     | {null}: null
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT ('x' = 1);

Error at test/sem_test.sql:XXXX : in eq : CQL0009: incompatible types in expression '='

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {eq}: err
  |     |       | {strlit 'x'}: text notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 = 2 THEN 'foo'
WHEN 3 = 4 THEN 'bar'
END;

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {case_expr}: text
  |     |     | {connector}: text
  |     |       | {case_list}: text notnull
  |     |         | {when}: text notnull
  |     |         | | {eq}: bool notnull
  |     |         | | | {int 1}: integer notnull
  |     |         | | | {int 2}: integer notnull
  |     |         | | {strlit 'foo'}: text notnull
  |     |         | {case_list}: text notnull
  |     |           | {when}: text notnull
  |     |             | {eq}: bool notnull
  |     |             | | {int 3}: integer notnull
  |     |             | | {int 4}: integer notnull
  |     |             | {strlit 'bar'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 = 2 THEN 'foo'
WHEN 3 = 4 THEN 2
END;

Error at test/sem_test.sql:XXXX : in num : CQL0009: incompatible types in expression 'then'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}: err
  |     |       | {case_list}: err
  |     |         | {when}: text notnull
  |     |         | | {eq}: bool notnull
  |     |         | | | {int 1}: integer notnull
  |     |         | | | {int 2}: integer notnull
  |     |         | | {strlit 'foo'}: text notnull
  |     |         | {case_list}: err
  |     |           | {when}
  |     |             | {eq}: bool notnull
  |     |             | | {int 3}: integer notnull
  |     |             | | {int 4}: integer notnull
  |     |             | {int 2}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 'x' THEN 'foo'
END;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'when'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}: err
  |     |       | {case_list}: err
  |     |         | {when}
  |     |           | {strlit 'x'}: err
  |     |           | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 'x' WHEN 'y' THEN 1
WHEN 'z' THEN 2
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {strlit 'x'}: text notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer notnull
  |     |         | {when}: integer notnull
  |     |         | | {strlit 'y'}: text notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {strlit 'z'}: text notnull
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 2 WHEN 1.0 THEN 1
WHEN 3 THEN 2
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {int 2}: integer notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer notnull
  |     |         | {when}: integer notnull
  |     |         | | {dbl 1.0}: real notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {int 3}: integer notnull
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 3 WHEN 'x' THEN 1
END;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'when'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {int 3}: integer notnull
  |     |     | {connector}: err
  |     |       | {case_list}: err
  |     |         | {when}
  |     |           | {strlit 'x'}: err
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 4 WHEN 1 THEN 1
ELSE 2.0
END;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {case_expr}: real notnull
  |     |     | {int 4}: integer notnull
  |     |     | {connector}: real notnull
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 5 WHEN 0 THEN NULL
WHEN 1 THEN 1
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {int 5}: integer notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer
  |     |         | {when}: null
  |     |         | | {int 0}: integer notnull
  |     |         | | {null}: null
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {int 1}: integer notnull
  |     |             | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 6 WHEN 0 THEN 1.0
ELSE 2.0
END;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {case_expr}: real notnull
  |     |     | {int 6}: integer notnull
  |     |     | {connector}: real notnull
  |     |       | {case_list}: real notnull
  |     |       | | {when}: real notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {dbl 1.0}: real notnull
  |     |       | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 7 WHEN 0 THEN 1 = 2
ELSE NULL
END;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {case_expr}: bool
  |     |     | {int 7}: integer notnull
  |     |     | {connector}: bool
  |     |       | {case_list}: bool notnull
  |     |       | | {when}: bool notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {eq}: bool notnull
  |     |       |     | {int 1}: integer notnull
  |     |       |     | {int 2}: integer notnull
  |     |       | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 8 WHEN 0 THEN 1
ELSE 'bar'
END;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'else'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {int 8}: integer notnull
  |     |     | {connector}
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       | {strlit 'bar'}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE NOT 'x' WHEN 1 THEN 0
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {connector}
  |     |       | {case_list}
  |     |         | {when}
  |     |           | {int 1}
  |     |           | {int 0}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 BETWEEN 0 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN 'a' AND 'z';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {strlit 'a'}: text notnull
  |     |       | {strlit 'z'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN 2 AND 3;

Error at test/sem_test.sql:XXXX : in between : CQL0009: incompatible types in expression 'BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN NULL AND 3;

Error at test/sem_test.sql:XXXX : in between : CQL0009: incompatible types in expression 'BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {null}: null
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL BETWEEN 1 AND 2;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {between}: bool
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL BETWEEN 1 AND 'x';

Error at test/sem_test.sql:XXXX : in between : CQL0012: incompatible types in expression 'BETWEEN/AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 'x') BETWEEN 1122 AND 3344;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 1122}: integer notnull
  |     |       | {int 3344}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT BETWEEN 0 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN 'a' AND 'z';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {strlit 'a'}: text notnull
  |     |       | {strlit 'z'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN 2 AND 3;

Error at test/sem_test.sql:XXXX : in not_between : CQL0009: incompatible types in expression 'NOT BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN NULL AND 3;

Error at test/sem_test.sql:XXXX : in not_between : CQL0009: incompatible types in expression 'NOT BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {null}: null
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT BETWEEN 1 AND 2;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_between}: bool
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT BETWEEN 1 AND 'x';

Error at test/sem_test.sql:XXXX : in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN/AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 'x') NOT BETWEEN 1122 AND 3344;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 1122}: integer notnull
  |     |       | {int 3344}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (SELECT 1 AS id, 'x' AS name) AS Item;

  {select_stmt}: select: { id: integer notnull, name: text notnull }
  | {select_core_list}: select: { id: integer notnull, name: text notnull }
  | | {select_core}: select: { id: integer notnull, name: text notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
  |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
  |     | | {star}: select: { id: integer notnull, name: text notnull }
  |     | {select_from_etc}: TABLE { Item: select }
  |       | {table_or_subquery_list}: TABLE { Item: select }
  |       | | {table_or_subquery}: TABLE { Item: select }
  |       |   | {select_stmt}: select: { id: integer notnull, name: text notnull }
  |       |   | | {select_core_list}: select: { id: integer notnull, name: text notnull }
  |       |   | | | {select_core}: select: { id: integer notnull, name: text notnull }
  |       |   | |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
  |       |   | |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
  |       |   | |     | | {select_expr}: id: integer notnull
  |       |   | |     | | | {int 1}: integer notnull
  |       |   | |     | | | {opt_as_alias}
  |       |   | |     | |   | {name id}
  |       |   | |     | | {select_expr_list}
  |       |   | |     |   | {select_expr}: name: text notnull
  |       |   | |     |     | {strlit 'x'}: text notnull
  |       |   | |     |     | {opt_as_alias}
  |       |   | |     |       | {name name}
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name Item}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (SELECT 1 AS id1, 'x' AS name) AS Item
  INNER JOIN (SELECT 1 AS id2, 'b' AS brand) AS ItemBrand ON ItemBrand.id2 = Item.id1;

  {select_stmt}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  | {select_core_list}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  | | {select_core}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |   | {select_expr_list_con}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | {select_expr_list}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | | {star}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | {select_from_etc}: JOIN { Item: select, ItemBrand: select }
  |       | {join_clause}: JOIN { Item: select, ItemBrand: select }
  |       | | {table_or_subquery}: TABLE { Item: select }
  |       | | | {select_stmt}: select: { id1: integer notnull, name: text notnull }
  |       | | | | {select_core_list}: select: { id1: integer notnull, name: text notnull }
  |       | | | | | {select_core}: select: { id1: integer notnull, name: text notnull }
  |       | | | |   | {select_expr_list_con}: select: { id1: integer notnull, name: text notnull }
  |       | | | |     | {select_expr_list}: select: { id1: integer notnull, name: text notnull }
  |       | | | |     | | {select_expr}: id1: integer notnull
  |       | | | |     | | | {int 1}: integer notnull
  |       | | | |     | | | {opt_as_alias}
  |       | | | |     | |   | {name id1}
  |       | | | |     | | {select_expr_list}
  |       | | | |     |   | {select_expr}: name: text notnull
  |       | | | |     |     | {strlit 'x'}: text notnull
  |       | | | |     |     | {opt_as_alias}
  |       | | | |     |       | {name name}
  |       | | | |     | {select_from_etc}: ok
  |       | | | |       | {select_where}
  |       | | | |         | {select_groupby}
  |       | | | |           | {select_having}
  |       | | | | {select_orderby}
  |       | | |   | {select_limit}
  |       | | |     | {select_offset}
  |       | | | {opt_as_alias}
  |       | |   | {name Item}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { Item: select, ItemBrand: select }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { ItemBrand: select }
  |       |       | | {select_stmt}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | | {select_core_list}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | | | {select_core}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |   | {select_expr_list_con}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |     | {select_expr_list}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |     | | {select_expr}: id2: integer notnull
  |       |       | | |     | | | {int 1}: integer notnull
  |       |       | | |     | | | {opt_as_alias}
  |       |       | | |     | |   | {name id2}
  |       |       | | |     | | {select_expr_list}
  |       |       | | |     |   | {select_expr}: brand: text notnull
  |       |       | | |     |     | {strlit 'b'}: text notnull
  |       |       | | |     |     | {opt_as_alias}
  |       |       | | |     |       | {name brand}
  |       |       | | |     | {select_from_etc}: ok
  |       |       | | |       | {select_where}
  |       |       | | |         | {select_groupby}
  |       |       | | |           | {select_having}
  |       |       | | | {select_orderby}
  |       |       | |   | {select_limit}
  |       |       | |     | {select_offset}
  |       |       | | {opt_as_alias}
  |       |       |   | {name ItemBrand}
  |       |       | {join_cond}: JOIN { Item: select, ItemBrand: select }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id2: integer notnull
  |       |           | | {name ItemBrand}
  |       |           | | {name id2}
  |       |           | {dot}: id1: integer notnull
  |       |             | {name Item}
  |       |             | {name id1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 AS unused ) AS result;

  {select_stmt}: select: { result: integer notnull }
  | {select_core_list}: select: { result: integer notnull }
  | | {select_core}: select: { result: integer notnull }
  |   | {select_expr_list_con}: select: { result: integer notnull }
  |     | {select_expr_list}: select: { result: integer notnull }
  |     | | {select_expr}: result: integer notnull
  |     |   | {select_stmt}: unused: integer notnull
  |     |   | | {select_core_list}: select: { unused: integer notnull }
  |     |   | | | {select_core}: select: { unused: integer notnull }
  |     |   | |   | {select_expr_list_con}: select: { unused: integer notnull }
  |     |   | |     | {select_expr_list}: select: { unused: integer notnull }
  |     |   | |     | | {select_expr}: unused: integer notnull
  |     |   | |     |   | {int 1}: integer notnull
  |     |   | |     |   | {opt_as_alias}
  |     |   | |     |     | {name unused}
  |     |   | |     | {select_from_etc}: ok
  |     |   | |       | {select_where}
  |     |   | |         | {select_groupby}
  |     |   | |           | {select_having}
  |     |   | | {select_orderby}
  |     |   |   | {select_limit}
  |     |   |     | {select_offset}
  |     |   | {opt_as_alias}
  |     |     | {name result}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1, 2 );

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0232: nested select expression must return exactly one column

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {select_stmt}: err
  |     |     | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |     | | {select_expr}: integer notnull
  |     |     |     | | | {int 1}: integer notnull
  |     |     |     | | {select_expr_list}
  |     |     |     |   | {select_expr}: integer notnull
  |     |     |     |     | {int 2}: integer notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 * ( SELECT 1 );

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mul}: integer notnull
  |     |     | {int 1}: integer notnull
  |     |     | {select_stmt}: _anon: integer notnull
  |     |       | {select_core_list}: select: { _anon: integer notnull }
  |     |       | | {select_core}: select: { _anon: integer notnull }
  |     |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |       |     | | {select_expr}: integer notnull
  |     |       |     |   | {int 1}: integer notnull
  |     |       |     | {select_from_etc}: ok
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 ) || ( SELECT 2 );

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {select_stmt}: _anon: integer notnull
  |     |     | | {select_core_list}: select: { _anon: integer notnull }
  |     |     | | | {select_core}: select: { _anon: integer notnull }
  |     |     | |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | |     | | {select_expr}: integer notnull
  |     |     | |     |   | {int 1}: integer notnull
  |     |     | |     | {select_from_etc}: ok
  |     |     | |       | {select_where}
  |     |     | |         | {select_groupby}
  |     |     | |           | {select_having}
  |     |     | | {select_orderby}
  |     |     |   | {select_limit}
  |     |     |     | {select_offset}
  |     |     | {select_stmt}: _anon: integer notnull
  |     |       | {select_core_list}: select: { _anon: integer notnull }
  |     |       | | {select_core}: select: { _anon: integer notnull }
  |     |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |       |     | | {select_expr}: integer notnull
  |     |       |     |   | {int 2}: integer notnull
  |     |       |     | {select_from_etc}: ok
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo,
bar);

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: JOIN { foo: foo, bar: bar }
  |       |   | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       |     | {table_or_subquery}: TABLE { foo: foo }
  |       |     | | {name foo}: TABLE { foo: foo }
  |       |     | {table_or_subquery_list}: TABLE { bar: bar }
  |       |       | {table_or_subquery}: TABLE { bar: bar }
  |       |         | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo,
foo);

Error at test/sem_test.sql:XXXX : in table_or_subquery_list : CQL0016: duplicate table name in join 'foo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {table_or_subquery_list}: err
  |       |     | {table_or_subquery}: TABLE { foo: foo }
  |       |     | | {name foo}: TABLE { foo: foo }
  |       |     | {table_or_subquery_list}: TABLE { foo: foo }
  |       |       | {table_or_subquery}: TABLE { foo: foo }
  |       |         | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {dot}: name: text
  |           |       | {name T2}
  |           |       | {name name}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  INNER JOIN bar AS T2 ON 'v'
  WHERE 'w'
  HAVING 'x'
LIMIT 'y';

Error at test/sem_test.sql:XXXX : in on : CQL0015: expected numeric expression 'ON'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {on}: err
  |       |         | {strlit 'v'}: err
  |       | {select_where}
  |         | {opt_where}
  |         | | {strlit 'w'}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_having}
  |               | {strlit 'x'}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {strlit 'y'}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE 'w'
  HAVING 'x'
LIMIT 'y';

Error at test/sem_test.sql:XXXX : in opt_where : CQL0015: expected numeric expression 'WHERE'
Error at test/sem_test.sql:XXXX : in opt_having : CQL0099: HAVING clause requires GROUP BY clause
Error at test/sem_test.sql:XXXX : in opt_having : CQL0015: expected numeric expression 'HAVING'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {strlit 'w'}: err
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_having}: err
  |               | {strlit 'x'}: err
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {strlit 'y'}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
ORDER BY bogus
LIMIT 'y';

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'
Error at test/sem_test.sql:XXXX : in opt_limit : CQL0015: expected numeric expression 'LIMIT'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {groupby_list}: err
    |   | {groupby_item}
    |     | {name bogus}: err
    | {select_limit}
      | {opt_limit}: err
      | | {strlit 'y'}: err
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT NOT 'x' );

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {select_stmt}: err
  |     |     | {select_core_list}: err
  |     |     | | {select_core}: err
  |     |     |   | {select_expr_list_con}: err
  |     |     |     | {select_expr_list}: err
  |     |     |     | | {select_expr}: err
  |     |     |     |   | {not}: err
  |     |     |     |     | {strlit 'x'}: text notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IN (1, 2, NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IN ('x', 2);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}
  |     |         | {int 2}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IN ('x', 1);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0009: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN (1, 2);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {in_pred}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {in_pred}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN (1, 'x');

Error at test/sem_test.sql:XXXX : in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x' IN (1, 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {expr_list}
  |     |       | {int 1}
  |     |       | {expr_list}
  |     |         | {strlit 'x'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT DISTINCT 1 IN (1, NOT 'x', 'y');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_opts}
  |   | | {distinct}
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: err
  |     |         | {not}: err
  |     |         | | {strlit 'x'}: text notnull
  |     |         | {expr_list}
  |     |           | {strlit 'y'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT IN (1, 2, NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_in}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT IN ('x', 2);

Error at test/sem_test.sql:XXXX : in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}
  |     |         | {int 2}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_in}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT IN ('x', 1);

Error at test/sem_test.sql:XXXX : in not_in : CQL0009: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN (1, 2);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_in}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_in}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN (1, 'x');

Error at test/sem_test.sql:XXXX : in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT f1, f2, ViewAlias.f3
  FROM MyView AS ViewAlias;

  {select_stmt}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {select_core_list}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | | {select_core}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |   | {select_expr_list_con}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |     | {select_expr_list}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |     | | {select_expr}: f1: integer notnull
  |     | | | {name f1}: f1: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: f2: integer notnull
  |     |   | | {name f2}: f2: integer notnull
  |     |   | {select_expr_list}
  |     |     | {select_expr}: f3: integer notnull
  |     |       | {dot}: f3: integer notnull
  |     |         | {name ViewAlias}
  |     |         | {name f3}
  |     | {select_from_etc}: TABLE { ViewAlias: MyView }
  |       | {table_or_subquery_list}: TABLE { ViewAlias: MyView }
  |       | | {table_or_subquery}: TABLE { ViewAlias: MyView }
  |       |   | {name MyView}: TABLE { ViewAlias: MyView }
  |       |   | {opt_as_alias}
  |       |     | {name ViewAlias}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS y;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_view_stmt : CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3
Error at test/sem_test.sql:XXXX : in create_view_stmt : CREATE VIEW MyView AS
SELECT 1 AS y
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0103: duplicate table/view name 'MyView'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}: err
      | {select_stmt}: MyView: { y: integer notnull }
        | {select_core_list}: MyView: { y: integer notnull }
        | | {select_core}: MyView: { y: integer notnull }
        |   | {select_expr_list_con}: MyView: { y: integer notnull }
        |     | {select_expr_list}: MyView: { y: integer notnull }
        |     | | {select_expr}: y: integer notnull
        |     |   | {int 1}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name y}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW foo AS
SELECT 2 AS x;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
)
Error at test/sem_test.sql:XXXX : in create_view_stmt : CREATE VIEW foo AS
SELECT 2 AS x
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0103: duplicate table/view name 'foo'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name foo}: err
      | {select_stmt}: foo: { x: integer notnull }
        | {select_core_list}: foo: { x: integer notnull }
        | | {select_core}: foo: { x: integer notnull }
        |   | {select_expr_list_con}: foo: { x: integer notnull }
        |     | {select_expr_list}: foo: { x: integer notnull }
        |     | | {select_expr}: x: integer notnull
        |     |   | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW V AS
SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name V}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM V;

Error at test/sem_test.sql:XXXX : in table_or_subquery : CQL0095: table/view not defined 'V'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name V}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE INDEX index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_4 ON foo (id) @DELETE(1, AMigrateProc);

Error at test/sem_test.sql:XXXX : in create_index_stmt : CQL0321: migration proc not allowed on object 'index_4'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_4}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
      | | {indexed_column}
      |   | {name id}: id: integer notnull
      | {delete_attr}
        | {version_annotation}
          | {int 1}
          | {name AMigrateProc}

The statement ending at line XXXX

CREATE INDEX index_1 ON bar (id);

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_index_stmt : CREATE INDEX index_1 ON foo (id)
Error at test/sem_test.sql:XXXX : in create_index_stmt : CREATE INDEX index_1 ON bar (id)
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0018: duplicate index name 'index_1'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_1}: err
  | | {name bar}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_2 ON doesNotExist (id);

Error at test/sem_test.sql:XXXX : in str : CQL0019: create index table name not found 'doesNotExist'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_2}
  | | {name doesNotExist}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}

The statement ending at line XXXX

CREATE INDEX index_3 ON foo (doesNotExist);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'doesNotExist'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_3}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}: err
        | {indexed_column}
          | {name doesNotExist}: err

The statement ending at line XXXX

CREATE TABLE simple_pk_table(
  id INTEGER NOT NULL,
  PRIMARY KEY (id)
);

  {create_table_stmt}: simple_pk_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_pk_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
        | {name_list}
          | {name id}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER NOT NULL,
  PRIMARY KEY (pk_col_not_exist)
);

Error at test/sem_test.sql:XXXX : in str : CQL0024: table does not have pk column 'pk_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
        | {name_list}
          | {name pk_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER NOT NULL,
  PRIMARY KEY (id),
  PRIMARY KEY (id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0143: more than one primary key in table 'baz'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
      | | {name_list}
      |   | {name id}
      | {col_key_list}
        | {pk_def}
          | {name_list}
            | {name id}

The statement ending at line XXXX

CREATE TABLE simple_ak_table(
  id INTEGER NOT NULL,
  CONSTRAINT ak1 UNIQUE (id)
);

  {create_table_stmt}: simple_ak_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {name_list}
          | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE TABLE simple_ak_table_2(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (a, c),
  UNIQUE (d)
);

  {create_table_stmt}: simple_ak_table_2: { a: integer notnull, b: text, c: real, d: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_2}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: text
            | {col_key_list}
              | {unq_def}
              | | {name_list}
              |   | {name a}: a: integer notnull
              |   | {name_list}
              |     | {name c}: c: real
              | {col_key_list}
                | {unq_def}
                  | {name_list}
                    | {name d}: d: longint

The statement ending at line XXXX

CREATE TABLE simple_ak_table_3(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (b, d)
);

  {create_table_stmt}: simple_ak_table_3: { a: integer notnull, b: text, c: real, d: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_3}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {name_list}
                  | {name b}: b: text
                  | {name_list}
                    | {name d}: d: longint

The statement ending at line XXXX

CREATE TABLE simple_ak_table_4(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  UNIQUE (a, b),
  UNIQUE (a, b, c)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_4}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {unq_def}
          | | {name_list}
          |   | {name a}: a: integer notnull
          |   | {name_list}
          |     | {name b}: b: text
          | {col_key_list}
            | {unq_def}
              | {name_list}
                | {name a}
                | {name_list}
                  | {name b}
                  | {name_list}
                    | {name c}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_5(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (b, a)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_5}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {name_list}
                  | {name b}
                  | {name_list}
                    | {name a}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_6(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (c, d, b, a)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_6}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {name_list}
                  | {name c}
                  | {name_list}
                    | {name d}
                    | {name_list}
                      | {name b}
                      | {name_list}
                        | {name a}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_7(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (a)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_7}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {name_list}
                  | {name a}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (id),
  CONSTRAINT ak1 UNIQUE (id)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0020: duplicate unique key in table 'ak1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
      | | {name ak1}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {col_key_list}
        | {unq_def}
          | {name ak1}
          | {name_list}
            | {name id}

The statement ending at line XXXX

CREATE TABLE baz_2(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  name TEXT,
  UNIQUE (id, name),
  UNIQUE (name, id)
);

Error at test/sem_test.sql:XXXX : in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {unq_def}
        | | {name_list}
        |   | {name id}: id: integer notnull
        |   | {name_list}
        |     | {name name}: name: text
        | {col_key_list}
          | {unq_def}
            | {name_list}
              | {name name}
              | {name_list}
                | {name id}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (ak_col_not_exist)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'ak_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {name_list}: err
          | {name ak_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE baz_3(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  UNIQUE (ak_col_not_exist)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'ak_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_3}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name_list}: err
          | {name ak_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE fk_table(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id)
);

  {create_table_stmt}: fk_table: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}: id: integer notnull
          | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (bogus) REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {name_list}: err
        | | {name bogus}: err
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}
          | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (bogus)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}: err
          |   | {name bogus}: err
          | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES bogus (id)
);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0021: foreign key refers to non-existent table 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name bogus}
          | | {name_list}
          |   | {name id}
          | {int 0}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE
  SELECT 2;
END IF;

  {if_stmt}: integer notnull
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: ok
    | {else}: ok
      | {stmt_list}: ok
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 2}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 'x' THEN
  SELECT 1;
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: err
  | | {strlit 'x'}: text notnull
  | | {stmt_list}
  |   | {select_stmt}
  |     | {select_core_list}
  |     | | {select_core}
  |     |   | {select_expr_list_con}
  |     |     | {select_expr_list}
  |     |     | | {select_expr}
  |     |     |   | {int 1}
  |     |     | {select_from_etc}
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF NOT 'x' THEN
  SELECT 1;
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: err
  | | {not}: err
  | | | {strlit 'x'}: text notnull
  | | {stmt_list}
  |   | {select_stmt}
  |     | {select_core_list}
  |     | | {select_core}
  |     |   | {select_expr_list_con}
  |     |     | {select_expr_list}
  |     |     | | {select_expr}
  |     |     |   | {int 1}
  |     |     | {select_from_etc}
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF 1 THEN
  SELECT NOT 'x';
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: err
  | | {int 1}: integer notnull
  | | {stmt_list}: err
  |   | {select_stmt}: err
  |     | {select_core_list}: err
  |     | | {select_core}: err
  |     |   | {select_expr_list_con}: err
  |     |     | {select_expr_list}: err
  |     |     | | {select_expr}: err
  |     |     |   | {not}: err
  |     |     |     | {strlit 'x'}: text notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE
  SELECT NOT 'x';
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {else}: err
      | {stmt_list}: err
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {not}: err
          |     |     | {strlit 'x'}: text notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF 2 THEN
  SELECT 2;
ELSE
  SELECT 3;
END IF;

  {if_stmt}: integer notnull
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: ok
    | {elseif}: integer notnull
    | | {cond_action}: integer notnull
    |   | {int 2}: integer notnull
    |   | {stmt_list}: ok
    |     | {select_stmt}: select: { _anon: integer notnull }
    |       | {select_core_list}: select: { _anon: integer notnull }
    |       | | {select_core}: select: { _anon: integer notnull }
    |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |       |     | {select_expr_list}: select: { _anon: integer notnull }
    |       |     | | {select_expr}: integer notnull
    |       |     |   | {int 2}: integer notnull
    |       |     | {select_from_etc}: ok
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {else}: ok
      | {stmt_list}: ok
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 3}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF '2' THEN
  SELECT 2;
ELSE
  SELECT 3;
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {elseif}: err
    | | {cond_action}: err
    |   | {strlit '2'}: text notnull
    |   | {stmt_list}
    |     | {select_stmt}
    |       | {select_core_list}
    |       | | {select_core}
    |       |   | {select_expr_list_con}
    |       |     | {select_expr_list}
    |       |     | | {select_expr}
    |       |     |   | {int 2}
    |       |     | {select_from_etc}
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {else}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {select_expr}
          |     |   | {int 3}
          |     | {select_from_etc}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF 2 THEN
  SELECT 2;
ELSE IF 3 THEN
  SELECT 3;
ELSE IF '4' THEN
  SELECT 4;
END IF;

Error at test/sem_test.sql:XXXX : in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {elseif}: err
      | {cond_action}: integer notnull
      | | {int 2}: integer notnull
      | | {stmt_list}: ok
      |   | {select_stmt}: select: { _anon: integer notnull }
      |     | {select_core_list}: select: { _anon: integer notnull }
      |     | | {select_core}: select: { _anon: integer notnull }
      |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     |     | {select_expr_list}: select: { _anon: integer notnull }
      |     |     | | {select_expr}: integer notnull
      |     |     |   | {int 2}: integer notnull
      |     |     | {select_from_etc}: ok
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {elseif}: integer notnull
        | {cond_action}: integer notnull
        | | {int 3}: integer notnull
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { _anon: integer notnull }
        |     | {select_core_list}: select: { _anon: integer notnull }
        |     | | {select_core}: select: { _anon: integer notnull }
        |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     |     | {select_expr_list}: select: { _anon: integer notnull }
        |     |     | | {select_expr}: integer notnull
        |     |     |   | {int 3}: integer notnull
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {elseif}: err
          | {cond_action}: err
            | {strlit '4'}: text notnull
            | {stmt_list}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {select_expr}
                |     |   | {int 4}
                |     | {select_from_etc}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  GROUP BY id, NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |   | | {name id}: id: integer notnull
  |           |   | {groupby_list}
  |           |     | {groupby_item}
  |           |       | {not}: err
  |           |         | {strlit 'x'}: text notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
ORDER BY id, NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {groupby_list}: err
    |   | {groupby_item}
    |   | | {name id}: id: integer notnull
    |   | {groupby_list}
    |     | {groupby_item}
    |       | {not}: err
    |         | {strlit 'x'}: text notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE booly(
  id INTEGER DEFAULT 8675309,
  flag BOOL
);

  {create_table_stmt}: booly: { id: integer has_default, flag: bool }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name booly}
  | {col_key_list}
    | {col_def}: id: integer has_default
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_default}: ok
    |     | {int 8675309}
    | {col_key_list}
      | {col_def}: flag: bool
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name flag}
            | {type_bool}: bool

The statement ending at line XXXX

SELECT DISTINCTROW id, flag
  FROM booly;

  {select_stmt}: select: { id: integer, flag: bool }
  | {select_core_list}: select: { id: integer, flag: bool }
  | | {select_core}: select: { id: integer, flag: bool }
  |   | {select_opts}
  |   | | {distinctrow}
  |   | {select_expr_list_con}: select: { id: integer, flag: bool }
  |     | {select_expr_list}: select: { id: integer, flag: bool }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: flag: bool
  |     |     | {name flag}: flag: bool
  |     | {select_from_etc}: TABLE { booly: booly }
  |       | {table_or_subquery_list}: TABLE { booly: booly }
  |       | | {table_or_subquery}: TABLE { booly: booly }
  |       |   | {name booly}: TABLE { booly: booly }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE X, Y INTEGER;

  {declare_vars_type}: integer
  | {name_list}: X: integer variable
  | | {name X}: X: integer variable
  | | {name_list}: Y: integer variable
  |   | {name Y}: Y: integer variable
  | {type_int}: integer

The statement ending at line XXXX

DECLARE X_not_null INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: X_not_null: integer notnull variable
  | | {name X_not_null}: X_not_null: integer notnull variable
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

DECLARE X INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0197: duplicate variable name in the same scope 'X'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name X}: err
  | {type_int}: integer

The statement ending at line XXXX

DECLARE foo INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0198: global variable hides table/view name 'foo'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name foo}: err
  | {type_int}: integer

The statement ending at line XXXX

SELECT X;

  {select_stmt}: select: { X: integer variable }
  | {select_core_list}: select: { X: integer variable }
  | | {select_core}: select: { X: integer variable }
  |   | {select_expr_list_con}: select: { X: integer variable }
  |     | {select_expr_list}: select: { X: integer variable }
  |     | | {select_expr}: X: integer variable
  |     |   | {name X}: X: integer variable
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT 1 AS one, 2 AS two;

  {declare_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {select_stmt}: select: { one: integer notnull, two: integer notnull }
    | {select_core_list}: select: { one: integer notnull, two: integer notnull }
    | | {select_core}: select: { one: integer notnull, two: integer notnull }
    |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
    |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
    |     | | {select_expr}: one: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name one}
    |     | | {select_expr_list}
    |     |   | {select_expr}: two: integer notnull
    |     |     | {int 2}: integer notnull
    |     |     | {opt_as_alias}
    |     |       | {name two}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT 1;

Error at test/sem_test.sql:XXXX : in declare_cursor : CQL0197: duplicate variable name in the same scope 'my_cursor'

  {declare_cursor}: err
  | {name my_cursor}: err
  | {select_stmt}: select: { _anon: integer notnull }
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {declare_cursor}: err
  | {name my_cursor}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  LEAVE;
END;

  {loop_stmt}: ok
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name_list}
  |   | {name X}: X: integer variable
  |   | {name_list}
  |     | {name Y}: Y: integer variable
  | {stmt_list}: ok
    | {leave_stmt}: ok

The statement ending at line XXXX

WHILE 1
BEGIN
  LEAVE;
  LEAVE;
END;

Error at test/sem_test.sql:XXXX : in leave_stmt : CQL0308: statement should be the last thing in a statement list

  {while_stmt}: err
  | {int 1}: integer notnull
  | {stmt_list}: err
    | {leave_stmt}: err
    | {leave_stmt}: ok

The statement ending at line XXXX

WHILE 1
BEGIN
  CONTINUE;
  LEAVE;
END;

Error at test/sem_test.sql:XXXX : in continue_stmt : CQL0308: statement should be the last thing in a statement list

  {while_stmt}: err
  | {int 1}: integer notnull
  | {stmt_list}: err
    | {continue_stmt}: err
    | {leave_stmt}: ok

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  CONTINUE;
END;

  {loop_stmt}: ok
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name_list}
  |   | {name X}: X: integer variable
  |   | {name_list}
  |     | {name Y}: Y: integer variable
  | {stmt_list}: ok
    | {continue_stmt}: ok

The statement ending at line XXXX

LOOP FETCH X INTO y
BEGIN
  LEAVE;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'X'

  {loop_stmt}: err
  | {fetch_stmt}: err
  | | {name X}: err
  | | {name_list}
  |   | {name y}
  | {stmt_list}
    | {leave_stmt}

The statement ending at line XXXX

LOOP FETCH not_a_variable INTO x
BEGIN
  LEAVE;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_variable'

  {loop_stmt}: err
  | {fetch_stmt}: err
  | | {name not_a_variable}: err
  | | {name_list}
  |   | {name x}
  | {stmt_list}
    | {leave_stmt}

The statement ending at line XXXX

LEAVE;

Error at test/sem_test.sql:XXXX : in leave_stmt : CQL0219: leave must be inside of a 'loop' or 'while' statement

  {leave_stmt}: err

The statement ending at line XXXX

CONTINUE;

Error at test/sem_test.sql:XXXX : in continue_stmt : CQL0218: continue must be inside of a 'loop' or 'while' statement

  {continue_stmt}: err

The statement ending at line XXXX

CREATE PROC return_with_attr ()
BEGIN
  IF 1 THEN
    @ATTRIBUTE(goo)
    RETURN;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name return_with_attr}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 1}: integer notnull
        | | {stmt_list}: ok
        |   | {stmt_and_attr}: ok
        |     | {misc_attrs}: ok
        |     | | {misc_attr}
        |     |   | {name goo}
        |     | {return_stmt}: ok
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC return_no_attr ()
BEGIN
  IF 1 THEN
    RETURN;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name return_no_attr}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 1}: integer notnull
        | | {stmt_list}: ok
        |   | {return_stmt}: ok
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC return_not_last_with_attr ()
BEGIN
  IF 1 THEN
    @ATTRIBUTE(goo)
    RETURN;
    RETURN;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in return_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name return_not_last_with_attr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {stmt_and_attr}: err
        |   | | {misc_attrs}: ok
        |   | | | {misc_attr}
        |   | |   | {name goo}
        |   | | {return_stmt}: err
        |   | {return_stmt}: ok
        | {if_alt}

The statement ending at line XXXX

CREATE PROC return_not_last_no_attr ()
BEGIN
  IF 1 THEN
    RETURN;
    RETURN;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in return_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name return_not_last_no_attr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {return_stmt}: err
        |   | {return_stmt}: ok
        | {if_alt}

The statement ending at line XXXX

RETURN;

Error at test/sem_test.sql:XXXX : in return_stmt : CQL0307: return statement should be in a procedure and not at the top level

  {return_stmt}: err

The statement ending at line XXXX

CREATE PROC return_at_top_level ()
BEGIN
  RETURN;
END;

Error at test/sem_test.sql:XXXX : in return_stmt : CQL0307: return statement should be in a procedure and not at the top level

  {create_proc_stmt}: err
  | {name return_at_top_level}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {return_stmt}: err

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  SELECT NOT 'X';
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {loop_stmt}: err
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | | {name_list}
  |   | {name X}: X: integer variable
  |   | {name_list}
  |     | {name Y}: Y: integer variable
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'X'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

OPEN my_cursor;

  {open_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable

The statement ending at line XXXX

CLOSE my_cursor;

  {close_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable

The statement ending at line XXXX

OPEN X;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'X'

  {open_stmt}: err
  | {name X}: err

The statement ending at line XXXX

CLOSE X;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'X'

  {close_stmt}: err
  | {name X}: err

The statement ending at line XXXX

DELETE FROM foo WHERE id = 33;

  {delete_stmt}: ok
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {opt_where}: bool notnull
    | {eq}: bool notnull
      | {name id}: id: integer notnull
      | {int 33}: integer notnull

The statement ending at line XXXX

DELETE FROM bogus_table;

Error at test/sem_test.sql:XXXX : in str : CQL0151: table in delete statement does not exist 'bogus_table'

  {delete_stmt}: err
  | {name bogus_table}

The statement ending at line XXXX

DELETE FROM MyView;

Error at test/sem_test.sql:XXXX : in str : CQL0152: cannot delete from a view 'MyView'

  {delete_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

DELETE FROM foo WHERE missing_column = 1;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'missing_column'

  {delete_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {opt_where}: err
    | {eq}: err
      | {name missing_column}: err
      | {int 1}: integer notnull

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

REPLACE INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_replace}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR FAIL INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_fail}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR ROLLBACK INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_rollback}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR ABORT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_abort}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo DEFAULT VALUES;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {default_columns_values}

The statement ending at line XXXX

INSERT INTO bar DEFAULT VALUES;

Error at test/sem_test.sql:XXXX : in str : CQL0315: mandatory column with no default value in INSERT INTO name DEFAULT VALUES statement 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {default_columns_values}

The statement ending at line XXXX

INSERT INTO bogus_table VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0160: table in insert statement does not exist 'bogus_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bogus_table}
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO MyView VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0161: cannot insert into a view 'MyView'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(id, 'bazzle', 3);

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        |     | {insert_list}
        |       | {name id}: err
        |       | {insert_list}
        |         | {strlit 'bazzle'}
        |         | {insert_list}
        |           | {int 3}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null }
        | {select_core_list}: values: { column1: null }
        | | {select_core}: values: { column1: null }
        |   | {select_values}
        |   | {values}: values: { column1: null }
        |     | {insert_list}
        |       | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES('string is wrong', 'string', 1);

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: err
        | {select_core_list}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: err
        |       | {strlit 'string is wrong'}: err
        |       | {insert_list}
        |         | {strlit 'string'}: text notnull
        |         | {insert_list}
        |           | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 2, 3);

Error at test/sem_test.sql:XXXX : in num : CQL0009: incompatible types in expression 'name'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: err
        | {select_core_list}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        |     | {insert_list}: err
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {int 2}: err
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL, 2);

Error at test/sem_test.sql:XXXX : in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null, column2: integer notnull }
        | {select_core_list}: values: { column1: null, column2: integer notnull }
        | | {select_core}: values: { column1: null, column2: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: integer notnull }
        |     | {insert_list}
        |       | {null}: null
        |       | {insert_list}
        |         | {int 2}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES();

Error at test/sem_test.sql:XXXX : in values : CQL0336: select statement with VALUES clause requires a non empty list of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(NULL, 'string', 1);

Error at test/sem_test.sql:XXXX : in null : CQL0013: cannot assign/copy possibly null expression to not null target 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: err
        | {select_core_list}: values: { column1: null, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: null, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: err
        |       | {null}: null
        |       | {insert_list}
        |         | {strlit 'string'}: text notnull
        |         | {insert_list}
        |           | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE two_autoincs_is_bad(
  id1 INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  id2 INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL
);

Error at test/sem_test.sql:XXXX : in str : CQL0040: table can only have one autoinc column 'id2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_autoincs_is_bad}
  | {col_key_list}
    | {col_def}: id1: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id1}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_pk}: ok
            | {col_attrs_autoinc}
            | {col_attrs_not_null}

The statement ending at line XXXX

SET X := 1;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {int 1}: integer notnull

The statement ending at line XXXX

SET XX := 1;

Error at test/sem_test.sql:XXXX : in assign : CQL0173: variable not found 'XX'

  {assign}: err
  | {name XX}
  | {int 1}

The statement ending at line XXXX

SET my_cursor := 1;

Error at test/sem_test.sql:XXXX : in assign : CQL0174: cannot set a cursor 'my_cursor'

  {assign}: err
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {int 1}

The statement ending at line XXXX

SET X := 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'X'

  {assign}: err
  | {name X}: err
  | {strlit 'x'}: err

The statement ending at line XXXX

SET X := NULL;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {null}: null

The statement ending at line XXXX

SET X := NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable
  | {not}: err
    | {strlit 'x'}: text notnull

The statement ending at line XXXX

DECLARE fetch_cursor CURSOR FOR SELECT 1, 'foo', NULL;

  {declare_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |     | | {select_expr}: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | {select_expr_list}
    |     |   | {select_expr}: text notnull
    |     |   | | {strlit 'foo'}: text notnull
    |     |   | {select_expr_list}
    |     |     | {select_expr}: null
    |     |       | {null}: null
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE an_int INTEGER;

  {declare_vars_type}: integer
  | {name_list}: an_int: integer variable
  | | {name an_int}: an_int: integer variable
  | {type_int}: integer

The statement ending at line XXXX

DECLARE an_int2 INTEGER;

  {declare_vars_type}: integer
  | {name_list}: an_int2: integer variable
  | | {name an_int2}: an_int2: integer variable
  | {type_int}: integer

The statement ending at line XXXX

DECLARE a_string TEXT;

  {declare_vars_type}: text
  | {name_list}: a_string: text variable
  | | {name a_string}: a_string: text variable
  | {type_text}: text

The statement ending at line XXXX

DECLARE a_string2 TEXT;

  {declare_vars_type}: text
  | {name_list}: a_string2: text variable
  | | {name a_string2}: a_string2: text variable
  | {type_text}: text

The statement ending at line XXXX

DECLARE a_nullable TEXT;

  {declare_vars_type}: text
  | {name_list}: a_nullable: text variable
  | | {name a_nullable}: a_nullable: text variable
  | {type_text}: text

The statement ending at line XXXX

DECLARE an_long LONG_INT;

  {declare_vars_type}: longint
  | {name_list}: an_long: longint variable
  | | {name an_long}: an_long: longint variable
  | {type_long}: longint

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string, a_nullable;

  {fetch_stmt}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name an_int}: an_int: integer variable
    | {name_list}
      | {name a_string}: a_string: text variable
      | {name_list}
        | {name a_nullable}: a_nullable: text variable

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string;

Error at test/sem_test.sql:XXXX : in fetch_stmt : CQL0217: number of variables did not match count of columns in cursor 'fetch_cursor'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name an_int}: an_int: integer variable
    | {name_list}
      | {name a_string}: a_string: text variable

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string, a_nullable, a_string2;

Error at test/sem_test.sql:XXXX : in fetch_stmt : CQL0217: number of variables did not match count of columns in cursor 'fetch_cursor'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name an_int}: an_int: integer variable
    | {name_list}
      | {name a_string}: a_string: text variable
      | {name_list}
        | {name a_nullable}: a_nullable: text variable
        | {name_list}
          | {name a_string2}

The statement ending at line XXXX

FETCH fetch_cursor INTO a_string2, a_string, a_nullable;

Error at test/sem_test.sql:XXXX : in str : CQL0009: incompatible types in expression 'a_string2'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name a_string2}: err
    | {name_list}
      | {name a_string}
      | {name_list}
        | {name a_nullable}

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, an_int2, a_nullable;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'an_int2'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name an_int}: an_int: integer variable
    | {name_list}
      | {name an_int2}: err
      | {name_list}
        | {name a_nullable}

The statement ending at line XXXX

FETCH not_a_cursor INTO i;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_cursor'

  {fetch_stmt}: err
  | {name not_a_cursor}: err
  | {name_list}
    | {name i}

The statement ending at line XXXX

FETCH fetch_cursor INTO non_existent_variable;

Error at test/sem_test.sql:XXXX : in str : CQL0216: FETCH variable not found 'non_existent_variable'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name non_existent_variable}

The statement ending at line XXXX

FETCH fetch_cursor INTO var_id, var_id;

Error at test/sem_test.sql:XXXX : in str : CQL0206: duplicate name in list 'var_id'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable
  | {name_list}
    | {name var_id}
    | {name_list}
      | {name var_id}

The statement ending at line XXXX

CREATE INDEX index_7 ON foo (id, id);

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'id'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_7}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}: err
        | {indexed_column}
        | | {name id}: id: integer notnull
        | {indexed_columns}
          | {indexed_column}
            | {name id}: err

The statement ending at line XXXX

CREATE TABLE bad_table(
  key_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (key_id, key_id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'key_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: key_id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name key_id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {name_list}: err
          | {name key_id}: key_id: integer notnull
          | {name_list}
            | {name key_id}: err

The statement ending at line XXXX

CREATE TABLE bad_table_2(
  key_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  UNIQUE (key_id, key_id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'key_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table_2}
  | {col_key_list}
    | {col_def}: key_id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name key_id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name_list}: err
          | {name key_id}: key_id: integer notnull
          | {name_list}
            | {name key_id}: err

The statement ending at line XXXX

CREATE TABLE bad_table(
  col_id INTEGER,
  FOREIGN KEY (col_id, col_id) REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'col_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: col_id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col_id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {name_list}: err
        | | {name col_id}: col_id: integer
        | | {name_list}
        |   | {name col_id}: err
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}
          | {int 0}

The statement ending at line XXXX

CREATE TABLE ref_target(
  ref_id1 INTEGER,
  ref_id2 INTEGER
);

  {create_table_stmt}: ref_target: { ref_id1: integer, ref_id2: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name ref_target}
  | {col_key_list}
    | {col_def}: ref_id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name ref_id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: ref_id2: integer
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name ref_id2}
            | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE bad_table(
  id1 INTEGER,
  id2 INTEGER,
  FOREIGN KEY (id1, id2) REFERENCES ref_target (ref_id1, ref_id1)
);

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'ref_id1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}
          | {name_list}
          | | {name id1}: id1: integer
          | | {name_list}
          |   | {name id2}: id2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name ref_target}
            | | {name_list}: err
            |   | {name ref_id1}: ref_id1: integer
            |   | {name_list}
            |     | {name ref_id1}: err
            | {int 0}

The statement ending at line XXXX

SET X := my_cursor;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {name my_cursor}: _my_cursor_has_row_: bool notnull variable

The statement ending at line XXXX

UPDATE foo
SET id = 1
  WHERE id = 2;

  {update_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_where}
      | {opt_where}: bool notnull
      | | {eq}: bool notnull
      |   | {name id}: id: integer notnull
      |   | {int 2}: integer notnull
      | {update_orderby}

The statement ending at line XXXX

UPDATE myView
SET id = 1;

Error at test/sem_test.sql:XXXX : in str : CQL0155: cannot update a view 'myView'

  {update_stmt}: err
  | {name myView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name id}
    |   | {int 1}
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 1
  WHERE NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_where}
      | {opt_where}: err
      | | {not}: err
      |   | {strlit 'x'}: text notnull
      | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 1
LIMIT 'x';

Error at test/sem_test.sql:XXXX : in opt_limit : CQL0015: expected numeric expression 'LIMIT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_where}
      | {update_orderby}
        | {opt_limit}: err
          | {strlit 'x'}: err

The statement ending at line XXXX

UPDATE foo
SET id = 1
ORDER BY NOT 'x'
LIMIT 2;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_where}
      | {update_orderby}
        | {opt_orderby}: err
        | | {groupby_list}: err
        |   | {groupby_item}
        |     | {not}: err
        |       | {strlit 'x'}: text notnull
        | {opt_limit}
          | {int 2}

The statement ending at line XXXX

UPDATE foo
SET non_existent_column = 1;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'non_existent_column'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name non_existent_column}: err
    |   | {int 1}
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 'x';

Error at test/sem_test.sql:XXXX : in update_entry : CQL0012: incompatible types in expression 'id'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {strlit 'x'}: text notnull
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET name = 2;

Error at test/sem_test.sql:XXXX : in update_entry : CQL0009: incompatible types in expression 'name'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name name}: name: text
    |   | {int 2}: integer notnull
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET id = NULL;

Error at test/sem_test.sql:XXXX : in update_entry : CQL0013: cannot assign/copy possibly null expression to not null target 'id'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}
    |   | {name id}: id: integer notnull
    |   | {null}: null
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET X = 1;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'X'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name X}: err
    |   | {int 1}
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET rate = NULL;

  {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: rate: longint
    |   | {name rate}: rate: longint
    |   | {null}: null
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET id = NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {not}: err
    |     | {strlit 'x'}: text notnull
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

CREATE PROC proc1 ()
BEGIN
  DELETE FROM foo;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc1}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {delete_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

CREATE PROC proc1 ()
BEGIN
  DELETE FROM foo;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0186: duplicate stored proc name 'proc1'

  {create_proc_stmt}: err
  | {name proc1}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {delete_stmt}
        | {name foo}

The statement ending at line XXXX

CREATE PROC proc2 (arg1 INTEGER, arg2 TEXT)
BEGIN
  DELETE FROM foo WHERE arg1 = ('x' IN (arg2));
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc2}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable in
    |     | {param_detail}: arg2: text variable in
    |       | {name arg2}: arg2: text variable in
    |       | {type_text}: text
    | {stmt_list}: ok
      | {delete_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }
        | {opt_where}: bool
          | {eq}: bool
            | {name arg1}: arg1: integer variable in
            | {in_pred}: bool notnull
              | {strlit 'x'}: text notnull
              | {expr_list}: arg2: text variable in
                | {name arg2}: arg2: text variable in

The statement ending at line XXXX

SELECT arg1;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'arg1'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name arg1}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT arg2;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'arg2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name arg2}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC proc3 (arg1 INTEGER, arg1 TEXT)
BEGIN
  CALL anything(arg1, arg2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0175: duplicate parameter name 'arg1'

  {create_proc_stmt}: err
  | {name proc3}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: arg1: integer variable in
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: err
    |     | {param_detail}
    |       | {name arg1}
    |       | {type_text}
    | {stmt_list}
      | {call_stmt}
        | {name anything}
        | {expr_list}
          | {name arg1}
          | {expr_list}
            | {name arg2}

The statement ending at line XXXX

CREATE PROC proc3 ()
BEGIN
  THROW;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0186: duplicate stored proc name 'proc3'

  {create_proc_stmt}: err
  | {name proc3}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {throw_stmt}

The statement ending at line XXXX

CREATE PROC proc_throw_not_at_end ()
BEGIN
  THROW;
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in throw_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name proc_throw_not_at_end}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {throw_stmt}: err
      | {declare_vars_type}: integer
        | {name_list}: x: integer variable
        | | {name x}: x: integer variable
        | {type_int}: integer

The statement ending at line XXXX

CREATE PROC throw_before_out ()
BEGIN
  BEGIN TRY
    DECLARE C CURSOR FOR SELECT 1 AS x;
    FETCH C;
  END TRY;
  BEGIN CATCH
    THROW;
  END CATCH;
  OUT C;
END;

  {create_proc_stmt}: C: select: { x: integer notnull } variable dml_proc auto_cursor uses_out uses_throw
  | {name throw_before_out}: C: select: { x: integer notnull } variable dml_proc auto_cursor uses_out uses_throw
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {trycatch_stmt}: ok
      | | {stmt_list}: ok
      | | | {declare_cursor}: C: select: { x: integer notnull } variable
      | | | | {name C}: C: select: { x: integer notnull } variable auto_cursor
      | | | | {select_stmt}: select: { x: integer notnull }
      | | |   | {select_core_list}: select: { x: integer notnull }
      | | |   | | {select_core}: select: { x: integer notnull }
      | | |   |   | {select_expr_list_con}: select: { x: integer notnull }
      | | |   |     | {select_expr_list}: select: { x: integer notnull }
      | | |   |     | | {select_expr}: x: integer notnull
      | | |   |     |   | {int 1}: integer notnull
      | | |   |     |   | {opt_as_alias}
      | | |   |     |     | {name x}
      | | |   |     | {select_from_etc}: ok
      | | |   |       | {select_where}
      | | |   |         | {select_groupby}
      | | |   |           | {select_having}
      | | |   | {select_orderby}
      | | |     | {select_limit}
      | | |       | {select_offset}
      | | | {fetch_stmt}: C: select: { x: integer notnull } variable auto_cursor
      | |   | {name C}: C: select: { x: integer notnull } variable auto_cursor
      | | {stmt_list}: ok
      |   | {throw_stmt}: ok
      | {out_stmt}: C: select: { x: integer notnull } variable auto_cursor
        | {name C}: C: select: { x: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC proc4 (IN arg1 INTEGER, OUT arg2 TEXT, INOUT arg3 REAL)
BEGIN
  CALL anything(arg1, arg3);
END;

  {create_proc_stmt}: ok
  | {name proc4}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable out
    |   | | {out}
    |   | | {param_detail}: arg2: text variable out
    |   |   | {name arg2}: arg2: text variable out
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: arg3: real variable in out
    |       | {inout}
    |       | {param_detail}: arg3: real variable in out
    |         | {name arg3}: arg3: real variable in out
    |         | {type_real}: real
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name anything}: ok
        | {expr_list}: ok
          | {name arg1}: arg1: integer variable in
          | {expr_list}
            | {name arg3}: arg3: real variable in out

The statement ending at line XXXX

CREATE PROC proc5 (IN arg1 INTEGER, OUT arg2 TEXT, INOUT arg3 REAL)
BEGIN
  DECLARE arg1 INTEGER;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0197: duplicate variable name in the same scope 'arg1'

  {create_proc_stmt}: err
  | {name proc5}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable out
    |   | | {out}
    |   | | {param_detail}: arg2: text variable out
    |   |   | {name arg2}: arg2: text variable out
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: arg3: real variable in out
    |       | {inout}
    |       | {param_detail}: arg3: real variable in out
    |         | {name arg3}: arg3: real variable in out
    |         | {type_real}: real
    | {stmt_list}: err
      | {declare_vars_type}: err
        | {name_list}: err
        | | {name arg1}: err
        | {type_int}: integer

The statement ending at line XXXX

SELECT bar
  FROM bar AS T;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bar'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name bar}: err
  |     | {select_from_etc}: TABLE { T: bar }
  |       | {table_or_subquery_list}: TABLE { T: bar }
  |       | | {table_or_subquery}: TABLE { T: bar }
  |       |   | {name bar}: TABLE { T: bar }
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T
  FROM bar AS T;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'T'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name T}: err
  |     | {select_from_etc}: TABLE { T: bar }
  |       | {table_or_subquery_list}: TABLE { T: bar }
  |       | | {table_or_subquery}: TABLE { T: bar }
  |       |   | {name bar}: TABLE { T: bar }
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, rate
  FROM (SELECT id, rate
  FROM bar);

  {select_stmt}: select: { id: integer notnull, rate: longint }
  | {select_core_list}: select: { id: integer notnull, rate: longint }
  | | {select_core}: select: { id: integer notnull, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: rate: longint
  |     |     | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { id: integer notnull, rate: longint }
  |       |     | {select_core_list}: select: { id: integer notnull, rate: longint }
  |       |     | | {select_core}: select: { id: integer notnull, rate: longint }
  |       |     |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |       |     |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |       |     |     | | {select_expr}: id: integer notnull
  |       |     |     | | | {name id}: id: integer notnull
  |       |     |     | | {select_expr_list}
  |       |     |     |   | {select_expr}: rate: longint
  |       |     |     |     | {name rate}: rate: longint
  |       |     |     | {select_from_etc}: TABLE { bar: bar }
  |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |     |       |   | {name bar}: TABLE { bar: bar }
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, rate
  FROM (SELECT *
  FROM bar);

  {select_stmt}: select: { id: integer notnull, rate: longint }
  | {select_core_list}: select: { id: integer notnull, rate: longint }
  | | {select_core}: select: { id: integer notnull, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: rate: longint
  |     |     | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
  |       |     | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
  |       |     | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | {select_from_etc}: TABLE { bar: bar }
  |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |     |       |   | {name bar}: TABLE { bar: bar }
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo.id
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {dot}: id: integer notnull
  |     |     | {name foo}
  |     |     | {name id}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo.id
  FROM foo AS T1;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name foo}
  |     |     | {name id}
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE int_nn INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: int_nn: integer notnull variable
  | | {name int_nn}: int_nn: integer notnull variable
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

SET int_nn := NULL;

Error at test/sem_test.sql:XXXX : in null : CQL0013: cannot assign/copy possibly null expression to not null target 'int_nn'

  {assign}: err
  | {name int_nn}: err
  | {null}: null

The statement ending at line XXXX

CALL foo();

  {call_stmt}: ok
  | {name foo}: ok

The statement ending at line XXXX

CALL printf('Hello, world');

  {call_stmt}: ok
  | {name printf}: ok
  | {expr_list}: ok
    | {strlit 'Hello, world'}: text notnull

The statement ending at line XXXX

CALL proc1();

  {call_stmt}: ok dml_proc
  | {name proc1}: ok dml_proc

The statement ending at line XXXX

CALL proc2(1, 'foo');

  {call_stmt}: ok dml_proc
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {strlit 'foo'}: text notnull

The statement ending at line XXXX

CALL proc2('bar', 'foo');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'arg1'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {strlit 'bar'}: err
    | {expr_list}
      | {strlit 'foo'}: text notnull

The statement ending at line XXXX

CALL proc2(1, 2);

Error at test/sem_test.sql:XXXX : in num : CQL0009: incompatible types in expression 'arg2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {int 2}: err

The statement ending at line XXXX

CALL proc2(1, 'foo', 1);

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0235: too many arguments provided to procedure 'proc2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {int 1}: integer notnull

The statement ending at line XXXX

CALL proc2(1);

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0212: too few arguments provided to procedure 'proc2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull

The statement ending at line XXXX

CALL proc3(1, 'foo');

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0213: procedure had errors, can't call 'proc3'

  {call_stmt}: err
  | {name proc3}
  | {expr_list}
    | {int 1}
    | {expr_list}
      | {strlit 'foo'}

The statement ending at line XXXX

CREATE PROC proc_with_output (IN arg1 INTEGER, INOUT arg2 INTEGER, OUT arg3 INTEGER)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name proc_with_output}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: arg1: integer variable in
      | | {in}
      | | {param_detail}: arg1: integer variable in
      |   | {name arg1}: arg1: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: arg2: integer variable in out
        | | {inout}
        | | {param_detail}: arg2: integer variable in out
        |   | {name arg2}: arg2: integer variable in out
        |   | {type_int}: integer
        | {params}
          | {param}: arg3: integer variable out
            | {out}
            | {param_detail}: arg3: integer variable out
              | {name arg3}: arg3: integer variable out
              | {type_int}: integer

The statement ending at line XXXX

CALL proc_with_output(1, 2, X);

Error at test/sem_test.sql:XXXX : in num : CQL0207: proc out parameter: formal cannot be fulfilled by non-variable 'arg2'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {int 2}: integer notnull
      | {expr_list}
        | {name X}: X: integer variable

The statement ending at line XXXX

CALL proc_with_output(1, X, 3);

Error at test/sem_test.sql:XXXX : in num : CQL0207: proc out parameter: formal cannot be fulfilled by non-variable 'arg3'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {name X}: X: integer variable
      | {expr_list}
        | {int 3}: integer notnull

The statement ending at line XXXX

CALL proc_with_output(1, X, Y);

  {call_stmt}: ok
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {name X}: X: integer variable
      | {expr_list}
        | {name Y}: Y: integer variable

The statement ending at line XXXX

CREATE PROC test_proc1 (IN arg1 INTEGER)
BEGIN
  CALL proc_with_output(1, X, arg1);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0208: proc out parameter: formal cannot be fulfilled by in-only variable 'arg1'

  {create_proc_stmt}: err
  | {name test_proc1}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    |   | {in}
    |   | {param_detail}: arg1: integer variable in
    |     | {name arg1}: arg1: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {call_stmt}: err
        | {name proc_with_output}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {name X}: X: integer variable
            | {expr_list}
              | {name arg1}: arg1: integer variable in

The statement ending at line XXXX

CREATE PROC test_proc2 (INOUT arg1 INTEGER)
BEGIN
  CALL proc_with_output(1, X, arg1);
END;

  {create_proc_stmt}: ok
  | {name test_proc2}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in out
    |   | {inout}
    |   | {param_detail}: arg1: integer variable in out
    |     | {name arg1}: arg1: integer variable in out
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name proc_with_output}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {name X}: X: integer variable
            | {expr_list}
              | {name arg1}: arg1: integer variable in out

The statement ending at line XXXX

CREATE PROC test_proc3 (OUT arg1 INTEGER)
BEGIN
  CALL proc_with_output(1, X, arg1);
END;

  {create_proc_stmt}: ok
  | {name test_proc3}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable out
    |   | {out}
    |   | {param_detail}: arg1: integer variable out
    |     | {name arg1}: arg1: integer variable out
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name proc_with_output}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {name X}: X: integer variable
            | {expr_list}
              | {name arg1}: arg1: integer variable out

The statement ending at line XXXX

SELECT count(*)
  FROM foo;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name count}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {star}: integer
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT id)
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {call}: id: integer notnull
  |     |     | {name count}: id: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT id) FILTER (WHERE id = 0)
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {call}: id: integer notnull
  |     |     | {name count}: id: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | | {opt_filter_clause}: bool notnull
  |     |       |   | {opt_where}: bool notnull
  |     |       |     | {eq}: bool notnull
  |     |       |       | {name id}: id: integer notnull
  |     |       |       | {int 0}: integer notnull
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT *)
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0304: DISTINCT may only be used with one explicit argument in an aggregate function 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name count}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | {arg_list}: ok
  |     |         | {star}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(id)
  FROM foo;

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {call}: id: integer
  |     |     | {name sum}: id: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(id)
  FROM foo;

  {select_stmt}: select: { id: real notnull }
  | {select_core_list}: select: { id: real notnull }
  | | {select_core}: select: { id: real notnull }
  |   | {select_expr_list_con}: select: { id: real notnull }
  |     | {select_expr_list}: select: { id: real notnull }
  |     | | {select_expr}: id: real notnull
  |     |   | {call}: id: real notnull
  |     |     | {name total}: id: real notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(id, rate)
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'total'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name total}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     |         | {arg_list}
  |     |           | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(*)
  FROM foo;

Error at test/sem_test.sql:XXXX : in star : CQL0051: argument can only be used in count(*) '*'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name sum}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {star}: err
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT avg(id)
  FROM foo;

  {select_stmt}: select: { id: real }
  | {select_core_list}: select: { id: real }
  | | {select_core}: select: { id: real }
  |   | {select_expr_list_con}: select: { id: real }
  |     | {select_expr_list}: select: { id: real }
  |     | | {select_expr}: id: real
  |     |   | {call}: id: real
  |     |     | {name avg}: id: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(id)
  FROM foo;

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {call}: id: integer
  |     |     | {name min}: id: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT count(1, 2)
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'count'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name count}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT max()
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'max'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name max}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg(1, 2)
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'avg'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg('foo')
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0082: argument must be numeric 'avg'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'foo'}: text notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg(NULL)
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0082: argument must be numeric 'avg'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {null}: null
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT X * 10 AS v
  WHERE v = 1 );

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {select_stmt}: v: integer
    | {select_core_list}: select: { v: integer }
    | | {select_core}: select: { v: integer }
    |   | {select_expr_list_con}: select: { v: integer }
    |     | {select_expr_list}: select: { v: integer }
    |     | | {select_expr}: v: integer
    |     |   | {mul}: integer
    |     |   | | {name X}: X: integer variable
    |     |   | | {int 10}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name v}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {opt_where}: bool
    |         | | {eq}: bool
    |         |   | {name v}: v: integer
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X_not_null := ( SELECT 1
  WHERE 0 );

  {assign}: X_not_null: integer notnull variable
  | {name X_not_null}: X_not_null: integer notnull variable
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT some_unknown_function(NULL) );

Error at test/sem_test.sql:XXXX : in str : CQL0094: function not yet implemented 'some_unknown_function'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name some_unknown_function}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {null}: null
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WHILE X
BEGIN
  SELECT 1;
END;

  {while_stmt}: ok
  | {name X}: X: integer variable
  | {stmt_list}: ok
    | {select_stmt}: select: { _anon: integer notnull }
      | {select_core_list}: select: { _anon: integer notnull }
      | | {select_core}: select: { _anon: integer notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull }
      |     | | {select_expr}: integer notnull
      |     |   | {int 1}: integer notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

WHILE 'X'
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in while_stmt : CQL0015: expected numeric expression 'WHILE'

  {while_stmt}: err
  | {strlit 'X'}: err
  | {stmt_list}
    | {select_stmt}
      | {select_core_list}
      | | {select_core}
      |   | {select_expr_list_con}
      |     | {select_expr_list}
      |     | | {select_expr}
      |     |   | {int 1}
      |     | {select_from_etc}
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

WHILE X
BEGIN
  SELECT NOT 'x';
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {while_stmt}: err
  | {name X}: X: integer variable
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'x'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC foo ()
BEGIN
  CREATE PROC bar ()
  BEGIN
    SELECT 1;
  END;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0184: stored procedures cannot be nested 'bar'

  {create_proc_stmt}: err
  | {name foo}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_proc_stmt}: err
        | {name bar}: err
        | {proc_params_stmts}
          | {stmt_list}
            | {select_stmt}
              | {select_core_list}
              | | {select_core}
              |   | {select_expr_list_con}
              |     | {select_expr_list}
              |     | | {select_expr}
              |     |   | {int 1}
              |     | {select_from_etc}
              |       | {select_where}
              |         | {select_groupby}
              |           | {select_having}
              | {select_orderby}
                | {select_limit}
                  | {select_offset}

The statement ending at line XXXX

CREATE PROC calls_dml ()
BEGIN
  CALL proc1();
END;

  {create_proc_stmt}: ok dml_proc
  | {name calls_dml}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: ok dml_proc
        | {name proc1}: ok dml_proc

The statement ending at line XXXX

BEGIN TRY
  SELECT 1;
END TRY;
BEGIN CATCH
  THROW;
END CATCH;

  {trycatch_stmt}: ok
  | {stmt_list}: ok
  | | {select_stmt}: select: { _anon: integer notnull }
  |   | {select_core_list}: select: { _anon: integer notnull }
  |   | | {select_core}: select: { _anon: integer notnull }
  |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |   |     | {select_expr_list}: select: { _anon: integer notnull }
  |   |     | | {select_expr}: integer notnull
  |   |     |   | {int 1}: integer notnull
  |   |     | {select_from_etc}: ok
  |   |       | {select_where}
  |   |         | {select_groupby}
  |   |           | {select_having}
  |   | {select_orderby}
  |     | {select_limit}
  |       | {select_offset}
  | {stmt_list}: ok
    | {throw_stmt}: ok

The statement ending at line XXXX

BEGIN TRY
  SELECT NOT 'x';
END TRY;
BEGIN CATCH
  THROW;
END CATCH;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {trycatch_stmt}: err
  | {stmt_list}: err
  | | {select_stmt}: err
  |   | {select_core_list}: err
  |   | | {select_core}: err
  |   |   | {select_expr_list_con}: err
  |   |     | {select_expr_list}: err
  |   |     | | {select_expr}: err
  |   |     |   | {not}: err
  |   |     |     | {strlit 'x'}: text notnull
  |   |     | {select_from_etc}: ok
  |   |       | {select_where}
  |   |         | {select_groupby}
  |   |           | {select_having}
  |   | {select_orderby}
  |     | {select_limit}
  |       | {select_offset}
  | {stmt_list}
    | {throw_stmt}

The statement ending at line XXXX

BEGIN TRY
  THROW;
END TRY;
BEGIN CATCH
  SELECT NOT 'x';
END CATCH;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {trycatch_stmt}: err
  | {stmt_list}: ok
  | | {throw_stmt}: ok
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'x'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC with_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;

  {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
  | {name with_result_set}: select: { id: integer notnull, name: text, rate: longint } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC with_matching_result (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A, 4.7 AS B;
  END IF;
END;

  {create_proc_stmt}: select: { A: integer notnull, B: real notnull } dml_proc
  | {name with_matching_result}: select: { A: integer notnull, B: real notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: i: integer variable in
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: ok
          | {else}: ok
            | {stmt_list}: ok
              | {select_stmt}: select: { A: integer notnull, B: real notnull }
                | {select_core_list}: select: { A: integer notnull, B: real notnull }
                | | {select_core}: select: { A: integer notnull, B: real notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
                |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
                |     | | {select_expr}: A: integer notnull
                |     | | | {int 3}: integer notnull
                |     | | | {opt_as_alias}
                |     | |   | {name A}
                |     | | {select_expr_list}
                |     |   | {select_expr}: B: real notnull
                |     |     | {dbl 4.7}: real notnull
                |     |     | {opt_as_alias}
                |     |       | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_types (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A, 4 AS B;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0061: in multiple select statements, all columns must be an exact type match (expected real notnull; found integer notnull) 'B'

  {create_proc_stmt}: err
  | {name with_wrong_types}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer notnull, B: integer notnull }
                | | {select_core}: select: { A: integer notnull, B: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     | | | {int 3}: integer notnull
                |     | | | {opt_as_alias}
                |     | |   | {name A}
                |     | | {select_expr_list}
                |     |   | {select_expr}: B: integer notnull
                |     |     | {int 4}: integer notnull
                |     |     | {opt_as_alias}
                |     |       | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_count (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0057: in multiple select statements, all must have the same column count

  {create_proc_stmt}: err
  | {name with_wrong_count}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer notnull }
                | | {select_core}: select: { A: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     |   | {int 3}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_flags (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT i AS A;
  ELSE
    SELECT X AS A;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0062: in multiple select statements, all columns must be an exact type match (including nullability) (expected integer notnull; found integer) 'A'

  {create_proc_stmt}: err
  | {name with_wrong_flags}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull variable in }
        |     | {select_core_list}: select: { A: integer notnull variable in }
        |     | | {select_core}: select: { A: integer notnull variable in }
        |     |   | {select_expr_list_con}: select: { A: integer notnull variable in }
        |     |     | {select_expr_list}: select: { A: integer notnull variable in }
        |     |     | | {select_expr}: A: integer notnull variable in
        |     |     |   | {name i}: i: integer notnull variable in
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer variable }
                | | {select_core}: select: { A: integer variable }
                |   | {select_expr_list_con}: select: { A: integer variable }
                |     | {select_expr_list}: select: { A: integer variable }
                |     | | {select_expr}: A: integer variable
                |     |   | {name X}: X: integer variable
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_ok_flags (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT i AS A;
  ELSE
    SELECT 2 AS A;
  END IF;
END;

  {create_proc_stmt}: select: { A: integer notnull variable in } dml_proc
  | {name with_ok_flags}: select: { A: integer notnull variable in } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: i: integer notnull variable in
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull variable in }
        |     | {select_core_list}: select: { A: integer notnull variable in }
        |     | | {select_core}: select: { A: integer notnull variable in }
        |     |   | {select_expr_list_con}: select: { A: integer notnull variable in }
        |     |     | {select_expr_list}: select: { A: integer notnull variable in }
        |     |     | | {select_expr}: A: integer notnull variable in
        |     |     |   | {name i}: i: integer notnull variable in
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: ok
          | {else}: ok
            | {stmt_list}: ok
              | {select_stmt}: select: { A: integer notnull }
                | {select_core_list}: select: { A: integer notnull }
                | | {select_core}: select: { A: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     |   | {int 2}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_bad_names (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT 1 AS A;
  ELSE
    SELECT 2 AS B;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0058: in multiple select statements, all column names must be identical so they have unambiguous names 'B'

  {create_proc_stmt}: err
  | {name with_bad_names}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull }
        |     | {select_core_list}: select: { A: integer notnull }
        |     | | {select_core}: select: { A: integer notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     |   | {int 1}: integer notnull
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { B: integer notnull }
                | | {select_core}: select: { B: integer notnull }
                |   | {select_expr_list_con}: select: { B: integer notnull }
                |     | {select_expr_list}: select: { B: integer notnull }
                |     | | {select_expr}: B: integer notnull
                |     |   | {int 2}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_no_names (i INTEGER NOT NULL)
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0055: all columns in the select must have a name

  {create_proc_stmt}: err
  | {name with_no_names}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: select: { _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     |   | {int 1}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE curs CURSOR FOR CALL with_result_set();

  {declare_cursor}: curs: select: { id: integer notnull, name: text, rate: longint } variable
  | {name curs}: curs: select: { id: integer notnull, name: text, rate: longint } variable
  | {call_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name with_result_set}: select: { id: integer notnull, name: text, rate: longint } dml_proc

The statement ending at line XXXX

CALL with_result_set();

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0214: procedures with results can only be called using a cursor in global context 'with_result_set'

  {call_stmt}: err
  | {name with_result_set}

The statement ending at line XXXX

DECLARE curs CURSOR FOR CALL bogus_call(NOT 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {declare_cursor}: err
  | {name curs}
  | {call_stmt}: err
    | {name bogus_call}
    | {expr_list}: err
      | {not}: err
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

DECLARE curs CURSOR FOR CALL proc1();

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0199: cursor requires a procedure that returns a result set via select 'curs'

  {declare_cursor}: err
  | {name curs}
  | {call_stmt}: ok dml_proc
    | {name proc1}: ok dml_proc

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name ASC, T2.id DESC
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5
OFFSET 7;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |   | | {dot}: name: text
  |           |   | | | {name T2}
  |           |   | | | {name name}
  |           |   | | {asc}
  |           |   | {groupby_list}
  |           |     | {groupby_item}
  |           |       | {dot}: id: integer notnull
  |           |       | | {name T2}
  |           |       | | {name id}
  |           |       | {desc}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 7}: integer notnull

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5
OFFSET 'x';

Error at test/sem_test.sql:XXXX : in opt_offset : CQL0015: expected numeric expression 'OFFSET'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {dot}: name: text
  |           |       | {name T2}
  |           |       | {name name}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}: err
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}
        | {opt_offset}: err
          | {strlit 'x'}: err

The statement ending at line XXXX

SELECT count(1);

Error at test/sem_test.sql:XXXX : in call : CQL0081: aggregates only make sense if there is a FROM clause 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name count}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE count(*) = 1;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name count}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {star}: integer
  |         |   | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT max(1);

Error at test/sem_test.sql:XXXX : in call : CQL0081: aggregates only make sense if there is a FROM clause 'max'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name max}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT avg(1);

Error at test/sem_test.sql:XXXX : in call : CQL0081: aggregates only make sense if there is a FROM clause 'avg'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name avg}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC out_proc (OUT result INTEGER)
BEGIN
  SET result := 5;
END;

  {create_proc_stmt}: ok
  | {name out_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: result: integer variable out
    |   | {out}
    |   | {param_detail}: result: integer variable out
    |     | {name result}: result: integer variable out
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: result: integer variable out
        | {name result}: result: integer variable out
        | {int 5}: integer notnull

The statement ending at line XXXX

DECLARE my_int INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: my_int: integer notnull variable
  | | {name my_int}: my_int: integer notnull variable
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

CALL out_proc(my_int);

Error at test/sem_test.sql:XXXX : in str : CQL0013: cannot assign/copy possibly null expression to not null target 'my_int'

  {call_stmt}: err
  | {name out_proc}: ok
  | {expr_list}: ok
    | {name my_int}: my_int: integer notnull variable

The statement ending at line XXXX

DECLARE my_real REAL;

  {declare_vars_type}: real
  | {name_list}: my_real: real variable
  | | {name my_real}: my_real: real variable
  | {type_real}: real

The statement ending at line XXXX

CALL out_proc(my_real);

Error at test/sem_test.sql:XXXX : in str : CQL0209: proc out parameter: arg must be an exact type match (expected integer; found real) 'my_real'

  {call_stmt}: err
  | {name out_proc}: ok
  | {expr_list}: ok
    | {name my_real}: my_real: real variable

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE EXISTS (SELECT *
  FROM foo);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {exists_expr}: bool notnull
  |         |   | {select_stmt}: select: { id: integer notnull }
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {star}: select: { id: integer notnull }
  |         |     |     | {select_from_etc}: TABLE { foo: foo }
  |         |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |     |       |   | {name foo}: TABLE { foo: foo }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE NOT EXISTS (SELECT *
  FROM foo);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {not}: bool notnull
  |         |   | {exists_expr}: bool notnull
  |         |     | {select_stmt}: select: { id: integer notnull }
  |         |       | {select_core_list}: select: { id: integer notnull }
  |         |       | | {select_core}: select: { id: integer notnull }
  |         |       |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |       |     | {select_expr_list}: select: { id: integer notnull }
  |         |       |     | | {star}: select: { id: integer notnull }
  |         |       |     | {select_from_etc}: TABLE { foo: foo }
  |         |       |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |       |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |       |       |   | {name foo}: TABLE { foo: foo }
  |         |       |       | {select_where}
  |         |       |         | {select_groupby}
  |         |       |           | {select_having}
  |         |       | {select_orderby}
  |         |         | {select_limit}
  |         |           | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE EXISTS (SELECT NOT 'x'
  FROM foo);

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {exists_expr}: err
  |         |   | {select_stmt}: err
  |         |     | {select_core_list}: err
  |         |     | | {select_core}: err
  |         |     |   | {select_expr_list_con}: err
  |         |     |     | {select_expr_list}: err
  |         |     |     | | {select_expr}: err
  |         |     |     |   | {not}: err
  |         |     |     |     | {strlit 'x'}: text notnull
  |         |     |     | {select_from_etc}: TABLE { foo: foo }
  |         |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |     |       |   | {name foo}: TABLE { foo: foo }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE NOT EXISTS (SELECT NOT 'x'
  FROM foo);

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {not}: err
  |         |   | {exists_expr}: err
  |         |     | {select_stmt}: err
  |         |       | {select_core_list}: err
  |         |       | | {select_core}: err
  |         |       |   | {select_expr_list_con}: err
  |         |       |     | {select_expr_list}: err
  |         |       |     | | {select_expr}: err
  |         |       |     |   | {not}: err
  |         |       |     |     | {strlit 'x'}: text notnull
  |         |       |     | {select_from_etc}: TABLE { foo: foo }
  |         |       |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |       |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |       |       |   | {name foo}: TABLE { foo: foo }
  |         |       |       | {select_where}
  |         |       |         | {select_groupby}
  |         |       |           | {select_having}
  |         |       | {select_orderby}
  |         |         | {select_limit}
  |         |           | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := EXISTS (SELECT *
  FROM foo);

Error at test/sem_test.sql:XXXX : in exists_expr : CQL0080: function may not appear in this context 'exists'

  {assign}: err
  | {name X}: X: integer variable
  | {exists_expr}: err
    | {select_stmt}
      | {select_core_list}
      | | {select_core}
      |   | {select_expr_list_con}
      |     | {select_expr_list}
      |     | | {star}
      |     | {select_from_etc}
      |       | {table_or_subquery_list}
      |       | | {table_or_subquery}
      |       |   | {name foo}
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

SET X := NOT EXISTS (SELECT *
  FROM foo);

Error at test/sem_test.sql:XXXX : in exists_expr : CQL0080: function may not appear in this context 'exists'

  {assign}: err
  | {name X}: X: integer variable
  | {not}: err
    | {exists_expr}: err
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {star}
        |     | {select_from_etc}
        |       | {table_or_subquery_list}
        |       | | {table_or_subquery}
        |       |   | {name foo}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

RELEASE SAVEPOINT garbonzo;

Error at test/sem_test.sql:XXXX : in release_savepoint_stmt : CQL0221: savepoint has not been mentioned yet, probably wrong 'garbonzo'

  {release_savepoint_stmt}: err
  | {name garbonzo}: ok

The statement ending at line XXXX

ROLLBACK TRANSACTION TO SAVEPOINT another_garbonzo;

Error at test/sem_test.sql:XXXX : in rollback_trans_stmt : CQL0220: savepoint has not been mentioned yet, probably wrong 'another_garbonzo'

  {rollback_trans_stmt}: err
  | {name another_garbonzo}: ok

The statement ending at line XXXX

DECLARE auto_cursor CURSOR FOR SELECT 1 AS one, 2 AS two;

  {declare_cursor}: auto_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {name auto_cursor}: auto_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor
  | {select_stmt}: select: { one: integer notnull, two: integer notnull }
    | {select_core_list}: select: { one: integer notnull, two: integer notnull }
    | | {select_core}: select: { one: integer notnull, two: integer notnull }
    |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
    |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
    |     | | {select_expr}: one: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name one}
    |     | | {select_expr_list}
    |     |   | {select_expr}: two: integer notnull
    |     |     | {int 2}: integer notnull
    |     |     | {opt_as_alias}
    |     |       | {name two}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

FETCH auto_cursor;

  {fetch_stmt}: auto_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor
  | {name auto_cursor}: auto_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor

The statement ending at line XXXX

SELECT auto_cursor.one;

  {select_stmt}: select: { auto_cursor_.one: integer notnull variable }
  | {select_core_list}: select: { auto_cursor_.one: integer notnull variable }
  | | {select_core}: select: { auto_cursor_.one: integer notnull variable }
  |   | {select_expr_list_con}: select: { auto_cursor_.one: integer notnull variable }
  |     | {select_expr_list}: select: { auto_cursor_.one: integer notnull variable }
  |     | | {select_expr}: auto_cursor_.one: integer notnull variable
  |     |   | {dot}: auto_cursor_.one: integer notnull variable
  |     |     | {name auto_cursor}
  |     |     | {name one}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT auto_cursor.three;

Error at test/sem_test.sql:XXXX : in dot : CQL0068: field not found in cursor 'three'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name auto_cursor}
  |     |     | {name three}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT my_cursor.one;

Error at test/sem_test.sql:XXXX : in dot : CQL0067: cursor was not used with 'fetch [cursor]' 'my_cursor'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name my_cursor}
  |     |     | {name one}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id);

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {join_clause}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: foo }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id, id);

Error at test/sem_test.sql:XXXX : in str : CQL0206: duplicate name in list 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}
  |       |           | {name id}
  |       |           | {name_list}
  |       |             | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id, idx);

Error at test/sem_test.sql:XXXX : in name_list : CQL0096: join using column not found on the left side of the join 'idx'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       |           | {name_list}
  |       |             | {name idx}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM bar AS T1
  INNER JOIN foo AS T2 USING (id, name);

Error at test/sem_test.sql:XXXX : in name_list : CQL0097: join using column not found on the right side of the join 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       |           | {name_list}: name: text
  |       |             | {name name}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE payload1(
  id INTEGER NOT NULL,
  data1 INTEGER NOT NULL
);

  {create_table_stmt}: payload1: { id: integer notnull, data1: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name payload1}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: data1: integer notnull
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name data1}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE payload2(
  id INTEGER NOT NULL,
  data2 INTEGER NOT NULL
);

  {create_table_stmt}: payload2: { id: integer notnull, data2: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name payload2}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: data2: integer notnull
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name data2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT *
  FROM payload1
  INNER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | {select_core_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | | {select_core}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | | {star}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  LEFT OUTER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  | {select_core_list}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  | | {select_core}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | {select_expr_list}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | | {star}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 3}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  RIGHT OUTER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  | {select_core_list}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  | | {select_core}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | {select_expr_list}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | | {star}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 4}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  CROSS JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer, data1: integer, id: integer, data2: integer }
  | {select_core_list}: select: { id: integer, data1: integer, id: integer, data2: integer }
  | | {select_core}: select: { id: integer, data1: integer, id: integer, data2: integer }
  |   | {select_expr_list_con}: select: { id: integer, data1: integer, id: integer, data2: integer }
  |     | {select_expr_list}: select: { id: integer, data1: integer, id: integer, data2: integer }
  |     | | {star}: select: { id: integer, data1: integer, id: integer, data2: integer }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 2}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo AS A,
foo AS B)
  INNER JOIN (foo AS C,
foo AS D);

  {select_stmt}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       | {join_clause}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       | | {table_or_subquery}: JOIN { A: foo, B: foo }
  |       | | | {table_or_subquery_list}: JOIN { A: foo, B: foo }
  |       | |   | {table_or_subquery}: TABLE { A: foo }
  |       | |   | | {name foo}: TABLE { A: foo }
  |       | |   | | {opt_as_alias}
  |       | |   |   | {name A}
  |       | |   | {table_or_subquery_list}: TABLE { B: foo }
  |       | |     | {table_or_subquery}: TABLE { B: foo }
  |       | |       | {name foo}: TABLE { B: foo }
  |       | |       | {opt_as_alias}
  |       | |         | {name B}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: JOIN { C: foo, D: foo }
  |       |         | {table_or_subquery_list}: JOIN { C: foo, D: foo }
  |       |           | {table_or_subquery}: TABLE { C: foo }
  |       |           | | {name foo}: TABLE { C: foo }
  |       |           | | {opt_as_alias}
  |       |           |   | {name C}
  |       |           | {table_or_subquery_list}: TABLE { D: foo }
  |       |             | {table_or_subquery}: TABLE { D: foo }
  |       |               | {name foo}: TABLE { D: foo }
  |       |               | {opt_as_alias}
  |       |                 | {name D}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM (foo
  INNER JOIN bar ON NOT 'x')
  INNER JOIN foo ON 1;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: err
  |       | | | {join_clause}: err
  |       | |   | {table_or_subquery}: TABLE { foo: foo }
  |       | |   | | {name foo}: TABLE { foo: foo }
  |       | |   | {join_target_list}
  |       | |     | {join_target}: err
  |       | |       | {int 1}
  |       | |       | {table_join}
  |       | |         | {table_or_subquery}: TABLE { bar: bar }
  |       | |         | | {name bar}: TABLE { bar: bar }
  |       | |         | {join_cond}: err
  |       | |           | {on}: err
  |       | |           | {not}: err
  |       | |             | {strlit 'x'}: text notnull
  |       | | {join_target_list}
  |       |   | {join_target}
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { foo: foo }
  |       |       | | {name foo}: TABLE { foo: foo }
  |       |       | {join_cond}
  |       |         | {on}
  |       |         | {int 1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 0);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, Y, 1.5);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {name Y}: Y: integer variable
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, NULL, 1.5);

Error at test/sem_test.sql:XXXX : in null : CQL0076: Null literal is useless in function 'coalesce'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {null}: err
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, 5, 1.5);

Error at test/sem_test.sql:XXXX : in num : CQL0077: encountered arg known to be not null before the end of the list, rendering the rest useless.

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {int 5}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 5, 1.5);

Error at test/sem_test.sql:XXXX : in str : CQL0075: Incorrect number of arguments 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {int 5}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(5);

Error at test/sem_test.sql:XXXX : in str : CQL0074: Too few arguments provided 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 'hello');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(NOT 'x', NOT 'hello');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {not}: err
  |     |         | | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {not}
  |     |             | {strlit 'hello'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE fk_table_2(
  id1 INTEGER,
  id2 INTEGER,
  FOREIGN KEY (id1, id2) REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0023: The number of columns on both sides of a foreign key must match

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table_2}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: err
          | {name_list}
          | | {name id1}: id1: integer
          | | {name_list}
          |   | {name id2}: id2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_table_2(
  id REAL,
  FOREIGN KEY (id) REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0022: the exact type of both sides of a foreign key must match (expected real; found integer notnull) 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table_2}
  | {col_key_list}
    | {col_def}: id: real
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_real}: real
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name id}: id: real
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}: id: integer notnull
          | {int 0}

The statement ending at line XXXX

CREATE TABLE join_clause_1(
  id REAL
);

  {create_table_stmt}: join_clause_1: { id: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name join_clause_1}
  | {col_key_list}
    | {col_def}: id: real
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_real}: real

The statement ending at line XXXX

CREATE TABLE join_clause_2(
  id INTEGER
);

  {create_table_stmt}: join_clause_2: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name join_clause_2}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

SELECT *
  FROM join_clause_1
  INNER JOIN join_clause_2 USING (id);

Error at test/sem_test.sql:XXXX : in name_list : CQL0098: left/right column types in join USING(...) do not match exactly 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { join_clause_1: join_clause_1 }
  |       | | | {name join_clause_1}: TABLE { join_clause_1: join_clause_1 }
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { join_clause_2: join_clause_2 }
  |       |       | | {name join_clause_2}: TABLE { join_clause_2: join_clause_2 }
  |       |       | {join_cond}
  |       |         | {using}
  |       |         | {name_list}: id: integer
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT last_insert_rowid();

  {select_stmt}: select: { _anon: longint notnull }
  | {select_core_list}: select: { _anon: longint notnull }
  | | {select_core}: select: { _anon: longint notnull }
  |   | {select_expr_list_con}: select: { _anon: longint notnull }
  |     | {select_expr_list}: select: { _anon: longint notnull }
  |     | | {select_expr}: longint notnull
  |     |   | {call}: longint notnull
  |     |     | {name last_insert_rowid}: longint notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT last_insert_rowid(1);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'last_insert_rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name last_insert_rowid}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
LIMIT last_insert_rowid();

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'last_insert_rowid'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {call}: err
      |   | {name last_insert_rowid}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {select_offset}

The statement ending at line XXXX

DECLARE rowid_result LONG_INT NOT NULL;

  {declare_vars_type}: longint notnull
  | {name_list}: rowid_result: longint notnull variable
  | | {name rowid_result}: rowid_result: longint notnull variable
  | {notnull}: longint notnull
    | {type_long}: longint

The statement ending at line XXXX

SET rowid_result := last_insert_rowid();

  {assign}: rowid_result: longint notnull variable
  | {name rowid_result}: rowid_result: longint notnull variable
  | {call}: longint notnull
    | {name last_insert_rowid}: longint notnull
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SELECT changes();

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name changes}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT changes(1);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'changes'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name changes}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
LIMIT changes();

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'changes'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {call}: err
      |   | {name changes}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {select_offset}

The statement ending at line XXXX

DECLARE changes_result INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: changes_result: integer notnull variable
  | | {name changes_result}: changes_result: integer notnull variable
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

SET changes_result := changes();

  {assign}: changes_result: integer notnull variable
  | {name changes_result}: changes_result: integer notnull variable
  | {call}: integer notnull
    | {name changes}: integer notnull
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SELECT printf('%s %d', 'x', 5);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s %d'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := printf('Hello');

  {assign}: a_string: text variable
  | {name a_string}: a_string: text variable
  | {call}: text notnull
    | {name printf}: text notnull
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'Hello'}: text notnull

The statement ending at line XXXX

SET a_string := printf();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'printf'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name printf}: err
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SET a_string := printf(7);

Error at test/sem_test.sql:XXXX : in call : CQL0086: first argument must be a string in function 'printf'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name printf}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 7}: integer notnull

The statement ending at line XXXX

SELECT 1
  FROM (SELECT 1)
LIMIT printf('%s %d', 'x', 5) = 'x';

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'printf'

  {select_stmt}: err
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { _anon: integer notnull }
  |       |     | {select_core_list}: select: { _anon: integer notnull }
  |       |     | | {select_core}: select: { _anon: integer notnull }
  |       |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     |     | | {select_expr}: integer notnull
  |       |     |     |   | {int 1}: integer notnull
  |       |     |     | {select_from_etc}: ok
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {eq}: err
      |   | {call}: err
      |   | | {name printf}
      |   | | {call_arg_list}
      |   |   | {call_filter_clause}
      |   |   | {arg_list}: ok
      |   |     | {strlit '%s %d'}: text notnull
      |   |     | {arg_list}
      |   |       | {strlit 'x'}: text notnull
      |   |       | {arg_list}
      |   |         | {int 5}: integer notnull
      |   | {strlit 'x'}: text notnull
      | {select_offset}

The statement ending at line XXXX

UPDATE foo
SET id = 1,
id = 3
  WHERE id = 2;

Error at test/sem_test.sql:XXXX : in str : CQL0153: duplicate target column name in update statement 'id'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: id: integer notnull
    | | | {name id}: id: integer notnull
    | | | {int 1}: integer notnull
    | | {update_list}
    |   | {update_entry}: err
    |     | {name id}: err
    |     | {int 3}
    | {update_where}
      | {opt_where}
      | | {eq}
      |   | {name id}
      |   | {int 2}
      | {update_orderby}

The statement ending at line XXXX

SET X := ( SELECT sum(1, 2)
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'sum'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sum}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT id
  FROM foo
LIMIT sum(1) );

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'sum'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: select: { id: integer notnull }
    | | {select_core}: select: { id: integer notnull }
    |   | {select_expr_list_con}: select: { id: integer notnull }
    |     | {select_expr_list}: select: { id: integer notnull }
    |     | | {select_expr}: id: integer notnull
    |     |   | {name id}: id: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}: err
      | {select_limit}
        | {opt_limit}: err
        | | {call}: err
        |   | {name sum}
        |   | {call_arg_list}
        |     | {call_filter_clause}
        |     | {arg_list}: ok
        |       | {int 1}: integer notnull
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT sum('x')
  FROM foo );

Error at test/sem_test.sql:XXXX : in str : CQL0083: argument must be numeric 'sum'

  {assign}: err
  | {name X}: X: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sum}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE TABLE A1(
  foo INTEGER
);

  {create_table_stmt}: A1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name A1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE B1(
  foo INTEGER
);

  {create_table_stmt}: B1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name B1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE C1(
  foo INTEGER
);

  {create_table_stmt}: C1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name C1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

SELECT *
  FROM A1 AS T1
  LEFT OUTER JOIN B1 AS T2 ON T1.foo = t2.foo
  LEFT OUTER JOIN C1 AS T3 ON T2.foo = t3.foo;

  {select_stmt}: select: { foo: integer, foo: integer, foo: integer }
  | {select_core_list}: select: { foo: integer, foo: integer, foo: integer }
  | | {select_core}: select: { foo: integer, foo: integer, foo: integer }
  |   | {select_expr_list_con}: select: { foo: integer, foo: integer, foo: integer }
  |     | {select_expr_list}: select: { foo: integer, foo: integer, foo: integer }
  |     | | {star}: select: { foo: integer, foo: integer, foo: integer }
  |     | {select_from_etc}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       | {join_clause}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       | | {table_or_subquery}: TABLE { T1: A1 }
  |       | | | {name A1}: TABLE { T1: A1 }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: A1, T2: B1 }
  |       |   | | {int 3}
  |       |   | | {table_join}
  |       |   |   | {table_or_subquery}: TABLE { T2: B1 }
  |       |   |   | | {name B1}: TABLE { T2: B1 }
  |       |   |   | | {opt_as_alias}
  |       |   |   |   | {name T2}
  |       |   |   | {join_cond}: JOIN { T1: A1, T2: B1 }
  |       |   |     | {on}: bool
  |       |   |     | {eq}: bool
  |       |   |       | {dot}: foo: integer
  |       |   |       | | {name T1}
  |       |   |       | | {name foo}
  |       |   |       | {dot}: foo: integer
  |       |   |         | {name t2}
  |       |   |         | {name foo}
  |       |   | {join_target_list}
  |       |     | {join_target}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       |       | {int 3}
  |       |       | {table_join}
  |       |         | {table_or_subquery}: TABLE { T3: C1 }
  |       |         | | {name C1}: TABLE { T3: C1 }
  |       |         | | {opt_as_alias}
  |       |         |   | {name T3}
  |       |         | {join_cond}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       |           | {on}: bool
  |       |           | {eq}: bool
  |       |             | {dot}: foo: integer
  |       |             | | {name T2}
  |       |             | | {name foo}
  |       |             | {dot}: foo: integer
  |       |               | {name t3}
  |       |               | {name foo}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name)
  FROM bar
  GROUP BY id;

  {select_stmt}: select: { id: integer notnull, name: text }
  | {select_core_list}: select: { id: integer notnull, name: text }
  | | {select_core}: select: { id: integer notnull, name: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
  |     | {select_expr_list}: select: { id: integer notnull, name: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: name: text
  |     |     | {call}: name: text
  |     |       | {name group_concat}: name: text
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: name: text
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name, 'x')
  FROM bar
  GROUP BY id;

  {select_stmt}: select: { id: integer notnull, name: text }
  | {select_core_list}: select: { id: integer notnull, name: text }
  | | {select_core}: select: { id: integer notnull, name: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
  |     | {select_expr_list}: select: { id: integer notnull, name: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: name: text
  |     |     | {call}: name: text
  |     |       | {name group_concat}: name: text
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: name: text
  |     |           | {arg_list}
  |     |             | {strlit 'x'}: text notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name, 0)
  FROM bar
  GROUP BY id;

Error at test/sem_test.sql:XXXX : in call : CQL0084: second argument must be a string in function 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: name: text
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}
  |           | | {groupby_list}
  |           |   | {groupby_item}
  |           |     | {name id}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat()
  FROM bar
  GROUP BY id;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}: err
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}
  |           | | {groupby_list}
  |           |   | {groupby_item}
  |           |     | {name id}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat('x', 'y', 'z')
  FROM bar
  GROUP BY id;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}: err
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {strlit 'x'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'y'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit 'z'}: text notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}
  |           | | {groupby_list}
  |           |   | {groupby_item}
  |           |     | {name id}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM bar
  WHERE group_concat(name) = 'foo';

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name group_concat}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {name name}: name: text
  |         |   | {strlit 'foo'}: text notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 'now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name strftime}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%YYYY-%mm-%DDT%HH:%MM:%SS.SSS', 'now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name strftime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%YYYY-%mm-%DDT%HH:%MM:%SS.SSS'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%W', 'now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name strftime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%W'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit '+1 month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit 'start of month'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit '-3 minutes'}: text notnull
  |     |                 | {arg_list}
  |     |                   | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 'now', 3);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime(42, 'now');

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 42);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := strftime('%s', 'now');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'strftime'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name strftime}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit '%s'}: text notnull
        | {arg_list}
          | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT strftime('now');

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name date}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name date}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name date}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', 3);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date(42);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := date('now');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'date'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name date}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT date();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name time}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name time}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name time}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', 3);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time(42);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := time('now');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'time'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name time}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT time();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name datetime}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name datetime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name datetime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', 3);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime(42);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := datetime('now');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'datetime'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name datetime}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT datetime();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now');

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name julianday}: real notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', '+1 month');

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name julianday}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name julianday}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', 3);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday(42);

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := julianday('now');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'julianday'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name julianday}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT julianday();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CAST(1 AS TEXT);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {cast_expr}: text notnull
  |     |     | {int 1}: integer notnull
  |     |     | {type_text}: text
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := CAST(5.0 AS TEXT);

Error at test/sem_test.sql:XXXX : in cast_expr : CQL0073: CAST may only appear in the context of SQL statement

  {assign}: err
  | {name X}: X: integer variable
  | {cast_expr}: err
    | {dbl 5.0}: real notnull
    | {type_text}: text

The statement ending at line XXXX

SELECT CAST(NOT 'x' AS INTEGER);

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {cast_expr}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {type_int}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE pk_test(
  id INTEGER PRIMARY KEY
);

  {create_table_stmt}: pk_test: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name pk_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok

The statement ending at line XXXX

CREATE TABLE pk_test_2(
  id INTEGER,
  PRIMARY KEY (id)
);

  {create_table_stmt}: pk_test_2: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name pk_test_2}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
        | {name_list}
          | {name id}

The statement ending at line XXXX

CREATE TABLE AA1(
  id1 INTEGER NOT NULL
);

  {create_table_stmt}: AA1: { id1: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name AA1}
  | {col_key_list}
    | {col_def}: id1: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id1}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE BB2(
  id2 INTEGER NOT NULL
);

  {create_table_stmt}: BB2: { id2: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name BB2}
  | {col_key_list}
    | {col_def}: id2: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id2}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE CC3(
  id3 INTEGER NOT NULL
);

  {create_table_stmt}: CC3: { id3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name CC3}
  | {col_key_list}
    | {col_def}: id3: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id3}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT *
  FROM (AA1 AS A,
BB2 AS B)
  LEFT OUTER JOIN CC3 AS C ON C.id3 = A.id1;

  {select_stmt}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  | {select_core_list}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  | | {select_core}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |   | {select_expr_list_con}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | {select_expr_list}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | | {star}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | {select_from_etc}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       | {join_clause}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       | | {table_or_subquery}: JOIN { A: AA1, B: BB2 }
  |       | | | {table_or_subquery_list}: JOIN { A: AA1, B: BB2 }
  |       | |   | {table_or_subquery}: TABLE { A: AA1 }
  |       | |   | | {name AA1}: TABLE { A: AA1 }
  |       | |   | | {opt_as_alias}
  |       | |   |   | {name A}
  |       | |   | {table_or_subquery_list}: TABLE { B: BB2 }
  |       | |     | {table_or_subquery}: TABLE { B: BB2 }
  |       | |       | {name BB2}: TABLE { B: BB2 }
  |       | |       | {opt_as_alias}
  |       | |         | {name B}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       |     | {int 3}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { C: CC3 }
  |       |       | | {name CC3}: TABLE { C: CC3 }
  |       |       | | {opt_as_alias}
  |       |       |   | {name C}
  |       |       | {join_cond}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       |         | {on}: bool
  |       |         | {eq}: bool
  |       |           | {dot}: id3: integer
  |       |           | | {name C}
  |       |           | | {name id3}
  |       |           | {dot}: id1: integer notnull
  |       |             | {name A}
  |       |             | {name id1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl2 (id INTEGER) USING TRANSACTION;

  {declare_proc_stmt}: ok dml_proc
  | {proc_name_type}
  | | {name decl2}: ok dml_proc
  | | {int 2}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl3 (id INTEGER) (A INTEGER NOT NULL, B BOOL);

  {declare_proc_stmt}: select: { A: integer notnull, B: bool } dml_proc
  | {proc_name_type}
  | | {name decl3}: select: { A: integer notnull, B: bool } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: select: { A: integer notnull, B: bool }
      | {typed_name}: A: integer notnull
      | | {name A}
      | | {notnull}: A: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: B: bool
          | {name B}
          | {type_bool}: B: bool

The statement ending at line XXXX

CREATE PROC bogus_nested_declare ()
BEGIN
  DECLARE PROC yy ();
END;

Error at test/sem_test.sql:XXXX : in str : CQL0194: declared procedures must be top level 'yy'

  {create_proc_stmt}: err
  | {name bogus_nested_declare}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_proc_stmt}: err
        | {proc_name_type}
        | | {name yy}
        | | {int 0}
        | {proc_params_stmts}

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER NOT NULL);

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in declare_proc_stmt : DECLARE PROC decl1 (id INTEGER)
Error at test/sem_test.sql:XXXX : in declare_proc_stmt : DECLARE PROC decl1 (id INTEGER NOT NULL)
The above must be identical.
Error at test/sem_test.sql:XXXX : in declare_proc_stmt : CQL0196: procedure declarations/definitions do not match 'decl1'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer notnull variable in
        | {param_detail}: id: integer notnull variable in
          | {name id}: id: integer notnull variable in
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC bogus_duplicate_params (id INTEGER, id INTEGER);

Error at test/sem_test.sql:XXXX : in str : CQL0175: duplicate parameter name 'id'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name bogus_duplicate_params}
  | | {int 0}
  | {proc_params_stmts}
    | {params}: err
      | {param}: id: integer variable in
      | | {param_detail}: id: integer variable in
      |   | {name id}: id: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: err
          | {param_detail}
            | {name id}
            | {type_int}

The statement ending at line XXXX

DECLARE PROC bogus_select_list (id INTEGER) (id INTEGER, id INTEGER);

Error at test/sem_test.sql:XXXX : in str : CQL0190: duplicate column name 'id'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name bogus_select_list}
  | | {int 3}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: err
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: err
          | {name id}
          | {type_int}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT id
  FROM bar);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {in_pred}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: id: integer
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     |   | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT id, id
  FROM bar);

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0232: nested select expression must return exactly one column

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {in_pred}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: err
  |         |     | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     | | | {name id}: id: integer notnull
  |         |     |     | | {select_expr_list}
  |         |     |     |   | {select_expr}: id: integer notnull
  |         |     |     |     | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT name
  FROM bar);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {in_pred}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: name: text
  |         |     | {select_core_list}: select: { name: text }
  |         |     | | {select_core}: select: { name: text }
  |         |     |   | {select_expr_list_con}: select: { name: text }
  |         |     |     | {select_expr_list}: select: { name: text }
  |         |     |     | | {select_expr}: name: text
  |         |     |     |   | {name name}: name: text
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id NOT IN (SELECT id
  FROM bar);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {not_in}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: id: integer
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     |   | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id NOT IN (SELECT name
  FROM bar);

Error at test/sem_test.sql:XXXX : in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {not_in}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: name: text
  |         |     | {select_core_list}: select: { name: text }
  |         |     | | {select_core}: select: { name: text }
  |         |     |   | {select_expr_list_con}: select: { name: text }
  |         |     |     | {select_expr_list}: select: { name: text }
  |         |     |     | | {select_expr}: name: text
  |         |     |     |   | {name name}: name: text
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION
SELECT 3 AS A, 4 AS B;

  {select_stmt}: UNION: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 1}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 3 AS A, 4 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS C
UNION ALL
SELECT 3 AS A, 4 AS B;

Error at test/sem_test.sql:XXXX : in select_core : CQL0058: if multiple selects, all column names must be identical so they have unambiguous names 'B'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: C: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name C}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 3 AS A, 4.3 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: real notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: real notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: integer notnull, B: real notnull }
  |     | {select_core}: select: { A: integer notnull, B: real notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: real notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: real notnull
  |         |     | {dbl 4.3}: real notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x' AS A
UNION ALL
SELECT 1 AS A;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: err
  | |   | {select_expr_list}: err
  | |   | | {select_expr}: err
  | |   |   | {not}: err
  | |   |   | | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}
  |     | {select_core}
  |       | {select_expr_list_con}
  |         | {select_expr_list}
  |         | | {select_expr}
  |         |   | {int 1}
  |         |   | {opt_as_alias}
  |         |     | {name A}
  |         | {select_from_etc}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' AS A
UNION ALL
SELECT NOT 'x' AS A;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: select: { A: text notnull }
  | | | {select_expr_list_con}: select: { A: text notnull }
  | |   | {select_expr_list}: select: { A: text notnull }
  | |   | | {select_expr}: A: text notnull
  | |   |   | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: err
  |       | {select_expr_list_con}: err
  |         | {select_expr_list}: err
  |         | | {select_expr}: err
  |         |   | {not}: err
  |         |   | | {strlit 'x'}: text notnull
  |         |   | {opt_as_alias}
  |         |     | {name A}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
INTERSECT
SELECT 3 AS A, 4 AS B;

  {select_stmt}: INTERSECT: { A: integer notnull, B: integer notnull }
  | {select_core_list}: INTERSECT: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 3}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
EXCEPT
SELECT 3 AS A, 4 AS B;

  {select_stmt}: EXCEPT: { A: integer notnull, B: integer notnull }
  | {select_core_list}: EXCEPT: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 4}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullable(1);

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {call}: integer
  |     |     | {name nullable}: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullable(1, 2);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'nullable'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name nullable}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1
  FROM bar
  WHERE nullable(1) = 1;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'nullable'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: integer notnull
  |     |   | {int 1}: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name nullable}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {int 1}: integer notnull
  |         |   | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

WITH
foo (a, a) AS (SELECT 1, 2)
SELECT 1;

Error at test/sem_test.sql:XXXX : in str : CQL0206: duplicate name in list 'a'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a, b) AS (SELECT 1, 2),
foo (a, b) AS (SELECT 1, 2)
SELECT 1;

Error at test/sem_test.sql:XXXX : in cte_decl : CQL0100: duplicate common table name 'foo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: foo: { a: integer notnull, b: integer notnull }
  |   | | {cte_decl}: foo: { a: integer notnull, b: integer notnull }
  |   | | | {name foo}
  |   | | | {name_list}
  |   | |   | {name a}
  |   | |   | {name_list}
  |   | |     | {name b}
  |   | | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |     | | {select_expr}: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: integer notnull
  |   |   |     |     | {int 2}: integer notnull
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}: err
  |       | | {name foo}
  |       | | {name_list}
  |       |   | {name a}
  |       |   | {name_list}
  |       |     | {name b}
  |       | {select_stmt}
  |         | {select_core_list}
  |         | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |     | | {select_expr}: integer notnull
  |         |     | | | {int 1}: integer notnull
  |         |     | | {select_expr_list}
  |         |     |   | {select_expr}: integer notnull
  |         |     |     | {int 2}: integer notnull
  |         |     | {select_from_etc}: ok
  |         |       | {select_where}
  |         |         | {select_groupby}
  |         |           | {select_having}
  |         | {select_orderby}
  |           | {select_limit}
  |             | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a) AS (SELECT 1, 2)
SELECT 1;

Error at test/sem_test.sql:XXXX : in cte_decl : CQL0101: too few column names specified in common table expression 'foo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a, b, c) AS (SELECT 1, 2)
SELECT 1;

Error at test/sem_test.sql:XXXX : in cte_decl : CQL0102: too many column names specified in common table expression 'foo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     |     | {name_list}
  |     |       | {name c}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a) AS (SELECT NOT 'x')
SELECT 1;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       |   | {select_expr_list_con}: err
  |       |     | {select_expr_list}: err
  |       |     | | {select_expr}: err
  |       |     |   | {not}: err
  |       |     |     | {strlit 'x'}: text notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a) AS (SELECT 1)
SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: foo: { a: integer notnull }
  |     | {cte_decl}: foo: { a: integer notnull }
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}: select: { _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a, b) AS (SELECT 1, 2)
SELECT a, b
  FROM some_cte;

  {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { a: integer notnull, b: integer notnull }
  |     | {cte_decl}: some_cte: { a: integer notnull, b: integer notnull }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |     | | {select_expr}: a: integer notnull
    |     | | | {name a}: a: integer notnull
    |     | | {select_expr_list}
    |     |   | {select_expr}: b: integer notnull
    |     |     | {name b}: b: integer notnull
    |     | {select_from_etc}: TABLE { some_cte: some_cte }
    |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |   | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (a) AS (SELECT 1 AS x
UNION ALL
SELECT NULL AS x)
SELECT *
  FROM foo;

  {with_select_stmt}: select: { a: integer }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: foo: { a: integer }
  |     | {cte_decl}: foo: { a: integer }
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}: UNION ALL: { x: integer }
  |       | {select_core_list}: UNION ALL: { x: integer }
  |       | | {select_core}: select: { x: integer notnull }
  |       | | | {select_expr_list_con}: select: { x: integer notnull }
  |       | |   | {select_expr_list}: select: { x: integer notnull }
  |       | |   | | {select_expr}: x: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   |   | {opt_as_alias}
  |       | |   |     | {name x}
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { x: null }
  |       |     | {select_core}: select: { x: null }
  |       |       | {select_expr_list_con}: select: { x: null }
  |       |         | {select_expr_list}: select: { x: null }
  |       |         | | {select_expr}: x: null
  |       |         |   | {null}: null
  |       |         |   | {opt_as_alias}
  |       |         |     | {name x}
  |       |         | {select_from_etc}: ok
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer }
    | {select_core_list}: select: { a: integer }
    | | {select_core}: select: { a: integer }
    |   | {select_expr_list_con}: select: { a: integer }
    |     | {select_expr_list}: select: { a: integer }
    |     | | {star}: select: { a: integer }
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
x (a, b) AS (SELECT 1, 2)
SELECT *
  FROM x AS X
  INNER JOIN (WITH
y (a, b) AS (SELECT 1, 3)
SELECT *
  FROM y) AS Y ON X.a = Y.a
  INNER JOIN (WITH
y (a, b) AS (SELECT 1, 3)
SELECT *
  FROM y) AS Z ON X.a = Z.a;

  {with_select_stmt}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: x: { a: integer notnull, b: integer notnull }
  |     | {cte_decl}: x: { a: integer notnull, b: integer notnull }
  |     | | {name x}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    | {select_core_list}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    | | {select_core}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | | {star}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | {select_from_etc}: JOIN { X: x, Y: select, Z: select }
    |       | {join_clause}: JOIN { X: x, Y: select, Z: select }
    |       | | {table_or_subquery}: TABLE { X: x }
    |       | | | {name x}: TABLE { X: x }
    |       | | | {opt_as_alias}
    |       | |   | {name X}
    |       | | {join_target_list}
    |       |   | {join_target}: JOIN { X: x, Y: select }
    |       |   | | {int 1}
    |       |   | | {table_join}
    |       |   |   | {table_or_subquery}: TABLE { Y: select }
    |       |   |   | | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | | | {with}
    |       |   |   | | | | {cte_tables}: ok
    |       |   |   | | |   | {cte_table}: y: { a: integer notnull, b: integer notnull }
    |       |   |   | | |     | {cte_decl}: y: { a: integer notnull, b: integer notnull }
    |       |   |   | | |     | | {name y}
    |       |   |   | | |     | | {name_list}
    |       |   |   | | |     |   | {name a}
    |       |   |   | | |     |   | {name_list}
    |       |   |   | | |     |     | {name b}
    |       |   |   | | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |     | | {select_expr}: integer notnull
    |       |   |   | | |       |     | | | {int 1}: integer notnull
    |       |   |   | | |       |     | | {select_expr_list}
    |       |   |   | | |       |     |   | {select_expr}: integer notnull
    |       |   |   | | |       |     |     | {int 3}: integer notnull
    |       |   |   | | |       |     | {select_from_etc}: ok
    |       |   |   | | |       |       | {select_where}
    |       |   |   | | |       |         | {select_groupby}
    |       |   |   | | |       |           | {select_having}
    |       |   |   | | |       | {select_orderby}
    |       |   |   | | |         | {select_limit}
    |       |   |   | | |           | {select_offset}
    |       |   |   | | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | {select_from_etc}: TABLE { y: y }
    |       |   |   | |   |       | {table_or_subquery_list}: TABLE { y: y }
    |       |   |   | |   |       | | {table_or_subquery}: TABLE { y: y }
    |       |   |   | |   |       |   | {name y}: TABLE { y: y }
    |       |   |   | |   |       | {select_where}
    |       |   |   | |   |         | {select_groupby}
    |       |   |   | |   |           | {select_having}
    |       |   |   | |   | {select_orderby}
    |       |   |   | |     | {select_limit}
    |       |   |   | |       | {select_offset}
    |       |   |   | | {opt_as_alias}
    |       |   |   |   | {name Y}
    |       |   |   | {join_cond}: JOIN { X: x, Y: select }
    |       |   |     | {on}: bool notnull
    |       |   |     | {eq}: bool notnull
    |       |   |       | {dot}: a: integer notnull
    |       |   |       | | {name X}
    |       |   |       | | {name a}
    |       |   |       | {dot}: a: integer notnull
    |       |   |         | {name Y}
    |       |   |         | {name a}
    |       |   | {join_target_list}
    |       |     | {join_target}: JOIN { X: x, Y: select, Z: select }
    |       |       | {int 1}
    |       |       | {table_join}
    |       |         | {table_or_subquery}: TABLE { Z: select }
    |       |         | | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |         | | | {with}
    |       |         | | | | {cte_tables}: ok
    |       |         | | |   | {cte_table}: y: { a: integer notnull, b: integer notnull }
    |       |         | | |     | {cte_decl}: y: { a: integer notnull, b: integer notnull }
    |       |         | | |     | | {name y}
    |       |         | | |     | | {name_list}
    |       |         | | |     |   | {name a}
    |       |         | | |     |   | {name_list}
    |       |         | | |     |     | {name b}
    |       |         | | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |     | | {select_expr}: integer notnull
    |       |         | | |       |     | | | {int 1}: integer notnull
    |       |         | | |       |     | | {select_expr_list}
    |       |         | | |       |     |   | {select_expr}: integer notnull
    |       |         | | |       |     |     | {int 3}: integer notnull
    |       |         | | |       |     | {select_from_etc}: ok
    |       |         | | |       |       | {select_where}
    |       |         | | |       |         | {select_groupby}
    |       |         | | |       |           | {select_having}
    |       |         | | |       | {select_orderby}
    |       |         | | |         | {select_limit}
    |       |         | | |           | {select_offset}
    |       |         | | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | {select_from_etc}: TABLE { y: y }
    |       |         | |   |       | {table_or_subquery_list}: TABLE { y: y }
    |       |         | |   |       | | {table_or_subquery}: TABLE { y: y }
    |       |         | |   |       |   | {name y}: TABLE { y: y }
    |       |         | |   |       | {select_where}
    |       |         | |   |         | {select_groupby}
    |       |         | |   |           | {select_having}
    |       |         | |   | {select_orderby}
    |       |         | |     | {select_limit}
    |       |         | |       | {select_offset}
    |       |         | | {opt_as_alias}
    |       |         |   | {name Z}
    |       |         | {join_cond}: JOIN { X: x, Y: select, Z: select }
    |       |           | {on}: bool notnull
    |       |           | {eq}: bool notnull
    |       |             | {dot}: a: integer notnull
    |       |             | | {name X}
    |       |             | | {name a}
    |       |             | {dot}: a: integer notnull
    |       |               | {name Z}
    |       |               | {name a}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

  {with_select_stmt}: select: { current: integer notnull }
  | {with_recursive}
  | | {cte_tables}: ok
  |   | {cte_table}: cnt: { current: integer notnull }
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
  |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { _anon: integer notnull }
  |       |     | {select_core}: select: { _anon: integer notnull }
  |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |         | {select_expr_list}: select: { _anon: integer notnull }
  |       |         | | {select_expr}: integer notnull
  |       |         |   | {add}: integer notnull
  |       |         |     | {name current}: current: integer notnull
  |       |         |     | {int 1}: integer notnull
  |       |         | {select_from_etc}: TABLE { cnt: cnt }
  |       |           | {table_or_subquery_list}: TABLE { cnt: cnt }
  |       |           | | {table_or_subquery}: TABLE { cnt: cnt }
  |       |           |   | {name cnt}: TABLE { cnt: cnt }
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}: integer notnull
  |           | | {int 10}: integer notnull
  |           | {select_offset}
  | {select_stmt}: select: { current: integer notnull }
    | {select_core_list}: select: { current: integer notnull }
    | | {select_core}: select: { current: integer notnull }
    |   | {select_expr_list_con}: select: { current: integer notnull }
    |     | {select_expr_list}: select: { current: integer notnull }
    |     | | {select_expr}: current: integer notnull
    |     |   | {name current}: current: integer notnull
    |     | {select_from_etc}: TABLE { cnt: cnt }
    |       | {table_or_subquery_list}: TABLE { cnt: cnt }
    |       | | {table_or_subquery}: TABLE { cnt: cnt }
    |       |   | {name cnt}: TABLE { cnt: cnt }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current, current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

Error at test/sem_test.sql:XXXX : in str : CQL0206: duplicate name in list 'current'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     |   | {name_list}
  |     |     | {name current}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}
  |       |     | {select_core}
  |       |       | {select_expr_list_con}
  |       |         | {select_expr_list}
  |       |         | | {select_expr}
  |       |         |   | {add}
  |       |         |     | {name current}
  |       |         |     | {int 1}
  |       |         | {select_from_etc}
  |       |           | {table_or_subquery_list}
  |       |           | | {table_or_subquery}
  |       |           |   | {name cnt}
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}
  |           | | {int 10}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT NOT 'x'
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       | | | {select_expr_list_con}: err
  |       | |   | {select_expr_list}: err
  |       | |   | | {select_expr}: err
  |       | |   |   | {not}: err
  |       | |   |     | {strlit 'x'}: text notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}
  |       |     | {select_core}
  |       |       | {select_expr_list_con}
  |       |         | {select_expr_list}
  |       |         | | {select_expr}
  |       |         |   | {add}
  |       |         |     | {name current}
  |       |         |     | {int 1}
  |       |         | {select_from_etc}
  |       |           | {table_or_subquery_list}
  |       |           | | {table_or_subquery}
  |       |           |   | {name cnt}
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}
  |           | | {int 10}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT NOT 'x')
SELECT current
  FROM cnt;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: err
  |       | {select_core_list}: err
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: err
  |       |     | {select_core}: err
  |       |       | {select_expr_list_con}: err
  |       |         | {select_expr_list}: err
  |       |         | | {select_expr}: err
  |       |         |   | {not}: err
  |       |         |     | {strlit 'x'}: text notnull
  |       |         | {select_from_etc}: ok
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: ok
  |   | {cte_table}: cnt: { current: integer notnull }
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
  |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { _anon: integer notnull }
  |       |     | {select_core}: select: { _anon: integer notnull }
  |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |         | {select_expr_list}: select: { _anon: integer notnull }
  |       |         | | {select_expr}: integer notnull
  |       |         |   | {add}: integer notnull
  |       |         |     | {name current}: current: integer notnull
  |       |         |     | {int 1}: integer notnull
  |       |         | {select_from_etc}: TABLE { cnt: cnt }
  |       |           | {table_or_subquery_list}: TABLE { cnt: cnt }
  |       |           | | {table_or_subquery}: TABLE { cnt: cnt }
  |       |           |   | {name cnt}: TABLE { cnt: cnt }
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}: integer notnull
  |           | | {int 10}: integer notnull
  |           | {select_offset}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT X AS A
UNION ALL
SELECT X AS A
UNION ALL
SELECT Y AS A;

  {select_stmt}: UNION ALL: { A: integer }
  | {select_core_list}: UNION ALL: { A: integer }
  | | {select_core}: select: { A: integer variable }
  | | | {select_expr_list_con}: select: { A: integer variable }
  | |   | {select_expr_list}: select: { A: integer variable }
  | |   | | {select_expr}: A: integer variable
  | |   |   | {name X}: X: integer variable
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: UNION ALL: { A: integer }
  |     | {select_core}: select: { A: integer variable }
  |     | | {select_expr_list_con}: select: { A: integer variable }
  |     |   | {select_expr_list}: select: { A: integer variable }
  |     |   | | {select_expr}: A: integer variable
  |     |   |   | {name X}: X: integer variable
  |     |   |   | {opt_as_alias}
  |     |   |     | {name A}
  |     |   | {select_from_etc}: ok
  |     |     | {select_where}
  |     |       | {select_groupby}
  |     |         | {select_having}
  |     | {select_core_compound}
  |       | {int 2}
  |       | {select_core_list}: select: { A: integer variable }
  |         | {select_core}: select: { A: integer variable }
  |           | {select_expr_list_con}: select: { A: integer variable }
  |             | {select_expr_list}: select: { A: integer variable }
  |             | | {select_expr}: A: integer variable
  |             |   | {name Y}: Y: integer variable
  |             |   | {opt_as_alias}
  |             |     | {name A}
  |             | {select_from_etc}: ok
  |               | {select_where}
  |                 | {select_groupby}
  |                   | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW view_with_cte AS
WITH
goo (x) AS (SELECT 1)
SELECT *
  FROM goo;

  {create_view_stmt}: view_with_cte: { x: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name view_with_cte}
      | {with_select_stmt}: view_with_cte: { x: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: goo: { x: integer notnull }
        |     | {cte_decl}: goo: { x: integer notnull }
        |     | | {name goo}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: view_with_cte: { x: integer notnull }
          | {select_core_list}: view_with_cte: { x: integer notnull }
          | | {select_core}: view_with_cte: { x: integer notnull }
          |   | {select_expr_list_con}: view_with_cte: { x: integer notnull }
          |     | {select_expr_list}: view_with_cte: { x: integer notnull }
          |     | | {star}: view_with_cte: { x: integer notnull }
          |     | {select_from_etc}: TABLE { goo: goo }
          |       | {table_or_subquery_list}: TABLE { goo: goo }
          |       | | {table_or_subquery}: TABLE { goo: goo }
          |       |   | {name goo}: TABLE { goo: goo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT 1 IN (SELECT 1
UNION ALL
SELECT 2
UNION ALL
SELECT 3) AS A;

  {select_stmt}: select: { A: bool notnull }
  | {select_core_list}: select: { A: bool notnull }
  | | {select_core}: select: { A: bool notnull }
  |   | {select_expr_list_con}: select: { A: bool notnull }
  |     | {select_expr_list}: select: { A: bool notnull }
  |     | | {select_expr}: A: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |   | | {int 1}: integer notnull
  |     |   | | {select_stmt}: _anon: integer notnull
  |     |   |   | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |     |   |   | | {select_core}: select: { _anon: integer notnull }
  |     |   |   | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   | |   | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   | |   | | {select_expr}: integer notnull
  |     |   |   | |   |   | {int 1}: integer notnull
  |     |   |   | |   | {select_from_etc}: ok
  |     |   |   | |     | {select_where}
  |     |   |   | |       | {select_groupby}
  |     |   |   | |         | {select_having}
  |     |   |   | | {select_core_compound}
  |     |   |   |   | {int 2}
  |     |   |   |   | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |     |   |   |     | {select_core}: select: { _anon: integer notnull }
  |     |   |   |     | | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   |     |   | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   |     |   | | {select_expr}: integer notnull
  |     |   |   |     |   |   | {int 2}: integer notnull
  |     |   |   |     |   | {select_from_etc}: ok
  |     |   |   |     |     | {select_where}
  |     |   |   |     |       | {select_groupby}
  |     |   |   |     |         | {select_having}
  |     |   |   |     | {select_core_compound}
  |     |   |   |       | {int 2}
  |     |   |   |       | {select_core_list}: select: { _anon: integer notnull }
  |     |   |   |         | {select_core}: select: { _anon: integer notnull }
  |     |   |   |           | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   |             | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   |             | | {select_expr}: integer notnull
  |     |   |   |             |   | {int 3}: integer notnull
  |     |   |   |             | {select_from_etc}: ok
  |     |   |   |               | {select_where}
  |     |   |   |                 | {select_groupby}
  |     |   |   |                   | {select_having}
  |     |   |   | {select_orderby}
  |     |   |     | {select_limit}
  |     |   |       | {select_offset}
  |     |   | {opt_as_alias}
  |     |     | {name A}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 AS _first, T.*, 3 AS _last
  FROM (SELECT 1 AS A, 2 AS B) AS T;

  {select_stmt}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  | {select_core_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  | | {select_core}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |   | {select_expr_list_con}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |     | {select_expr_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |     | | {select_expr}: _first: integer notnull
  |     | | | {int 0}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name _first}
  |     | | {select_expr_list}
  |     |   | {table_star}: T: select: { A: integer notnull, B: integer notnull }
  |     |   | | {name T}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: _last: integer notnull
  |     |       | {int 3}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name _last}
  |     | {select_from_etc}: TABLE { T: select }
  |       | {table_or_subquery_list}: TABLE { T: select }
  |       | | {table_or_subquery}: TABLE { T: select }
  |       |   | {select_stmt}: select: { A: integer notnull, B: integer notnull }
  |       |   | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |       |   | | | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       |   | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |       |   | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |       |   | |     | | {select_expr}: A: integer notnull
  |       |   | |     | | | {int 1}: integer notnull
  |       |   | |     | | | {opt_as_alias}
  |       |   | |     | |   | {name A}
  |       |   | |     | | {select_expr_list}
  |       |   | |     |   | {select_expr}: B: integer notnull
  |       |   | |     |     | {int 2}: integer notnull
  |       |   | |     |     | {opt_as_alias}
  |       |   | |     |       | {name B}
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 AS _first, T.*, S.*, 3 AS _last
  FROM (SELECT 1 AS A, 2 AS B) AS T,
(SELECT 1 AS C) AS S;

  {select_stmt}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  | {select_core_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  | | {select_core}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |   | {select_expr_list_con}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |     | {select_expr_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |     | | {select_expr}: _first: integer notnull
  |     | | | {int 0}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name _first}
  |     | | {select_expr_list}
  |     |   | {table_star}: T: select: { A: integer notnull, B: integer notnull }
  |     |   | | {name T}
  |     |   | {select_expr_list}
  |     |     | {table_star}: S: select: { C: integer notnull }
  |     |     | | {name S}
  |     |     | {select_expr_list}
  |     |       | {select_expr}: _last: integer notnull
  |     |         | {int 3}: integer notnull
  |     |         | {opt_as_alias}
  |     |           | {name _last}
  |     | {select_from_etc}: JOIN { T: select, S: select }
  |       | {table_or_subquery_list}: JOIN { T: select, S: select }
  |       | | {table_or_subquery}: TABLE { T: select }
  |       | | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
  |       | | | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |       | | | | | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | | | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |       | | | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |       | | | |     | | {select_expr}: A: integer notnull
  |       | | | |     | | | {int 1}: integer notnull
  |       | | | |     | | | {opt_as_alias}
  |       | | | |     | |   | {name A}
  |       | | | |     | | {select_expr_list}
  |       | | | |     |   | {select_expr}: B: integer notnull
  |       | | | |     |     | {int 2}: integer notnull
  |       | | | |     |     | {opt_as_alias}
  |       | | | |     |       | {name B}
  |       | | | |     | {select_from_etc}: ok
  |       | | | |       | {select_where}
  |       | | | |         | {select_groupby}
  |       | | | |           | {select_having}
  |       | | | | {select_orderby}
  |       | | |   | {select_limit}
  |       | | |     | {select_offset}
  |       | | | {opt_as_alias}
  |       | |   | {name T}
  |       | | {table_or_subquery_list}: TABLE { S: select }
  |       |   | {table_or_subquery}: TABLE { S: select }
  |       |     | {select_stmt}: select: { C: integer notnull }
  |       |     | | {select_core_list}: select: { C: integer notnull }
  |       |     | | | {select_core}: select: { C: integer notnull }
  |       |     | |   | {select_expr_list_con}: select: { C: integer notnull }
  |       |     | |     | {select_expr_list}: select: { C: integer notnull }
  |       |     | |     | | {select_expr}: C: integer notnull
  |       |     | |     |   | {int 1}: integer notnull
  |       |     | |     |   | {opt_as_alias}
  |       |     | |     |     | {name C}
  |       |     | |     | {select_from_etc}: ok
  |       |     | |       | {select_where}
  |       |     | |         | {select_groupby}
  |       |     | |           | {select_having}
  |       |     | | {select_orderby}
  |       |     |   | {select_limit}
  |       |     |     | {select_offset}
  |       |     | {opt_as_alias}
  |       |       | {name S}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T.*;

Error at test/sem_test.sql:XXXX : in table_star : CQL0053: select [table].* cannot be used with no FROM clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {table_star}: err
  |     |   | {name T}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T.*
  FROM (SELECT 1) AS U;

Error at test/sem_test.sql:XXXX : in table_star : CQL0054: table not found 'T'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {table_star}: err
  |     |   | {name T}
  |     | {select_from_etc}: TABLE { U: select }
  |       | {table_or_subquery_list}: TABLE { U: select }
  |       | | {table_or_subquery}: TABLE { U: select }
  |       |   | {select_stmt}: select: { _anon: integer notnull }
  |       |   | | {select_core_list}: select: { _anon: integer notnull }
  |       |   | | | {select_core}: select: { _anon: integer notnull }
  |       |   | |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |   | |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |   | |     | | {select_expr}: integer notnull
  |       |   | |     |   | {int 1}: integer notnull
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name U}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE FUNC simple_func (arg1 INTEGER NOT NULL) REAL NOT NULL;

  {declare_func_stmt}: real notnull
  | {name simple_func}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer notnull variable in
    |   | {param_detail}: arg1: integer notnull variable in
    |     | {name arg1}: arg1: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

DECLARE FUNC simple_func (arg1 INTEGER) REAL NOT NULL;

Error at test/sem_test.sql:XXXX : in str : CQL0193: duplicate function name 'simple_func'

  {declare_func_stmt}: err
  | {name simple_func}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer variable in
    |   | {param_detail}: arg1: integer variable in
    |     | {name arg1}: arg1: integer variable in
    |     | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

DECLARE PROC simple_func (arg1 INTEGER NOT NULL);

Error at test/sem_test.sql:XXXX : in str : CQL0195: proc name conflicts with func name 'simple_func'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name simple_func}
  | | {int 0}
  | {proc_params_stmts}
    | {params}
      | {param}
        | {param_detail}
          | {name arg1}
          | {notnull}
            | {type_int}

The statement ending at line XXXX

CREATE PROC simple_func (arg1 INTEGER NOT NULL)
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0185: proc name conflicts with func name 'simple_func'

  {create_proc_stmt}: err
  | {name simple_func}: err
  | {proc_params_stmts}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name arg1}
    |     | {notnull}
    |       | {type_int}
    | {stmt_list}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE FUNC proc1 (i INTEGER) INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0192: func name conflicts with proc name 'proc1'

  {declare_func_stmt}: err
  | {name proc1}
  | {func_params_return}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name i}
    |     | {type_int}
    | {type_int}

The statement ending at line XXXX

CREATE PROC nested_func_wrapper ()
BEGIN
  DECLARE FUNC foo () INTEGER;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0191: declared functions must be top level 'foo'

  {create_proc_stmt}: err
  | {name nested_func_wrapper}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_func_stmt}: err
        | {name foo}
        | {func_params_return}
          | {type_int}

The statement ending at line XXXX

DECLARE FUNC dup_formal (a INTEGER, a INTEGER) INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0175: duplicate parameter name 'a'

  {declare_func_stmt}: err
  | {name dup_formal}
  | {func_params_return}
    | {params}: err
    | | {param}: a: integer variable in
    | | | {param_detail}: a: integer variable in
    | |   | {name a}: a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: err
    |     | {param_detail}
    |       | {name a}
    |       | {type_int}
    | {type_int}

The statement ending at line XXXX

DECLARE real_result REAL;

  {declare_vars_type}: real
  | {name_list}: real_result: real variable
  | | {name real_result}: real_result: real variable
  | {type_real}: real

The statement ending at line XXXX

SET real_result := simple_func(1);

  {assign}: real_result: real variable
  | {name real_result}: real_result: real variable
  | {call}: real notnull
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET real_result := simple_func('xx');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'arg1'

  {assign}: err
  | {name real_result}: real_result: real variable
  | {call}: err
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'xx'}: err

The statement ending at line XXXX

SET real_result := simple_func(NOT 'xx');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {assign}: err
  | {name real_result}: real_result: real variable
  | {call}: err
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: err
        | {not}: err
          | {strlit 'xx'}: text notnull

The statement ending at line XXXX

SELECT simple_func(1);

Error at test/sem_test.sql:XXXX : in call : CQL0088: User function may not appear in the context of a SQL statement 'simple_func'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name simple_func}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE obj_var OBJECT;

  {declare_vars_type}: object
  | {name_list}: obj_var: object variable
  | | {name obj_var}: obj_var: object variable
  | {type_object}: object

The statement ending at line XXXX

SET X := obj_var < 1;

Error at test/sem_test.sql:XXXX : in str : CQL0002: left operand cannot be an object in '<'

  {assign}: err
  | {name X}: X: integer variable
  | {lt}: err
    | {name obj_var}: obj_var: object variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 < obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0003: right operand cannot be an object in '<'

  {assign}: err
  | {name X}: X: integer variable
  | {lt}: err
    | {int 1}: integer notnull
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var = obj_var;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {eq}: bool
    | {name obj_var}: obj_var: object variable
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var <> obj_var;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {ne}: bool
    | {name obj_var}: obj_var: object variable
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var + 1;

Error at test/sem_test.sql:XXXX : in str : CQL0002: left operand cannot be an object in '+'

  {assign}: err
  | {name X}: X: integer variable
  | {add}: err
    | {name obj_var}: obj_var: object variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 + obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0003: right operand cannot be an object in '+'

  {assign}: err
  | {name X}: X: integer variable
  | {add}: err
    | {int 1}: integer notnull
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := NOT obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0049: object operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable
  | {not}: err
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := -obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0046: object operand not allowed in '-'

  {assign}: err
  | {name X}: X: integer variable
  | {uminus}: err
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET a_string := obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0009: incompatible types in expression 'a_string'

  {assign}: err
  | {name a_string}: err
  | {name obj_var}: err

The statement ending at line XXXX

SET obj_var := a_string;

Error at test/sem_test.sql:XXXX : in str : CQL0010: incompatible types in expression 'obj_var'

  {assign}: err
  | {name obj_var}: err
  | {name a_string}: err

The statement ending at line XXXX

CREATE PROC obj_proc (OUT an_obj OBJECT)
BEGIN
  SET an_obj := NULL;
END;

  {create_proc_stmt}: ok
  | {name obj_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: an_obj: object variable out
    |   | {out}
    |   | {param_detail}: an_obj: object variable out
    |     | {name an_obj}: an_obj: object variable out
    |     | {type_object}: object
    | {stmt_list}: ok
      | {assign}: an_obj: object variable out
        | {name an_obj}: an_obj: object variable out
        | {null}: null

The statement ending at line XXXX

CREATE TABLE object_table_test(
  obj OBJECT
);

Error at test/sem_test.sql:XXXX : in str : CQL0041: tables cannot have object columns 'obj'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name object_table_test}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name obj}
          | {type_object}: object

The statement ending at line XXXX

SELECT obj_var;

Error at test/sem_test.sql:XXXX : in str : CQL0064: object variables may not appear in the context of a SQL statement (except table-valued functions) 'obj_var'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name obj_var}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := obj_var IN (obj_var, NULL);

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {in_pred}: bool
    | {name obj_var}: obj_var: object variable
    | {expr_list}: obj_var: object variable
      | {name obj_var}: obj_var: object variable
      | {expr_list}: null
        | {null}: null

The statement ending at line XXXX

SET X := obj_var IN (obj_var, 1);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0010: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {name obj_var}: obj_var: object variable
    | {expr_list}: obj_var: object variable
      | {name obj_var}: obj_var: object variable
      | {expr_list}: integer notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

SET X := obj_var IN ('foo', obj_var);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0010: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {name obj_var}: obj_var: object variable
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {name obj_var}

The statement ending at line XXXX

SET X := 'foo' IN ('foo', obj_var);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0009: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {strlit 'foo'}: text notnull
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}: obj_var: object variable
        | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := CASE obj_var WHEN obj_var THEN 2
ELSE 3
END;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {case_expr}: integer notnull
    | {name obj_var}: obj_var: object variable
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {name obj_var}: obj_var: object variable
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET obj_var := CASE 1 WHEN 1 THEN obj_var
ELSE NULL
END;

  {assign}: obj_var: object variable
  | {name obj_var}: obj_var: object variable
  | {case_expr}: object
    | {int 1}: integer notnull
    | {connector}: object
      | {case_list}: object variable
      | | {when}: obj_var: object variable
      |   | {int 1}: integer notnull
      |   | {name obj_var}: obj_var: object variable
      | {null}: null

The statement ending at line XXXX

SET X := obj_var BETWEEN 1 AND 3;

Error at test/sem_test.sql:XXXX : in str : CQL0072: first operand cannot be an object in 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {name obj_var}: obj_var: object variable
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN obj_var AND 3;

Error at test/sem_test.sql:XXXX : in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {name obj_var}: obj_var: object variable
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN 1 AND obj_var;

Error at test/sem_test.sql:XXXX : in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var NOT BETWEEN 1 AND 3;

Error at test/sem_test.sql:XXXX : in str : CQL0072: first operand cannot be an object in 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {name obj_var}: obj_var: object variable
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN obj_var AND 3;

Error at test/sem_test.sql:XXXX : in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {name obj_var}: obj_var: object variable
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN 1 AND obj_var;

Error at test/sem_test.sql:XXXX : in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET a_string := printf('Foo', obj_var);

Error at test/sem_test.sql:XXXX : in call : CQL0087: no object/blob types are allowed in arguments for function 'printf'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name printf}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: err
        | {strlit 'Foo'}: text notnull
        | {arg_list}
          | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

DECLARE FUNC creater_func () CREATE OBJECT NOT NULL;

  {declare_func_stmt}: object notnull create_func
  | {name creater_func}: object notnull create_func
  | {func_params_return}
    | {create}: object notnull create_func
      | {notnull}: object notnull
        | {type_object}: object

The statement ending at line XXXX

DECLARE FUNC maybe_create_func () CREATE OBJECT;

  {declare_func_stmt}: object create_func
  | {name maybe_create_func}: object create_func
  | {func_params_return}
    | {create}: object create_func
      | {type_object}: object

The statement ending at line XXXX

DECLARE not_null_object OBJECT NOT NULL;

  {declare_vars_type}: object notnull
  | {name_list}: not_null_object: object notnull variable
  | | {name not_null_object}: not_null_object: object notnull variable
  | {notnull}: object notnull
    | {type_object}: object

The statement ending at line XXXX

SET not_null_object := attest_notnull(obj_var);

  {assign}: not_null_object: object notnull variable
  | {name not_null_object}: not_null_object: object notnull variable
  | {call}: obj_var: object notnull variable
    | {name attest_notnull}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET not_null_object := attest_notnull(not_null_object);

Error at test/sem_test.sql:XXXX : in str : CQL0344: argument must be a nullable type (but not constant NULL) in 'attest_notnull'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable
  | {call}: err
    | {name attest_notnull}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name not_null_object}: not_null_object: object notnull variable

The statement ending at line XXXX

SET not_null_object := attest_notnull(NULL);

Error at test/sem_test.sql:XXXX : in null : CQL0344: argument must be a nullable type (but not constant NULL) in 'attest_notnull'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable
  | {call}: err
    | {name attest_notnull}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {null}: null

The statement ending at line XXXX

SET not_null_object := attest_notnull(1, 7);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'attest_notnull'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable
  | {call}: err
    | {name attest_notnull}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 7}: integer notnull

The statement ending at line XXXX

SET not_null_object := ( SELECT attest_notnull(1) );

Error at test/sem_test.sql:XXXX : in call : CQL0044: operator may only appear in the context of a SQL statement 'attest_notnull'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name attest_notnull}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ECHO c, 'foo\n';

  {echo_stmt}: ok
  | {name c}
  | {strlit 'foo\n'}

The statement ending at line XXXX

CREATE PROC invalid_echo ()
BEGIN
  @ECHO c, 'foo\n';
END;

Error at test/sem_test.sql:XXXX : in echo_stmt : CQL0224: literal output can only appear outside of procedures

  {create_proc_stmt}: err
  | {name invalid_echo}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {echo_stmt}: err
        | {name c}
        | {strlit 'foo\n'}

The statement ending at line XXXX

DECLARE foo_obj OBJECT<Foo>;

  {declare_vars_type}: object<Foo>
  | {name_list}: foo_obj: object<Foo> variable
  | | {name foo_obj}: foo_obj: object<Foo> variable
  | {type_object}: object<Foo>
    | {name Foo}

The statement ending at line XXXX

SET foo_obj := foo_obj;

  {assign}: foo_obj: object<Foo> variable
  | {name foo_obj}: foo_obj: object<Foo> variable
  | {name foo_obj}: foo_obj: object<Foo> variable

The statement ending at line XXXX

DECLARE FUNC foo_func () OBJECT<Foo>;

  {declare_func_stmt}: object<Foo>
  | {name foo_func}: object<Foo>
  | {func_params_return}
    | {type_object}: object<Foo>
      | {name Foo}

The statement ending at line XXXX

SET foo_obj := foo_func();

  {assign}: foo_obj: object<Foo> variable
  | {name foo_obj}: foo_obj: object<Foo> variable
  | {call}: object<Foo>
    | {name foo_func}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

DECLARE bar_obj OBJECT<Bar>;

  {declare_vars_type}: object<Bar>
  | {name_list}: bar_obj: object<Bar> variable
  | | {name bar_obj}: bar_obj: object<Bar> variable
  | {type_object}: object<Bar>
    | {name Bar}

The statement ending at line XXXX

SET bar_obj := foo_obj;

Error at test/sem_test.sql:XXXX : in str : CQL0070: incompatible object type 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
WHEN 2 THEN foo_obj
END;

Error at test/sem_test.sql:XXXX : in str : CQL0070: incompatible object type 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}: err
      | {case_list}: err
        | {when}: bar_obj: object<Bar> variable
        | | {int 1}: integer notnull
        | | {name bar_obj}: bar_obj: object<Bar> variable
        | {case_list}: err
          | {when}
            | {int 2}: integer notnull
            | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_object
WHEN 2 THEN foo_obj
END;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bar_object'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}: err
      | {case_list}: err
        | {when}
        | | {int 1}: integer notnull
        | | {name bar_object}: err
        | {case_list}
          | {when}
            | {int 2}
            | {name foo_obj}

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
ELSE foo_obj
END;

Error at test/sem_test.sql:XXXX : in str : CQL0070: incompatible object type 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: object<Bar> variable
      | | {when}: bar_obj: object<Bar> variable
      |   | {int 1}: integer notnull
      |   | {name bar_obj}: bar_obj: object<Bar> variable
      | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
ELSE foo_object
END;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'foo_object'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: object<Bar> variable
      | | {when}: bar_obj: object<Bar> variable
      |   | {int 1}: integer notnull
      |   | {name bar_obj}: bar_obj: object<Bar> variable
      | {name foo_object}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
WHEN 2 THEN bar_obj
ELSE bar_obj
END;

  {assign}: bar_obj: object<Bar> variable
  | {name bar_obj}: bar_obj: object<Bar> variable
  | {case_expr}: object<Bar>
    | {int 1}: integer notnull
    | {connector}: object<Bar>
      | {case_list}: object<Bar>
      | | {when}: bar_obj: object<Bar> variable
      | | | {int 1}: integer notnull
      | | | {name bar_obj}: bar_obj: object<Bar> variable
      | | {case_list}: bar_obj: object<Bar> variable
      |   | {when}: bar_obj: object<Bar> variable
      |     | {int 2}: integer notnull
      |     | {name bar_obj}: bar_obj: object<Bar> variable
      | {name bar_obj}: bar_obj: object<Bar> variable

The statement ending at line XXXX

CALL printf('%d', simple_func(NOT 'x'));

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {call_stmt}: err
  | {name printf}
  | {expr_list}: err
    | {strlit '%d'}: text notnull
    | {expr_list}
      | {call}: err
        | {name simple_func}
        | {call_arg_list}
          | {call_filter_clause}
          | {arg_list}: err
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, '2', 3);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit '2'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null }
        | {select_core_list}: values: { column1: null }
        | | {select_core}: values: { column1: null }
        |   | {select_values}
        |   | {values}: values: { column1: null }
        |     | {insert_list}
        |       | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(name) VALUES('x');

Error at test/sem_test.sql:XXXX : in insert_stmt : CQL0158: required column missing in INSERT statement 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(garbonzo) VALUES('x');

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'garbonzo'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}: err
      |   | {name garbonzo}: err
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, id) VALUES('x');

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}: err
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name id}: err
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO booly(id) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name booly}: booly: { id: integer has_default, flag: bool }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO MyView(id) VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0161: cannot insert into a view 'MyView'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO garbonzo(id) VALUES('x');

Error at test/sem_test.sql:XXXX : in str : CQL0160: table in insert statement does not exist 'garbonzo'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name garbonzo}
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {strlit 'x'}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE FUNC goo_func (goo OBJECT<Goo>) TEXT;

  {declare_func_stmt}: text
  | {name goo_func}: text
  | {func_params_return}
    | {params}: ok
    | | {param}: goo: object<Goo> variable in
    |   | {param_detail}: goo: object<Goo> variable in
    |     | {name goo}: goo: object<Goo> variable in
    |     | {type_object}: object<Goo>
    |       | {name Goo}
    | {type_text}: text

The statement ending at line XXXX

SET a_string := goo_func(bar_obj);

Error at test/sem_test.sql:XXXX : in str : CQL0070: incompatible object type 'Bar'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name goo_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name bar_obj}: err

The statement ending at line XXXX

SET a_string := goo_func(NOT 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name goo_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: err
        | {not}: err
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL, NULL);

Error at test/sem_test.sql:XXXX : in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null, column2: null }
        | {select_core_list}: values: { column1: null, column2: null }
        | | {select_core}: values: { column1: null, column2: null }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: null }
        |     | {insert_list}
        |       | {null}: null
        |       | {insert_list}
        |         | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NOT 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        |     | {insert_list}
        |       | {not}: err
        |         | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES('x');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: err
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: err
        |       | {strlit 'x'}: err
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TEMP VIEW temp_view AS
SELECT 1 AS A, 2 AS B;

  {create_view_stmt}: temp_view: { A: integer notnull, B: integer notnull }
  | {int 1}
  | {view_and_attrs}
    | {name_and_select}
      | {name temp_view}
      | {select_stmt}: temp_view: { A: integer notnull, B: integer notnull }
        | {select_core_list}: temp_view: { A: integer notnull, B: integer notnull }
        | | {select_core}: temp_view: { A: integer notnull, B: integer notnull }
        |   | {select_expr_list_con}: temp_view: { A: integer notnull, B: integer notnull }
        |     | {select_expr_list}: temp_view: { A: integer notnull, B: integer notnull }
        |     | | {select_expr}: A: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name A}
        |     | | {select_expr_list}
        |     |   | {select_expr}: B: integer notnull
        |     |     | {int 2}: integer notnull
        |     |     | {opt_as_alias}
        |     |       | {name B}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT;

  {alter_table_add_column_stmt}: ok
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name name}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT NOT NULL;

Error at test/sem_test.sql:XXXX : in col_def : CQL0147: adding a not nullable column with no default value is not allowed 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text notnull
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {col_attrs_not_null}: ok

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name INTEGER;

Error at test/sem_test.sql:XXXX : in col_def : CQL0149: added column must be an exact match for the column type declared in the table 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: integer
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name name}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN goo INTEGER;

Error at test/sem_test.sql:XXXX : in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'goo'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: goo: integer
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name goo}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN NAME TEXT;

Error at test/sem_test.sql:XXXX : in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'NAME'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: NAME: text
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name NAME}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN foo OBJECT;

Error at test/sem_test.sql:XXXX : in str : CQL0041: tables cannot have object columns 'foo'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name foo}
        | {type_object}: object

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

Error at test/sem_test.sql:XXXX : in col_def : CQL0146: adding an auto increment column is not allowed 'id'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: id: integer notnull primary_key autoinc
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}: integer
      | {col_attrs_pk}: ok
        | {col_attrs_autoinc}

The statement ending at line XXXX

ALTER TABLE garbonzo ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

Error at test/sem_test.sql:XXXX : in str : CQL0144: table in alter statement does not exist 'garbonzo'

  {alter_table_add_column_stmt}: err
  | {name garbonzo}
  | {col_def}
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}
      | {col_attrs_pk}
        | {col_attrs_autoinc}

The statement ending at line XXXX

ALTER TABLE MyView ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

Error at test/sem_test.sql:XXXX : in str : CQL0144: cannot alter a view 'MyView'

  {alter_table_add_column_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {col_def}
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}
      | {col_attrs_pk}
        | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE PROC bogus_version ()
BEGIN
  @SCHEMA_UPGRADE (11);
END;

Error at test/sem_test.sql:XXXX : in schema_upgrade_version_stmt : CQL0230: schema upgrade version declaration must be outside of any proc

  {create_proc_stmt}: err
  | {name bogus_version}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {schema_upgrade_version_stmt}: err
        | {int 11}

The statement ending at line XXXX

@SCHEMA_UPGRADE (11);

Error at test/sem_test.sql:XXXX : in schema_upgrade_version_stmt : CQL0231: schema upgrade version declaration must come before any tables are declared

  {schema_upgrade_version_stmt}: err
  | {int 11}

The statement ending at line XXXX

@SCHEMA_UPGRADE (0);

Error at test/sem_test.sql:XXXX : in schema_upgrade_version_stmt : CQL0228: schema upgrade version must be a positive integer

  {schema_upgrade_version_stmt}: err
  | {int 0}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(1, foo);

Error at test/sem_test.sql:XXXX : in col_def : CQL0145: version annotations not valid in alter statement 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text @create(1)
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: ok
        | {version_annotation}
          | {int 1}
          | {name foo}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @DELETE(1);

Error at test/sem_test.sql:XXXX : in col_def : CQL0145: version annotations not valid in alter statement 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text hidden @delete(1)
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {delete_attr}: ok
        | {version_annotation}
          | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @DELETE(1) @DELETE(1);

Error at test/sem_test.sql:XXXX : in delete_attr : CQL0026: duplicate version annotation

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {delete_attr}: err
        | {version_annotation}
        | | {int 1}
        | {delete_attr}: err
          | {version_annotation}
            | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(1) @CREATE(1);

Error at test/sem_test.sql:XXXX : in create_attr : CQL0026: duplicate version annotation

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: err
        | {version_annotation}
        | | {int 1}
        | {create_attr}: err
          | {version_annotation}
            | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(0);

Error at test/sem_test.sql:XXXX : in create_attr : CQL0025: version number in annotation must be positive

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: err
        | {version_annotation}
          | {int 0}

The statement ending at line XXXX

CREATE TABLE hides_id_not_name(
  id INTEGER @DELETE(2),
  name TEXT @CREATE(3)
);

  {create_table_stmt}: hides_id_not_name: { name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name hides_id_not_name}
  | {col_key_list}
    | {col_def}: id: integer hidden @delete(2)
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {delete_attr}: ok
    |     | {version_annotation}
    |       | {int 2}
    | {col_key_list}
      | {col_def}: name: text @create(3)
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name name}
          | | {type_text}: text
          | {create_attr}: ok
            | {version_annotation}
              | {int 3}

The statement ending at line XXXX

SELECT id
  FROM hides_id_not_name;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name id}: err
  |     | {select_from_etc}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {table_or_subquery_list}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | | {table_or_subquery}: TABLE { hides_id_not_name: hides_id_not_name }
  |       |   | {name hides_id_not_name}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM hides_id_not_name;

  {select_stmt}: select: { name: text }
  | {select_core_list}: select: { name: text }
  | | {select_core}: select: { name: text }
  |   | {select_expr_list_con}: select: { name: text }
  |     | {select_expr_list}: select: { name: text }
  |     | | {select_expr}: name: text
  |     |   | {name name}: name: text
  |     | {select_from_etc}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {table_or_subquery_list}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | | {table_or_subquery}: TABLE { hides_id_not_name: hides_id_not_name }
  |       |   | {name hides_id_not_name}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE migrate_test(
  id INTEGER NOT NULL,
  id2 INTEGER @CREATE(4, creator),
  id3 INTEGER @CREATE(4, creator)
);

Error at test/sem_test.sql:XXXX : in str : CQL0027: a procedure can appear in only one annotation 'creator'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_test}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: id2: integer @create(4)
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name id2}
      |   | | {type_int}: integer
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 4}
      |       | {name creator}
      | {col_key_list}
        | {col_def}: err
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name id3}
            | | {type_int}: integer
            | {create_attr}: err
              | {version_annotation}
                | {int 4}
                | {name creator}

The statement ending at line XXXX

CREATE PROC creator ()
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0187: @schema_upgrade_version not declared or doesn't match upgrade version 4 for proc 'creator'

  {create_proc_stmt}: err
  | {name creator}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken(
  col1 INTEGER,
  col2 INTEGER @CREATE(3),
  col3 INTEGER
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0032: created columns must be at the end and must be in version order 'col3'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: col2: integer @create(3)
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name col2}
      |   | | {type_int}: integer
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 3}
      | {col_key_list}
        | {col_def}: err
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name col3}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken_not_null_create(
  col1 INTEGER,
  col2 INTEGER NOT NULL @CREATE(3)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0034: create/delete version numbers can only be applied to columns that are nullable or have a default value 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken_not_null_create}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok
            | {create_attr}
              | {version_annotation}
                | {int 3}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken_not_null_delete(
  col1 INTEGER,
  col2 INTEGER NOT NULL @DELETE(3)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0034: create/delete version numbers can only be applied to columns that are nullable or have a default value 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken_not_null_delete}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok
            | {delete_attr}
              | {version_annotation}
                | {int 3}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_delete_out_of_order(
  col1 INTEGER,
  col2 INTEGER @DELETE(3) @CREATE(4)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0035: column delete version can't be <= column create version 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_delete_out_of_order}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {delete_attr}: ok
            | {version_annotation}
            | | {int 3}
            | {create_attr}
              | {version_annotation}
                | {int 4}

The statement ending at line XXXX

CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc);

  {create_table_stmt}: versioned_table: { id: integer } hidden @create(1) @delete(3)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | | {name table_create_proc}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 3}
  | |       | {name table_delete_proc}
  | | {name versioned_table}
  | {col_key_list}
    | {col_def}: id: integer @create(2)
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE bogus_migration_proc(
  id INTEGER
) @CREATE(1, x_crc);

Error at test/sem_test.sql:XXXX : in create_attr : CQL0338: the name of a migration procedure may not end in '_crc' 'x_crc'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}: err
  | |   | {version_annotation}
  | |     | {int 1}
  | |     | {name x_crc}
  | | {name bogus_migration_proc}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TABLE versioned_table_double_create(
  id INTEGER
) @CREATE(1) @CREATE(1);

Error at test/sem_test.sql:XXXX : in create_attr : CQL0026: duplicate version annotation

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | {create_attr}: err
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name versioned_table_double_create}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TABLE versioned_table_double_delete(
  id INTEGER
) @DELETE(1) @DELETE(1);

Error at test/sem_test.sql:XXXX : in delete_attr : CQL0026: duplicate version annotation

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | {delete_attr}: err
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name versioned_table_double_delete}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE INDEX index_broken ON versioned_table (id);

Error at test/sem_test.sql:XXXX : in str : CQL0019: create index table name not found (hidden by @delete) 'versioned_table'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_broken}
  | | {name versioned_table}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES versioned_table (id)
);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0021: foreign key refers to non-existent table (hidden by @delete) 'versioned_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name versioned_table}
          | | {name_list}
          |   | {name id}
          | {int 0}

The statement ending at line XXXX

SELECT *
  FROM versioned_table;

Error at test/sem_test.sql:XXXX : in table_or_subquery : CQL0095: table/view not defined (hidden by @delete) 'versioned_table'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name versioned_table}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

ALTER TABLE versioned_table ADD COLUMN id INTEGER;

  {alter_table_add_column_stmt}: ok
  | {name versioned_table}: versioned_table: { id: integer } hidden @create(1) @delete(3)
  | {col_def}: id: integer
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name id}
        | {type_int}: integer

The statement ending at line XXXX

DELETE FROM versioned_table;

Error at test/sem_test.sql:XXXX : in str : CQL0151: table in delete statement does not exist (hidden by @delete) 'versioned_table'

  {delete_stmt}: err
  | {name versioned_table}

The statement ending at line XXXX

INSERT INTO versioned_table VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0160: table in insert statement does not exist (hidden by @delete) 'versioned_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name versioned_table}
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO versioned_table(id) VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0160: table in insert statement does not exist (hidden by @delete) 'versioned_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name versioned_table}
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW versioned_table AS
SELECT 1 AS x;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc)
Error at test/sem_test.sql:XXXX : in create_view_stmt : CREATE VIEW versioned_table AS
SELECT 1 AS x
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0103: duplicate table/view name 'versioned_table'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name versioned_table}: err
      | {select_stmt}: versioned_table: { x: integer notnull }
        | {select_core_list}: versioned_table: { x: integer notnull }
        | | {select_core}: versioned_table: { x: integer notnull }
        |   | {select_expr_list_con}: versioned_table: { x: integer notnull }
        |     | {select_expr_list}: versioned_table: { x: integer notnull }
        |     | | {select_expr}: x: integer notnull
        |     |   | {int 1}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE versioned_table INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0198: global variable hides table/view name 'versioned_table'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name versioned_table}: err
  | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE versioned_table(
  id2 INTEGER
);

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc)
Error at test/sem_test.sql:XXXX : in create_table_stmt : CREATE TABLE versioned_table(
  id2 INTEGER
)
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0103: duplicate table/view name 'versioned_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name versioned_table}: err
  | {col_key_list}
    | {col_def}: id2: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id2}
          | {type_int}: integer

The statement ending at line XXXX

DROP TABLE IF EXISTS versioned_table;

  {drop_table_stmt}: ok
  | {int 1}
  | {name versioned_table}: versioned_table: { id: integer } hidden @create(1) @delete(3)

The statement ending at line XXXX

DROP TABLE garbonzo;

Error at test/sem_test.sql:XXXX : in str : CQL0108: table in drop statement does not exist 'garbonzo'

  {drop_table_stmt}: err
  | {name garbonzo}

The statement ending at line XXXX

DROP TABLE MyView;

Error at test/sem_test.sql:XXXX : in str : CQL0109: cannot drop a view with drop table 'MyView'

  {drop_table_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

CREATE PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;

  {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
  | {name uses_proc_for_result}: select: { id: integer notnull, name: text, rate: longint } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
        | {name with_result_set}: select: { id: integer notnull, name: text, rate: longint } dml_proc

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @DELETE(2)
) @CREATE(3);

Error at test/sem_test.sql:XXXX : in col_def : CQL0036: column delete version can't be <= the table create version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 3}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {delete_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @CREATE(2)
) @CREATE(3);

Error at test/sem_test.sql:XXXX : in col_def : CQL0038: column create version can't be <= the table create version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 3}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @DELETE(2)
) @DELETE(1);

Error at test/sem_test.sql:XXXX : in col_def : CQL0037: column delete version can't be >= the table delete version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {delete_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @CREATE(2)
) @DELETE(1);

Error at test/sem_test.sql:XXXX : in col_def : CQL0039: column create version can't be >= the table delete version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_delete_notnull(
  id INTEGER NOT NULL DEFAULT 8675309 @DELETE(2)
);

  {create_table_stmt}: t_col_delete_notnull: {  }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name t_col_delete_notnull}
  | {col_key_list}
    | {col_def}: id: integer notnull has_default hidden @delete(2)
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {int 8675309}
            | {delete_attr}
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

CREATE TABLE neg_default(
  id INTEGER NOT NULL DEFAULT -1 @CREATE(2)
);

  {create_table_stmt}: neg_default: { id: integer notnull has_default }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name neg_default}
  | {col_key_list}
    | {col_def}: id: integer notnull has_default @create(2)
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {uminus}
            | | {int 1}
            | {create_attr}
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

ALTER TABLE neg_default ADD COLUMN id INTEGER NOT NULL DEFAULT -1;

  {alter_table_add_column_stmt}: ok
  | {name neg_default}: neg_default: { id: integer notnull has_default }
  | {col_def}: id: integer notnull has_default
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}: integer
      | {col_attrs_not_null}: ok
        | {col_attrs_default}
          | {uminus}
            | {int 1}

The statement ending at line XXXX

CREATE PROC bogus_validate ()
BEGIN
  @PREVIOUS_SCHEMA;
END;

Error at test/sem_test.sql:XXXX : in previous_schema_stmt : CQL0225: switching to previous schema validation mode must be outside of any proc

  {create_proc_stmt}: err
  | {name bogus_validate}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {previous_schema_stmt}: err

The statement ending at line XXXX

CREATE PROC bogus_fetch ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM foo AS T1
    INNER JOIN foo AS T2 ON T1.id = T2.id;
  FETCH C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0180: duplicate column name in result not allowed 'id'

  {create_proc_stmt}: err
  | {name bogus_fetch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, id: integer notnull } variable
      | | {name C}: C: select: { id: integer notnull, id: integer notnull } variable
      | | {select_stmt}: select: { id: integer notnull, id: integer notnull }
      |   | {select_core_list}: select: { id: integer notnull, id: integer notnull }
      |   | | {select_core}: select: { id: integer notnull, id: integer notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
      |   |     | | {star}: select: { id: integer notnull, id: integer notnull }
      |   |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
      |   |       | {join_clause}: JOIN { T1: foo, T2: foo }
      |   |       | | {table_or_subquery}: TABLE { T1: foo }
      |   |       | | | {name foo}: TABLE { T1: foo }
      |   |       | | | {opt_as_alias}
      |   |       | |   | {name T1}
      |   |       | | {join_target_list}
      |   |       |   | {join_target}: JOIN { T1: foo, T2: foo }
      |   |       |     | {int 1}
      |   |       |     | {table_join}
      |   |       |       | {table_or_subquery}: TABLE { T2: foo }
      |   |       |       | | {name foo}: TABLE { T2: foo }
      |   |       |       | | {opt_as_alias}
      |   |       |       |   | {name T2}
      |   |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
      |   |       |         | {on}: bool notnull
      |   |       |         | {eq}: bool notnull
      |   |       |           | {dot}: id: integer notnull
      |   |       |           | | {name T1}
      |   |       |           | | {name id}
      |   |       |           | {dot}: id: integer notnull
      |   |       |             | {name T2}
      |   |       |             | {name id}
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE PROC bogus_result_duplicate_names ()
BEGIN
  SELECT *
    FROM foo AS T1
    INNER JOIN foo AS T2 ON T1.id = T2.id;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0180: duplicate column name in result not allowed 'id'

  {create_proc_stmt}: err
  | {name bogus_result_duplicate_names}: err
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer notnull, id: integer notnull }
        | {select_core_list}: select: { id: integer notnull, id: integer notnull }
        | | {select_core}: select: { id: integer notnull, id: integer notnull }
        |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
        |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
        |     | | {star}: select: { id: integer notnull, id: integer notnull }
        |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
        |       | {join_clause}: JOIN { T1: foo, T2: foo }
        |       | | {table_or_subquery}: TABLE { T1: foo }
        |       | | | {name foo}: TABLE { T1: foo }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { T1: foo, T2: foo }
        |       |     | {int 1}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { T2: foo }
        |       |       | | {name foo}: TABLE { T2: foo }
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
        |       |         | {on}: bool notnull
        |       |         | {eq}: bool notnull
        |       |           | {dot}: id: integer notnull
        |       |           | | {name T1}
        |       |           | | {name id}
        |       |           | {dot}: id: integer notnull
        |       |             | {name T2}
        |       |             | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE table_with_text_as_name(
  text TEXT,
  text2 TEXT
);

  {create_table_stmt}: table_with_text_as_name: { text: text, text2: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name table_with_text_as_name}
  | {col_key_list}
    | {col_def}: text: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name text}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: text2: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name text2}
            | {type_text}: text

The statement ending at line XXXX

SELECT text, text2
  FROM table_with_text_as_name;

  {select_stmt}: select: { text: text, text2: text }
  | {select_core_list}: select: { text: text, text2: text }
  | | {select_core}: select: { text: text, text2: text }
  |   | {select_expr_list_con}: select: { text: text, text2: text }
  |     | {select_expr_list}: select: { text: text, text2: text }
  |     | | {select_expr}: text: text
  |     | | | {name text}: text: text
  |     | | {select_expr_list}
  |     |   | {select_expr}: text2: text
  |     |     | {name text2}: text2: text
  |     | {select_from_etc}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {table_or_subquery_list}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | | {table_or_subquery}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       |   | {name table_with_text_as_name}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT text2 AS text, text AS other_text
  FROM table_with_text_as_name;

  {select_stmt}: select: { text: text, other_text: text }
  | {select_core_list}: select: { text: text, other_text: text }
  | | {select_core}: select: { text: text, other_text: text }
  |   | {select_expr_list_con}: select: { text: text, other_text: text }
  |     | {select_expr_list}: select: { text: text, other_text: text }
  |     | | {select_expr}: text: text
  |     | | | {name text2}: text2: text
  |     | | | {opt_as_alias}
  |     | |   | {name text}
  |     | | {select_expr_list}
  |     |   | {select_expr}: other_text: text
  |     |     | {name text}: text: text
  |     |     | {opt_as_alias}
  |     |       | {name other_text}
  |     | {select_from_etc}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {table_or_subquery_list}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | | {table_or_subquery}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       |   | {name table_with_text_as_name}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@SCHEMA_UPGRADE_SCRIPT;

Error at test/sem_test.sql:XXXX : in schema_upgrade_script_stmt : CQL0227: schema upgrade declaration must come before any tables are declared

  {schema_upgrade_script_stmt}: err

The statement ending at line XXXX

CREATE PROC schema_upgrade_you_wish ()
BEGIN
  @SCHEMA_UPGRADE_SCRIPT;
END;

Error at test/sem_test.sql:XXXX : in schema_upgrade_script_stmt : CQL0226: schema upgrade declaration must be outside of any proc

  {create_proc_stmt}: err
  | {name schema_upgrade_you_wish}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {schema_upgrade_script_stmt}: err

The statement ending at line XXXX

INSERT INTO hides_id_not_name(name) VALUES('x');

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name hides_id_not_name}: hides_id_not_name: { name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE trickier_alter_target(
  id INTEGER,
  something_deleted TEXT @CREATE(1) @DELETE(2),
  added TEXT @CREATE(2),
  PRIMARY KEY (id)
);

  {create_table_stmt}: trickier_alter_target: { id: integer notnull, added: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name trickier_alter_target}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: something_deleted: text hidden @create(1) @delete(2)
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name something_deleted}
      |   | | {type_text}: text
      |   | {create_attr}: ok
      |     | {version_annotation}
      |     | | {int 1}
      |     | {delete_attr}
      |       | {version_annotation}
      |         | {int 2}
      | {col_key_list}
        | {col_def}: added: text @create(2)
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |   | | {name added}
        |   | | {type_text}: text
        |   | {create_attr}: ok
        |     | {version_annotation}
        |       | {int 2}
        | {col_key_list}
          | {pk_def}
            | {name_list}
              | {name id}

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN id INTEGER;

Error at test/sem_test.sql:XXXX : in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'id'

  {alter_table_add_column_stmt}: err
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull, added: text }
  | {col_def}: id: integer
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name id}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN something_deleted TEXT;

Error at test/sem_test.sql:XXXX : in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'something_deleted'

  {alter_table_add_column_stmt}: err
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull, added: text }
  | {col_def}: something_deleted: text
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name something_deleted}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN added TEXT;

  {alter_table_add_column_stmt}: ok
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull, added: text }
  | {col_def}: added: text
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name added}
        | {type_text}: text

The statement ending at line XXXX

SELECT *
  FROM (SELECT NOT 'x' AS X);

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {select_stmt}: err
  |       |     | {select_core_list}: err
  |       |     | | {select_core}: err
  |       |     |   | {select_expr_list_con}: err
  |       |     |     | {select_expr_list}: err
  |       |     |     | | {select_expr}: err
  |       |     |     |   | {not}: err
  |       |     |     |   | | {strlit 'x'}: text notnull
  |       |     |     |   | {opt_as_alias}
  |       |     |     |     | {name X}
  |       |     |     | {select_from_etc}: ok
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW view_with_version AS
SELECT *
  FROM bar @DELETE(2);

  {create_view_stmt}: view_with_version: { id: integer notnull, name: text, rate: longint } hidden @delete(2)
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
    | | {name view_with_version}
    | | {select_stmt}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   | {select_core_list}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   | | {select_core}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |   | {select_expr_list_con}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | {select_expr_list}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | | {star}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | {select_from_etc}: TABLE { bar: bar }
    |   |       | {table_or_subquery_list}: TABLE { bar: bar }
    |   |       | | {table_or_subquery}: TABLE { bar: bar }
    |   |       |   | {name bar}: TABLE { bar: bar }
    |   |       | {select_where}
    |   |         | {select_groupby}
    |   |           | {select_having}
    |   | {select_orderby}
    |     | {select_limit}
    |       | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 2}

The statement ending at line XXXX

DECLARE ll LONG_INT NOT NULL;

  {declare_vars_type}: longint notnull
  | {name_list}: ll: longint notnull variable
  | | {name ll}: ll: longint notnull variable
  | {notnull}: longint notnull
    | {type_long}: longint

The statement ending at line XXXX

SET ll := 3147483647L;

  {assign}: ll: longint notnull variable
  | {name ll}: ll: longint notnull variable
  | {longint 3147483647}: longint notnull

The statement ending at line XXXX

DROP VIEW view_not_present;

Error at test/sem_test.sql:XXXX : in str : CQL0110: view in drop statement does not exist 'view_not_present'

  {drop_view_stmt}: err
  | {name view_not_present}

The statement ending at line XXXX

DROP VIEW foo;

Error at test/sem_test.sql:XXXX : in str : CQL0111: cannot drop a table with drop view 'foo'

  {drop_view_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

DROP VIEW IF EXISTS MyView;

  {drop_view_stmt}: ok
  | {int 1}
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

DROP INDEX index_1;

  {drop_index_stmt}: ok
  | {name index_1}

The statement ending at line XXXX

DROP INDEX IF EXISTS I_dont_see_no_steekin_index;

Error at test/sem_test.sql:XXXX : in str : CQL0112: index in drop statement was not declared 'I_dont_see_no_steekin_index'

  {drop_index_stmt}: err
  | {int 1}
  | {name I_dont_see_no_steekin_index}

The statement ending at line XXXX

CREATE TABLE two_not_null(
  id INTEGER NOT NULL UNIQUE NOT NULL
);

Error at test/sem_test.sql:XXXX : in col_attrs_not_null : CQL0030: a column attribute was specified twice on the same column 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_not_null}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: err
          | {col_attrs_unique}
            | {col_attrs_not_null}

The statement ending at line XXXX

CREATE TABLE mixed_pk_uk(
  id INTEGER PRIMARY KEY UNIQUE
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0031: column can't be primary key and also unique key 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name mixed_pk_uk}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_unique}

The statement ending at line XXXX

CREATE TABLE table_with_uk(
  id INTEGER UNIQUE
);

  {create_table_stmt}: table_with_uk: { id: integer unique_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name table_with_uk}
  | {col_key_list}
    | {col_def}: id: integer unique_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_unique}: ok

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  PRIMARY KEY (id)
);

Error at test/sem_test.sql:XXXX : in str : CQL0143: more than one primary key in table 'baz'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {pk_def}
        | {name_list}
          | {name id}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3) @DUMMY_SEED('x');

Error at test/sem_test.sql:XXXX : in str : CQL0156: seed expression must be a non-nullable integer

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: err
  |   | {strlit 'x'}: text notnull
  |   | {int 0}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {strlit 'bazzle'}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3) @DUMMY_SEED(NOT 'x');

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: err
  |   | {not}: err
  |   | | {strlit 'x'}: text notnull
  |   | {int 0}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {strlit 'bazzle'}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(_seed_, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(1 + 2) @DUMMY_DEFAULTS @DUMMY_NULLABLES;

  {insert_stmt}: ok
  | {insert_normal}
  | | {insert_dummy_spec}: integer notnull
  |   | {add}: integer notnull
  |   | | {int 1}: integer notnull
  |   | | {int 2}: integer notnull
  |   | {int 3}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {insert_list}
        | {name _seed_}: _seed_: integer notnull variable
        | {insert_list}
          | {call}: text notnull
          | | {name printf}: text notnull
          | | {call_arg_list}
          |   | {call_filter_clause}
          |   | {arg_list}: ok
          |     | {strlit 'name_%d'}: text notnull
          |     | {arg_list}
          |       | {name _seed_}: _seed_: integer notnull variable
          | {insert_list}
            | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

INSERT INTO booly(flag) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name booly}: booly: { id: integer has_default, flag: bool }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name flag}: flag: bool
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE blob_var BLOB;

  {declare_vars_type}: blob
  | {name_list}: blob_var: blob variable
  | | {name blob_var}: blob_var: blob variable
  | {type_blob}: blob

The statement ending at line XXXX

SET X := blob_var < 1;

Error at test/sem_test.sql:XXXX : in str : CQL0004: left operand cannot be a blob in '<'

  {assign}: err
  | {name X}: X: integer variable
  | {lt}: err
    | {name blob_var}: blob_var: blob variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 < blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0005: right operand cannot be a blob in '<'

  {assign}: err
  | {name X}: X: integer variable
  | {lt}: err
    | {int 1}: integer notnull
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var = blob_var;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {eq}: bool
    | {name blob_var}: blob_var: blob variable
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var <> blob_var;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {ne}: bool
    | {name blob_var}: blob_var: blob variable
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var + 1;

Error at test/sem_test.sql:XXXX : in str : CQL0004: left operand cannot be a blob in '+'

  {assign}: err
  | {name X}: X: integer variable
  | {add}: err
    | {name blob_var}: blob_var: blob variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 + blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0005: right operand cannot be a blob in '+'

  {assign}: err
  | {name X}: X: integer variable
  | {add}: err
    | {int 1}: integer notnull
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := NOT blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0048: blob operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable
  | {not}: err
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := -blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0045: blob operand not allowed in '-'

  {assign}: err
  | {name X}: X: integer variable
  | {uminus}: err
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET a_string := blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0009: incompatible types in expression 'a_string'

  {assign}: err
  | {name a_string}: err
  | {name blob_var}: err

The statement ending at line XXXX

SET blob_var := a_string;

Error at test/sem_test.sql:XXXX : in str : CQL0011: incompatible types in expression 'blob_var'

  {assign}: err
  | {name blob_var}: err
  | {name a_string}: err

The statement ending at line XXXX

SET a_string := blob_var || 2.0;

Error at test/sem_test.sql:XXXX : in concat : CQL0241: CONCAT may only appear in the context of a SQL statement

  {assign}: err
  | {name a_string}: a_string: text variable
  | {concat}: err
    | {name blob_var}: blob_var: blob variable
    | {dbl 2.0}: real notnull

The statement ending at line XXXX

SELECT blob_var || 2.0;

Error at test/sem_test.sql:XXXX : in str : CQL0243: blob operand must be converted to string first in '||'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {name blob_var}: blob_var: blob variable
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 || blob_var;

Error at test/sem_test.sql:XXXX : in str : CQL0243: blob operand must be converted to string first in '||'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {int 1}: integer notnull
  |     |     | {name blob_var}: blob_var: blob variable
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;

  {create_proc_stmt}: ok
  | {name blob_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_blob: blob variable out
    |   | {out}
    |   | {param_detail}: a_blob: blob variable out
    |     | {name a_blob}: a_blob: blob variable out
    |     | {type_blob}: blob
    | {stmt_list}: ok
      | {assign}: a_blob: blob variable out
        | {name a_blob}: a_blob: blob variable out
        | {null}: null

The statement ending at line XXXX

CREATE TABLE blob_table_test(
  b BLOB
);

  {create_table_stmt}: blob_table_test: { b: blob }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name blob_table_test}
  | {col_key_list}
    | {col_def}: b: blob
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name b}
          | {type_blob}: blob

The statement ending at line XXXX

SELECT blob_var;

  {select_stmt}: select: { blob_var: blob variable }
  | {select_core_list}: select: { blob_var: blob variable }
  | | {select_core}: select: { blob_var: blob variable }
  |   | {select_expr_list_con}: select: { blob_var: blob variable }
  |     | {select_expr_list}: select: { blob_var: blob variable }
  |     | | {select_expr}: blob_var: blob variable
  |     |   | {name blob_var}: blob_var: blob variable
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := blob_var IN (blob_var, NULL);

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {in_pred}: bool
    | {name blob_var}: blob_var: blob variable
    | {expr_list}: blob_var: blob variable
      | {name blob_var}: blob_var: blob variable
      | {expr_list}: null
        | {null}: null

The statement ending at line XXXX

SET X := blob_var IN (blob_var, 1);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0011: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {name blob_var}: blob_var: blob variable
    | {expr_list}: blob_var: blob variable
      | {name blob_var}: blob_var: blob variable
      | {expr_list}: integer notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

SET X := blob_var IN ('foo', blob_var);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0011: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {name blob_var}: blob_var: blob variable
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {name blob_var}

The statement ending at line XXXX

SET X := 'foo' IN ('foo', blob_var);

Error at test/sem_test.sql:XXXX : in in_pred : CQL0009: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable
  | {in_pred}: err
    | {strlit 'foo'}: text notnull
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}: blob_var: blob variable
        | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := CASE blob_var WHEN blob_var THEN 2
ELSE 3
END;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {case_expr}: integer notnull
    | {name blob_var}: blob_var: blob variable
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {name blob_var}: blob_var: blob variable
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET blob_var := CASE 1 WHEN 1 THEN blob_var
ELSE NULL
END;

  {assign}: blob_var: blob variable
  | {name blob_var}: blob_var: blob variable
  | {case_expr}: blob
    | {int 1}: integer notnull
    | {connector}: blob
      | {case_list}: blob variable
      | | {when}: blob_var: blob variable
      |   | {int 1}: integer notnull
      |   | {name blob_var}: blob_var: blob variable
      | {null}: null

The statement ending at line XXXX

SET X := blob_var BETWEEN 1 AND 3;

Error at test/sem_test.sql:XXXX : in str : CQL0071: first operand cannot be a blob in 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {name blob_var}: blob_var: blob variable
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN blob_var AND 3;

Error at test/sem_test.sql:XXXX : in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {name blob_var}: blob_var: blob variable
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN 1 AND blob_var;

Error at test/sem_test.sql:XXXX : in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var NOT BETWEEN 1 AND 3;

Error at test/sem_test.sql:XXXX : in str : CQL0071: first operand cannot be a blob in 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {name blob_var}: blob_var: blob variable
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN blob_var AND 3;

Error at test/sem_test.sql:XXXX : in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {name blob_var}: blob_var: blob variable
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN 1 AND blob_var;

Error at test/sem_test.sql:XXXX : in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET a_string := printf('Foo', blob_var);

Error at test/sem_test.sql:XXXX : in call : CQL0087: no object/blob types are allowed in arguments for function 'printf'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name printf}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: err
        | {strlit 'Foo'}: text notnull
        | {arg_list}
          | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

CREATE PROC bogus_object_read ()
BEGIN
  DECLARE o1, o2, o3 OBJECT;
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  FETCH C INTO o1, o2, o3;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0010: incompatible types in expression 'o1'

  {create_proc_stmt}: err
  | {name bogus_object_read}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: object
      | | {name_list}: o1: object variable
      | | | {name o1}: o1: object variable
      | | | {name_list}: o2: object variable
      | |   | {name o2}: o2: object variable
      | |   | {name_list}: o3: object variable
      | |     | {name o3}: o3: object variable
      | | {type_object}: object
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable
        | {name_list}
          | {name o1}: err
          | {name_list}
            | {name o2}
            | {name_list}
              | {name o3}

The statement ending at line XXXX

CREATE PROC fool (x INTEGER)
BEGIN
  SET x := x IN (SELECT 1);
END;

Error at test/sem_test.sql:XXXX : in in_pred : CQL0078: [not] in (select ...) is only allowed inside of select lists, where, on, and having clauses

  {create_proc_stmt}: err
  | {name fool}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name x}: x: integer variable in
        | {in_pred}: err
          | {name x}: x: integer variable in
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     |   | {int 1}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE PROC notfool (x INTEGER)
BEGIN
  SET x := x NOT IN (SELECT 1);
END;

Error at test/sem_test.sql:XXXX : in not_in : CQL0078: [not] in (select ...) is only allowed inside of select lists, where, on, and having clauses

  {create_proc_stmt}: err
  | {name notfool}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name x}: x: integer variable in
        | {not_in}: err
          | {name x}: x: integer variable in
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     |   | {int 1}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

INSERT INTO blob_table_test(b) VALUES(CAST(printf('b_%d', _seed_) AS BLOB)) @DUMMY_SEED(1) @DUMMY_NULLABLES;

  {insert_stmt}: ok
  | {insert_normal}
  | | {insert_dummy_spec}: integer notnull
  |   | {int 1}: integer notnull
  |   | {int 2}
  | {name_columns_values}
    | {name blob_table_test}: blob_table_test: { b: blob }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name b}: b: blob
      | {insert_list}
        | {cast_expr}: blob notnull
          | {call}: text notnull
          | | {name printf}: text notnull
          | | {call_arg_list}
          |   | {call_filter_clause}
          |   | {arg_list}: ok
          |     | {strlit 'b_%d'}: text notnull
          |     | {arg_list}
          |       | {name _seed_}: _seed_: integer notnull variable
          | {type_blob}: blob

The statement ending at line XXXX

CREATE PROC out_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
  | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC out_cursor_proc_not_auto_cursor ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C INTO a, b;
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in out_stmt : CQL0223: the cursor was not fetched with the auto-fetch syntax 'fetch [cursor]' 'C'

  {create_proc_stmt}: err
  | {name out_cursor_proc_not_auto_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name_list}
      |   | {name a}: a: integer notnull variable
      |   | {name_list}
      |     | {name b}: b: integer notnull variable
      | {out_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable

The statement ending at line XXXX

CREATE PROC out_cursor_proc_incompat_results ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  DECLARE D CURSOR FOR SELECT 1 AS A, 2 AS C;
  FETCH C;
  FETCH D;
  OUT C;
  OUT D;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0058: in multiple select statements, all column names must be identical so they have unambiguous names 'C'

  {create_proc_stmt}: err
  | {name out_cursor_proc_incompat_results}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: D: select: { A: integer notnull, C: integer notnull } variable
      | | {name D}: D: select: { A: integer notnull, C: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: C: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {fetch_stmt}: D: select: { A: integer notnull, C: integer notnull } variable auto_cursor
      | | {name D}: D: select: { A: integer notnull, C: integer notnull } variable auto_cursor
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {out_stmt}: err
        | {name D}: D: select: { A: integer notnull, C: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT C;
  SELECT 1 AS A, 2 AS B;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {select_stmt}: err
        | {select_core_list}: select: { A: integer notnull, B: integer notnull }
        | | {select_core}: select: { A: integer notnull, B: integer notnull }
        |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
        |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
        |     | | {select_expr}: A: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name A}
        |     | | {select_expr_list}
        |     |   | {select_expr}: B: integer notnull
        |     |     | {int 2}: integer notnull
        |     |     | {opt_as_alias}
        |     |       | {name B}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select_select_first ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  SELECT 1 AS A, 2 AS B;
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in out_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select_select_first'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select_select_first}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      | | | {select_core}: select: { A: integer notnull, B: integer notnull }
      | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      | |     | | {select_expr}: A: integer notnull
      | |     | | | {int 1}: integer notnull
      | |     | | | {opt_as_alias}
      | |     | |   | {name A}
      | |     | | {select_expr_list}
      | |     |   | {select_expr}: B: integer notnull
      | |     |     | {int 2}: integer notnull
      | |     |     | {opt_as_alias}
      | |     |       | {name B}
      | |     | {select_from_etc}: ok
      | |       | {select_where}
      | |         | {select_groupby}
      | |           | {select_having}
      | | {select_orderby}
      |   | {select_limit}
      |     | {select_offset}
      | {out_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select_then_union ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  SELECT 1 AS A, 2 AS B;
  OUT UNION C;
END;

Error at test/sem_test.sql:XXXX : in out_union_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select_then_union'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select_then_union}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor
      | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      | | | {select_core}: select: { A: integer notnull, B: integer notnull }
      | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      | |     | | {select_expr}: A: integer notnull
      | |     | | | {int 1}: integer notnull
      | |     | | | {opt_as_alias}
      | |     | |   | {name A}
      | |     | | {select_expr_list}
      | |     |   | {select_expr}: B: integer notnull
      | |     |     | {int 2}: integer notnull
      | |     |     | {opt_as_alias}
      | |     |       | {name B}
      | |     | {select_from_etc}: ok
      | |       | {select_where}
      | |         | {select_groupby}
      | |           | {select_having}
      | | {select_orderby}
      |   | {select_limit}
      |     | {select_offset}
      | {out_union_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC out_not_cursor ()
BEGIN
  DECLARE C INTEGER;
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'C'

  {create_proc_stmt}: err
  | {name out_not_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C: integer variable
      | | | {name C}: C: integer variable
      | | {type_int}: integer
      | {out_stmt}: err
        | {name C}: err

The statement ending at line XXXX

OUT curs;

Error at test/sem_test.sql:XXXX : in out_stmt : CQL0222: the out cursor statement only makes sense inside of a procedure

  {out_stmt}: err
  | {name curs}

The statement ending at line XXXX

CREATE PROC result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;

  {create_proc_stmt}: ok dml_proc
  | {name result_reader}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
          | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out

The statement ending at line XXXX

CREATE PROC fails_result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0215: value cursors are not used with FETCH C, or FETCH C INTO 'C'

  {create_proc_stmt}: err
  | {name fails_result_reader}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

DECLARE PROC declared_proc (id INTEGER) OUT (t TEXT);

  {declare_proc_stmt}: select: { t: text } uses_out
  | {proc_name_type}
  | | {name declared_proc}: select: { t: text } uses_out
  | | {int 5}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: select: { t: text }
      | {typed_name}: t: text
        | {name t}
        | {type_text}: t: text

The statement ending at line XXXX

CREATE PROC invalid_proc_fetch_bogus_call ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc(NOT 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name invalid_proc_fetch_bogus_call}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: err
        | {name C}
        | {call_stmt}: err
          | {name out_cursor_proc}
          | {expr_list}: err
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE PROC invalid_proc_fetch ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL xyzzy();
END;

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0203: cursor requires a procedure that returns a cursor with OUT 'C'

  {create_proc_stmt}: err
  | {name invalid_proc_fetch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: err
        | {name C}
        | {call_stmt}: err
          | {name xyzzy}: ok

The statement ending at line XXXX

CREATE PROC fails_result_reader_double_decl ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;

Error at test/sem_test.sql:XXXX : in declare_value_cursor : CQL0197: duplicate variable name in the same scope 'C'

  {create_proc_stmt}: err
  | {name fails_result_reader_double_decl}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {declare_value_cursor}: err
        | {name C}: err
        | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
          | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out

The statement ending at line XXXX

SET an_int := proc_with_output(1, an_int);

  {assign}: an_int: integer variable
  | {name an_int}: an_int: integer variable
  | {call}: integer
    | {name proc_with_output}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name an_int}: an_int: integer variable

The statement ending at line XXXX

CREATE PROC proc_func (IN arg1 INTEGER, OUT arg2 INTEGER)
BEGIN
  DROP TABLE foo;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc_func}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: integer variable out
    |     | {out}
    |     | {param_detail}: arg2: integer variable out
    |       | {name arg2}: arg2: integer variable out
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {drop_table_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

SET an_int := proc_func(DISTINCT 1);

Error at test/sem_test.sql:XXXX : in call : CQL0305: DISTINCT may only be used in function that are aggregated or user defined 'proc_func'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name proc_func}
    | {call_arg_list}
      | {call_filter_clause}
      | | {distinct}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET an_int := proc_with_output(1, an_int, an_int);

Error at test/sem_test.sql:XXXX : in call : CQL0235: too many arguments provided to procedure 'proc_with_output'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name proc_with_output}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name an_int}: an_int: integer variable
          | {arg_list}
            | {name an_int}: an_int: integer variable

The statement ending at line XXXX

SET an_int := out_cursor_proc();

Error at test/sem_test.sql:XXXX : in call : CQL0091: Stored procs that deal with result sets or cursors cannot be invoked as functions 'out_cursor_proc'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name out_cursor_proc}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SET an_int := proc2(1);

Error at test/sem_test.sql:XXXX : in param : CQL0211: last formal arg of procedure is not an out arg, cannot use proc as a function 'proc2'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name proc2}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET an_int := ( SELECT proc_with_output(1, an_int, an_int) );

Error at test/sem_test.sql:XXXX : in call : CQL0090: Stored proc calls may not appear in the context of a SQL statement 'proc_with_output'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name proc_with_output}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {name an_int}: an_int: integer variable
    |     |           | {arg_list}
    |     |             | {name an_int}: an_int: integer variable
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC dml_func (OUT a INTEGER NOT NULL)
BEGIN
  SET a := ( SELECT 1 );
END;

  {create_proc_stmt}: ok dml_proc
  | {name dml_func}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer notnull variable out
    |   | {out}
    |   | {param_detail}: a: integer notnull variable out
    |     | {name a}: a: integer notnull variable out
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: a: integer notnull variable out
        | {name a}: a: integer notnull variable out
        | {select_stmt}: _anon: integer notnull
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 1}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC should_be_dml (OUT a INTEGER NOT NULL)
BEGIN
  SET a := dml_func();
END;

  {create_proc_stmt}: ok dml_proc
  | {name should_be_dml}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer notnull variable out
    |   | {out}
    |   | {param_detail}: a: integer notnull variable out
    |     | {name a}: a: integer notnull variable out
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: a: integer notnull variable out
        | {name a}: a: integer notnull variable out
        | {call}: integer notnull
          | {name dml_func}
          | {call_arg_list}
            | {call_filter_clause}

The statement ending at line XXXX

CREATE PROC fetch_values ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, 2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC fetch_values_dummy ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(_seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values_dummy}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}
              | {name _seed_}: _seed_: integer notnull variable
              | {insert_list}
                | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_from_call ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

  {create_proc_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out value_cursor
  | {name fetch_from_call}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_call_stmt}: ok
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_that_does_not_exist ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL does_not_exist();
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0203: cursor requires a procedure that returns a cursor with OUT 'C'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_that_does_not_exist}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_call_stmt}: err
      | | {name C}
      | | {call_stmt}: err
      |   | {name does_not_exist}: ok
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_invalid_arguments ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc(42);
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0235: too many arguments provided to procedure 'out_cursor_proc'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_invalid_arguments}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_call_stmt}: err
      | | {name C}
      | | {call_stmt}: err
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {expr_list}: ok
      |     | {int 42}: integer notnull
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_invalid_cursor ()
BEGIN
  DECLARE C TEXT;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'C'
Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'C'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_invalid_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: text
      | | {name_list}: C: text variable
      | | | {name C}: C: text variable
      | | {type_text}: text
      | {fetch_call_stmt}: err
      | | {name C}: err
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {out_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_different_column_names ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2 AS C;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0058: in multiple select statements, all column names must be identical so they have unambiguous names 'B'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_different_column_names}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: C: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_call_stmt}: err
      | | {name C}: err
      | | {call_stmt}: err
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {out_stmt}: C: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

FETCH not_a_cursor FROM VALUES(1, 2, 3);

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_cursor'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name not_a_cursor}: err
    | {columns_values}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

FETCH my_cursor FROM VALUES(1, 2, 3);

Error at test/sem_test.sql:XXXX : in str : CQL0165: fetch values is only for value cursors, not for sqlite cursors 'my_cursor'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
    | {columns_values}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_seed_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C() FROM VALUES() @DUMMY_SEED(NOT 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_seed_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {insert_dummy_spec}: err
        | | {not}: err
        | | | {strlit 'x'}: text notnull
        | | {int 0}
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}

The statement ending at line XXXX

CREATE PROC fetch_values_missing_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES();
END;

Error at test/sem_test.sql:XXXX : in fetch_values_stmt : CQL0166: count of columns differs from count of values

  {create_proc_stmt}: err
  | {name fetch_values_missing_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
              | {name_list}
                | {name A}: A: integer notnull
                | {name_list}
                  | {name B}: B: integer notnull

The statement ending at line XXXX

CREATE PROC blob_out ()
BEGIN
  DECLARE C CURSOR FOR SELECT CASE WHEN 1 THEN CAST('x' AS BLOB)
  ELSE NULL
  END AS B;
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
  | {name blob_out}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { B: blob } variable
      | | {name C}: C: select: { B: blob } variable auto_cursor
      | | {select_stmt}: select: { B: blob }
      |   | {select_core_list}: select: { B: blob }
      |   | | {select_core}: select: { B: blob }
      |   |   | {select_expr_list_con}: select: { B: blob }
      |   |     | {select_expr_list}: select: { B: blob }
      |   |     | | {select_expr}: B: blob
      |   |     |   | {case_expr}: blob
      |   |     |   | | {connector}: blob
      |   |     |   |   | {case_list}: blob notnull
      |   |     |   |   | | {when}: blob notnull
      |   |     |   |   |   | {int 1}: integer notnull
      |   |     |   |   |   | {cast_expr}: blob notnull
      |   |     |   |   |     | {strlit 'x'}: text notnull
      |   |     |   |   |     | {type_blob}: blob
      |   |     |   |   | {null}: null
      |   |     |   | {opt_as_alias}
      |   |     |     | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { B: blob } variable auto_cursor
      | | {name C}: C: select: { B: blob } variable auto_cursor
      | {out_stmt}: C: select: { B: blob } variable auto_cursor
        | {name C}: C: select: { B: blob } variable auto_cursor

The statement ending at line XXXX

CREATE PROC fetch_values_blob_dummy ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL blob_out();
  FETCH C() FROM VALUES() @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;

Error at test/sem_test.sql:XXXX : in fetch_values_stmt : CQL0168: there's no good way to generate dummy blobs; not supported for now

  {create_proc_stmt}: err
  | {name fetch_values_blob_dummy}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { B: blob } variable auto_cursor value_cursor
      | | {name C}: C: select: { B: blob } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
      |   | {name blob_out}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: select: { B: blob } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}

The statement ending at line XXXX

CREATE PROC fetch_values_missing_columns ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A) FROM VALUES(1);
END;

Error at test/sem_test.sql:XXXX : in fetch_values_stmt : CQL0167: required column missing in FETCH statement 'B'

  {create_proc_stmt}: err
  | {name fetch_values_missing_columns}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            | {insert_list}
              | {int 1}

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, NOT 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {not}: err
                  | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_type ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'B'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {strlit 'x'}: err

The statement ending at line XXXX

CREATE PROC fetch_values_blob_dummy_with_null ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL blob_out();
  FETCH C(B) FROM VALUES(NULL) @DUMMY_SEED(123);
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values_blob_dummy_with_null}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: select: { B: blob } variable auto_cursor value_cursor
      | | {name C}: C: select: { B: blob } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
      |   | {name blob_out}: C: select: { B: blob } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 0}
        | {name_columns_values}
          | {name C}: C: select: { B: blob } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name B}: B: blob
            | {insert_list}
              | {null}: null

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
  OUT C1;
END;

  {create_proc_stmt}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor uses_out value_cursor
  | {name fetch_to_cursor_from_cursor}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_name}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_cursor_stmt}: ok
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | {out_stmt}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_invalid_cursor ()
BEGIN
  DECLARE C0 INTEGER;
  DECLARE C1 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  FETCH C1 FROM C0;
  OUT C1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'C0'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_invalid_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C0: integer variable
      | | | {name C0}: C0: integer variable
      | | {type_int}: integer
      | {declare_cursor_like_select}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_cursor_stmt}: err
      | | {name C1}
      | | {name C0}: err
      | {out_stmt}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_invalid_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 INTEGER;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'C1'

  {create_proc_stmt}: err
  | {name fetch_to_invalid_cursor_from_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_vars_type}: integer
      | | {name_list}: C1: integer variable
      | | | {name C1}: C1: integer variable
      | | {type_int}: integer
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_cursor_stmt}: err
        | {name C1}: err
        | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_statement_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0170: cursor must be a value cursor, not a statement cursor 'C1'

  {create_proc_stmt}: err
  | {name fetch_to_statement_cursor_from_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: C1: select: { A: integer notnull, B: integer notnull } variable
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_cursor_stmt}: err
        | {name C1}: err
        | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor_with_different_columns ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR LIKE SELECT 1 AS A, 2 AS C;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0058: in multiple select statements, all column names must be identical so they have unambiguous names 'B'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_cursor_with_different_columns}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_select}: C1: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor
      | | {name C1}: C1: select: { A: integer notnull, C: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: C: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_cursor_stmt}: err
        | {name C1}: err
        | {name C0}: err

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor_without_fields ()
BEGIN
  DECLARE X INTEGER;
  DECLARE Y REAL;
  DECLARE C0 CURSOR FOR SELECT 1 AS A, 2.5;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0 INTO X, Y;
  FETCH C1 FROM C0;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0169: cannot fetch from a cursor without fields 'C0'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_cursor_without_fields}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: X: integer variable
      | | | {name X}: X: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: real
      | | {name_list}: Y: real variable
      | | | {name Y}: Y: real variable
      | | {type_real}: real
      | {declare_cursor}: C0: select: { A: integer notnull, _anon: real notnull } variable
      | | {name C0}: C0: select: { A: integer notnull, _anon: real notnull } variable
      | | {select_stmt}: select: { A: integer notnull, _anon: real notnull }
      |   | {select_core_list}: select: { A: integer notnull, _anon: real notnull }
      |   | | {select_core}: select: { A: integer notnull, _anon: real notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, _anon: real notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, _anon: real notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: real notnull
      |   |     |     | {dbl 2.5}: real notnull
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_name}: C1: select: { A: integer notnull, _anon: real notnull } variable auto_cursor value_cursor
      | | {name C1}: C1: select: { A: integer notnull, _anon: real notnull } variable auto_cursor value_cursor
      | | {like}: C0: select: { A: integer notnull, _anon: real notnull } variable
      |   | {name C0}: C0: select: { A: integer notnull, _anon: real notnull } variable
      | {fetch_stmt}: C0: select: { A: integer notnull, _anon: real notnull } variable
      | | {name C0}: C0: select: { A: integer notnull, _anon: real notnull } variable
      | | {name_list}
      |   | {name X}: X: integer variable
      |   | {name_list}
      |     | {name Y}: Y: real variable
      | {fetch_cursor_stmt}: err
        | {name C1}
        | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_cursor ()
BEGIN
  DECLARE C0 CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C1 CURSOR LIKE C0;
END;

  {create_proc_stmt}: ok dml_proc
  | {name declare_cursor_like_cursor}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {declare_cursor_like_name}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {like}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
          | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC declare_cursor_like_non_cursor_variable ()
BEGIN
  DECLARE C0 INTEGER;
  DECLARE C1 CURSOR LIKE C0;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0200: variable is not a cursor 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_non_cursor_variable}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C0: integer variable
      | | | {name C0}: C0: integer variable
      | | {type_int}: integer
      | {declare_cursor_like_name}: err
        | {name C1}
        | {like}: err
          | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_cursor_with_same_name ()
BEGIN
  DECLARE C0 CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C0 CURSOR LIKE C0;
END;

Error at test/sem_test.sql:XXXX : in declare_cursor_like_name : CQL0197: duplicate variable name in the same scope 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_cursor_with_same_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {declare_cursor_like_name}: err
        | {name C0}: err
        | {like}
          | {name C0}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_undefined_variable ()
BEGIN
  DECLARE C1 CURSOR LIKE C0;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_undefined_variable}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: err
        | {name C1}
        | {like}: err
          | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_proc ()
BEGIN
  DECLARE C CURSOR LIKE decl3;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_proc}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: bool } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: bool } variable auto_cursor value_cursor
        | {like}: select: { A: integer notnull, B: bool } dml_proc
          | {name decl3}: select: { A: integer notnull, B: bool } dml_proc

The statement ending at line XXXX

CREATE PROC declare_cursor_like_proc_with_no_result ()
BEGIN
  DECLARE C CURSOR LIKE decl1;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0178: proc has no result 'decl1'

  {create_proc_stmt}: err
  | {name declare_cursor_like_proc_with_no_result}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: err
        | {name C}
        | {like}: err
          | {name decl1}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_table ()
BEGIN
  DECLARE C CURSOR LIKE bar;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_table}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
        | {like}: bar: { id: integer notnull, name: text, rate: longint }
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }

The statement ending at line XXXX

CREATE PROC declare_cursor_like_view ()
BEGIN
  DECLARE C CURSOR LIKE MyView;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_view}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull } variable auto_cursor value_cursor
        | {like}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
          | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

CREATE PROC declare_cursor_like_select ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2.5 AS B, 'x' AS C;
  FETCH C(A, B, C) FROM VALUES(_seed_, _seed_, printf('C_%d', _seed_)) @DUMMY_SEED(123);
  OUT C;
END;

  {create_proc_stmt}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor uses_out value_cursor
  | {name declare_cursor_like_select}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   | | {select_core}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: real notnull
      |   |     |   | | {dbl 2.5}: real notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: text notnull
      |   |     |       | {strlit 'x'}: text notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {insert_dummy_spec}: integer notnull
      | | | {int 123}: integer notnull
      | | | {int 0}
      | | {name_columns_values}
      |   | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: real notnull
      |     |     | {name_list}
      |     |       | {name C}: C: text notnull
      |     | {insert_list}
      |       | {name _seed_}: _seed_: integer notnull variable
      |       | {insert_list}
      |         | {name _seed_}: _seed_: integer notnull variable
      |         | {insert_list}
      |           | {call}: text notnull
      |             | {name printf}: text notnull
      |             | {call_arg_list}
      |               | {call_filter_clause}
      |               | {arg_list}: ok
      |                 | {strlit 'C_%d'}: text notnull
      |                 | {arg_list}
      |                   | {name _seed_}: _seed_: integer notnull variable
      | {out_stmt}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

DECLARE some_cursor CURSOR LIKE SELECT 1 AS A, 2.5 AS B, NOT 'x' AS C;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {declare_cursor_like_select}: err
  | {name some_cursor}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: A: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name A}
    |     | | {select_expr_list}
    |     |   | {select_expr}: B: real notnull
    |     |   | | {dbl 2.5}: real notnull
    |     |   | | {opt_as_alias}
    |     |   |   | {name B}
    |     |   | {select_expr_list}
    |     |     | {select_expr}: err
    |     |       | {not}: err
    |     |       | | {strlit 'x'}: text notnull
    |     |       | {opt_as_alias}
    |     |         | {name C}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE X CURSOR LIKE SELECT 1 AS A, 2.5 AS B, 'x' AS C;

Error at test/sem_test.sql:XXXX : in declare_cursor_like_select : CQL0197: duplicate variable name in the same scope 'X'

  {declare_cursor_like_select}: err
  | {name X}: err
  | {select_stmt}: select: { A: integer notnull, B: real notnull, C: text notnull }
    | {select_core_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
    | | {select_core}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |     | {select_expr_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |     | | {select_expr}: A: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name A}
    |     | | {select_expr_list}
    |     |   | {select_expr}: B: real notnull
    |     |   | | {dbl 2.5}: real notnull
    |     |   | | {opt_as_alias}
    |     |   |   | {name B}
    |     |   | {select_expr_list}
    |     |     | {select_expr}: C: text notnull
    |     |       | {strlit 'x'}: text notnull
    |     |       | {opt_as_alias}
    |     |         | {name C}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT rowid
  FROM foo;

  {select_stmt}: select: { rowid: longint notnull }
  | {select_core_list}: select: { rowid: longint notnull }
  | | {select_core}: select: { rowid: longint notnull }
  |   | {select_expr_list_con}: select: { rowid: longint notnull }
  |     | {select_expr_list}: select: { rowid: longint notnull }
  |     | | {select_expr}: rowid: longint notnull
  |     |   | {name rowid}: rowid: longint notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.rowid
  FROM foo AS T1,
bar AS T2;

  {select_stmt}: select: { rowid: longint notnull }
  | {select_core_list}: select: { rowid: longint notnull }
  | | {select_core}: select: { rowid: longint notnull }
  |   | {select_expr_list_con}: select: { rowid: longint notnull }
  |     | {select_expr_list}: select: { rowid: longint notnull }
  |     | | {select_expr}: rowid: longint notnull
  |     |   | {dot}: rowid: longint notnull
  |     |     | {name T1}
  |     |     | {name rowid}
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {table_or_subquery_list}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: TABLE { T2: bar }
  |       |   | {table_or_subquery}: TABLE { T2: bar }
  |       |     | {name bar}: TABLE { T2: bar }
  |       |     | {opt_as_alias}
  |       |       | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.rowid
  FROM foo AS T2,
foo AS T3;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name T1}
  |     |     | {name rowid}
  |     | {select_from_etc}: JOIN { T2: foo, T3: foo }
  |       | {table_or_subquery_list}: JOIN { T2: foo, T3: foo }
  |       | | {table_or_subquery}: TABLE { T2: foo }
  |       | | | {name foo}: TABLE { T2: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T2}
  |       | | {table_or_subquery_list}: TABLE { T3: foo }
  |       |   | {table_or_subquery}: TABLE { T3: foo }
  |       |     | {name foo}: TABLE { T3: foo }
  |       |     | {opt_as_alias}
  |       |       | {name T3}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT rowid
  FROM foo AS T1,
foo AS T2;

Error at test/sem_test.sql:XXXX : in str : CQL0066: identifier is ambiguous 'rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name rowid}: err
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {table_or_subquery_list}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: TABLE { T2: foo }
  |       |   | {table_or_subquery}: TABLE { T2: foo }
  |       |     | {name foo}: TABLE { T2: foo }
  |       |     | {opt_as_alias}
  |       |       | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC value_result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL declare_cursor_like_select();
END;

  {create_proc_stmt}: ok
  | {name value_result_reader}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor value_cursor
        | {call_stmt}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor uses_out value_cursor
          | {name declare_cursor_like_select}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable auto_cursor uses_out value_cursor

The statement ending at line XXXX

@ATTRIBUTE(foo)
@ATTRIBUTE(goo)
@ATTRIBUTE(num=-9)
CREATE TABLE misc_attr_table(
  @ATTRIBUTE(bar=baz)
  id INTEGER NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |   | | {name goo}
  |   | {misc_attrs}
  |     | {misc_attr}
  |       | {name num}
  |       | {uminus}
  |         | {int 9}
  | {create_table_stmt}: misc_attr_table: { id: integer notnull }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name misc_attr_table}
    | {col_key_list}
      | {col_def}: id: integer notnull
        | {col_def_type_attrs}
        | | {col_def_name_type}
        | | | {name id}
        | | | {type_int}: integer
        | | {col_attrs_not_null}: ok
        | {misc_attrs}
          | {misc_attr}
            | {name bar}
            | {name baz}

The statement ending at line XXXX

CREATE UNIQUE INDEX IF NOT EXISTS my_unique_index ON bar (id ASC, name DESC, rate);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name my_unique_index}
  | | {name bar}
  | {flags_names_attrs}
    | {int 3}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
        | | {name id}: id: integer notnull
        | | {asc}
        | {indexed_columns}
          | {indexed_column}
          | | {name name}: name: text
          | | {desc}
          | {indexed_columns}
            | {indexed_column}
              | {name rate}: rate: longint

The statement ending at line XXXX

UPDATE This_Table_Does_Not_Exist
SET x = 1;

Error at test/sem_test.sql:XXXX : in str : CQL0154: table in update statement does not exist 'This_Table_Does_Not_Exist'

  {update_stmt}: err
  | {name This_Table_Does_Not_Exist}
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name x}
    |   | {int 1}
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

CREATE TABLE fk_on_col(
  fk_src INTEGER REFERENCES foo (id) ON UPDATE CASCADE ON DELETE SET NULL
);

  {create_table_stmt}: fk_on_col: { fk_src: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_on_col}
  | {col_key_list}
    | {col_def}: fk_src: integer foreign_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 49}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (id, name) ON UPDATE CASCADE ON DELETE SET NULL
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0028: the FK reference must be exactly one column with the correct type 'fk_src'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            | {int 49}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (name)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0028: the FK reference must be exactly one column with the correct type 'fk_src'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}
            |   | {name name}: name: text
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES no_such_table (name)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0021: foreign key refers to non-existent table 'no_such_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name no_such_table}
            | | {name_list}
            |   | {name name}
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (no_such_column)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'no_such_column'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}: err
            |   | {name no_such_column}: err
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_autoinc_type(
  id BOOL PRIMARY KEY AUTOINCREMENT
);

Error at test/sem_test.sql:XXXX : in col_attrs_autoinc : CQL0029: autoincrement column must be [LONG_]INTEGER PRIMARY KEY 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_autoinc_type}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_bool}: bool
        | {col_attrs_pk}: err
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE bogus_without_rowid(
  id INTEGER PRIMARY KEY AUTOINCREMENT
) WITHOUT ROWID;

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0141: table has an AUTOINCREMENT column; it cannot also be WITHOUT ROWID 'bogus_without_rowid'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name bogus_without_rowid}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE recreatable(
  id INTEGER PRIMARY KEY,
  name TEXT
) @RECREATE;

  {create_table_stmt}: recreatable: { id: integer notnull primary_key, name: text } @recreate
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE column_marked_delete_on_recreate_table(
  id INTEGER PRIMARY KEY @CREATE(2),
  name TEXT
) @RECREATE;

Error at test/sem_test.sql:XXXX : in col_def : CQL0033: columns in a table marked @recreate cannot have @create or @delete 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name column_marked_delete_on_recreate_table}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {create_attr}
    |       | {version_annotation}
    |         | {int 2}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE PROC cte_test ()
BEGIN
  WITH
  should_not_conflict (a, b) AS (SELECT 111, 222)
  SELECT *
    FROM should_not_conflict;
  WITH
  should_not_conflict (a, b) AS (SELECT 111, 222)
  SELECT *
    FROM should_not_conflict;
END;

  {create_proc_stmt}: select: { a: integer notnull, b: integer notnull } dml_proc
  | {name cte_test}: select: { a: integer notnull, b: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
      | | {with}
      | | | {cte_tables}: ok
      | |   | {cte_table}: should_not_conflict: { a: integer notnull, b: integer notnull }
      | |     | {cte_decl}: should_not_conflict: { a: integer notnull, b: integer notnull }
      | |     | | {name should_not_conflict}
      | |     | | {name_list}
      | |     |   | {name a}
      | |     |   | {name_list}
      | |     |     | {name b}
      | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |     | | {select_expr}: integer notnull
      | |       |     | | | {int 111}: integer notnull
      | |       |     | | {select_expr_list}
      | |       |     |   | {select_expr}: integer notnull
      | |       |     |     | {int 222}: integer notnull
      | |       |     | {select_from_etc}: ok
      | |       |       | {select_where}
      | |       |         | {select_groupby}
      | |       |           | {select_having}
      | |       | {select_orderby}
      | |         | {select_limit}
      | |           | {select_offset}
      | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
      |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
      |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
      |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
      |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
      |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
      |   |     | {select_from_etc}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | {table_or_subquery_list}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | | {table_or_subquery}: TABLE { should_not_conflict: should_not_conflict }
      |   |       |   | {name should_not_conflict}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: should_not_conflict: { a: integer notnull, b: integer notnull }
        |     | {cte_decl}: should_not_conflict: { a: integer notnull, b: integer notnull }
        |     | | {name should_not_conflict}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 111}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: integer notnull
        |       |     |     | {int 222}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { a: integer notnull, b: integer notnull }
          | {select_core_list}: select: { a: integer notnull, b: integer notnull }
          | | {select_core}: select: { a: integer notnull, b: integer notnull }
          |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
          |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
          |     | | {star}: select: { a: integer notnull, b: integer notnull }
          |     | {select_from_etc}: TABLE { should_not_conflict: should_not_conflict }
          |       | {table_or_subquery_list}: TABLE { should_not_conflict: should_not_conflict }
          |       | | {table_or_subquery}: TABLE { should_not_conflict: should_not_conflict }
          |       |   | {name should_not_conflict}: TABLE { should_not_conflict: should_not_conflict }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_form ()
BEGIN
  WITH
  x (a, b, c) AS (SELECT 12, 'foo', 35L)
  INSERT INTO bar(id, name, rate) VALUES(ifnull(( SELECT a
    FROM x ), 0), ifnull(( SELECT b
    FROM x ), 'foo'), ifnull(( SELECT 1L AS c
    WHERE 0 ), 0));
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_insert_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_insert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | {cte_decl}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     |     | {name_list}
        |     |       | {name c}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 12}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: text notnull
        |       |     |   | | {strlit 'foo'}: text notnull
        |       |     |   | {select_expr_list}
        |       |     |     | {select_expr}: longint notnull
        |       |     |       | {longint 35}: longint notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: ok
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}: id: integer notnull
              |   | {name_list}
              |     | {name name}: name: text
              |     | {name_list}
              |       | {name rate}: rate: longint
              | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |   | {select_values}
                |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |     | {insert_list}
                |       | {call}: integer notnull
                |       | | {name ifnull}
                |       | | {call_arg_list}
                |       |   | {call_filter_clause}
                |       |   | {arg_list}: ok
                |       |     | {select_stmt}: a: integer
                |       |     | | {select_core_list}: select: { a: integer notnull }
                |       |     | | | {select_core}: select: { a: integer notnull }
                |       |     | |   | {select_expr_list_con}: select: { a: integer notnull }
                |       |     | |     | {select_expr_list}: select: { a: integer notnull }
                |       |     | |     | | {select_expr}: a: integer notnull
                |       |     | |     |   | {name a}: a: integer notnull
                |       |     | |     | {select_from_etc}: TABLE { x: x }
                |       |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |       |     | |       | | {table_or_subquery}: TABLE { x: x }
                |       |     | |       |   | {name x}: TABLE { x: x }
                |       |     | |       | {select_where}
                |       |     | |         | {select_groupby}
                |       |     | |           | {select_having}
                |       |     | | {select_orderby}
                |       |     |   | {select_limit}
                |       |     |     | {select_offset}
                |       |     | {arg_list}
                |       |       | {int 0}: integer notnull
                |       | {insert_list}
                |         | {call}: text notnull
                |         | | {name ifnull}
                |         | | {call_arg_list}
                |         |   | {call_filter_clause}
                |         |   | {arg_list}: ok
                |         |     | {select_stmt}: b: text
                |         |     | | {select_core_list}: select: { b: text notnull }
                |         |     | | | {select_core}: select: { b: text notnull }
                |         |     | |   | {select_expr_list_con}: select: { b: text notnull }
                |         |     | |     | {select_expr_list}: select: { b: text notnull }
                |         |     | |     | | {select_expr}: b: text notnull
                |         |     | |     |   | {name b}: b: text notnull
                |         |     | |     | {select_from_etc}: TABLE { x: x }
                |         |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |         |     | |       | | {table_or_subquery}: TABLE { x: x }
                |         |     | |       |   | {name x}: TABLE { x: x }
                |         |     | |       | {select_where}
                |         |     | |         | {select_groupby}
                |         |     | |           | {select_having}
                |         |     | | {select_orderby}
                |         |     |   | {select_limit}
                |         |     |     | {select_offset}
                |         |     | {arg_list}
                |         |       | {strlit 'foo'}: text notnull
                |         | {insert_list}
                |           | {call}: longint notnull
                |             | {name ifnull}
                |             | {call_arg_list}
                |               | {call_filter_clause}
                |               | {arg_list}: ok
                |                 | {select_stmt}: c: longint
                |                 | | {select_core_list}: select: { c: longint notnull }
                |                 | | | {select_core}: select: { c: longint notnull }
                |                 | |   | {select_expr_list_con}: select: { c: longint notnull }
                |                 | |     | {select_expr_list}: select: { c: longint notnull }
                |                 | |     | | {select_expr}: c: longint notnull
                |                 | |     |   | {longint 1}: longint notnull
                |                 | |     |   | {opt_as_alias}
                |                 | |     |     | {name c}
                |                 | |     | {select_from_etc}: ok
                |                 | |       | {select_where}
                |                 | |         | {opt_where}: integer notnull
                |                 | |         | | {int 0}: integer notnull
                |                 | |         | {select_groupby}
                |                 | |           | {select_having}
                |                 | | {select_orderby}
                |                 |   | {select_limit}
                |                 |     | {select_offset}
                |                 | {arg_list}
                |                   | {int 0}: integer notnull
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_column_spec_form ()
BEGIN
  WITH
  x (a, b, c) AS (SELECT 12, 'foo', 35L)
  INSERT INTO bar(id, name, rate) VALUES(ifnull(( SELECT a
    FROM x ), 0), ifnull(( SELECT b
    FROM x ), 'foo'), ifnull(( SELECT 1L AS c
    WHERE 0 ), 0));
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_column_spec_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_insert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | {cte_decl}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     |     | {name_list}
        |     |       | {name c}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 12}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: text notnull
        |       |     |   | | {strlit 'foo'}: text notnull
        |       |     |   | {select_expr_list}
        |       |     |     | {select_expr}: longint notnull
        |       |     |       | {longint 35}: longint notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: ok
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}: id: integer notnull
              |   | {name_list}
              |     | {name name}: name: text
              |     | {name_list}
              |       | {name rate}: rate: longint
              | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |   | {select_values}
                |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |     | {insert_list}
                |       | {call}: integer notnull
                |       | | {name ifnull}
                |       | | {call_arg_list}
                |       |   | {call_filter_clause}
                |       |   | {arg_list}: ok
                |       |     | {select_stmt}: a: integer
                |       |     | | {select_core_list}: select: { a: integer notnull }
                |       |     | | | {select_core}: select: { a: integer notnull }
                |       |     | |   | {select_expr_list_con}: select: { a: integer notnull }
                |       |     | |     | {select_expr_list}: select: { a: integer notnull }
                |       |     | |     | | {select_expr}: a: integer notnull
                |       |     | |     |   | {name a}: a: integer notnull
                |       |     | |     | {select_from_etc}: TABLE { x: x }
                |       |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |       |     | |       | | {table_or_subquery}: TABLE { x: x }
                |       |     | |       |   | {name x}: TABLE { x: x }
                |       |     | |       | {select_where}
                |       |     | |         | {select_groupby}
                |       |     | |           | {select_having}
                |       |     | | {select_orderby}
                |       |     |   | {select_limit}
                |       |     |     | {select_offset}
                |       |     | {arg_list}
                |       |       | {int 0}: integer notnull
                |       | {insert_list}
                |         | {call}: text notnull
                |         | | {name ifnull}
                |         | | {call_arg_list}
                |         |   | {call_filter_clause}
                |         |   | {arg_list}: ok
                |         |     | {select_stmt}: b: text
                |         |     | | {select_core_list}: select: { b: text notnull }
                |         |     | | | {select_core}: select: { b: text notnull }
                |         |     | |   | {select_expr_list_con}: select: { b: text notnull }
                |         |     | |     | {select_expr_list}: select: { b: text notnull }
                |         |     | |     | | {select_expr}: b: text notnull
                |         |     | |     |   | {name b}: b: text notnull
                |         |     | |     | {select_from_etc}: TABLE { x: x }
                |         |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |         |     | |       | | {table_or_subquery}: TABLE { x: x }
                |         |     | |       |   | {name x}: TABLE { x: x }
                |         |     | |       | {select_where}
                |         |     | |         | {select_groupby}
                |         |     | |           | {select_having}
                |         |     | | {select_orderby}
                |         |     |   | {select_limit}
                |         |     |     | {select_offset}
                |         |     | {arg_list}
                |         |       | {strlit 'foo'}: text notnull
                |         | {insert_list}
                |           | {call}: longint notnull
                |             | {name ifnull}
                |             | {call_arg_list}
                |               | {call_filter_clause}
                |               | {arg_list}: ok
                |                 | {select_stmt}: c: longint
                |                 | | {select_core_list}: select: { c: longint notnull }
                |                 | | | {select_core}: select: { c: longint notnull }
                |                 | |   | {select_expr_list_con}: select: { c: longint notnull }
                |                 | |     | {select_expr_list}: select: { c: longint notnull }
                |                 | |     | | {select_expr}: c: longint notnull
                |                 | |     |   | {longint 1}: longint notnull
                |                 | |     |   | {opt_as_alias}
                |                 | |     |     | {name c}
                |                 | |     | {select_from_etc}: ok
                |                 | |       | {select_where}
                |                 | |         | {opt_where}: integer notnull
                |                 | |         | | {int 0}: integer notnull
                |                 | |         | {select_groupby}
                |                 | |           | {select_having}
                |                 | | {select_orderby}
                |                 |   | {select_limit}
                |                 |     | {select_offset}
                |                 | {arg_list}
                |                   | {int 0}: integer notnull
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_bogus_cte ()
BEGIN
  WITH
  x (a) AS (SELECT NOT 'x')
  INSERT INTO bar(id, name, rate) VALUES(1, 'x', 2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_insert_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_insert_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}: err
        |       |   | {select_expr_list_con}: err
        |       |     | {select_expr_list}: err
        |       |     | | {select_expr}: err
        |       |     |   | {not}: err
        |       |     |     | {strlit 'x'}: text notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}
          | {insert_normal}
          | {name_columns_values}
            | {name bar}
            | {columns_values}
              | {column_spec}
              | | {name_list}
              |   | {name id}
              |   | {name_list}
              |     | {name name}
              |     | {name_list}
              |       | {name rate}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_values}
                |   | {values}
                |     | {insert_list}
                |       | {int 1}
                |       | {insert_list}
                |         | {strlit 'x'}
                |         | {insert_list}
                |           | {int 2}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_bogus_insert ()
BEGIN
  WITH
  x (a) AS (SELECT 1)
  INSERT INTO bar(id, name, rate) VALUES(1, NOT 'x', 1);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_insert_bogus_insert}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_insert_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull }
        |     | {cte_decl}: x: { a: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: err
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}
              |   | {name_list}
              |     | {name name}
              |     | {name_list}
              |       | {name rate}
              | {select_stmt}: err
                | {select_core_list}: err
                | | {select_core}: err
                |   | {select_values}
                |   | {values}: err
                |     | {insert_list}
                |       | {int 1}: integer notnull
                |       | {insert_list}
                |         | {not}: err
                |         | | {strlit 'x'}: text notnull
                |         | {insert_list}
                |           | {int 1}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT *
  FROM bar
  WHERE id > 5;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {gt}: bool notnull
        |         |   | {name id}: id: integer notnull
        |         |   | {int 5}: integer notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT id
  FROM bar;

Error at test/sem_test.sql:XXXX : in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { id: integer notnull }
        | {select_core_list}: select: { id: integer notnull }
        | | {select_core}: select: { id: integer notnull }
        |   | {select_expr_list_con}: select: { id: integer notnull }
        |     | {select_expr_list}: select: { id: integer notnull }
        |     | | {select_expr}: id: integer notnull
        |     |   | {name id}: id: integer notnull
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT name, id, rate
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: err
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { name: text, id: integer notnull, rate: longint }
        | {select_core_list}: select: { name: text, id: integer notnull, rate: longint }
        | | {select_core}: select: { name: text, id: integer notnull, rate: longint }
        |   | {select_expr_list_con}: select: { name: text, id: integer notnull, rate: longint }
        |     | {select_expr_list}: select: { name: text, id: integer notnull, rate: longint }
        |     | | {select_expr}: name: text
        |     | | | {name name}: name: text
        |     | | {select_expr_list}
        |     |   | {select_expr}: id: integer notnull
        |     |   | | {name id}: id: integer notnull
        |     |   | {select_expr_list}
        |     |     | {select_expr}: rate: longint
        |     |       | {name rate}: rate: longint
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT NOT 'x';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC SqlUserFunc (id INTEGER) REAL NOT NULL;

  {declare_select_func_stmt}: real notnull select_func
  | {name SqlUserFunc}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

SELECT SqlUserFunc(1);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SqlUserFunc(DISTINCT id)
  FROM foo;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SqlUserFunc(DISTINCT id) FILTER (WHERE 1)
  FROM foo;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | | {opt_filter_clause}: integer notnull
  |     |       |   | {opt_where}: integer notnull
  |     |       |     | {int 1}: integer notnull
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET my_real := SqlUserFunc(1);

Error at test/sem_test.sql:XXXX : in call : CQL0089: User function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET my_real := SqlUserFunc(DISTINCT 1);

Error at test/sem_test.sql:XXXX : in call : CQL0089: User function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | | {distinct}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET my_real := SqlUserFunc(1) FILTER (WHERE 0);

Error at test/sem_test.sql:XXXX : in call : CQL0089: User function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | | {opt_filter_clause}: integer notnull
      |   | {opt_where}: integer notnull
      |     | {int 0}: integer notnull
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

DECLARE SELECT FUNC foo (x INTEGER, x INTEGER) INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0192: func name conflicts with proc name 'foo'

  {declare_select_func_stmt}: err
  | {name foo}
  | {func_params_return}
    | {params}
    | | {param}
    | | | {param_detail}
    | |   | {name x}
    | |   | {type_int}
    | | {params}
    |   | {param}
    |     | {param_detail}
    |       | {name x}
    |       | {type_int}
    | {type_int}

The statement ending at line XXXX

CREATE PROC arg_fetcher (arg1 TEXT NOT NULL, arg2 INTEGER NOT NULL, arg3 REAL NOT NULL)
BEGIN
  DECLARE curs CURSOR LIKE SELECT 'x' AS A, 1 AS B, 3.5 AS C;
  FETCH curs(A, B, C) FROM VALUES(arg1, arg2, arg3);
END;

  {create_proc_stmt}: ok
  | {name arg_fetcher}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: text notnull variable in
    | | | {param_detail}: arg1: text notnull variable in
    | |   | {name arg1}: arg1: text notnull variable in
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: arg2: integer notnull variable in
    |   | | {param_detail}: arg2: integer notnull variable in
    |   |   | {name arg2}: arg2: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: arg3: real notnull variable in
    |       | {param_detail}: arg3: real notnull variable in
    |         | {name arg3}: arg3: real notnull variable in
    |         | {notnull}: real notnull
    |           | {type_real}: real
    | {stmt_list}: ok
      | {declare_cursor_like_select}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
      | | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | {select_core_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | | {select_core}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |   | {select_expr_list_con}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | {select_expr_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | | {select_expr}: A: text notnull
      |   |     | | | {strlit 'x'}: text notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: real notnull
      |   |     |       | {dbl 3.5}: real notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: text notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            |     | {name_list}
            |       | {name C}: C: real notnull
            | {insert_list}
              | {name arg1}: arg1: text notnull variable in
              | {insert_list}
                | {name arg2}: arg2: integer notnull variable in
                | {insert_list}
                  | {name arg3}: arg3: real notnull variable in

The statement ending at line XXXX

CREATE PROC fetch_bar (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  DECLARE curs CURSOR LIKE bar;
  FETCH curs(id, name, rate) FROM VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok
  | {name fetch_bar}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {declare_cursor_like_name}: curs: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {name curs}: curs: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {like}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name curs}: curs: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {name id_}: id_: integer notnull variable in
              | {insert_list}
                | {name name_}: name_: text variable in
                | {insert_list}
                  | {name rate_}: rate_: longint variable in

The statement ending at line XXXX

CREATE PROC qualified_like (x_id INTEGER NOT NULL, x_name TEXT, x_rate LONG_INT, y_id INTEGER NOT NULL, y_name TEXT, y_rate LONG_INT)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name qualified_like}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_id: integer notnull variable in
      | | {param_detail}: x_id: integer notnull variable in
      |   | {name x_id}: x_id: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: x_name: text variable in
        | | {param_detail}: x_name: text variable in
        |   | {name x_name}: x_name: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: x_rate: longint variable in
          | | {param_detail}: x_rate: longint variable in
          |   | {name x_rate}: x_rate: longint variable in
          |   | {type_long}: longint
          | {params}
            | {param}: y_id: integer notnull variable in
            | | {param_detail}: y_id: integer notnull variable in
            |   | {name y_id}: y_id: integer notnull variable in
            |   | {notnull}: integer notnull
            |     | {type_int}: integer
            | {params}
              | {param}: y_name: text variable in
              | | {param_detail}: y_name: text variable in
              |   | {name y_name}: y_name: text variable in
              |   | {type_text}: text
              | {params}
                | {param}: y_rate: longint variable in
                  | {param_detail}: y_rate: longint variable in
                    | {name y_rate}: y_rate: longint variable in
                    | {type_long}: longint

The statement ending at line XXXX

CREATE PROC insert_bar (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_bar}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {name id_}: id_: integer notnull variable in
              | {insert_list}
                | {name name_}: name_: text variable in
                | {insert_list}
                  | {name rate_}: rate_: longint variable in

The statement ending at line XXXX

CREATE PROC insert_bar_explicit (extra INTEGER, id INTEGER NOT NULL, name_ TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id, name_, rate);
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_bar_explicit}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id: integer notnull variable in
    |   | | {param_detail}: id: integer notnull variable in
    |   |   | {name id}: id: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate: longint variable in
    |         | {param_detail}: rate: longint variable in
    |           | {name rate}: rate: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {name id}: id: integer notnull variable in
              | {insert_list}
                | {name name_}: name_: text variable in
                | {insert_list}
                  | {name rate}: rate: longint variable in

The statement ending at line XXXX

CREATE PROC insert_bar_missing (extra INTEGER, id INTEGER NOT NULL)
BEGIN
  INSERT INTO bar(id, name, rate) FROM ARGUMENTS LIKE bar;
END;

Error at test/sem_test.sql:XXXX : in columns_values : CQL0201: expanding FROM ARGUMENTS, there is no argument matching 'name'
Error at test/sem_test.sql:XXXX : in columns_values : CQL0201: expanding FROM ARGUMENTS, there is no argument matching 'rate'

  {create_proc_stmt}: err
  | {name insert_bar_missing}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id: integer notnull variable in
    |     | {param_detail}: id: integer notnull variable in
    |       | {name id}: id: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name id}
            |   | {name_list}
            |     | {name name}
            |     | {name_list}
            |       | {name rate}
            | {from_arguments}
              | {like}: ok
                | {name bar}

The statement ending at line XXXX

CREATE PROC insert_bar_from_bogus (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) FROM ARGUMENTS LIKE bogus_name_here;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'bogus_name_here'

  {create_proc_stmt}: err
  | {name insert_bar_from_bogus}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name id}
            |   | {name_list}
            |     | {name name}
            |     | {name_list}
            |       | {name rate}
            | {from_arguments}
              | {like}: err
                | {name bogus_name_here}: err

The statement ending at line XXXX

DECLARE val_cursor CURSOR LIKE my_cursor;

  {declare_cursor_like_name}: val_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor value_cursor
  | {name val_cursor}: val_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor value_cursor
  | {like}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
    | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable

The statement ending at line XXXX

FETCH val_cursor(one, two) FROM ARGUMENTS;

Error at test/sem_test.sql:XXXX : in columns_values : CQL0163: FROM ARGUMENTS construct is only valid inside a procedure

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name val_cursor}: val_cursor: select: { one: integer notnull, two: integer notnull } variable auto_cursor value_cursor
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name one}
      |   | {name_list}
      |     | {name two}
      | {from_arguments}

The statement ending at line XXXX

CREATE PROC arg_fetcher_not_enough_args (arg1 TEXT NOT NULL)
BEGIN
  DECLARE curs CURSOR LIKE SELECT 'x' AS A, 1 AS B, 3.5 AS C;
  FETCH curs(A, B, C) FROM ARGUMENTS;
END;

Error at test/sem_test.sql:XXXX : in columns_values : CQL0164: too few arguments available

  {create_proc_stmt}: err
  | {name arg_fetcher_not_enough_args}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: text notnull variable in
    |   | {param_detail}: arg1: text notnull variable in
    |     | {name arg1}: arg1: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: err
      | {declare_cursor_like_select}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
      | | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | {select_core_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | | {select_core}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |   | {select_expr_list_con}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | {select_expr_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | | {select_expr}: A: text notnull
      |   |     | | | {strlit 'x'}: text notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: real notnull
      |   |     |       | {dbl 3.5}: real notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable auto_cursor value_cursor
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name A}
            |   | {name_list}
            |     | {name B}
            |     | {name_list}
            |       | {name C}
            | {from_arguments}

The statement ending at line XXXX

CREATE PROC bar_auto_inserter (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id, name, rate);
END;

  {create_proc_stmt}: ok dml_proc
  | {name bar_auto_inserter}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {name id}: id: integer notnull variable in
              | {insert_list}
                | {name name}: name: text variable in
                | {insert_list}
                  | {name rate}: rate: longint variable in

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_mininal (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id) VALUES(id);
END;

  {create_proc_stmt}: ok dml_proc
  | {name bar_auto_inserter_mininal}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {insert_list}
              | {name id}: id: integer notnull variable in

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_no_columns (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar() FROM ARGUMENTS @DUMMY_SEED(1);
END;

Error at test/sem_test.sql:XXXX : in from_arguments : CQL0162: FROM ARGUMENTS is redundant if column list is empty

  {create_proc_stmt}: err
  | {name bar_auto_inserter_no_columns}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | | {insert_dummy_spec}
        |   | {int 1}
        |   | {int 0}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | {from_arguments}

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_missing_columns (id INTEGER)
BEGIN
  INSERT INTO bar(id, name, rate) FROM ARGUMENTS;
END;

Error at test/sem_test.sql:XXXX : in columns_values : CQL0164: too few arguments available

  {create_proc_stmt}: err
  | {name bar_auto_inserter_missing_columns}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name id}
            |   | {name_list}
            |     | {name name}
            |     | {name_list}
            |       | {name rate}
            | {from_arguments}

The statement ending at line XXXX

CREATE PROC rewritten_like_args (id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok dml_proc
  | {name rewritten_like_args}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id_: integer notnull variable in
    | | | {param_detail}: id_: integer notnull variable in
    | |   | {name id_}: id_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name_: text variable in
    |   | | {param_detail}: name_: text variable in
    |   |   | {name name_}: name_: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate_: longint variable in
    |       | {param_detail}: rate_: longint variable in
    |         | {name rate_}: rate_: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {name id_}: id_: integer notnull variable in
              | {insert_list}
                | {name name_}: name_: text variable in
                | {insert_list}
                  | {name rate_}: rate_: longint variable in

The statement ending at line XXXX

CREATE PROC rewrite_args_fails (LIKE garbonzo)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'garbonzo'

  {create_proc_stmt}: err
  | {name rewrite_args_fails}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {like}: err
    |       | {name garbonzo}: err
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name x}
        | {type_int}

The statement ending at line XXXX

CREATE TABLE args1(
  id INTEGER PRIMARY KEY,
  name TEXT,
  data BLOB
);

  {create_table_stmt}: args1: { id: integer notnull primary_key, name: text, data: blob }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name args1}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: data: blob
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name data}
              | {type_blob}: blob

The statement ending at line XXXX

CREATE TABLE args2(
  id INTEGER REFERENCES args1 (id),
  name2 TEXT,
  rate REAL
);

  {create_table_stmt}: args2: { id: integer foreign_key, name2: text, rate: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name args2}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_fk}: ok
    |     | {fk_target_options}
    |       | {fk_target}
    |       | | {name args1}
    |       | | {name_list}
    |       |   | {name id}: id: integer notnull
    |       | {int 0}
    | {col_key_list}
      | {col_def}: name2: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: real
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name rate}
              | {type_real}: real

The statement ending at line XXXX

CREATE PROC two_arg_sources (id_ INTEGER NOT NULL, name_ TEXT, data_ BLOB, name2_ TEXT, rate_ REAL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name two_arg_sources}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id_: integer notnull variable in
      | | {param_detail}: id_: integer notnull variable in
      |   | {name id_}: id_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: name_: text variable in
        | | {param_detail}: name_: text variable in
        |   | {name name_}: name_: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: data_: blob variable in
          | | {param_detail}: data_: blob variable in
          |   | {name data_}: data_: blob variable in
          |   | {type_blob}: blob
          | {params}
            | {param}: name2_: text variable in
            | | {param_detail}: name2_: text variable in
            |   | {name name2_}: name2_: text variable in
            |   | {type_text}: text
            | {params}
              | {param}: rate_: real variable in
                | {param_detail}: rate_: real variable in
                  | {name rate_}: rate_: real variable in
                  | {type_real}: real

The statement ending at line XXXX

CREATE PROC two_arg_sources_fully_redundant (id_ INTEGER NOT NULL, name_ TEXT, data_ BLOB)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name two_arg_sources_fully_redundant}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id_: integer notnull variable in
      | | {param_detail}: id_: integer notnull variable in
      |   | {name id_}: id_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: name_: text variable in
        | | {param_detail}: name_: text variable in
        |   | {name name_}: name_: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: data_: blob variable in
            | {param_detail}: data_: blob variable in
              | {name data_}: data_: blob variable in
              | {type_blob}: blob

The statement ending at line XXXX

CREATE VIEW ViewShape AS
SELECT CAST(1 AS BOOL) AS a, 2.5 AS b, 'xyz' AS c;

  {create_view_stmt}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name ViewShape}
      | {select_stmt}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        | {select_core_list}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        | | {select_core}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |   | {select_expr_list_con}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_expr_list}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |     | | {select_expr}: a: bool notnull
        |     | | | {cast_expr}: bool notnull
        |     | | | | {int 1}: integer notnull
        |     | | | | {type_bool}: bool
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: real notnull
        |     |   | | {dbl 2.5}: real notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: text notnull
        |     |       | {strlit 'xyz'}: text notnull
        |     |       | {opt_as_alias}
        |     |         | {name c}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC like_a_view (a_ BOOL NOT NULL, b_ REAL NOT NULL, c_ TEXT NOT NULL)
BEGIN
  SELECT *
    FROM ViewShape AS v
    WHERE v.a = a_ AND v.b = b_ AND v.c > c_;
END;

  {create_proc_stmt}: select: { a: bool notnull, b: real notnull, c: text notnull } dml_proc
  | {name like_a_view}: select: { a: bool notnull, b: real notnull, c: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_: bool notnull variable in
    | | | {param_detail}: a_: bool notnull variable in
    | |   | {name a_}: a_: bool notnull variable in
    | |   | {notnull}: bool notnull
    | |     | {type_bool}: bool
    | | {params}
    |   | {param}: b_: real notnull variable in
    |   | | {param_detail}: b_: real notnull variable in
    |   |   | {name b_}: b_: real notnull variable in
    |   |   | {notnull}: real notnull
    |   |     | {type_real}: real
    |   | {params}
    |     | {param}: c_: text notnull variable in
    |       | {param_detail}: c_: text notnull variable in
    |         | {name c_}: c_: text notnull variable in
    |         | {notnull}: text notnull
    |           | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { a: bool notnull, b: real notnull, c: text notnull }
        | {select_core_list}: select: { a: bool notnull, b: real notnull, c: text notnull }
        | | {select_core}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |   | {select_expr_list_con}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_expr_list}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | | {star}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_from_etc}: TABLE { v: ViewShape }
        |       | {table_or_subquery_list}: TABLE { v: ViewShape }
        |       | | {table_or_subquery}: TABLE { v: ViewShape }
        |       |   | {name ViewShape}: TABLE { v: ViewShape }
        |       |   | {opt_as_alias}
        |       |     | {name v}
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {and}: bool notnull
        |         |   | {and}: bool notnull
        |         |   | | {eq}: bool notnull
        |         |   | | | {dot}: a: bool notnull
        |         |   | | | | {name v}
        |         |   | | | | {name a}
        |         |   | | | {name a_}: a_: bool notnull variable in
        |         |   | | {eq}: bool notnull
        |         |   |   | {dot}: b: real notnull
        |         |   |   | | {name v}
        |         |   |   | | {name b}
        |         |   |   | {name b_}: b_: real notnull variable in
        |         |   | {gt}: bool notnull
        |         |     | {dot}: c: text notnull
        |         |     | | {name v}
        |         |     | | {name c}
        |         |     | {name c_}: c_: text notnull variable in
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC bogus_cursor_shape ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1, 2;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0055: all columns in the select must have a name

  {create_proc_stmt}: err
  | {name bogus_cursor_shape}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: err
        | {name C}
        | {select_stmt}: err
          | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: integer notnull
          |     |     | {int 2}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyBogusView AS
SELECT 1, 2;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0055: all columns in the select must have a name

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyBogusView}
      | {select_stmt}: err
        | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | {select_expr_list}
        |     |   | {select_expr}: integer notnull
        |     |     | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC like_other_proc (A_ INTEGER NOT NULL, B_ INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C(A, B) FROM VALUES(A_, B_);
  OUT C;
END;

  {create_proc_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor uses_out value_cursor
  | {name like_other_proc}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor uses_out value_cursor
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: A_: integer notnull variable in
    | | | {param_detail}: A_: integer notnull variable in
    | |   | {name A_}: A_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: B_: integer notnull variable in
    |     | {param_detail}: B_: integer notnull variable in
    |       | {name B_}: B_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}
      |       | {name A_}: A_: integer notnull variable in
      |       | {insert_list}
      |         | {name B_}: B_: integer notnull variable in
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC bogus_like_proc (LIKE proc1)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0178: proc has no result 'proc1'

  {create_proc_stmt}: err
  | {name bogus_like_proc}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {like}: err
    |       | {name proc1}: err
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name x}
        | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE nontemp_table_like_table(
  id INTEGER NOT NULL
);

  {create_table_stmt}: nontemp_table_like_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name nontemp_table_like_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_table(
  id INTEGER NOT NULL
);

  {create_table_stmt}: table_like_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_view(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

  {create_table_stmt}: table_like_view: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_view}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name f3}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_proc(
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: table_like_proc: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_proc}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: longint
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name rate}
              | {type_long}: longint

The statement ending at line XXXX

CREATE TEMP TABLE table_like_proc_with_no_result(
  LIKE proc1
);

Error at test/sem_test.sql:XXXX : in like : CQL0178: proc has no result 'proc1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_proc_with_no_result}
  | {col_key_list}: err
    | {like}: err
      | {name proc1}: err

The statement ending at line XXXX

CREATE TEMP TABLE table_like_nonexistent_view(
  LIKE this_thing_doesnt_exist
);

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'this_thing_doesnt_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_nonexistent_view}
  | {col_key_list}: err
    | {like}: err
      | {name this_thing_doesnt_exist}: err

The statement ending at line XXXX

CREATE TEMP TABLE table_multiple_like(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL,
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: table_multiple_like: { f1: integer notnull, f2: integer notnull, f3: integer notnull, id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_multiple_like}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |   | | {name f3}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: id: integer notnull
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |   | | {name id}
          |   | | {type_int}: integer
          |   | {col_attrs_not_null}: ok
          | {col_key_list}
            | {col_def}: name: text
            | | {col_def_type_attrs}
            |   | {col_def_name_type}
            |     | {name name}
            |     | {type_text}: text
            | {col_key_list}
              | {col_def}: rate: longint
                | {col_def_type_attrs}
                  | {col_def_name_type}
                    | {name rate}
                    | {type_long}: longint

The statement ending at line XXXX

CREATE TEMP TABLE table_like_mixed(
  garbage TEXT,
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL,
  happy INTEGER
);

  {create_table_stmt}: table_like_mixed: { garbage: text, f1: integer notnull, f2: integer notnull, f3: integer notnull, happy: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_mixed}
  | {col_key_list}
    | {col_def}: garbage: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name garbage}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: f1: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name f1}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f2: integer notnull
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |   | | {name f2}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: f3: integer notnull
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |   | | {name f3}
          |   | | {type_int}: integer
          |   | {col_attrs_not_null}: ok
          | {col_key_list}
            | {col_def}: happy: integer
              | {col_def_type_attrs}
                | {col_def_name_type}
                  | {name happy}
                  | {type_int}: integer

The statement ending at line XXXX

CREATE TEMP TABLE table_with_dup_col(
  f1 TEXT,
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

Error at test/sem_test.sql:XXXX : in str : CQL0142: duplicate column name 'f1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_with_dup_col}
  | {col_key_list}
    | {col_def}: f1: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name f1}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: f1: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name f1}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f2: integer notnull
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |   | | {name f2}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: f3: integer notnull
            | {col_def_type_attrs}
              | {col_def_name_type}
              | | {name f3}
              | | {type_int}: integer
              | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_create_versioning(
  id INTEGER
) @CREATE(1);

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0139: temp tables may not have versioning annotations 'bogus_temp_with_create_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_temp_with_create_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_delete_versioning(
  id INTEGER
) @DELETE(1);

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0139: temp tables may not have versioning annotations 'bogus_temp_with_delete_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_temp_with_delete_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_recreate_versioning(
  id INTEGER
) @RECREATE;

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0139: temp tables may not have versioning annotations 'bogus_temp_with_recreate_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {recreate_attr}
  | | {name bogus_temp_with_recreate_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_versioning_in_column(
  id INTEGER @CREATE(2)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0140: columns in a temp table may not have versioning attributes 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name bogus_temp_with_versioning_in_column}
  | {col_key_list}
    | {col_def}: id: integer @create(2)
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

SELECT 'x' MATCH 'y';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {match}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := 'x' MATCH 'y';

Error at test/sem_test.sql:XXXX : in match : CQL0044: operator may only appear in the context of a SQL statement 'MATCH'

  {assign}: err
  | {name X}: X: integer variable
  | {match}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SELECT 'x' GLOB 'y';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {glob}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := 'x' GLOB 'y';

Error at test/sem_test.sql:XXXX : in glob : CQL0044: operator may only appear in the context of a SQL statement 'GLOB'

  {assign}: err
  | {name X}: X: integer variable
  | {glob}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := 'x' MATCH 'y';

Error at test/sem_test.sql:XXXX : in match : CQL0044: operator may only appear in the context of a SQL statement 'MATCH'

  {assign}: err
  | {name X}: X: integer variable
  | {match}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := 'x' REGEXP 'y';

Error at test/sem_test.sql:XXXX : in regexp : CQL0044: operator may only appear in the context of a SQL statement 'REGEXP'

  {assign}: err
  | {name X}: X: integer variable
  | {regexp}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := ( SELECT 'x' REGEXP 'y' );

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {select_stmt}: _anon: bool notnull
    | {select_core_list}: select: { _anon: bool notnull }
    | | {select_core}: select: { _anon: bool notnull }
    |   | {select_expr_list_con}: select: { _anon: bool notnull }
    |     | {select_expr_list}: select: { _anon: bool notnull }
    |     | | {select_expr}: bool notnull
    |     |   | {regexp}: bool notnull
    |     |     | {strlit 'x'}: text notnull
    |     |     | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := 1 << 2 | 1 << 4 & 1 >> 8;

  {assign}: X: integer variable
  | {name X}: X: integer variable
  | {rshift}: integer notnull
    | {bin_and}: integer notnull
    | | {lshift}: integer notnull
    | | | {bin_or}: integer notnull
    | | | | {lshift}: integer notnull
    | | | | | {int 1}: integer notnull
    | | | | | {int 2}: integer notnull
    | | | | {int 1}: integer notnull
    | | | {int 4}: integer notnull
    | | {int 1}: integer notnull
    | {int 8}: integer notnull

The statement ending at line XXXX

SET X := 3.0 & 2;

Error at test/sem_test.sql:XXXX : in bin_and : CQL0001: operands must be an integer type, not real '&'

  {assign}: err
  | {name X}: X: integer variable
  | {bin_and}: err
    | {dbl 3.0}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SET X := ~3.0;

Error at test/sem_test.sql:XXXX : in tilde : CQL0001: operands must be an integer type, not real '~'

  {assign}: err
  | {name X}: X: integer variable
  | {tilde}: err
    | {dbl 3.0}: real notnull

The statement ending at line XXXX

SELECT 1 AS a, 2 AS b
  FROM (SELECT 1) AS T
  WHERE b = 2;

  {select_stmt}: select: { a: integer notnull, b: integer notnull }
  | {select_core_list}: select: { a: integer notnull, b: integer notnull }
  | | {select_core}: select: { a: integer notnull, b: integer notnull }
  |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
  |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
  |     | | {select_expr}: a: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name a}
  |     | | {select_expr_list}
  |     |   | {select_expr}: b: integer notnull
  |     |     | {int 2}: integer notnull
  |     |     | {opt_as_alias}
  |     |       | {name b}
  |     | {select_from_etc}: TABLE { T: select }
  |       | {table_or_subquery_list}: TABLE { T: select }
  |       | | {table_or_subquery}: TABLE { T: select }
  |       |   | {select_stmt}: select: { _anon: integer notnull }
  |       |   | | {select_core_list}: select: { _anon: integer notnull }
  |       |   | | | {select_core}: select: { _anon: integer notnull }
  |       |   | |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |   | |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |   | |     | | {select_expr}: integer notnull
  |       |   | |     |   | {int 1}: integer notnull
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {eq}: bool notnull
  |         |   | {name b}: b: integer notnull
  |         |   | {int 2}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC simple_alias_order_by ()
BEGIN
  SELECT id AS bar_id
    FROM bar
  ORDER BY bar_id;
END;

  {create_proc_stmt}: select: { bar_id: integer notnull } dml_proc
  | {name simple_alias_order_by}: select: { bar_id: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { bar_id: integer notnull }
        | {select_core_list}: select: { bar_id: integer notnull }
        | | {select_core}: select: { bar_id: integer notnull }
        |   | {select_expr_list_con}: select: { bar_id: integer notnull }
        |     | {select_expr_list}: select: { bar_id: integer notnull }
        |     | | {select_expr}: bar_id: integer notnull
        |     |   | {name id}: id: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name bar_id}
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {opt_orderby}: ok
          | | {groupby_list}: ok
          |   | {groupby_item}
          |     | {name bar_id}: bar_id: integer notnull
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC complex_alias_order_by ()
BEGIN
  SELECT 1 AS sort_order_value, id
    FROM bar
  UNION ALL
  SELECT 2 AS sort_order_value, id
    FROM bar
  ORDER BY sort_order_value, id;
END;

  {create_proc_stmt}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull } dml_proc
  | {name complex_alias_order_by}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull }
        | {select_core_list}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull }
        | | {select_core}: select: { sort_order_value: integer notnull, id: integer notnull }
        | | | {select_expr_list_con}: select: { sort_order_value: integer notnull, id: integer notnull }
        | |   | {select_expr_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        | |   | | {select_expr}: sort_order_value: integer notnull
        | |   | | | {int 1}: integer notnull
        | |   | | | {opt_as_alias}
        | |   | |   | {name sort_order_value}
        | |   | | {select_expr_list}
        | |   |   | {select_expr}: id: integer notnull
        | |   |     | {name id}: id: integer notnull
        | |   | {select_from_etc}: TABLE { bar: bar }
        | |     | {table_or_subquery_list}: TABLE { bar: bar }
        | |     | | {table_or_subquery}: TABLE { bar: bar }
        | |     |   | {name bar}: TABLE { bar: bar }
        | |     | {select_where}
        | |       | {select_groupby}
        | |         | {select_having}
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        |     | {select_core}: select: { sort_order_value: integer notnull, id: integer notnull }
        |       | {select_expr_list_con}: select: { sort_order_value: integer notnull, id: integer notnull }
        |         | {select_expr_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        |         | | {select_expr}: sort_order_value: integer notnull
        |         | | | {int 2}: integer notnull
        |         | | | {opt_as_alias}
        |         | |   | {name sort_order_value}
        |         | | {select_expr_list}
        |         |   | {select_expr}: id: integer notnull
        |         |     | {name id}: id: integer notnull
        |         | {select_from_etc}: TABLE { bar: bar }
        |           | {table_or_subquery_list}: TABLE { bar: bar }
        |           | | {table_or_subquery}: TABLE { bar: bar }
        |           |   | {name bar}: TABLE { bar: bar }
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {opt_orderby}: ok
          | | {groupby_list}: ok
          |   | {groupby_item}
          |   | | {name sort_order_value}: sort_order_value: integer notnull
          |   | {groupby_list}
          |     | {groupby_item}
          |       | {name id}: id: integer notnull
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE stories(
  media_id LONG_INT
);

  {create_table_stmt}: stories: { media_id: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name stories}
  | {col_key_list}
    | {col_def}: media_id: longint
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name media_id}
          | {type_long}: longint

The statement ending at line XXXX

SELECT 'xyzzy' AS media_id
  FROM stories
  WHERE media_id = 123;

  {select_stmt}: select: { media_id: text notnull }
  | {select_core_list}: select: { media_id: text notnull }
  | | {select_core}: select: { media_id: text notnull }
  |   | {select_expr_list_con}: select: { media_id: text notnull }
  |     | {select_expr_list}: select: { media_id: text notnull }
  |     | | {select_expr}: media_id: text notnull
  |     |   | {strlit 'xyzzy'}: text notnull
  |     |   | {opt_as_alias}
  |     |     | {name media_id}
  |     | {select_from_etc}: TABLE { stories: stories }
  |       | {table_or_subquery_list}: TABLE { stories: stories }
  |       | | {table_or_subquery}: TABLE { stories: stories }
  |       |   | {name stories}: TABLE { stories: stories }
  |       | {select_where}
  |         | {opt_where}: bool
  |         | | {eq}: bool
  |         |   | {name media_id}: media_id: longint
  |         |   | {int 123}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger1
  BEFORE DELETE ON bar
  FOR EACH ROW
  WHEN old.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
  DELETE FROM bar WHERE rate = old.id;
END;

  {create_trigger_stmt}: ok
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger1}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 256}
              | {trigger_when_stmts}
                | {eq}: bool notnull
                | | {dot}: id: integer notnull
                | | | {name old}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {opt_where}: bool
                  |   | {gt}: bool
                  |     | {name rate}: rate: longint
                  |     | {name id}: id: integer notnull
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {eq}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name old}
                          | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger1a
  BEFORE DELETE ON bar
  WHEN new.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger1a}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {eq}: err
                | | {dot}: err
                | | | {name new}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger2
  AFTER INSERT ON bar
BEGIN
  DELETE FROM bar WHERE rate > new.id;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name new}
                          | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger2a
  AFTER INSERT ON bar
  WHEN old.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2a}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {eq}: err
                | | {dot}: err
                | | | {name old}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
  UPDATE bar
  SET id = 7
    WHERE rate > old.b AND rate < new.b;
  INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {and}: bool notnull
                | | {gt}: bool notnull
                | | | {dot}: b: real notnull
                | | | | {name old}
                | | | | {name b}
                | | | {int 1}: integer notnull
                | | {lt}: bool notnull
                |   | {dot}: b: real notnull
                |   | | {name new}
                |   | | {name b}
                |   | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {update_set}
                  |   | {update_list}: ok
                  |   | | {update_entry}: id: integer notnull
                  |   |   | {name id}: id: integer notnull
                  |   |   | {int 7}: integer notnull
                  |   | {update_where}
                  |     | {opt_where}: bool
                  |     | | {and}: bool
                  |     |   | {gt}: bool
                  |     |   | | {name rate}: rate: longint
                  |     |   | | {dot}: b: real notnull
                  |     |   |   | {name old}
                  |     |   |   | {name b}
                  |     |   | {lt}: bool
                  |     |     | {name rate}: rate: longint
                  |     |     | {dot}: b: real notnull
                  |     |       | {name new}
                  |     |       | {name b}
                  |     | {update_orderby}
                  | {insert_stmt}: ok
                    | {insert_normal}
                    | {name_columns_values}
                      | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                      | {columns_values}: ok
                        | {column_spec}
                        | | {name_list}
                        |   | {name id}: id: integer notnull
                        |   | {name_list}
                        |     | {name name}: name: text
                        |     | {name_list}
                        |       | {name rate}: rate: longint
                        | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |   | {select_values}
                          |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |     | {insert_list}
                          |       | {int 7}: integer notnull
                          |       | {insert_list}
                          |         | {strlit 'goo'}: text notnull
                          |         | {insert_list}
                          |           | {longint 17}: longint notnull
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
  UPDATE bar
  SET id = 7
    WHERE rate > old.b AND rate < new.b;
  INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {and}: bool notnull
                | | {gt}: bool notnull
                | | | {dot}: b: real notnull
                | | | | {name old}
                | | | | {name b}
                | | | {int 1}: integer notnull
                | | {lt}: bool notnull
                |   | {dot}: b: real notnull
                |   | | {name new}
                |   | | {name b}
                |   | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {update_set}
                  |   | {update_list}: ok
                  |   | | {update_entry}: id: integer notnull
                  |   |   | {name id}: id: integer notnull
                  |   |   | {int 7}: integer notnull
                  |   | {update_where}
                  |     | {opt_where}: bool
                  |     | | {and}: bool
                  |     |   | {gt}: bool
                  |     |   | | {name rate}: rate: longint
                  |     |   | | {dot}: b: real notnull
                  |     |   |   | {name old}
                  |     |   |   | {name b}
                  |     |   | {lt}: bool
                  |     |     | {name rate}: rate: longint
                  |     |     | {dot}: b: real notnull
                  |     |       | {name new}
                  |     |       | {name b}
                  |     | {update_orderby}
                  | {insert_stmt}: ok
                    | {insert_normal}
                    | {name_columns_values}
                      | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                      | {columns_values}: ok
                        | {column_spec}
                        | | {name_list}
                        |   | {name id}: id: integer notnull
                        |   | {name_list}
                        |     | {name name}: name: text
                        |     | {name_list}
                        |       | {name rate}: rate: longint
                        | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |   | {select_values}
                          |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |     | {insert_list}
                          |       | {int 7}: integer notnull
                          |       | {insert_list}
                          |         | {strlit 'goo'}: text notnull
                          |         | {insert_list}
                          |           | {longint 17}: longint notnull
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
BEGIN
  SELECT 1;
END;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in create_trigger_stmt : CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
UPDATE bar
SET id = 7
  WHERE rate > old.b AND rate < new.b;

INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END
Error at test/sem_test.sql:XXXX : in create_trigger_stmt : CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
BEGIN
SELECT 1;
END
The above must be identical.
Error at test/sem_test.sql:XXXX : in str : CQL0136: trigger already exists 'trigger3'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}: err
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: integer notnull }
                    | {select_core_list}: select: { _anon: integer notnull }
                    | | {select_core}: select: { _anon: integer notnull }
                    |   | {select_expr_list_con}: select: { _anon: integer notnull }
                    |     | {select_expr_list}: select: { _anon: integer notnull }
                    |     | | {select_expr}: integer notnull
                    |     |   | {int 1}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4
  INSTEAD OF UPDATE OF a, b, c ON ViewShape
BEGIN
  SELECT 1;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | | {name_list}
          |   | {name a}: a: bool notnull
          |   | {name_list}
          |     | {name b}: b: real notnull
          |     | {name_list}
          |       | {name c}: c: text notnull
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: integer notnull }
                    | {select_core_list}: select: { _anon: integer notnull }
                    | | {select_core}: select: { _anon: integer notnull }
                    |   | {select_expr_list_con}: select: { _anon: integer notnull }
                    |     | {select_expr_list}: select: { _anon: integer notnull }
                    |     | | {select_expr}: integer notnull
                    |     |   | {int 1}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4a
  INSTEAD OF UPDATE OF a, a, c ON ViewShape
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0172: name list has duplicate name 'a'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4a}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | | {name_list}: err
          |   | {name a}: a: bool notnull
          |   | {name_list}
          |     | {name a}: err
          |     | {name_list}
          |       | {name c}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4b
  BEFORE UPDATE ON ViewShape
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0138: a trigger on a view must be the INSTEAD OF form 'ViewShape'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4b}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4c
  BEFORE UPDATE ON no_such_table_dude
BEGIN
  SELECT 1;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0137: table/view not found 'no_such_table_dude'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4c}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name no_such_table_dude}
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4d
  BEFORE INSERT ON bar
BEGIN
  SELECT old.id;
END;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4d}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {dot}: err
                    |     |     | {name old}
                    |     |     | {name id}
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE PROC make_trigger ()
BEGIN
  CREATE TRIGGER selecting_trigger
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name make_trigger}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {create_trigger_stmt}: ok
        | {int 0}
        | {trigger_body_vers}
          | {trigger_def}
            | {name selecting_trigger}
            | {trigger_condition}
              | {int 4}
              | {trigger_op_target}
                | {trigger_operation}
                | | {int 64}
                | {trigger_target_action}
                  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | {trigger_action}
                    | {int 256}
                    | {trigger_when_stmts}
                      | {gt}: bool notnull
                      | | {dot}: id: integer notnull
                      | | | {name old}
                      | | | {name id}
                      | | {int 7}: integer notnull
                      | {stmt_list}: ok
                        | {select_stmt}: select: { id: integer notnull }
                          | {select_core_list}: select: { id: integer notnull }
                          | | {select_core}: select: { id: integer notnull }
                          |   | {select_expr_list_con}: select: { id: integer notnull }
                          |     | {select_expr_list}: select: { id: integer notnull }
                          |     | | {select_expr}: id: integer notnull
                          |     |   | {dot}: id: integer notnull
                          |     |     | {name old}
                          |     |     | {name id}
                          |     | {select_from_etc}: ok
                          |       | {select_where}
                          |         | {select_groupby}
                          |           | {select_having}
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

DROP TRIGGER this_trigger_does_not_exist;

Error at test/sem_test.sql:XXXX : in str : CQL0113: trigger in drop statement was not declared 'this_trigger_does_not_exist'

  {drop_trigger_stmt}: err
  | {name this_trigger_does_not_exist}

The statement ending at line XXXX

DROP TRIGGER IF EXISTS trigger1;

  {drop_trigger_stmt}: ok
  | {int 1}
  | {name trigger1}

The statement ending at line XXXX

CREATE TABLE retro_deleted_table(
  id INTEGER
) @CREATE(3) @DELETE(1);

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0107: delete version can't be <= create version 'retro_deleted_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 3}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name retro_deleted_table}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger5
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, "omg roll it back!");
END;

  {create_trigger_stmt}: ok
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger5}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: null }
                    | {select_core_list}: select: { _anon: null }
                    | | {select_core}: select: { _anon: null }
                    |   | {select_expr_list_con}: select: { _anon: null }
                    |     | {select_expr_list}: select: { _anon: null }
                    |     | | {select_expr}: null
                    |     |   | {raise}: null
                    |     |     | {int 1}
                    |     |     | {strlit 'omg roll it back!'}: text notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

SELECT RAISE(IGNORE);

Error at test/sem_test.sql:XXXX : in raise : CQL0092: RAISE may only be used in a trigger statement

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {raise}: err
  |     |     | {int 0}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger6
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, 0);
END;

Error at test/sem_test.sql:XXXX : in num : CQL0093: RAISE 2nd argument must be a string

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger6}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {raise}: err
                    |     |     | {int 1}
                    |     |     | {int 0}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger7
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, NOT 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger7}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {raise}: err
                    |     |     | {int 1}
                    |     |     | {not}: err
                    |     |       | {strlit 'x'}: text notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger8
  BEFORE DELETE ON bar
BEGIN
  SELECT 1 AS x;
END @DELETE(1, MigrateProcFoo);

Error at test/sem_test.sql:XXXX : in create_trigger_stmt : CQL0321: migration proc not allowed on object 'trigger8'

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
    | | {name trigger8}
    | | {trigger_condition}
    |   | {int 4}
    |   | {trigger_op_target}
    |     | {trigger_operation}
    |     | | {int 64}
    |     | {trigger_target_action}
    |       | {name bar}
    |       | {trigger_action}
    |         | {int 0}
    |         | {trigger_when_stmts}
    |           | {stmt_list}
    |             | {select_stmt}
    |               | {select_core_list}
    |               | | {select_core}
    |               |   | {select_expr_list_con}
    |               |     | {select_expr_list}
    |               |     | | {select_expr}
    |               |     |   | {int 1}
    |               |     |   | {opt_as_alias}
    |               |     |     | {name x}
    |               |     | {select_from_etc}
    |               |       | {select_where}
    |               |         | {select_groupby}
    |               |           | {select_having}
    |               | {select_orderby}
    |                 | {select_limit}
    |                   | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 1}
        | {name MigrateProcFoo}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B, 3 AS C
UNION ALL
SELECT 3 AS A, 4 AS B;

Error at test/sem_test.sql:XXXX : in select_core : CQL0057: if multiple selects, all must have the same column count

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |   | | {int 2}: integer notnull
  | |   |   | | {opt_as_alias}
  | |   |   |   | {name B}
  | |   |   | {select_expr_list}
  | |   |     | {select_expr}: C: integer notnull
  | |   |       | {int 3}: integer notnull
  | |   |       | {opt_as_alias}
  | |   |         | {name C}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 'x' AS A, 4 AS B;

Error at test/sem_test.sql:XXXX : in select_core : CQL0012: incompatible types in expression 'A'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: text notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: text notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: text notnull, B: integer notnull }
  |         | | {select_expr}: A: text notnull
  |         | | | {strlit 'x'}: text notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, nullable(2) AS B
UNION ALL
SELECT NULL AS A, 4 AS B;

  {select_stmt}: UNION ALL: { A: integer, B: integer }
  | {select_core_list}: UNION ALL: { A: integer, B: integer }
  | | {select_core}: select: { A: integer notnull, B: integer }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer
  | |   |     | {call}: integer
  | |   |     | | {name nullable}: integer
  | |   |     | | {call_arg_list}
  | |   |     |   | {call_filter_clause}
  | |   |     |   | {arg_list}: ok
  | |   |     |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: null, B: integer notnull }
  |     | {select_core}: select: { A: null, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: null, B: integer notnull }
  |         | {select_expr_list}: select: { A: null, B: integer notnull }
  |         | | {select_expr}: A: null
  |         | | | {null}: null
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |     | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |     |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |     |   | | {select_expr}: A: integer notnull
  |     |   | | | {int 1}: integer notnull
  |     |   | | | {opt_as_alias}
  |     |   | |   | {name A}
  |     |   | | {select_expr_list}
  |     |   |   | {select_expr}: B: integer notnull
  |     |   |     | {int 2}: integer notnull
  |     |   |     | {opt_as_alias}
  |     |   |       | {name B}
  |     |   | {select_from_etc}: ok
  |     |     | {select_where}
  |     |       | {select_groupby}
  |     |         | {select_having}
  |     | {select_core_compound}
  |       | {int 2}
  |       | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  |         | {select_core}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         |   | | {select_expr}: A: integer notnull
  |         |   | | | {int 1}: integer notnull
  |         |   | | | {opt_as_alias}
  |         |   | |   | {name A}
  |         |   | | {select_expr_list}
  |         |   |   | {select_expr}: B: integer notnull
  |         |   |     | {int 2}: integer notnull
  |         |   |     | {opt_as_alias}
  |         |   |       | {name B}
  |         |   | {select_from_etc}: ok
  |         |     | {select_where}
  |         |       | {select_groupby}
  |         |         | {select_having}
  |         | {select_core_compound}
  |           | {int 2}
  |           | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |             | {select_core}: select: { A: integer notnull, B: integer notnull }
  |               | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |                 | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |                 | | {select_expr}: A: integer notnull
  |                 | | | {int 1}: integer notnull
  |                 | | | {opt_as_alias}
  |                 | |   | {name A}
  |                 | | {select_expr_list}
  |                 |   | {select_expr}: B: integer notnull
  |                 |     | {int 2}: integer notnull
  |                 |     | {opt_as_alias}
  |                 |       | {name B}
  |                 | {select_from_etc}: ok
  |                   | {select_where}
  |                     | {select_groupby}
  |                       | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC returns_bogus_null ()
BEGIN
  SELECT NULL AS n;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0056: NULL column did not specify a type 'n'

  {create_proc_stmt}: err
  | {name returns_bogus_null}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: select: { n: null }
        | | {select_core}: select: { n: null }
        |   | {select_expr_list_con}: select: { n: null }
        |     | {select_expr_list}: select: { n: null }
        |     | | {select_expr}: n: null
        |     |   | {null}: null
        |     |   | {opt_as_alias}
        |     |     | {name n}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC fetch_null_column ()
BEGIN
  DECLARE C CURSOR FOR SELECT NULL AS n;
  FETCH C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0056: NULL column did not specify a type 'n'

  {create_proc_stmt}: err
  | {name fetch_null_column}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { n: null } variable
      | | {name C}: C: select: { n: null } variable
      | | {select_stmt}: select: { n: null }
      |   | {select_core_list}: select: { n: null }
      |   | | {select_core}: select: { n: null }
      |   |   | {select_expr_list_con}: select: { n: null }
      |   |     | {select_expr_list}: select: { n: null }
      |   |     | | {select_expr}: n: null
      |   |     |   | {null}: null
      |   |     |   | {opt_as_alias}
      |   |     |     | {name n}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE TABLE with_sensitive(
  id INTEGER,
  name TEXT @SENSITIVE,
  info INTEGER @SENSITIVE
);

  {create_table_stmt}: with_sensitive: { id: integer, name: text sensitive, info: integer sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_sensitive}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: name: text sensitive
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name name}
      |   | | {type_text}: text
      |   | {sensitive_attr}: ok
      | {col_key_list}
        | {col_def}: info: integer sensitive
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name info}
            | | {type_int}: integer
            | {sensitive_attr}: ok

The statement ending at line XXXX

CREATE TABLE without_sensitive(
  name TEXT
);

  {create_table_stmt}: without_sensitive: { name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name without_sensitive}
  | {col_key_list}
    | {col_def}: name: text
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name name}
          | {type_text}: text

The statement ending at line XXXX

CREATE PROC get_sensitive ()
BEGIN
  SELECT 1 AS safe, info + 1 AS sensitive_1, name AS sensitive_2, 'x' AS not_sensitive_1, -info AS sensitive_3, info BETWEEN 1 AND 3 AS sensitive_4
    FROM with_sensitive;
END;

  {create_proc_stmt}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive } dml_proc
  | {name get_sensitive}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        | {select_core_list}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        | | {select_core}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |   | {select_expr_list_con}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |     | {select_expr_list}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |     | | {select_expr}: safe: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name safe}
        |     | | {select_expr_list}
        |     |   | {select_expr}: sensitive_1: integer sensitive
        |     |   | | {add}: integer sensitive
        |     |   | | | {name info}: info: integer sensitive
        |     |   | | | {int 1}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name sensitive_1}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: sensitive_2: text sensitive
        |     |     | | {name name}: name: text sensitive
        |     |     | | {opt_as_alias}
        |     |     |   | {name sensitive_2}
        |     |     | {select_expr_list}
        |     |       | {select_expr}: not_sensitive_1: text notnull
        |     |       | | {strlit 'x'}: text notnull
        |     |       | | {opt_as_alias}
        |     |       |   | {name not_sensitive_1}
        |     |       | {select_expr_list}
        |     |         | {select_expr}: sensitive_3: integer sensitive
        |     |         | | {uminus}: integer sensitive
        |     |         | | | {name info}: info: integer sensitive
        |     |         | | {opt_as_alias}
        |     |         |   | {name sensitive_3}
        |     |         | {select_expr_list}
        |     |           | {select_expr}: sensitive_4: bool sensitive
        |     |             | {between}: bool sensitive
        |     |             | | {name info}: info: integer sensitive
        |     |             | | {range}
        |     |             |   | {int 1}: integer notnull
        |     |             |   | {int 3}: integer notnull
        |     |             | {opt_as_alias}
        |     |               | {name sensitive_4}
        |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
        |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
        |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
        |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE _sens INTEGER @SENSITIVE;

  {declare_vars_type}: integer sensitive
  | {name_list}: _sens: integer variable sensitive
  | | {name _sens}: _sens: integer variable sensitive
  | {sensitive_attr}: integer sensitive
    | {type_int}: integer

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT _sens;

  {select_stmt}: select: { safe: integer notnull sensitive }
  | {select_core_list}: select: { safe: integer notnull sensitive }
  | | {select_core}: select: { safe: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { safe: integer notnull sensitive }
  |     | {select_expr_list}: select: { safe: integer notnull sensitive }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: _sens: integer variable sensitive
      | | {name _sens}: _sens: integer variable sensitive
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1;

  {select_stmt}: select: { safe: integer notnull }
  | {select_core_list}: select: { safe: integer notnull }
  | | {select_core}: select: { safe: integer notnull }
  |   | {select_expr_list_con}: select: { safe: integer notnull }
  |     | {select_expr_list}: select: { safe: integer notnull }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1
OFFSET _sens;

  {select_stmt}: select: { safe: integer notnull sensitive }
  | {select_core_list}: select: { safe: integer notnull sensitive }
  | | {select_core}: select: { safe: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { safe: integer notnull sensitive }
  |     | {select_expr_list}: select: { safe: integer notnull sensitive }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}
        | {opt_offset}: _sens: integer variable sensitive
          | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1
OFFSET 1;

  {select_stmt}: select: { safe: integer notnull }
  | {select_core_list}: select: { safe: integer notnull }
  | | {select_core}: select: { safe: integer notnull }
  |   | {select_expr_list_con}: select: { safe: integer notnull }
  |     | {select_expr_list}: select: { safe: integer notnull }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 1}: integer notnull

The statement ending at line XXXX

SET _sens := _sens + 1;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {add}: integer sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {int 1}: integer notnull

The statement ending at line XXXX

SET _sens := _sens IN (1, 2);

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {in_pred}: bool sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {expr_list}: integer notnull
      | {int 1}: integer notnull
      | {expr_list}: integer notnull
        | {int 2}: integer notnull

The statement ending at line XXXX

SET _sens := 1 IN (1, _sens);

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {in_pred}: bool notnull sensitive
    | {int 1}: integer notnull
    | {expr_list}: integer notnull
      | {int 1}: integer notnull
      | {expr_list}: _sens: integer variable sensitive
        | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SET _sens := ( SELECT 1 IN (SELECT info
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {in_pred}: bool notnull sensitive
    |     |     | {int 1}: integer notnull
    |     |     | {select_stmt}: info: integer sensitive
    |     |       | {select_core_list}: select: { info: integer sensitive }
    |     |       | | {select_core}: select: { info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { info: integer sensitive }
    |     |       |     | | {select_expr}: info: integer sensitive
    |     |       |     |   | {name info}: info: integer sensitive
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := CASE 0 WHEN 1 THEN 2
ELSE 3
END;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {case_expr}: integer notnull
    | {int 0}: integer notnull
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {int 1}: integer notnull
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := CASE _sens WHEN 1 THEN 2
ELSE 3
END;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {case_expr}: integer notnull sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {connector}: integer notnull sensitive
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {int 1}: integer notnull
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := CASE 0 WHEN _sens THEN 2
ELSE 3
END;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {case_expr}: integer notnull sensitive
    | {int 0}: integer notnull
    | {connector}: integer notnull sensitive
      | {case_list}: integer notnull sensitive
      | | {when}: integer notnull
      |   | {name _sens}: _sens: integer variable sensitive
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := CASE 0 WHEN 1 THEN _sens
ELSE 3
END;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {case_expr}: integer sensitive
    | {int 0}: integer notnull
    | {connector}: integer sensitive
      | {case_list}: integer variable sensitive
      | | {when}: _sens: integer variable sensitive
      |   | {int 1}: integer notnull
      |   | {name _sens}: _sens: integer variable sensitive
      | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := CASE 0 WHEN 1 THEN 2
ELSE _sens
END;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {case_expr}: integer sensitive
    | {int 0}: integer notnull
    | {connector}: integer sensitive
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {int 1}: integer notnull
      |   | {int 2}: integer notnull
      | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SET _sens := ( SELECT CAST(_sens AS INTEGER) );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: integer sensitive
    | {select_core_list}: select: { _anon: integer sensitive }
    | | {select_core}: select: { _anon: integer sensitive }
    |   | {select_expr_list_con}: select: { _anon: integer sensitive }
    |     | {select_expr_list}: select: { _anon: integer sensitive }
    |     | | {select_expr}: integer sensitive
    |     |   | {cast_expr}: integer sensitive
    |     |     | {name _sens}: _sens: integer variable sensitive
    |     |     | {type_int}: integer
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT AVG(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { info: real sensitive }
  | {select_core_list}: select: { info: real sensitive }
  | | {select_core}: select: { info: real sensitive }
  |   | {select_expr_list_con}: select: { info: real sensitive }
  |     | {select_expr_list}: select: { info: real sensitive }
  |     | | {select_expr}: info: real sensitive
  |     |   | {call}: info: real sensitive
  |     |     | {name AVG}: info: real sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MIN(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { info: integer sensitive }
  | {select_core_list}: select: { info: integer sensitive }
  | | {select_core}: select: { info: integer sensitive }
  |   | {select_expr_list_con}: select: { info: integer sensitive }
  |     | {select_expr_list}: select: { info: integer sensitive }
  |     | | {select_expr}: info: integer sensitive
  |     |   | {call}: info: integer sensitive
  |     |     | {name MIN}: info: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MAX(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { info: integer sensitive }
  | {select_core_list}: select: { info: integer sensitive }
  | | {select_core}: select: { info: integer sensitive }
  |   | {select_expr_list_con}: select: { info: integer sensitive }
  |     | {select_expr_list}: select: { info: integer sensitive }
  |     | | {select_expr}: info: integer sensitive
  |     |   | {call}: info: integer sensitive
  |     |     | {name MAX}: info: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SUM(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { info: integer sensitive }
  | {select_core_list}: select: { info: integer sensitive }
  | | {select_core}: select: { info: integer sensitive }
  |   | {select_expr_list_con}: select: { info: integer sensitive }
  |     | {select_expr_list}: select: { info: integer sensitive }
  |     | | {select_expr}: info: integer sensitive
  |     |   | {call}: info: integer sensitive
  |     |     | {name SUM}: info: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COUNT(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { info: integer notnull sensitive }
  | {select_core_list}: select: { info: integer notnull sensitive }
  | | {select_core}: select: { info: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { info: integer notnull sensitive }
  |     | {select_expr_list}: select: { info: integer notnull sensitive }
  |     | | {select_expr}: info: integer notnull sensitive
  |     |   | {call}: info: integer notnull sensitive
  |     |     | {name COUNT}: info: integer notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT AVG(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { id: real }
  | {select_core_list}: select: { id: real }
  | | {select_core}: select: { id: real }
  |   | {select_expr_list_con}: select: { id: real }
  |     | {select_expr_list}: select: { id: real }
  |     | | {select_expr}: id: real
  |     |   | {call}: id: real
  |     |     | {name AVG}: id: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MAX(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {call}: id: integer
  |     |     | {name MAX}: id: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SUM(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {call}: id: integer
  |     |     | {name SUM}: id: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COUNT(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {call}: id: integer notnull
  |     |     | {name COUNT}: id: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET _sens := coalesce(_sens, 0);

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {call}: integer notnull sensitive
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name _sens}: _sens: integer variable sensitive
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := coalesce(1, 0);

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {call}: integer notnull
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS _sens;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is}: bool notnull sensitive
    | {int 0}: integer notnull
    | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SET _sens := _sens IS 0;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is}: bool notnull sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS 0;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is}: bool notnull
    | {int 0}: integer notnull
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS NOT _sens;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is_not}: bool notnull sensitive
    | {int 0}: integer notnull
    | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SET _sens := _sens IS NOT 0;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is_not}: bool notnull sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS NOT 0;

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {is_not}: bool notnull
    | {int 0}: integer notnull
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT *
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {exists_expr}: bool notnull sensitive
    |     |     | {select_stmt}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       | {select_core_list}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       | | {select_core}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | | {star}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT info
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {exists_expr}: bool notnull sensitive
    |     |     | {select_stmt}: select: { info: integer sensitive }
    |     |       | {select_core_list}: select: { info: integer sensitive }
    |     |       | | {select_core}: select: { info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { info: integer sensitive }
    |     |       |     | | {select_expr}: info: integer sensitive
    |     |       |     |   | {name info}: info: integer sensitive
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT id
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: bool notnull
    | {select_core_list}: select: { _anon: bool notnull }
    | | {select_core}: select: { _anon: bool notnull }
    |   | {select_expr_list_con}: select: { _anon: bool notnull }
    |     | {select_expr_list}: select: { _anon: bool notnull }
    |     | | {select_expr}: bool notnull
    |     |   | {exists_expr}: bool notnull
    |     |     | {select_stmt}: select: { id: integer }
    |     |       | {select_core_list}: select: { id: integer }
    |     |       | | {select_core}: select: { id: integer }
    |     |       |   | {select_expr_list_con}: select: { id: integer }
    |     |       |     | {select_expr_list}: select: { id: integer }
    |     |       |     | | {select_expr}: id: integer
    |     |       |     |   | {name id}: id: integer
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  WHERE info = 1 );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: id: integer sensitive
    | {select_core_list}: select: { id: integer sensitive }
    | | {select_core}: select: { id: integer sensitive }
    |   | {select_expr_list_con}: select: { id: integer sensitive }
    |     | {select_expr_list}: select: { id: integer sensitive }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {opt_where}: bool sensitive
    |         | | {eq}: bool sensitive
    |         |   | {name info}: info: integer sensitive
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  WHERE id = 1 );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: id: integer
    | {select_core_list}: select: { id: integer }
    | | {select_core}: select: { id: integer }
    |   | {select_expr_list_con}: select: { id: integer }
    |     | {select_expr_list}: select: { id: integer }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {opt_where}: bool
    |         | | {eq}: bool
    |         |   | {name id}: id: integer
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  GROUP BY info
  HAVING info = 1 );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: id: integer sensitive
    | {select_core_list}: select: { id: integer sensitive }
    | | {select_core}: select: { id: integer sensitive }
    |   | {select_expr_list_con}: select: { id: integer sensitive }
    |     | {select_expr_list}: select: { id: integer sensitive }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {opt_groupby}: ok
    |           | | {groupby_list}: ok
    |           |   | {groupby_item}
    |           |     | {name info}: info: integer sensitive
    |           | {select_having}
    |             | {opt_having}: bool sensitive
    |               | {eq}: bool sensitive
    |                 | {name info}: info: integer sensitive
    |                 | {int 1}: integer notnull
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO without_sensitive(name) SELECT name
  FROM with_sensitive;

Error at test/sem_test.sql:XXXX : in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'name'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name without_sensitive}: without_sensitive: { name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: select: { name: text sensitive }
        | {select_core_list}: select: { name: text sensitive }
        | | {select_core}: select: { name: text sensitive }
        |   | {select_expr_list_con}: select: { name: text sensitive }
        |     | {select_expr_list}: select: { name: text sensitive }
        |     | | {select_expr}: name: text sensitive
        |     |   | {name name}: name: text sensitive
        |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
        |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
        |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
        |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE a(
  key_ INTEGER NOT NULL PRIMARY KEY,
  sort_key INTEGER NOT NULL
);

  {create_table_stmt}: a: { key_: integer notnull primary_key, sort_key: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a}
  | {col_key_list}
    | {col_def}: key_: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name key_}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    |     | {col_attrs_pk}
    | {col_key_list}
      | {col_def}: sort_key: integer notnull
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name sort_key}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE b(
  key_ INTEGER NOT NULL PRIMARY KEY,
  a_key_ INTEGER NOT NULL,
  sort_key INTEGER NOT NULL
);

  {create_table_stmt}: b: { key_: integer notnull primary_key, a_key_: integer notnull, sort_key: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name b}
  | {col_key_list}
    | {col_def}: key_: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name key_}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    |     | {col_attrs_pk}
    | {col_key_list}
      | {col_def}: a_key_: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name a_key_}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: sort_key: integer notnull
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name sort_key}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY sort_key, key_;

  {select_stmt}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |   | | {name sort_key}: sort_key: integer notnull
    |   | {groupby_list}
    |     | {groupby_item}
    |       | {name key_}: key_: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY a_key_
LIMIT 2
OFFSET 3;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'a_key_'

  {select_stmt}: err
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {groupby_list}: err
    |   | {groupby_item}
    |     | {name a_key_}: err
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 2}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 3}: integer notnull

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY b.a_key_;

Error at test/sem_test.sql:XXXX : in dot : CQL0069: name not found 'a_key_'

  {select_stmt}: err
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {groupby_list}: err
    |   | {groupby_item}
    |     | {dot}: err
    |       | {name b}
    |       | {name a_key_}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM bar AS T1
  INNER JOIN with_sensitive AS T2 ON T1.id = T2.id AND T2.info = 1;

  {select_stmt}: select: { id: integer notnull sensitive }
  | {select_core_list}: select: { id: integer notnull sensitive }
  | | {select_core}: select: { id: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { id: integer notnull sensitive }
  |     | {select_expr_list}: select: { id: integer notnull sensitive }
  |     | | {select_expr}: id: integer notnull sensitive
  |     |   | {dot}: id: integer notnull sensitive
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: bar, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: bar, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: bar, T2: with_sensitive }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: bar, T2: with_sensitive }
  |       |         | {on}: bool sensitive
  |       |         | {and}: bool sensitive
  |       |           | {eq}: bool
  |       |           | | {dot}: id: integer notnull
  |       |           | | | {name T1}
  |       |           | | | {name id}
  |       |           | | {dot}: id: integer
  |       |           |   | {name T2}
  |       |           |   | {name id}
  |       |           | {eq}: bool sensitive
  |       |             | {dot}: info: integer sensitive
  |       |             | | {name T2}
  |       |             | | {name info}
  |       |             | {int 1}: integer notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM bar AS T1
  INNER JOIN with_sensitive AS T2 ON T1.id = T2.id;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {dot}: id: integer notnull
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: bar, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: bar, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: bar, T2: with_sensitive }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: bar, T2: with_sensitive }
  |       |         | {on}: bool
  |       |         | {eq}: bool
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM with_sensitive AS T1
  INNER JOIN with_sensitive AS T2 USING (info);

  {select_stmt}: select: { id: integer sensitive }
  | {select_core_list}: select: { id: integer sensitive }
  | | {select_core}: select: { id: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer sensitive }
  |     | {select_expr_list}: select: { id: integer sensitive }
  |     | | {select_expr}: id: integer sensitive
  |     |   | {dot}: id: integer sensitive
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       | | | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |         | {using}
  |       |         | {name_list}: info: integer sensitive
  |       |           | {name info}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM with_sensitive AS T1
  INNER JOIN with_sensitive AS T2 USING (id);

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {dot}: id: integer
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       | | | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |         | {using}
  |       |         | {name_list}: id: integer
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := _sens;

Error at test/sem_test.sql:XXXX : in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'X'

  {assign}: err
  | {name X}: err
  | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

CALL decl1(_sens);

Error at test/sem_test.sql:XXXX : in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {call_stmt}: err
  | {name decl1}: ok
  | {expr_list}: ok
    | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

DECLARE PROC sens_proc (OUT foo INTEGER @SENSITIVE);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name sens_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer variable out sensitive
        | {out}
        | {param_detail}: foo: integer variable out sensitive
          | {name foo}: foo: integer variable out sensitive
          | {sensitive_attr}: integer sensitive
            | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC non_sens_proc (OUT foo INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name non_sens_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer variable out
        | {out}
        | {param_detail}: foo: integer variable out
          | {name foo}: foo: integer variable out
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC non_sens_proc_nonnull (OUT foo INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name non_sens_proc_nonnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer notnull variable out
        | {out}
        | {param_detail}: foo: integer notnull variable out
          | {name foo}: foo: integer notnull variable out
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CALL sens_proc(X);

Error at test/sem_test.sql:XXXX : in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'X'

  {call_stmt}: err
  | {name sens_proc}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable

The statement ending at line XXXX

CALL non_sens_proc(_sens);

  {call_stmt}: ok
  | {name non_sens_proc}: ok
  | {expr_list}: ok
    | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

CALL non_sens_proc(int_nn);

Error at test/sem_test.sql:XXXX : in str : CQL0013: cannot assign/copy possibly null expression to not null target 'int_nn'

  {call_stmt}: err
  | {name non_sens_proc}: ok
  | {expr_list}: ok
    | {name int_nn}: int_nn: integer notnull variable

The statement ending at line XXXX

CALL non_sens_proc_nonnull(X);

Error at test/sem_test.sql:XXXX : in str : CQL0210: proc out parameter: arg must be an exact type match (even nullability) (expected integer notnull; found integer) 'X'

  {call_stmt}: err
  | {name non_sens_proc_nonnull}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(coalesce(_sens, 0));

Error at test/sem_test.sql:XXXX : in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: err
        | {select_core_list}: values: { column1: integer notnull sensitive }
        | | {select_core}: values: { column1: integer notnull sensitive }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull sensitive }
        |     | {insert_list}: err
        |       | {call}: integer notnull sensitive
        |         | {name coalesce}
        |         | {call_arg_list}
        |           | {call_filter_clause}
        |           | {arg_list}: ok
        |             | {name _sens}: _sens: integer variable sensitive
        |             | {arg_list}
        |               | {int 0}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

UPDATE bar
SET id = coalesce(_sens, 0)
  WHERE name = 'x';

Error at test/sem_test.sql:XXXX : in update_entry : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}
    |   | {name id}: id: integer notnull
    |   | {call}: integer notnull sensitive
    |     | {name coalesce}
    |     | {call_arg_list}
    |       | {call_filter_clause}
    |       | {arg_list}: ok
    |         | {name _sens}: _sens: integer variable sensitive
    |         | {arg_list}
    |           | {int 0}: integer notnull
    | {update_where}
      | {opt_where}
      | | {eq}
      |   | {name name}
      |   | {strlit 'x'}
      | {update_orderby}

The statement ending at line XXXX

DECLARE FUNC sens_func (id INTEGER @SENSITIVE, t TEXT) TEXT @SENSITIVE;

  {declare_func_stmt}: text sensitive
  | {name sens_func}: text sensitive
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in sensitive
    | | | {param_detail}: id: integer variable in sensitive
    | |   | {name id}: id: integer variable in sensitive
    | |   | {sensitive_attr}: integer sensitive
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |     | {param_detail}: t: text variable in
    |       | {name t}: t: text variable in
    |       | {type_text}: text
    | {sensitive_attr}: text sensitive
      | {type_text}: text

The statement ending at line XXXX

DECLARE sens_text TEXT @SENSITIVE;

  {declare_vars_type}: text sensitive
  | {name_list}: sens_text: text variable sensitive
  | | {name sens_text}: sens_text: text variable sensitive
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE non_sens_text TEXT;

  {declare_vars_type}: text
  | {name_list}: non_sens_text: text variable
  | | {name non_sens_text}: non_sens_text: text variable
  | {type_text}: text

The statement ending at line XXXX

SET sens_text := sens_func(1, 'x');

  {assign}: sens_text: text variable sensitive
  | {name sens_text}: sens_text: text variable sensitive
  | {call}: text sensitive
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET non_sens_text := sens_func(1, 'x');

Error at test/sem_test.sql:XXXX : in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'non_sens_text'

  {assign}: err
  | {name non_sens_text}: err
  | {call}: text sensitive
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET sens_text := sens_func(1, sens_text);

Error at test/sem_test.sql:XXXX : in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 't'

  {assign}: err
  | {name sens_text}: sens_text: text variable sensitive
  | {call}: err
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name sens_text}: sens_text: text variable sensitive

The statement ending at line XXXX

UPDATE foo
SET id = CAST(1 AS INTEGER);

  {update_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {cast_expr}: integer notnull
    |     | {int 1}: integer notnull
    |     | {type_int}: integer
    | {update_where}
      | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_delete_form ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  DELETE FROM bar WHERE id IN (SELECT *
    FROM x);
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_delete_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_delete_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}: ok
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {opt_where}: bool notnull
            | {in_pred}: bool notnull
              | {name id}: id: integer notnull
              | {select_stmt}: id: integer
                | {select_core_list}: select: { id: integer notnull }
                | | {select_core}: select: { id: integer notnull }
                |   | {select_expr_list_con}: select: { id: integer notnull }
                |     | {select_expr_list}: select: { id: integer notnull }
                |     | | {star}: select: { id: integer notnull }
                |     | {select_from_etc}: TABLE { x: x }
                |       | {table_or_subquery_list}: TABLE { x: x }
                |       | | {table_or_subquery}: TABLE { x: x }
                |       |   | {name x}: TABLE { x: x }
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_delete_form_bogus_cte ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 'x')
  DELETE FROM bar WHERE id IN (SELECT *
    FROM x);
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0012: incompatible types in expression '_anon'

  {create_proc_stmt}: err
  | {name with_delete_form_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_delete_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: err
        |       | {select_core_list}: err
        |       | | {select_core}: err
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: err
        |       |     | {select_core}: select: { _anon: text notnull }
        |       |       | {select_expr_list_con}: select: { _anon: text notnull }
        |       |         | {select_expr_list}: select: { _anon: text notnull }
        |       |         | | {select_expr}: text notnull
        |       |         |   | {strlit 'x'}: text notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}
          | {name bar}
          | {opt_where}
            | {in_pred}
              | {name id}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {star}
                |     | {select_from_etc}
                |       | {table_or_subquery_list}
                |       | | {table_or_subquery}
                |       |   | {name x}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_delete_form_bogus_delete ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  DELETE FROM not_valid_table WHERE id IN (SELECT *
    FROM x);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0151: table in delete statement does not exist 'not_valid_table'

  {create_proc_stmt}: err
  | {name with_delete_form_bogus_delete}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_delete_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}: err
          | {name not_valid_table}
          | {opt_where}
            | {in_pred}
              | {name id}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {star}
                |     | {select_from_etc}
                |       | {table_or_subquery_list}
                |       | | {table_or_subquery}
                |       |   | {name x}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_update_form ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_update_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {update_set}
            | {update_list}: ok
            | | {update_entry}: name: text
            |   | {name name}: name: text
            |   | {strlit 'xyzzy'}: text notnull
            | {update_where}
              | {opt_where}: bool notnull
              | | {in_pred}: bool notnull
              |   | {name id}: id: integer notnull
              |   | {select_stmt}: id: integer
              |     | {select_core_list}: select: { id: integer notnull }
              |     | | {select_core}: select: { id: integer notnull }
              |     |   | {select_expr_list_con}: select: { id: integer notnull }
              |     |     | {select_expr_list}: select: { id: integer notnull }
              |     |     | | {star}: select: { id: integer notnull }
              |     |     | {select_from_etc}: TABLE { x: x }
              |     |       | {table_or_subquery_list}: TABLE { x: x }
              |     |       | | {table_or_subquery}: TABLE { x: x }
              |     |       |   | {name x}: TABLE { x: x }
              |     |       | {select_where}
              |     |         | {select_groupby}
              |     |           | {select_having}
              |     | {select_orderby}
              |       | {select_limit}
              |         | {select_offset}
              | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_update_form_bogus_cte ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 'x')
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0012: incompatible types in expression '_anon'

  {create_proc_stmt}: err
  | {name with_update_form_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_update_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: err
        |       | {select_core_list}: err
        |       | | {select_core}: err
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: err
        |       |     | {select_core}: select: { _anon: text notnull }
        |       |       | {select_expr_list_con}: select: { _anon: text notnull }
        |       |         | {select_expr_list}: select: { _anon: text notnull }
        |       |         | | {select_expr}: text notnull
        |       |         |   | {strlit 'x'}: text notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}
          | {name bar}
          | {update_set}
            | {update_list}
            | | {update_entry}
            |   | {name name}
            |   | {strlit 'xyzzy'}
            | {update_where}
              | {opt_where}
              | | {in_pred}
              |   | {name id}
              |   | {select_stmt}
              |     | {select_core_list}
              |     | | {select_core}
              |     |   | {select_expr_list_con}
              |     |     | {select_expr_list}
              |     |     | | {star}
              |     |     | {select_from_etc}
              |     |       | {table_or_subquery_list}
              |     |       | | {table_or_subquery}
              |     |       |   | {name x}
              |     |       | {select_where}
              |     |         | {select_groupby}
              |     |           | {select_having}
              |     | {select_orderby}
              |       | {select_limit}
              |         | {select_offset}
              | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_update_form_bogus_delete ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  UPDATE not_valid_table
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0154: table in update statement does not exist 'not_valid_table'

  {create_proc_stmt}: err
  | {name with_update_form_bogus_delete}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_update_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}: err
          | {name not_valid_table}
          | {update_set}
            | {update_list}
            | | {update_entry}
            |   | {name name}
            |   | {strlit 'xyzzy'}
            | {update_where}
              | {opt_where}
              | | {in_pred}
              |   | {name id}
              |   | {select_stmt}
              |     | {select_core_list}
              |     | | {select_core}
              |     |   | {select_expr_list_con}
              |     |     | {select_expr_list}
              |     |     | | {star}
              |     |     | {select_from_etc}
              |     |       | {table_or_subquery_list}
              |     |       | | {table_or_subquery}
              |     |       |   | {name x}
              |     |       | {select_where}
              |     |         | {select_groupby}
              |     |           | {select_having}
              |     | {select_orderby}
              |       | {select_limit}
              |         | {select_offset}
              | {update_orderby}

The statement ending at line XXXX

DECLARE PROC out_cursor_proc () OUT (A INTEGER NOT NULL, B INTEGER NOT NULL) USING TRANSACTION;

  {declare_proc_stmt}: select: { A: integer notnull, B: integer notnull } dml_proc uses_out
  | {proc_name_type}
  | | {name out_cursor_proc}: select: { A: integer notnull, B: integer notnull } dml_proc uses_out
  | | {int 7}
  | {proc_params_stmts}
    | {typed_names}: select: { A: integer notnull, B: integer notnull }
      | {typed_name}: A: integer notnull
      | | {name A}
      | | {notnull}: A: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: B: integer notnull
          | {name B}
          | {notnull}: B: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC decl1 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

  {create_proc_stmt}: ok
  | {name decl1}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_vars_type}: integer
        | {name_list}: i: integer variable
        | | {name i}: i: integer variable
        | {type_int}: integer

The statement ending at line XXXX

CREATE PROC decl1 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0186: duplicate stored proc name 'decl1'

  {create_proc_stmt}: err
  | {name decl1}: err
  | {proc_params_stmts}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name id}
    |     | {type_int}
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name i}
        | {type_int}

The statement ending at line XXXX

CREATE PROC decl2 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in declare_proc_stmt : DECLARE PROC decl2 (id INTEGER) USING TRANSACTION
Error at test/sem_test.sql:XXXX : in create_proc_stmt : DECLARE PROC decl2 (id INTEGER)
The above must be identical.
Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0189: procedure declarations/definitions do not match 'decl2'

  {create_proc_stmt}: err
  | {name decl2}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_vars_type}: integer
        | {name_list}: i: integer variable
        | | {name i}: i: integer variable
        | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test, dummy_table, dummy_insert, dummy_select, dummy_result_set))
CREATE PROC autotest_all_attribute ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_test}: ok
  |     | {misc_attr_value_list}
  |       | {name dummy_table}: ok
  |       | {misc_attr_value_list}
  |         | {name dummy_insert}: ok
  |         | {misc_attr_value_list}
  |           | {name dummy_select}: ok
  |           | {misc_attr_value_list}
  |             | {name dummy_result_set}: ok
  | {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_all_attribute}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name), (1, 'Nelly'), (-2, 'Babeth')), (foo, (id), (777)))))
CREATE PROC autotest_dummy_test_with_others_attributes ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: ok
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |           | | {name bar}: ok
  |           | | {misc_attr_value_list}
  |           |   | {misc_attr_value_list}
  |           |   | | {name id}: ok
  |           |   | | {misc_attr_value_list}
  |           |   |   | {name name}: ok
  |           |   | {misc_attr_value_list}
  |           |     | {misc_attr_value_list}
  |           |     | | {int 1}: ok
  |           |     | | {misc_attr_value_list}
  |           |     |   | {strlit 'Nelly'}: ok
  |           |     | {misc_attr_value_list}
  |           |       | {misc_attr_value_list}
  |           |         | {uminus}
  |           |         | | {int 2}: ok
  |           |         | {misc_attr_value_list}
  |           |           | {strlit 'Babeth'}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |               | {name foo}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                 | | {name id}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}
  |                     | {int 777}: ok
  | {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_with_others_attributes}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (id), (1), (2)))))
CREATE PROC autotest_dummy_test_without_other_attributes ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {misc_attr_value_list}
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |             | | {name id}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {int 1}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 2}: ok
  | {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_without_other_attributes}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (one)))))
CREATE PROC autotest_dummy_test_invalid_col_str_value ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {name one}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_str_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (id), (0.1)))))
CREATE PROC autotest_dummy_test_invalid_col_dbl_value ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in num : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {misc_attr_value_list}
  |       | {name dummy_test}: err
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |             | | {name id}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |                 | {dbl 0.1}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_dbl_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (rate), (1)))))
CREATE PROC autotest_dummy_test_long_col_with_int_value ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {misc_attr_value_list}
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |             | | {name rate}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |                 | {int 1}: ok
  | {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_long_col_with_int_value}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (rate), (-1)))))
CREATE PROC autotest_dummy_test_neg_long_col_with_int_value ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {misc_attr_value_list}
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |             | | {name rate}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |                 | {uminus}
  |                   | {int 1}: ok
  | {create_proc_stmt}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_neg_long_col_with_int_value}: select: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), ('bogus')))))
CREATE PROC autotest_dummy_test_invalid_col_strlit_value ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {strlit 'bogus'}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_strlit_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (1L)))))
CREATE PROC autotest_dummy_test_invalid_col_lng_value ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in num : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {longint 1}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_lng_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, id, (1), (2)))))
CREATE PROC autotest_dummy_test_invalid_col_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (column name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {name id}
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                 | | {int 1}
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}
  |                     | {int 2}
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (1, 2)))))
CREATE PROC autotest_dummy_test_too_many_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (too many column values) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 1}: ok
  |                   | {misc_attr_value_list}
  |                     | {int 2}
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_too_many_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name), (1)))))
CREATE PROC autotest_dummy_test_missing_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (mismatch number of column and values) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | | {misc_attr_value_list}
  |               |   | {name name}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_missing_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name)))))
CREATE PROC autotest_dummy_test_no_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (column value should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |                 | {name id}: ok
  |                 | {misc_attr_value_list}
  |                   | {name name}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_no_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (1, (id), (1)))))
CREATE PROC autotest_bogus_table_name_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in misc_attr_value_list : CQL0273: autotest attribute has incorrect format (table name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: err
  |             | {int 1}
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 1}
  | {create_proc_stmt}: err
    | {name autotest_bogus_table_name_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (1), (1)))))
CREATE PROC autotest_bogus_colum_name_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (column name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {int 1}
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 1}
  | {create_proc_stmt}: err
    | {name autotest_bogus_colum_name_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), 1))))
CREATE PROC autotest_colum_value_incorrect_format ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0273: autotest attribute has incorrect format (column value should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {int 1}
  | {create_proc_stmt}: err
    | {name autotest_colum_value_incorrect_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (bogus_col), (1), (2)))))
CREATE PROC autotest_dummy_test_bogus_col_name ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0275: autotest attribute 'dummy_test' has non existent column 'bogus_col'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name bogus_col}: err
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                 | | {int 1}
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}
  |                     | {int 2}
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_bogus_col_name}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bogus_table, (id), (1), (2)))))
CREATE PROC autotest_dummy_test_bogus_table_name ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0274: autotest attribute 'dummy_test' has non existent table 'bogus_table'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |             | {name bogus_table}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {name id}
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                 | | {int 1}
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}
  |                     | {int 2}
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_bogus_table_name}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_bogus))
CREATE PROC autotest_dummy_bogus ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0278: autotest attribute name is not valid 'dummy_bogus'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_bogus}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_bogus}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_bogus)))
CREATE PROC autotest_bogus_nested_attribute ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0277: autotest has incorrect format

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name dummy_bogus}: err
  | {create_proc_stmt}: err
    | {name autotest_bogus_nested_attribute}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test, (bar, (id), (1))))
CREATE PROC autotest_dummy_test_not_nested ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0277: autotest has incorrect format

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_test}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}
  |         | {name bar}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}
  |           | | {name id}
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |               | {int 1}
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_not_nested}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=dummy_table)
CREATE PROC autotest_incorrect_formatting ()
BEGIN
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0277: autotest has incorrect format

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {name dummy_table}: err
  | {create_proc_stmt}: err
    | {name autotest_incorrect_formatting}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TEMP TABLE table1(
  id INTEGER
);

  {create_table_stmt}: table1: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table1}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TEMP TABLE table2(
  id INTEGER
);

  {create_table_stmt}: table2: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table2}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE not_a_temp_table(
  id INTEGER
);

  {create_table_stmt}: not_a_temp_table: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name not_a_temp_table}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodropper ()
BEGIN
  SELECT *
    FROM table1;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: select: { id: integer } dml_proc
    | {name autodropper}: select: { id: integer } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(not_an_object))
CREATE PROC autodropper_not_an_objecte ()
BEGIN
  SELECT *
    FROM table1;
END;

Error at test/sem_test.sql:XXXX : in misc_attr_value_list : CQL0181: autodrop temp table does not exist 'not_an_object'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name not_an_object}
  | {create_proc_stmt}: err
    | {name autodropper_not_an_objecte}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(ViewShape))
CREATE PROC autodropper_dropping_view ()
BEGIN
  SELECT *
    FROM table1;
END;

Error at test/sem_test.sql:XXXX : in misc_attr_value_list : CQL0182: autodrop target is not a table 'ViewShape'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name ViewShape}
  | {create_proc_stmt}: err
    | {name autodropper_dropping_view}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(not_a_temp_table))
CREATE PROC autodropper_not_temp_table ()
BEGIN
  SELECT *
    FROM table1;
END;

Error at test/sem_test.sql:XXXX : in misc_attr_value_list : CQL0183: autodrop target must be a temporary table 'not_a_temp_table'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name not_a_temp_table}
  | {create_proc_stmt}: err
    | {name autodropper_not_temp_table}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodrop_not_really_a_result_set_proc ()
BEGIN
  DECLARE i INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0234: autodrop annotation can only go on a procedure that returns a result set 'autodrop_not_really_a_result_set_proc'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: err
    | {name autodrop_not_really_a_result_set_proc}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: i: integer variable
          | | {name i}: i: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodrop_no_db ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS id;
  FETCH c(id) FROM VALUES(1);
  OUT c;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0236: autodrop annotation can only go on a procedure that uses the database 'autodrop_no_db'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: err
    | {name autodrop_no_db}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_cursor_like_select}: C: select: { id: integer notnull } variable auto_cursor value_cursor
        | | {name C}: C: select: { id: integer notnull } variable auto_cursor value_cursor
        | | {select_stmt}: select: { id: integer notnull }
        |   | {select_core_list}: select: { id: integer notnull }
        |   | | {select_core}: select: { id: integer notnull }
        |   |   | {select_expr_list_con}: select: { id: integer notnull }
        |   |     | {select_expr_list}: select: { id: integer notnull }
        |   |     | | {select_expr}: id: integer notnull
        |   |     |   | {int 1}: integer notnull
        |   |     |   | {opt_as_alias}
        |   |     |     | {name id}
        |   |     | {select_from_etc}: ok
        |   |       | {select_where}
        |   |         | {select_groupby}
        |   |           | {select_having}
        |   | {select_orderby}
        |     | {select_limit}
        |       | {select_offset}
        | {fetch_values_stmt}: ok
        | | {name_columns_values}
        |   | {name c}: C: select: { id: integer notnull } variable auto_cursor value_cursor
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {insert_list}
        |       | {int 1}: integer notnull
        | {out_stmt}: C: select: { id: integer notnull } variable auto_cursor value_cursor
          | {name c}: C: select: { id: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE TABLE referenceable(
  a INTEGER PRIMARY KEY,
  b REAL UNIQUE,
  c TEXT,
  d TEXT,
  e LONG_INT
);

  {create_table_stmt}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable}
  | {col_key_list}
    | {col_def}: a: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: b: real unique_key
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name b}
      |   | | {type_real}: real
      |   | {col_attrs_unique}: ok
      | {col_key_list}
        | {col_def}: c: text
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_text}: text
        | {col_key_list}
          | {col_def}: d: text
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_text}: text
          | {col_key_list}
            | {col_def}: e: longint
              | {col_def_type_attrs}
                | {col_def_name_type}
                  | {name e}
                  | {type_long}: longint

The statement ending at line XXXX

CREATE TABLE referenceable_2(
  a INTEGER,
  b REAL,
  PRIMARY KEY (a, b)
);

  {create_table_stmt}: referenceable_2: { a: integer notnull, b: real notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable_2}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name a}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: b: real notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_real}: real
      | {col_key_list}
        | {pk_def}
          | {name_list}
            | {name a}
            | {name_list}
              | {name b}

The statement ending at line XXXX

CREATE UNIQUE INDEX referenceable_index ON referenceable (c, d);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name referenceable_index}
  | | {name referenceable}
  | {flags_names_attrs}
    | {int 1}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
        | | {name c}: c: text
        | {indexed_columns}
          | {indexed_column}
            | {name d}: d: text

The statement ending at line XXXX

CREATE TABLE reference_pk(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES referenceable (a)
);

  {create_table_stmt}: reference_pk: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name referenceable}
          | | {name_list}
          |   | {name a}: a: integer notnull
          | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_2_pk(
  id INTEGER,
  size REAL,
  FOREIGN KEY (id, size) REFERENCES referenceable_2 (a, b)
);

  {create_table_stmt}: reference_2_pk: { id: integer foreign_key, size: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_2_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: size: real
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name size}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: ok
          | {name_list}
          | | {name id}: id: integer
          | | {name_list}
          |   | {name size}: size: real
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable_2}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_2_wrong_order_pk(
  id INTEGER,
  size REAL,
  FOREIGN KEY (size, id) REFERENCES referenceable_2 (b, a)
);

  {create_table_stmt}: reference_2_wrong_order_pk: { id: integer foreign_key, size: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_2_wrong_order_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: size: real
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name size}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: ok
          | {name_list}
          | | {name size}: size: real
          | | {name_list}
          |   | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable_2}
            | | {name_list}
            |   | {name b}: b: real notnull
            |   | {name_list}
            |     | {name a}: a: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_uk(
  id REAL,
  FOREIGN KEY (id) REFERENCES referenceable (b)
);

  {create_table_stmt}: reference_uk: { id: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_uk}
  | {col_key_list}
    | {col_def}: id: real
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_real}: real
    | {col_key_list}
      | {fk_def}: ok
        | {name_list}
        | | {name id}: id: real
        | {fk_target_options}
          | {fk_target}
          | | {name referenceable}
          | | {name_list}
          |   | {name b}: b: real
          | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_pk_and_uk(
  id1 INTEGER,
  id2 REAL,
  FOREIGN KEY (id1, id2) REFERENCES referenceable (a, b)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk_and_uk}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: real
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: err
          | {name_list}
          | | {name id1}: id1: integer
          | | {name_list}
          |   | {name id2}: id2: real
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real
            | {int 0}

The statement ending at line XXXX

CREATE TABLE referenceable_unique_index(
  id TEXT,
  label TEXT,
  FOREIGN KEY (id, label) REFERENCES referenceable (c, d)
);

  {create_table_stmt}: referenceable_unique_index: { id: text foreign_key, label: text foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable_unique_index}
  | {col_key_list}
    | {col_def}: id: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: label: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name label}
      |     | {type_text}: text
      | {col_key_list}
        | {fk_def}: ok
          | {name_list}
          | | {name id}: id: text
          | | {name_list}
          |   | {name label}: label: text
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name c}: c: text
            |   | {name_list}
            |     | {name d}: d: text
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_pk_and_unique_index(
  id1 INTEGER,
  id2 TEXT,
  FOREIGN KEY (id1, id2) REFERENCES referenceable (a, c)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk_and_unique_index}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {fk_def}: err
          | {name_list}
          | | {name id1}: id1: integer
          | | {name_list}
          |   | {name id2}: id2: text
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name c}: c: text
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_uk_and_unique_index(
  id1 REAL,
  id2 TEXT,
  id3 TEXT,
  FOREIGN KEY (id1, id2, id3) REFERENCES referenceable (b, c, d)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_uk_and_unique_index}
  | {col_key_list}
    | {col_def}: id1: real
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_real}: real
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: id3: text
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name id3}
        |     | {type_text}: text
        | {col_key_list}
          | {fk_def}: err
            | {name_list}
            | | {name id1}: id1: real
            | | {name_list}
            |   | {name id2}: id2: text
            |   | {name_list}
            |     | {name id3}: id3: text
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable}
              | | {name_list}
              |   | {name b}: b: real
              |   | {name_list}
              |     | {name c}: c: text
              |     | {name_list}
              |       | {name d}: d: text
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_column(
  id LONG_INT PRIMARY KEY,
  FOREIGN KEY (id) REFERENCES referenceable (e)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_column}
  | {col_key_list}
    | {col_def}: id: longint notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_long}: longint
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name id}: id: longint notnull
        | {fk_target_options}
          | {fk_target}
          | | {name referenceable}
          | | {name_list}
          |   | {name e}: e: longint
          | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_columns(
  id1 TEXT PRIMARY KEY,
  id2 TEXT,
  id3 TEXT,
  FOREIGN KEY (id1, id2, id3) REFERENCES referenceable (c, d, e)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_columns}
  | {col_key_list}
    | {col_def}: id1: text notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id1}
    |   | | {type_text}: text
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: id3: text
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name id3}
        |     | {type_text}: text
        | {col_key_list}
          | {fk_def}: err
            | {name_list}
            | | {name id1}: id1: text notnull
            | | {name_list}
            |   | {name id2}: id2: text
            |   | {name_list}
            |     | {name id3}: id3: text
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable}
              | | {name_list}
              |   | {name c}: c: text
              |   | {name_list}
              |     | {name d}: d: text
              |     | {name_list}
              |       | {name e}: e: longint
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_column(
  id TEXT,
  FOREIGN KEY (id) REFERENCES referenceable (c)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_column}
  | {col_key_list}
    | {col_def}: id: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name id}: id: text
        | {fk_target_options}
          | {fk_target}
          | | {name referenceable}
          | | {name_list}
          |   | {name c}: c: text
          | {int 0}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON DELETE;

  {enforce_strict_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON UPDATE;

  {enforce_normal_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON DELETE;

  {enforce_normal_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON DELETE;

  {enforce_strict_stmt}: ok
  | {int 2}

The statement ending at line XXXX

CREATE TABLE fk_strict_ok(
  id INTEGER REFERENCES foo (id) ON UPDATE CASCADE ON DELETE CASCADE
);

  {create_table_stmt}: fk_strict_ok: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_ok}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 51}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_update(
  id INTEGER REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in col_attrs_fk : CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_update}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_delete(
  id INTEGER REFERENCES foo (id) ON UPDATE NO ACTION
);

Error at test/sem_test.sql:XXXX : in col_attrs_fk : CQL0238: strict FK validation requires that some ON DELETE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 80}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_delete_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id) ON UPDATE NO ACTION
);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0238: strict FK validation requires that some ON DELETE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_delete_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}: id: integer notnull
          | {int 80}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_update_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id)
);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_update_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}: id: integer notnull
          | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_strict_success_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id) ON UPDATE CASCADE ON DELETE NO ACTION
);

  {create_table_stmt}: fk_strict_success_loose: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_success_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {name_list}
        | | {name id}: id: integer
        | {fk_target_options}
          | {fk_target}
          | | {name foo}
          | | {name_list}
          |   | {name id}: id: integer notnull
          | {int 53}

The statement ending at line XXXX

@ATTRIBUTE(cql:identity=(col1, col3))
CREATE PROC invalid_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0239: procedure identity column does not exist in result set 'col3'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name identity}
  |   | {misc_attr_value_list}
  |     | {name col1}: ok
  |     | {misc_attr_value_list}
  |       | {name col3}
  | {create_proc_stmt}: err
    | {name invalid_identity}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          | {select_core_list}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          | | {select_core}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |   | {select_expr_list_con}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |     | {select_expr_list}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |     | | {select_expr}: col1: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name col1}
          |     | | {select_expr_list}
          |     |   | {select_expr}: col2: integer notnull
          |     |   | | {int 2}: integer notnull
          |     |   | | {opt_as_alias}
          |     |   |   | {name col2}
          |     |   | {select_expr_list}
          |     |     | {select_expr}: data: integer notnull
          |     |       | {int 3}: integer notnull
          |     |       | {opt_as_alias}
          |     |         | {name data}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:identity=(col1, col3))
CREATE PROC no_result_set_identity ()
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0240: identity annotation can only go on a procedure that returns a result set 'no_result_set_identity'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name identity}
  |   | {misc_attr_value_list}
  |     | {name col1}: ok
  |     | {misc_attr_value_list}
  |       | {name col3}: ok
  | {create_proc_stmt}: err
    | {name no_result_set_identity}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC test_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_base_fragment}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_two (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM plugin_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_extension_fragment_union}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_two: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: plugin_two: { x: integer notnull, y: text, z: longint }
          |       | | {name plugin_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { plugin_two: plugin_two }
            |       | {table_or_subquery_list}: TABLE { plugin_two: plugin_two }
            |       | | {table_or_subquery}: TABLE { plugin_two: plugin_two }
            |       |   | {name plugin_two}: TABLE { plugin_two: plugin_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_two_a (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM plugin_two_a;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_extension_fragment_union_two}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_two_a: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: plugin_two_a: { x: integer notnull, y: text, z: longint }
          |       | | {name plugin_two_a}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { plugin_two_a: plugin_two_a }
            |       | {table_or_subquery_list}: TABLE { plugin_two_a: plugin_two_a }
            |       | | {table_or_subquery}: TABLE { plugin_two_a: plugin_two_a }
            |       |   | {name plugin_two_a}: TABLE { plugin_two_a: plugin_two_a }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=another_core)
CREATE PROC test_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  another_core (x, y) AS (SELECT T1.id, name
    FROM foo AS T1
    INNER JOIN bar AS T2 ON T1.id = T2.id
    WHERE T1.id = id_)
  SELECT *
    FROM another_core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name another_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text } dml_proc
    | {name test_base_fragment_two}: select: { x: integer notnull, y: text } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: another_core: { x: integer notnull, y: text }
          |     | {cte_decl}: another_core: { x: integer notnull, y: text }
          |     | | {name another_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     | {select_stmt}: select: { id: integer notnull, name: text }
          |       | {select_core_list}: select: { id: integer notnull, name: text }
          |       | | {select_core}: select: { id: integer notnull, name: text }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {dot}: id: integer notnull
          |       |     | |   | {name T1}
          |       |     | |   | {name id}
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |     | {name name}: name: text
          |       |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
          |       |       | {join_clause}: JOIN { T1: foo, T2: bar }
          |       |       | | {table_or_subquery}: TABLE { T1: foo }
          |       |       | | | {name foo}: TABLE { T1: foo }
          |       |       | | | {opt_as_alias}
          |       |       | |   | {name T1}
          |       |       | | {join_target_list}
          |       |       |   | {join_target}: JOIN { T1: foo, T2: bar }
          |       |       |     | {int 1}
          |       |       |     | {table_join}
          |       |       |       | {table_or_subquery}: TABLE { T2: bar }
          |       |       |       | | {name bar}: TABLE { T2: bar }
          |       |       |       | | {opt_as_alias}
          |       |       |       |   | {name T2}
          |       |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
          |       |       |         | {on}: bool notnull
          |       |       |         | {eq}: bool notnull
          |       |       |           | {dot}: id: integer notnull
          |       |       |           | | {name T1}
          |       |       |           | | {name id}
          |       |       |           | {dot}: id: integer notnull
          |       |       |             | {name T2}
          |       |       |             | {name id}
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {dot}: id: integer notnull
          |       |         |   | | {name T1}
          |       |         |   | | {name id}
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text }
            | {select_core_list}: select: { x: integer notnull, y: text }
            | | {select_core}: select: { x: integer notnull, y: text }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
            |     | {select_expr_list}: select: { x: integer notnull, y: text }
            |     | | {star}: select: { x: integer notnull, y: text }
            |     | {select_from_etc}: TABLE { another_core: another_core }
            |       | {table_or_subquery_list}: TABLE { another_core: another_core }
            |       | | {table_or_subquery}: TABLE { another_core: another_core }
            |       |   | {name another_core}: TABLE { another_core: another_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC test_duplicate_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0256: fragment name conflicts with existing base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_duplicate_base_fragment}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_one)
CREATE PROC bad_base_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_one (id, name, rate) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT id
    FROM core_one;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core_one'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_one}
  | {create_proc_stmt}: err
    | {name bad_base_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_one: { id: integer notnull, name: text, rate: longint }
          |     | {cte_decl}: core_one: { id: integer notnull, name: text, rate: longint }
          |     | | {name core_one}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name name}
          |     |     | {name_list}
          |     |       | {name rate}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull }
            | | {select_core}: select: { id: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull }
            |     | | {select_expr}: id: integer notnull
            |     |   | {name id}: id: integer notnull
            |     | {select_from_etc}: TABLE { core_one: core_one }
            |       | {table_or_subquery_list}: TABLE { core_one: core_one }
            |       | | {table_or_subquery}: TABLE { core_one: core_one }
            |       |   | {name core_one}: TABLE { core_one: core_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_two)
CREATE PROC bad_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_two (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core_two'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_two}
  | {create_proc_stmt}: err
    | {name bad_base_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_two: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core_two: { x: integer notnull, y: text, z: longint }
          |     | | {name core_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { bar: bar }
            |       | {table_or_subquery_list}: TABLE { bar: bar }
            |       | | {table_or_subquery}: TABLE { bar: bar }
            |       |   | {name bar}: TABLE { bar: bar }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=bar)
CREATE PROC bad_base_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_three (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM bar;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0253: base fragment must include a single CTE named same as the fragment 'bar'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name bar}
  | {create_proc_stmt}: err
    | {name bad_base_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_three: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core_three: { x: integer notnull, y: text, z: longint }
          |     | | {name core_three}: err
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { bar: bar }
            |       | {table_or_subquery_list}: TABLE { bar: bar }
            |       | | {table_or_subquery}: TABLE { bar: bar }
            |       |   | {name bar}: TABLE { bar: bar }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_four)
CREATE PROC bad_base_fragment_four (id_ INTEGER NOT NULL)
BEGIN
  SELECT id, name, rate
    FROM bar
    WHERE id = id_;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_four}
  | {create_proc_stmt}: err
    | {name bad_base_fragment_four}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {select_expr}: id: integer notnull
          |     | | | {name id}: id: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text
          |     |   | | {name name}: name: text
          |     |   | {select_expr_list}
          |     |     | {select_expr}: rate: longint
          |     |       | {name rate}: rate: longint
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {opt_where}: bool notnull
          |         | | {eq}: bool notnull
          |         |   | {name id}: id: integer notnull
          |         |   | {name id_}: id_: integer notnull variable in
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TABLE plugin_table(
  id INTEGER PRIMARY KEY,
  name TEXT,
  flag BOOL
);

  {create_table_stmt}: plugin_table: { id: integer notnull primary_key, name: text, flag: bool }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name plugin_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: flag: bool
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name flag}
              | {type_bool}: bool

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_not_union_all (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  not_union_all (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z
  EXCEPT
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM not_union_all;
END;

Error at test/sem_test.sql:XXXX : in select_core_compound : CQL0333: all the compound operators in this CTE must be UNION ALL 'not_union_all'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_extension_fragment_not_union_all}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: not_union_all: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: not_union_all: { x: integer notnull, y: text, z: longint }
          |       | | {name not_union_all}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: EXCEPT: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     |   | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     |   | | {select_expr}: x: integer notnull
          |         |     |   | | | {int 3}: integer notnull
          |         |     |   | | | {opt_as_alias}
          |         |     |   | |   | {name x}
          |         |     |   | | {select_expr_list}
          |         |     |   |   | {select_expr}: y: text notnull
          |         |     |   |   | | {strlit 'y'}: text notnull
          |         |     |   |   | | {opt_as_alias}
          |         |     |   |   |   | {name y}
          |         |     |   |   | {select_expr_list}
          |         |     |   |     | {select_expr}: z: longint notnull
          |         |     |   |       | {longint 5}: longint notnull
          |         |     |   |       | {opt_as_alias}
          |         |     |   |         | {name z}
          |         |     |   | {select_from_etc}: ok
          |         |     |     | {select_where}
          |         |     |       | {select_groupby}
          |         |     |         | {select_having}
          |         |     | {select_core_compound}
          |         |       | {int 4}
          |         |       | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |           | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |             | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |             | | {select_expr}: x: integer notnull
          |         |             | | | {int 3}: integer notnull
          |         |             | | | {opt_as_alias}
          |         |             | |   | {name x}
          |         |             | | {select_expr_list}
          |         |             |   | {select_expr}: y: text notnull
          |         |             |   | | {strlit 'y'}: text notnull
          |         |             |   | | {opt_as_alias}
          |         |             |   |   | {name y}
          |         |             |   | {select_expr_list}
          |         |             |     | {select_expr}: z: longint notnull
          |         |             |       | {longint 5}: longint notnull
          |         |             |       | {opt_as_alias}
          |         |             |         | {name z}
          |         |             | {select_from_etc}: ok
          |         |               | {select_where}
          |         |                 | {select_groupby}
          |         |                   | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { not_union_all: not_union_all }
            |       | {table_or_subquery_list}: TABLE { not_union_all: not_union_all }
            |       | | {table_or_subquery}: TABLE { not_union_all: not_union_all }
            |       |   | {name not_union_all}: TABLE { not_union_all: not_union_all }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_extension_fragment}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_out_of_order (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  out_of_order (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM out_of_order;
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0332: all extension fragments that use UNION ALL must come before those that use LEFT OUTER JOIN 'out_of_order'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_extension_fragment_union_out_of_order}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: out_of_order: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: out_of_order: { x: integer notnull, y: text, z: longint }
          |       | | {name out_of_order}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { out_of_order: out_of_order }
            |       | {table_or_subquery_list}: TABLE { out_of_order: out_of_order }
            |       | | {table_or_subquery}: TABLE { out_of_order: out_of_order }
            |       |   | {name out_of_order}: TABLE { out_of_order: out_of_order }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_bad_args (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_one;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0322: fragment parameters must be exactly '(id_ INTEGER NOT NULL)'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_extension_fragment_bad_args}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=wrong_core)
CREATE PROC test_bad_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_one;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0255: fragment name is not a previously declared base fragment 'wrong_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name wrong_core}: err
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       |   | {name plugin_wrong_one}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_not_exist (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_two (x, y, z, a) AS (SELECT core_not_exist.*, plugin_table.flag
    FROM core_not_exist
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core_not_exist.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_two;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0268: extension/assembly fragment must have the CTE named same as the base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_not_exist: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core_not_exist: { x: integer notnull, y: text, z: longint }
          |   | | | {name core_not_exist}: err
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core_not_exist: core_not_exist: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core_not_exist}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core_not_exist: core_not_exist }
          |         |       | | | {name core_not_exist}: TABLE { core_not_exist: core_not_exist }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core_not_exist}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       |   | {name plugin_wrong_two}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_extra (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_),
  plugin_wrong_three (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_three;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0258: extension fragment must add exactly one CTE; found extra named 'plugin_wrong_three'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_extra: { x: integer notnull, y: text, z: longint, a: bool }
          |     | | {cte_decl}: plugin_wrong_extra: { x: integer notnull, y: text, z: longint, a: bool }
          |     | | | {name plugin_wrong_extra}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | |       | {name_list}
          |     | |         | {name a}
          |     | | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |     |   |     | | | {name core}
          |     |   |     | | {select_expr_list}
          |     |   |     |   | {select_expr}: flag: bool
          |     |   |     |     | {dot}: flag: bool
          |     |   |     |       | {name plugin_table}
          |     |   |     |       | {name flag}
          |     |   |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       | | {table_or_subquery}: TABLE { core: core }
          |     |   |       | | | {name core}: TABLE { core: core }
          |     |   |       | | {join_target_list}
          |     |   |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       |     | {int 3}
          |     |   |       |     | {table_join}
          |     |   |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |     |   |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |     |   |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       |         | {on}: bool
          |     |   |       |         | {and}: bool
          |     |   |       |           | {eq}: bool
          |     |   |       |           | | {dot}: name: text
          |     |   |       |           | | | {name plugin_table}
          |     |   |       |           | | | {name name}
          |     |   |       |           | | {dot}: y: text
          |     |   |       |           |   | {name core}
          |     |   |       |           |   | {name y}
          |     |   |       |           | {eq}: bool
          |     |   |       |             | {dot}: id: integer
          |     |   |       |             | | {name plugin_table}
          |     |   |       |             | | {name id}
          |     |   |       |             | {name id_}: id_: integer notnull variable in
          |     |   |       | {select_where}
          |     |   |         | {select_groupby}
          |     |   |           | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}: plugin_wrong_three: { x: integer notnull, y: text, z: longint, a: bool }
          |         | {cte_decl}: plugin_wrong_three: { x: integer notnull, y: text, z: longint, a: bool }
          |         | | {name plugin_wrong_three}
          |         | | {name_list}
          |         |   | {name x}
          |         |   | {name_list}
          |         |     | {name y}
          |         |     | {name_list}
          |         |       | {name z}
          |         |       | {name_list}
          |         |         | {name a}
          |         | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |           |     | | | {name core}
          |           |     | | {select_expr_list}
          |           |     |   | {select_expr}: flag: bool
          |           |     |     | {dot}: flag: bool
          |           |     |       | {name plugin_table}
          |           |     |       | {name flag}
          |           |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |           |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |           |       | | {table_or_subquery}: TABLE { core: core }
          |           |       | | | {name core}: TABLE { core: core }
          |           |       | | {join_target_list}
          |           |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |           |       |     | {int 3}
          |           |       |     | {table_join}
          |           |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |           |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |           |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |           |       |         | {on}: bool
          |           |       |         | {and}: bool
          |           |       |           | {eq}: bool
          |           |       |           | | {dot}: name: text
          |           |       |           | | | {name plugin_table}
          |           |       |           | | | {name name}
          |           |       |           | | {dot}: y: text
          |           |       |           |   | {name core}
          |           |       |           |   | {name y}
          |           |       |           | {eq}: bool
          |           |       |             | {dot}: id: integer
          |           |       |             | | {name plugin_table}
          |           |       |             | | {name id}
          |           |       |             | {name id_}: id_: integer notnull variable in
          |           |       | {select_where}
          |           |         | {select_groupby}
          |           |           | {select_having}
          |           | {select_orderby}
          |             | {select_limit}
          |               | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       |   | {name plugin_wrong_three}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_shape (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_shape (x, y, z, a) AS (SELECT core.*, 1 AS a
    FROM core)
  SELECT *
    FROM bogus_shape;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bogus_extension_shape}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_shape: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_shape: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_shape}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer notnull
          |         |     |     | {int 1}: integer notnull
          |         |     |     | {opt_as_alias}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: TABLE { core: core }
          |         |       | {table_or_subquery_list}: TABLE { core: core }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       |   | {name core}: TABLE { core: core }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_shape: bogus_shape }
            |       | {table_or_subquery_list}: TABLE { bogus_shape: bogus_shape }
            |       | | {table_or_subquery}: TABLE { bogus_shape: bogus_shape }
            |       |   | {name bogus_shape}: TABLE { bogus_shape: bogus_shape }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_data_source (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_not_a_table (x, y, z, a) AS (SELECT core.*, junk.a
    FROM (SELECT *
    FROM core) AS core
    INNER JOIN (SELECT 1 AS a) AS junk)
  SELECT *
    FROM bogus_not_a_table;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bogus_extension_data_source}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_not_a_table: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_not_a_table: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_not_a_table}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | {table_star}: core: select: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer notnull
          |         |     |     | {dot}: a: integer notnull
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: select, junk: select }
          |         |       | {join_clause}: JOIN { core: select, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: select }
          |         |       | | | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | {select_from_etc}: TABLE { core: core }
          |         |       | | | |       | {table_or_subquery_list}: TABLE { core: core }
          |         |       | | | |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | |       |   | {name core}: TABLE { core: core }
          |         |       | | | |       | {select_where}
          |         |       | | | |         | {select_groupby}
          |         |       | | | |           | {select_having}
          |         |       | | | | {select_orderby}
          |         |       | | |   | {select_limit}
          |         |       | | |     | {select_offset}
          |         |       | | | {opt_as_alias}
          |         |       | |   | {name core}
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: select, junk: select }
          |         |       |     | {int 1}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | {table_or_subquery_list}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | | {table_or_subquery}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       |   | {name bogus_not_a_table}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE VIEW core2 AS
SELECT 1 AS x, nullable("a") AS y, nullable(3L) AS z;

  {create_view_stmt}: core2: { x: integer notnull, y: text, z: longint }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name core2}
      | {select_stmt}: core2: { x: integer notnull, y: text, z: longint }
        | {select_core_list}: core2: { x: integer notnull, y: text, z: longint }
        | | {select_core}: core2: { x: integer notnull, y: text, z: longint }
        |   | {select_expr_list_con}: core2: { x: integer notnull, y: text, z: longint }
        |     | {select_expr_list}: core2: { x: integer notnull, y: text, z: longint }
        |     | | {select_expr}: x: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name x}
        |     | | {select_expr_list}
        |     |   | {select_expr}: y: text
        |     |   | | {call}: text
        |     |   | | | {name nullable}: text
        |     |   | | | {call_arg_list}
        |     |   | |   | {call_filter_clause}
        |     |   | |   | {arg_list}: ok
        |     |   | |     | {strlit 'a'}: text notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name y}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: z: longint
        |     |       | {call}: longint
        |     |       | | {name nullable}: longint
        |     |       | | {call_arg_list}
        |     |       |   | {call_filter_clause}
        |     |       |   | {arg_list}: ok
        |     |       |     | {longint 3}: longint notnull
        |     |       | {opt_as_alias}
        |     |         | {name z}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_table_name (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_wrong_table (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core2 AS core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk)
  SELECT *
    FROM bogus_wrong_table;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bogus_extension_table_name}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_wrong_table: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_wrong_table: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_wrong_table}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core2: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core2, junk: select }
          |         |       | {join_clause}: JOIN { core: core2, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core2 }
          |         |       | | | {name core2}: TABLE { core: core2 }
          |         |       | | | {opt_as_alias}
          |         |       | |   | {name core}
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core2, junk: select }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | {table_or_subquery_list}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | | {table_or_subquery}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       |   | {name bogus_wrong_table}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_four (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z, a) AS (SELECT 1, nullable("a"), nullable(3L), 4),
  plugin_wrong_four (x, y, z, a, flag) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_four;
END;

Error at test/sem_test.sql:XXXX : in cte_decl : CQL0268: extension/assembly fragment must use base CTE column list same as from the base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_four}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |   | | {cte_decl}: err
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | |       | {name_list}
          |   | |         | {name a}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |     | | {call}: longint
          |   |   |     |     |   | {name nullable}: longint
          |   |   |     |     |   | {call_arg_list}
          |   |   |     |     |     | {call_filter_clause}
          |   |   |     |     |     | {arg_list}: ok
          |   |   |     |     |       | {longint 3}: longint notnull
          |   |   |     |     | {select_expr_list}
          |   |   |     |       | {select_expr}: integer notnull
          |   |   |     |         | {int 4}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_four: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |       | {cte_decl}: plugin_wrong_four: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |       | | {name plugin_wrong_four}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       |         | {name_list}
          |       |           | {name flag}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       |   | {name plugin_wrong_four}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_where_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk
    WHERE core.x = 1)
  SELECT *
    FROM bogus_extra_clauses;
END;

Error at test/sem_test.sql:XXXX : in select_from_etc : CQL0320: extension fragment CTE must have a FROM clause and no other top level clauses 'bogus_extra_clauses'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_where_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_extra_clauses}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core, junk: select }
          |         |       | {join_clause}: JOIN { core: core, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, junk: select }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {opt_where}: bool notnull
          |         |         | | {eq}: bool notnull
          |         |         |   | {dot}: x: integer notnull
          |         |         |   | | {name core}
          |         |         |   | | {name x}
          |         |         |   | {int 1}: integer notnull
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       |   | {name bogus_extra_clauses}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_limit_in_union_all (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses2 (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT *
    FROM core
  LIMIT 1)
  SELECT *
    FROM bogus_extra_clauses2;
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0331: extension fragment CTE must have not have ORDER BY or LIMIT clauses 'bogus_extra_clauses2'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_limit_in_union_all}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses2: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: bogus_extra_clauses2: { x: integer notnull, y: text, z: longint }
          |       | | {name bogus_extra_clauses2}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |         | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_from_etc}: TABLE { core: core }
          |         |           | {table_or_subquery_list}: TABLE { core: core }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           |   | {name core}: TABLE { core: core }
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {opt_limit}: integer notnull
          |             | | {int 1}: integer notnull
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       |   | {name bogus_extra_clauses2}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_limit_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk
  LIMIT 3)
  SELECT *
    FROM bogus_extra_clauses;
END;

Error at test/sem_test.sql:XXXX : in select_from_etc : CQL0320: extension fragment CTE must have a FROM clause and no other top level clauses 'bogus_extra_clauses'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_limit_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_extra_clauses}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core, junk: select }
          |         |       | {join_clause}: JOIN { core: core, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, junk: select }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {opt_limit}: integer notnull
          |             | | {int 3}: integer notnull
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       |   | {name bogus_extra_clauses}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_missing_from_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_missing_from (x, y, z, a) AS (SELECT 1, nullable("a"), nullable(3L), 1 AS a)
  SELECT *
    FROM bogus_missing_from;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_missing_from_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: bogus_missing_from: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_missing_from: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_missing_from}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         |     | | {select_expr}: integer notnull
          |         |     | | | {int 1}: integer notnull
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: text
          |         |     |   | | {call}: text
          |         |     |   |   | {name nullable}: text
          |         |     |   |   | {call_arg_list}
          |         |     |   |     | {call_filter_clause}
          |         |     |   |     | {arg_list}: ok
          |         |     |   |       | {strlit 'a'}: text notnull
          |         |     |   | {select_expr_list}
          |         |     |     | {select_expr}: longint
          |         |     |     | | {call}: longint
          |         |     |     |   | {name nullable}: longint
          |         |     |     |   | {call_arg_list}
          |         |     |     |     | {call_filter_clause}
          |         |     |     |     | {arg_list}: ok
          |         |     |     |       | {longint 3}: longint notnull
          |         |     |     | {select_expr_list}
          |         |     |       | {select_expr}: a: integer notnull
          |         |     |         | {int 1}: integer notnull
          |         |     |         | {opt_as_alias}
          |         |     |           | {name a}
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | {table_or_subquery_list}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | | {table_or_subquery}: TABLE { bogus_missing_from: bogus_missing_from }
            |       |   | {name bogus_missing_from}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_five (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_five (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_five;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_five}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_five: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_five: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_five}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 1}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool notnull
          |         |       |             | {dot}: id: integer notnull
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       |   | {name plugin_wrong_five}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_six (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_six (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT plugin_wrong_six.x
    FROM plugin_wrong_six;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM plugin_wrong_six'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_six}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_six: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_six: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_six}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {select_expr}: x: integer notnull
            |     |   | {dot}: x: integer notnull
            |     |     | {name plugin_wrong_six}
            |     |     | {name x}
            |     | {select_from_etc}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       |   | {name plugin_wrong_six}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_seven (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_seven (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM core;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM plugin_wrong_seven'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_seven}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_seven: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_seven: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_seven}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_eight (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_eight (x, y, z, a) AS (SELECT bar.*, plugin_table.flag
    FROM bar
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_eight;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_eight}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: plugin_wrong_eight: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_eight: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_eight}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         | {select_core_list}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         | | {select_core}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         |     | | {table_star}: bar: bar: { id: integer notnull, name: text, rate: longint }
          |         |     | | | {name bar}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { bar: bar }
          |         |       | | | {name bar}: TABLE { bar: bar }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       |   | {name plugin_wrong_eight}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_nine (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y) AS (SELECT core.y, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_nine}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: text, y: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: plugin_wrong_nine: { x: text, y: bool }
          |       | {cte_decl}: plugin_wrong_nine: { x: text, y: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       | {select_stmt}: select: { y: text, flag: bool }
          |         | {select_core_list}: select: { y: text, flag: bool }
          |         | | {select_core}: select: { y: text, flag: bool }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { y: text, flag: bool }
          |         |     | | {select_expr}: y: text
          |         |     | | | {dot}: y: text
          |         |     | |   | {name core}
          |         |     | |   | {name y}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: text, y: bool }
            | {select_core_list}: select: { x: text, y: bool }
            | | {select_core}: select: { x: text, y: bool }
            |   | {select_expr_list_con}: select: { x: text, y: bool }
            |     | {select_expr_list}: select: { x: text, y: bool }
            |     | | {star}: select: { x: text, y: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_nine_ok (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_extension_fragment_nine_ok}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_ten (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

Error at test/sem_test.sql:XXXX : in cte_table : CQL0266: extension fragment name conflicts with existing fragment 'plugin_wrong_nine'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_ten}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: err
          |       | {cte_decl}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_eleven (id_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM plugin_table;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_eleven}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, flag: bool }
          | {select_core_list}: select: { id: integer notnull, name: text, flag: bool }
          | | {select_core}: select: { id: integer notnull, name: text, flag: bool }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, flag: bool }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, flag: bool }
          |     | | {star}: select: { id: integer notnull, name: text, flag: bool }
          |     | {select_from_etc}: TABLE { plugin_table: plugin_table }
          |       | {table_or_subquery_list}: TABLE { plugin_table: plugin_table }
          |       | | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |       |   | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_with_wrong_base_sem_type (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3)),
  plugin_wrong_eleven (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_eleven;
END;

Error at test/sem_test.sql:XXXX : in select_expr_list : CQL0287: extension/assembly fragment must add stub for base CTE with same types from base fragment (expected longint; found integer) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_with_wrong_base_sem_type}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: integer, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: integer }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: integer }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   |   | {select_expr_list_con}: err
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: integer
          |   |   |     |       | {call}: integer
          |   |   |     |         | {name nullable}: integer
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {int 3}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_eleven: { x: integer notnull, y: text, z: integer, a: bool }
          |       | {cte_decl}: plugin_wrong_eleven: { x: integer notnull, y: text, z: integer, a: bool }
          |       | | {name plugin_wrong_eleven}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: integer }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: integer, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: integer, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       |   | {name plugin_wrong_eleven}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_with_wrong_base_nullability (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), 3L),
  plugin_wrong_twelve (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_twelve;
END;

Error at test/sem_test.sql:XXXX : in select_expr_list : CQL0288: extension/assembly fragment stub for base CTE column must be exact type match (including nullability) (expected longint; found longint notnull) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_with_wrong_base_nullability}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint notnull }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint notnull }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   |   | {select_expr_list_con}: err
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint notnull
          |   |   |     |       | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_twelve: { x: integer notnull, y: text, z: longint notnull, a: bool }
          |       | {cte_decl}: plugin_wrong_twelve: { x: integer notnull, y: text, z: longint notnull, a: bool }
          |       | | {name plugin_wrong_twelve}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint notnull }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       |   | {name plugin_wrong_twelve}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_union_one (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_one (x, y, z, name) AS (SELECT core.*, CAST(NULL AS TEXT) AS name2
    FROM core
  UNION ALL
  SELECT core.*, plugin_table.name
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = "test")
  SELECT *
    FROM test_bad_extension_fragment_union_one;
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0058: if multiple selects, all column names must be identical so they have unambiguous names 'name'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_union_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: err
          |       | {cte_decl}: test_bad_extension_fragment_union_one: { x: integer notnull, y: text, z: longint, name: text }
          |       | | {name test_bad_extension_fragment_union_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name name}
          |       | {select_stmt}: err
          |         | {select_core_list}: err
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name2: text }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name2: text }
          |         | |   | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         | |   | | | {name core}
          |         | |   | | {select_expr_list}
          |         | |   |   | {select_expr}: name2: text
          |         | |   |     | {cast_expr}: text
          |         | |   |     | | {null}: null
          |         | |   |     | | {type_text}: text
          |         | |   |     | {opt_as_alias}
          |         | |   |       | {name name2}
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: err
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |         | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |         | | | {name core}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: name: text
          |         |         |     | {dot}: name: text
          |         |         |       | {name plugin_table}
          |         |         |       | {name name}
          |         |         | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           | | | {name core}: TABLE { core: core }
          |         |           | | {join_target_list}
          |         |           |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |     | {int 1}
          |         |           |     | {table_join}
          |         |           |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |           |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |           |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |         | {on}: bool
          |         |           |         | {eq}: bool
          |         |           |           | {dot}: name: text
          |         |           |           | | {name plugin_table}
          |         |           |           | | {name name}
          |         |           |           | {strlit 'test'}: text notnull
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name test_bad_extension_fragment_union_one}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_union_two (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_two (x, y, z, name) AS (SELECT core.*, CAST(NULL AS TEXT) AS name
    FROM core
  UNION ALL
  SELECT core.*
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = "test")
  SELECT *
    FROM test_bad_extension_fragment_union_two;
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0057: if multiple selects, all must have the same column count

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_union_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: err
          |       | {cte_decl}: test_bad_extension_fragment_union_two: { x: integer notnull, y: text, z: longint, name: text }
          |       | | {name test_bad_extension_fragment_union_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name name}
          |       | {select_stmt}: err
          |         | {select_core_list}: err
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         | |   | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         | |   | | | {name core}
          |         | |   | | {select_expr_list}
          |         | |   |   | {select_expr}: name: text
          |         | |   |     | {cast_expr}: text
          |         | |   |     | | {null}: null
          |         | |   |     | | {type_text}: text
          |         | |   |     | {opt_as_alias}
          |         | |   |       | {name name}
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: err
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |         | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |         |   | {name core}
          |         |         | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           | | | {name core}: TABLE { core: core }
          |         |           | | {join_target_list}
          |         |           |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |     | {int 1}
          |         |           |     | {table_join}
          |         |           |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |           |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |           |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |         | {on}: bool
          |         |           |         | {eq}: bool
          |         |           |           | {dot}: name: text
          |         |           |           | | {name plugin_table}
          |         |           |           | | {name name}
          |         |           |           | {strlit 'test'}: text notnull
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name test_bad_extension_fragment_union_two}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_three (id, name, rate) AS (SELECT *
    FROM bar
  UNION ALL
  SELECT *
    FROM bar)
  SELECT *
    FROM test_bad_extension_fragment_union_three;
END;

Error at test/sem_test.sql:XXXX : in select_core : CQL0330: fragment must start with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name test_extension_fragment_union_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: test_bad_extension_fragment_union_three: { id: integer notnull, name: text, rate: longint }
          |       | {cte_decl}: test_bad_extension_fragment_union_three: { id: integer notnull, name: text, rate: longint }
          |       | | {name test_bad_extension_fragment_union_three}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name name}
          |       |     | {name_list}
          |       |       | {name rate}
          |       | {select_stmt}: UNION ALL: { id: integer notnull, name: text, rate: longint }
          |         | {select_core_list}: UNION ALL: { id: integer notnull, name: text, rate: longint }
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | {select_from_etc}: TABLE { bar: bar }
          |         | |     | {table_or_subquery_list}: TABLE { bar: bar }
          |         | |     | | {table_or_subquery}: TABLE { bar: bar }
          |         | |     |   | {name bar}: TABLE { bar: bar }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |         |     | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |         |       | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | {select_from_etc}: TABLE { bar: bar }
          |         |           | {table_or_subquery_list}: TABLE { bar: bar }
          |         |           | | {table_or_subquery}: TABLE { bar: bar }
          |         |           |   | {name bar}: TABLE { bar: bar }
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | {table_or_subquery_list}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | | {table_or_subquery}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       |   | {name test_bad_extension_fragment_union_three}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core)
CREATE PROC test_assembly_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_assembly_base_fragment}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core: assembly_core }
            |       | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
            |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
            |       |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_one (x, y, z) AS (SELECT *
    FROM assembly_core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM assembly_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_assembly_extension_fragment_one}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_one: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: assembly_one: { x: integer notnull, y: text, z: longint }
          |       | | {name assembly_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { assembly_core: assembly_core }
          |         | |     | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
          |         | |     | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         | |     |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_one: assembly_one }
            |       | {table_or_subquery_list}: TABLE { assembly_one: assembly_one }
            |       | | {table_or_subquery}: TABLE { assembly_one: assembly_one }
            |       |   | {name assembly_one}: TABLE { assembly_one: assembly_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_two (x, y, z, a, b, c) AS (SELECT assembly_core.*, plugin_table.flag, min(plugin_table.id, 10L), min(plugin_table.id, 10.05)
    FROM assembly_core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real } dml_proc
    | {name test_assembly_extension_fragment_two}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | {cte_decl}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | {name assembly_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       |         | {name_list}
          |       |           | {name b}
          |       |           | {name_list}
          |       |             | {name c}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |     | | {table_star}: assembly_core: assembly_core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |   | | {dot}: flag: bool
          |         |     |   |   | {name plugin_table}
          |         |     |   |   | {name flag}
          |         |     |   | {select_expr_list}
          |         |     |     | {select_expr}: longint
          |         |     |     | | {call}: longint
          |         |     |     |   | {name min}: longint
          |         |     |     |   | {call_arg_list}
          |         |     |     |     | {call_filter_clause}
          |         |     |     |     | {arg_list}: ok
          |         |     |     |       | {dot}: id: integer
          |         |     |     |       | | {name plugin_table}
          |         |     |     |       | | {name id}
          |         |     |     |       | {arg_list}
          |         |     |     |         | {longint 10}: longint notnull
          |         |     |     | {select_expr_list}
          |         |     |       | {select_expr}: real
          |         |     |         | {call}: real
          |         |     |           | {name min}: real
          |         |     |           | {call_arg_list}
          |         |     |             | {call_filter_clause}
          |         |     |             | {arg_list}: ok
          |         |     |               | {dot}: id: integer
          |         |     |               | | {name plugin_table}
          |         |     |               | | {name id}
          |         |     |               | {arg_list}
          |         |     |                 | {dbl 10.05}: real notnull
          |         |     | {select_from_etc}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         |       | | | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | {select_from_etc}: TABLE { assembly_two: assembly_two }
            |       | {table_or_subquery_list}: TABLE { assembly_two: assembly_two }
            |       | | {table_or_subquery}: TABLE { assembly_two: assembly_two }
            |       |   | {name assembly_two}: TABLE { assembly_two: assembly_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_three (x, y, z, d) AS (SELECT assembly_core.*, plugin_table.id AS d
    FROM assembly_core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM assembly_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer } dml_proc
    | {name test_assembly_extension_fragment_three}: select: { x: integer notnull, y: text, z: longint, d: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_three: { x: integer notnull, y: text, z: longint, d: integer }
          |       | {cte_decl}: assembly_three: { x: integer notnull, y: text, z: longint, d: integer }
          |       | | {name assembly_three}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name d}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |     | | {table_star}: assembly_core: assembly_core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: d: integer
          |         |     |     | {dot}: id: integer
          |         |     |     | | {name plugin_table}
          |         |     |     | | {name id}
          |         |     |     | {opt_as_alias}
          |         |     |       | {name d}
          |         |     | {select_from_etc}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         |       | | | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | {select_from_etc}: TABLE { assembly_three: assembly_three }
            |       | {table_or_subquery_list}: TABLE { assembly_three: assembly_three }
            |       | | {table_or_subquery}: TABLE { assembly_three: assembly_three }
            |       |   | {name assembly_three}: TABLE { assembly_three: assembly_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core)
CREATE PROC assembly_core (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_),
  assembly_one (x, y, z) AS (SELECT *
    FROM assembly_core
  UNION ALL
  SELECT 3 AS x, 'y' AS y, 5L AS z),
  assembly_two (x, y, z, a, b, c) AS (SELECT assembly_one.*, plugin_table.flag, min(plugin_table.id, 10L), min(plugin_table.id, 10.05)
    FROM assembly_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_one.y AND plugin_table.id = id_),
  assembly_three (x, y, z, a, b, c, d) AS (SELECT assembly_two.*, plugin_table.id AS d
    FROM assembly_two
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM assembly_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer } dml_proc
    | {name assembly_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {name id}: id: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: name: text
          |   |   |     |   | | {name name}: name: text
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: rate: longint
          |   |   |     |       | {name rate}: rate: longint
          |   |   |     | {select_from_etc}: TABLE { bar: bar }
          |   |   |       | {table_or_subquery_list}: TABLE { bar: bar }
          |   |   |       | | {table_or_subquery}: TABLE { bar: bar }
          |   |   |       |   | {name bar}: TABLE { bar: bar }
          |   |   |       | {select_where}
          |   |   |         | {opt_where}: bool notnull
          |   |   |         | | {eq}: bool notnull
          |   |   |         |   | {name id}: id: integer notnull
          |   |   |         |   | {name id_}: id_: integer notnull variable in
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_one: { x: integer notnull, y: text, z: longint }
          |     | | {cte_decl}: assembly_one: { x: integer notnull, y: text, z: longint }
          |     | | | {name assembly_one}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |     |   | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |     |   | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |     |   | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | {select_from_etc}: TABLE { assembly_core: assembly_core }
          |     |   | |     | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
          |     |   | |     | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |     |   | |     |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |     |   | |     | {select_where}
          |     |   | |       | {select_groupby}
          |     |   | |         | {select_having}
          |     |   | | {select_core_compound}
          |     |   |   | {int 2}
          |     |   |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |         | | {select_expr}: x: integer notnull
          |     |   |         | | | {int 3}: integer notnull
          |     |   |         | | | {opt_as_alias}
          |     |   |         | |   | {name x}
          |     |   |         | | {select_expr_list}
          |     |   |         |   | {select_expr}: y: text notnull
          |     |   |         |   | | {strlit 'y'}: text notnull
          |     |   |         |   | | {opt_as_alias}
          |     |   |         |   |   | {name y}
          |     |   |         |   | {select_expr_list}
          |     |   |         |     | {select_expr}: z: longint notnull
          |     |   |         |       | {longint 5}: longint notnull
          |     |   |         |       | {opt_as_alias}
          |     |   |         |         | {name z}
          |     |   |         | {select_from_etc}: ok
          |     |   |           | {select_where}
          |     |   |             | {select_groupby}
          |     |   |               | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | {cte_decl}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | | {name assembly_two}
          |       | | | {name_list}
          |       | |   | {name x}
          |       | |   | {name_list}
          |       | |     | {name y}
          |       | |     | {name_list}
          |       | |       | {name z}
          |       | |       | {name_list}
          |       | |         | {name a}
          |       | |         | {name_list}
          |       | |           | {name b}
          |       | |           | {name_list}
          |       | |             | {name c}
          |       | | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |     | | {table_star}: assembly_one: assembly_one: { x: integer notnull, y: text, z: longint }
          |       |   |     | | | {name assembly_one}
          |       |   |     | | {select_expr_list}
          |       |   |     |   | {select_expr}: flag: bool
          |       |   |     |   | | {dot}: flag: bool
          |       |   |     |   |   | {name plugin_table}
          |       |   |     |   |   | {name flag}
          |       |   |     |   | {select_expr_list}
          |       |   |     |     | {select_expr}: longint
          |       |   |     |     | | {call}: longint
          |       |   |     |     |   | {name min}: longint
          |       |   |     |     |   | {call_arg_list}
          |       |   |     |     |     | {call_filter_clause}
          |       |   |     |     |     | {arg_list}: ok
          |       |   |     |     |       | {dot}: id: integer
          |       |   |     |     |       | | {name plugin_table}
          |       |   |     |     |       | | {name id}
          |       |   |     |     |       | {arg_list}
          |       |   |     |     |         | {longint 10}: longint notnull
          |       |   |     |     | {select_expr_list}
          |       |   |     |       | {select_expr}: real
          |       |   |     |         | {call}: real
          |       |   |     |           | {name min}: real
          |       |   |     |           | {call_arg_list}
          |       |   |     |             | {call_filter_clause}
          |       |   |     |             | {arg_list}: ok
          |       |   |     |               | {dot}: id: integer
          |       |   |     |               | | {name plugin_table}
          |       |   |     |               | | {name id}
          |       |   |     |               | {arg_list}
          |       |   |     |                 | {dbl 10.05}: real notnull
          |       |   |     | {select_from_etc}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       | {join_clause}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       | | {table_or_subquery}: TABLE { assembly_one: assembly_one }
          |       |   |       | | | {name assembly_one}: TABLE { assembly_one: assembly_one }
          |       |   |       | | {join_target_list}
          |       |   |       |   | {join_target}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       |     | {int 3}
          |       |   |       |     | {table_join}
          |       |   |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |       |   |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |       |   |       |       | {join_cond}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       |         | {on}: bool
          |       |   |       |         | {and}: bool
          |       |   |       |           | {eq}: bool
          |       |   |       |           | | {dot}: name: text
          |       |   |       |           | | | {name plugin_table}
          |       |   |       |           | | | {name name}
          |       |   |       |           | | {dot}: y: text
          |       |   |       |           |   | {name assembly_one}
          |       |   |       |           |   | {name y}
          |       |   |       |           | {eq}: bool
          |       |   |       |             | {dot}: id: integer
          |       |   |       |             | | {name plugin_table}
          |       |   |       |             | | {name id}
          |       |   |       |             | {name id_}: id_: integer notnull variable in
          |       |   |       | {select_where}
          |       |   |         | {select_groupby}
          |       |   |           | {select_having}
          |       |   | {select_orderby}
          |       |     | {select_limit}
          |       |       | {select_offset}
          |       | {cte_tables}
          |         | {cte_table}: assembly_three: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |           | {cte_decl}: assembly_three: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |           | | {name assembly_three}
          |           | | {name_list}
          |           |   | {name x}
          |           |   | {name_list}
          |           |     | {name y}
          |           |     | {name_list}
          |           |       | {name z}
          |           |       | {name_list}
          |           |         | {name a}
          |           |         | {name_list}
          |           |           | {name b}
          |           |           | {name_list}
          |           |             | {name c}
          |           |             | {name_list}
          |           |               | {name d}
          |           | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |     | | {table_star}: assembly_two: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |             |     | | | {name assembly_two}
          |             |     | | {select_expr_list}
          |             |     |   | {select_expr}: d: integer
          |             |     |     | {dot}: id: integer
          |             |     |     | | {name plugin_table}
          |             |     |     | | {name id}
          |             |     |     | {opt_as_alias}
          |             |     |       | {name d}
          |             |     | {select_from_etc}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       | {join_clause}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       | | {table_or_subquery}: TABLE { assembly_two: assembly_two }
          |             |       | | | {name assembly_two}: TABLE { assembly_two: assembly_two }
          |             |       | | {join_target_list}
          |             |       |   | {join_target}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       |     | {int 3}
          |             |       |     | {table_join}
          |             |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |             |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |             |       |       | {join_cond}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       |         | {on}: bool
          |             |       |         | {eq}: bool
          |             |       |           | {dot}: id: integer
          |             |       |           | | {name plugin_table}
          |             |       |           | | {name id}
          |             |       |           | {name id_}: id_: integer notnull variable in
          |             |       | {select_where}
          |             |         | {select_groupby}
          |             |           | {select_having}
          |             | {select_orderby}
          |               | {select_limit}
          |                 | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | {select_from_etc}: TABLE { assembly_three: assembly_three }
            |       | {table_or_subquery_list}: TABLE { assembly_three: assembly_three }
            |       | | {table_or_subquery}: TABLE { assembly_three: assembly_three }
            |       |   | {name assembly_three}: TABLE { assembly_three: assembly_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=for_bad2)
CREATE PROC test_assembly_base_for_bad2 (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name for_bad2}
  | {create_proc_stmt}: err
    | {name test_assembly_base_for_bad2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=for_bad)
CREATE PROC test_assembly_base_for_bad (id_ INTEGER NOT NULL)
BEGIN
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name for_bad}
  | {create_proc_stmt}: select: { x: integer notnull } dml_proc
    | {name test_assembly_base_for_bad}: select: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=for_bad)
CREATE PROC test_bad_ext (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1),
  plugin_one (x, a) AS (SELECT 1, 2)
  SELECT *
    FROM plugin_one;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name for_bad}
  | {create_proc_stmt}: err
    | {name test_bad_ext}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |   | | {cte_decl}: for_bad: { x: integer notnull }
          |   | | | {name for_bad}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {select_stmt}: select: { _anon: integer notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     |   | {int 1}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, a: integer notnull }
          |       | {cte_decl}: plugin_one: { x: integer notnull, a: integer notnull }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name a}
          |       | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
          |         | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |         | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |     | | {select_expr}: integer notnull
          |         |     | | | {int 1}: integer notnull
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: integer notnull
          |         |     |     | {int 2}: integer notnull
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, a: integer notnull }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=for_bad)
CREATE PROC test_assembly_fragment2 (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name for_bad}
  | {create_proc_stmt}: err
    | {name test_assembly_fragment2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core)
CREATE PROC duplicate_assembly_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, 2, nullable(3L))
  SELECT *
    FROM assembly_core;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0264: duplicate assembly fragments of base fragment 'assembly_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core}
  | {create_proc_stmt}: err
    | {name duplicate_assembly_fragment}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: integer notnull, z: longint }
          |     | {cte_decl}: assembly_core: { x: integer notnull, y: integer notnull, z: longint }
          |     | | {name assembly_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: integer notnull
          |       |     |   | | {int 2}: integer notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: longint }
            | | {select_core}: select: { x: integer notnull, y: integer notnull, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | | {star}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core: assembly_core }
            |       | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
            |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
            |       |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=another_core)
CREATE PROC bad_assembly_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  another_core (x, y) AS (SELECT 1, nullable("a")),
  another_cte (x, y) AS (SELECT another_core.*
    FROM another_core)
  SELECT *
    FROM another_cte;
END;

Error at test/sem_test.sql:XXXX : in cte_tables : CQL0265: assembly fragment can only have one CTE 'another_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name another_core}
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text }
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: another_core: { x: integer notnull, y: text }
          |   | | {cte_decl}: another_core: { x: integer notnull, y: text }
          |   | | | {name another_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |     | {call}: text
          |   |   |     |       | {name nullable}: text
          |   |   |     |       | {call_arg_list}
          |   |   |     |         | {call_filter_clause}
          |   |   |     |         | {arg_list}: ok
          |   |   |     |           | {strlit 'a'}: text notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: another_cte: { x: integer notnull, y: text }
          |       | {cte_decl}: another_cte: { x: integer notnull, y: text }
          |       | | {name another_cte}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       | {select_stmt}: select: { x: integer notnull, y: text }
          |         | {select_core_list}: select: { x: integer notnull, y: text }
          |         | | {select_core}: select: { x: integer notnull, y: text }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text }
          |         |     | | {table_star}: another_core: another_core: { x: integer notnull, y: text }
          |         |     |   | {name another_core}
          |         |     | {select_from_etc}: TABLE { another_core: another_core }
          |         |       | {table_or_subquery_list}: TABLE { another_core: another_core }
          |         |       | | {table_or_subquery}: TABLE { another_core: another_core }
          |         |       |   | {name another_core}: TABLE { another_core: another_core }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text }
            | {select_core_list}: select: { x: integer notnull, y: text }
            | | {select_core}: select: { x: integer notnull, y: text }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
            |     | {select_expr_list}: select: { x: integer notnull, y: text }
            |     | | {star}: select: { x: integer notnull, y: text }
            |     | {select_from_etc}: TABLE { another_cte: another_cte }
            |       | {table_or_subquery_list}: TABLE { another_cte: another_cte }
            |       | | {table_or_subquery}: TABLE { another_cte: another_cte }
            |       |   | {name another_cte}: TABLE { another_cte: another_cte }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=wrong_core)
CREATE PROC bad_assembly_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  wrong_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L))
  SELECT *
    FROM wrong_core;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0255: fragment name is not a previously declared base fragment 'wrong_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name wrong_core}: err
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: wrong_core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: wrong_core: { x: integer notnull, y: text, z: longint }
          |     | | {name wrong_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: text
          |       |     |   | | {call}: text
          |       |     |   |   | {name nullable}: text
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {strlit 'a'}: text notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { wrong_core: wrong_core }
            |       | {table_or_subquery_list}: TABLE { wrong_core: wrong_core }
            |       | | {table_or_subquery}: TABLE { wrong_core: wrong_core }
            |       |   | {name wrong_core}: TABLE { wrong_core: wrong_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=test_bad_assembly_base_fragment)
CREATE PROC test_bad_assembly_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  test_bad_assembly_base_fragment (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM test_bad_assembly_base_fragment;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name test_bad_assembly_base_fragment}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_bad_assembly_base_fragment}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint }
          |     | | {name test_bad_assembly_base_fragment}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | {table_or_subquery_list}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | | {table_or_subquery}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       |   | {name test_bad_assembly_base_fragment}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=test_bad_assembly_base_fragment)
CREATE PROC bad_assembly_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  SELECT id, name, rate
    FROM bar
    WHERE id = id_;
END;

Error at test/sem_test.sql:XXXX : in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH..SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name test_bad_assembly_base_fragment}
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {select_expr}: id: integer notnull
          |     | | | {name id}: id: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text
          |     |   | | {name name}: name: text
          |     |   | {select_expr_list}
          |     |     | {select_expr}: rate: longint
          |     |       | {name rate}: rate: longint
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {opt_where}: bool notnull
          |         | | {eq}: bool notnull
          |         |   | {name id}: id: integer notnull
          |         |   | {name id_}: id_: integer notnull variable in
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_base_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_one}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_bad_assembly_base_fragment_one}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_one}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       |   | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_bad_one (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_bad_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core_bad_one}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_assembly_extension_fragment_one}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_bad_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: assembly_bad_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name assembly_bad_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: assembly_core_bad_one: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core_bad_one}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core_bad_one}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_bad_one: assembly_bad_one }
            |       |   | {name assembly_bad_one}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_bad_two (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_bad_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core_bad_one}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_assembly_extension_fragment_two}: select: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_bad_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: assembly_bad_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name assembly_bad_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: assembly_core_bad_one: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core_bad_one}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core_bad_one}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_bad_two: assembly_bad_two }
            |       |   | {name assembly_bad_two}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_one)
CREATE PROC assembly_core_bad_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_),
  assembly_bad_one (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_),
  assembly_bad_two (x, y, z, a) AS (SELECT assembly_bad_one.*, plugin_table.flag
    FROM assembly_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_core_bad_one;
END;

Error at test/sem_test.sql:XXXX : in name_list : CQL0267: extension fragments of same base fragment share the same cte column 'a'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_one}
  | {create_proc_stmt}: err
    | {name assembly_core_bad_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {name id}: id: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: name: text
          |   |   |     |   | | {name name}: name: text
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: rate: longint
          |   |   |     |       | {name rate}: rate: longint
          |   |   |     | {select_from_etc}: TABLE { bar: bar }
          |   |   |       | {table_or_subquery_list}: TABLE { bar: bar }
          |   |   |       | | {table_or_subquery}: TABLE { bar: bar }
          |   |   |       |   | {name bar}: TABLE { bar: bar }
          |   |   |       | {select_where}
          |   |   |         | {opt_where}: bool notnull
          |   |   |         | | {eq}: bool notnull
          |   |   |         |   | {name id}: id: integer notnull
          |   |   |         |   | {name id_}: id_: integer notnull variable in
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}
          |     | | {cte_decl}
          |     | | | {name assembly_bad_one}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | |       | {name_list}
          |     | |         | {name a}
          |     | | {select_stmt}
          |     |   | {select_core_list}
          |     |   | | {select_core}
          |     |   |   | {select_expr_list_con}
          |     |   |     | {select_expr_list}
          |     |   |     | | {table_star}
          |     |   |     | | | {name assembly_core_bad_one}
          |     |   |     | | {select_expr_list}
          |     |   |     |   | {select_expr}
          |     |   |     |     | {dot}
          |     |   |     |       | {name plugin_table}
          |     |   |     |       | {name flag}
          |     |   |     | {select_from_etc}
          |     |   |       | {join_clause}
          |     |   |       | | {table_or_subquery}
          |     |   |       | | | {name assembly_core_bad_one}
          |     |   |       | | {join_target_list}
          |     |   |       |   | {join_target}
          |     |   |       |     | {int 3}
          |     |   |       |     | {table_join}
          |     |   |       |       | {table_or_subquery}
          |     |   |       |       | | {name plugin_table}
          |     |   |       |       | {join_cond}
          |     |   |       |         | {on}
          |     |   |       |         | {and}
          |     |   |       |           | {eq}
          |     |   |       |           | | {dot}
          |     |   |       |           | | | {name plugin_table}
          |     |   |       |           | | | {name name}
          |     |   |       |           | | {dot}
          |     |   |       |           |   | {name assembly_core_bad_one}
          |     |   |       |           |   | {name y}
          |     |   |       |           | {eq}
          |     |   |       |             | {dot}
          |     |   |       |             | | {name plugin_table}
          |     |   |       |             | | {name id}
          |     |   |       |             | {name id_}
          |     |   |       | {select_where}
          |     |   |         | {select_groupby}
          |     |   |           | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}
          |         | {cte_decl}
          |         | | {name assembly_bad_two}
          |         | | {name_list}
          |         |   | {name x}
          |         |   | {name_list}
          |         |     | {name y}
          |         |     | {name_list}
          |         |       | {name z}
          |         |       | {name_list}: err
          |         |         | {name a}
          |         | {select_stmt}
          |           | {select_core_list}
          |           | | {select_core}
          |           |   | {select_expr_list_con}
          |           |     | {select_expr_list}
          |           |     | | {table_star}
          |           |     | | | {name assembly_bad_one}
          |           |     | | {select_expr_list}
          |           |     |   | {select_expr}
          |           |     |     | {dot}
          |           |     |       | {name plugin_table}
          |           |     |       | {name flag}
          |           |     | {select_from_etc}
          |           |       | {join_clause}
          |           |       | | {table_or_subquery}
          |           |       | | | {name assembly_bad_one}
          |           |       | | {join_target_list}
          |           |       |   | {join_target}
          |           |       |     | {int 3}
          |           |       |     | {table_join}
          |           |       |       | {table_or_subquery}
          |           |       |       | | {name plugin_table}
          |           |       |       | {join_cond}
          |           |       |         | {on}
          |           |       |         | {and}
          |           |       |           | {eq}
          |           |       |           | | {dot}
          |           |       |           | | | {name plugin_table}
          |           |       |           | | | {name name}
          |           |       |           | | {dot}
          |           |       |           |   | {name assembly_bad_one}
          |           |       |           |   | {name y}
          |           |       |           | {eq}
          |           |       |             | {dot}
          |           |       |             | | {name plugin_table}
          |           |       |             | | {name id}
          |           |       |             | {name id_}
          |           |       | {select_where}
          |           |         | {select_groupby}
          |           |           | {select_having}
          |           | {select_orderby}
          |             | {select_limit}
          |               | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       |   | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_two)
CREATE PROC create_bad_assembly_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_two (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_two}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name create_bad_assembly_base_fragment_two}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       |   | {name assembly_core_bad_two}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_two)
CREATE PROC test_bad_assembly_fragment_with_wrong_base_sem_type (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_two (x, y, z) AS (SELECT 1, nullable("a"), 3L)
  SELECT *
    FROM assembly_core_bad_two;
END;

Error at test/sem_test.sql:XXXX : in select_expr_list : CQL0288: extension/assembly fragment stub for base CTE column must be exact type match (including nullability) (expected longint; found longint notnull) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_two}
  | {create_proc_stmt}: err
    | {name test_bad_assembly_fragment_with_wrong_base_sem_type}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint notnull }
          |     | {cte_decl}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint notnull }
          |     | | {name assembly_core_bad_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: text
          |       |     |   | | {call}: text
          |       |     |   |   | {name nullable}: text
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {strlit 'a'}: text notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint notnull
          |       |     |       | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | {select_from_etc}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       |   | {name assembly_core_bad_two}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_three)
CREATE PROC create_bad_assembly_base_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_three (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_three}
  | {create_proc_stmt}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {name create_bad_assembly_base_fragment_three}: select: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_three: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_three: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_three}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       |   | {name assembly_core_bad_three}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_three)
CREATE PROC test_bad_assembly_fragment_with_wrong_base_nullability (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_three (x, y, z) AS (SELECT 1, nullable(2), nullable(3L))
  SELECT *
    FROM assembly_core_bad_three;
END;

Error at test/sem_test.sql:XXXX : in select_expr_list : CQL0287: extension/assembly fragment must add stub for base CTE with same types from base fragment (expected text; found integer) 'name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_three}
  | {create_proc_stmt}: err
    | {name test_bad_assembly_fragment_with_wrong_base_nullability}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: integer, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_three: { x: integer notnull, y: integer, z: longint }
          |     | {cte_decl}: assembly_core_bad_three: { x: integer notnull, y: integer, z: longint }
          |     | | {name assembly_core_bad_three}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: integer
          |       |     |   | | {call}: integer
          |       |     |   |   | {name nullable}: integer
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {int 2}: integer notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: integer, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: integer, z: longint }
            | | {select_core}: select: { x: integer notnull, y: integer, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: integer, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: integer, z: longint }
            |     | | {star}: select: { x: integer notnull, y: integer, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       |   | {name assembly_core_bad_three}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_simple)
CREATE PROC base_with_args (idx_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_simple (x) AS (SELECT 1 AS x)
  SELECT *
    FROM assembly_core_simple;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_simple}
  | {create_proc_stmt}: select: { x: integer notnull } dml_proc
    | {name base_with_args}: select: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: idx_: integer notnull variable in
      |   | {param_detail}: idx_: integer notnull variable in
      |     | {name idx_}: idx_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_simple: { x: integer notnull }
          |     | {cte_decl}: assembly_core_simple: { x: integer notnull }
          |     | | {name assembly_core_simple}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {table_or_subquery_list}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | | {table_or_subquery}: TABLE { assembly_core_simple: assembly_core_simple }
            |       |   | {name assembly_core_simple}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_simple)
CREATE PROC assembly_core_simple (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_simple (x) AS (SELECT 1 AS x)
  SELECT *
    FROM assembly_core_simple;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0322: fragment parameters must be exactly '(idx_ INTEGER NOT NULL)'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_simple}
  | {create_proc_stmt}: err
    | {name assembly_core_simple}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_simple: { x: integer notnull }
          |     | {cte_decl}: assembly_core_simple: { x: integer notnull }
          |     | | {name assembly_core_simple}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {table_or_subquery_list}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | | {table_or_subquery}: TABLE { assembly_core_simple: assembly_core_simple }
            |       |   | {name assembly_core_simple}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region;

  {declare_schema_region_stmt}: root_region: region
  | {name root_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION dep_region USING root_region;

  {declare_schema_region_stmt}: dep_region: region
  | {name dep_region}
  | {region_list}
    | {region_spec}
      | {name root_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region;

Error at test/sem_test.sql:XXXX : in declare_schema_region_stmt : CQL0245: schema region already defined 'root_region'

  {declare_schema_region_stmt}: err
  | {name root_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region USING unknown_region;

Error at test/sem_test.sql:XXXX : in region_list : CQL0244: unknown schema region 'unknown_region'

  {declare_schema_region_stmt}: err
  | {name root_region}
  | {region_list}
    | {region_spec}
      | {name unknown_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region USING root_region, root_region;

Error at test/sem_test.sql:XXXX : in region_spec : CQL0206: duplicate name in list 'root_region'

  {declare_schema_region_stmt}: err
  | {name root_region}
  | {region_list}
    | {region_spec}
    | | {name root_region}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name root_region}
        | {int 0}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

  {begin_schema_region_stmt}: ok
  | {name root_region}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

Error at test/sem_test.sql:XXXX : in begin_schema_region_stmt : CQL0246: schema regions do not nest; end the current region before starting a new one

  {begin_schema_region_stmt}: err
  | {name root_region}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION dep2_region USING root_region;

  {declare_schema_region_stmt}: dep2_region: region
  | {name dep2_region}
  | {region_list}
    | {region_spec}
      | {name root_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION diamond_region USING dep_region, dep2_region;

  {declare_schema_region_stmt}: diamond_region: region
  | {name diamond_region}
  | {region_list}
    | {region_spec}
    | | {name dep_region}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name dep2_region}
        | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

Error at test/sem_test.sql:XXXX : in end_schema_region_stmt : CQL0247: you must begin a schema region before you can end one

  {end_schema_region_stmt}: err

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION what_is_this_region;

Error at test/sem_test.sql:XXXX : in str : CQL0244: unknown schema region 'what_is_this_region'

  {begin_schema_region_stmt}: err
  | {name what_is_this_region}

The statement ending at line XXXX

CREATE PROC decl_region_in_proc ()
BEGIN
  @DECLARE_SCHEMA_REGION fooey;
END;

Error at test/sem_test.sql:XXXX : in declare_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name decl_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_schema_region_stmt}: err
        | {name fooey}

The statement ending at line XXXX

CREATE PROC begin_region_in_proc ()
BEGIN
  @BEGIN_SCHEMA_REGION fooey;
END;

Error at test/sem_test.sql:XXXX : in begin_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name begin_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {begin_schema_region_stmt}: err
        | {name fooey}

The statement ending at line XXXX

CREATE PROC end_region_in_proc ()
BEGIN
  @END_SCHEMA_REGION;
END;

Error at test/sem_test.sql:XXXX : in end_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name end_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {end_schema_region_stmt}: err

The statement ending at line XXXX

SET my_real := 1.3 / 2;

  {assign}: my_real: real variable
  | {name my_real}: my_real: real variable
  | {div}: real notnull
    | {dbl 1.3}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SET X := 1.3 % 2;

Error at test/sem_test.sql:XXXX : in mod : CQL0001: operands must be an integer type, not real '%'

  {assign}: err
  | {name X}: X: integer variable
  | {mod}: err
    | {dbl 1.3}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SELECT (NOT 'x') || 'plugh';

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {strlit 'plugh'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

  {begin_schema_region_stmt}: ok
  | {name root_region}

The statement ending at line XXXX

CREATE TABLE a_table_in_root_region(
  id INTEGER
);

  {create_table_stmt}: a_table_in_root_region: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_in_root_region}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TRIGGER a_trigger_in_root_region
  BEFORE DELETE ON a_table_in_root_region
BEGIN
  DELETE FROM a_table_in_root_region WHERE id > 3;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name a_trigger_in_root_region}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name id}: id: integer
                        | {int 3}: integer notnull

The statement ending at line XXXX

CREATE INDEX a_index_in_root_region ON a_table_in_root_region (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name a_index_in_root_region}
  | | {name a_table_in_root_region}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}: id: integer

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION dep_region;

  {begin_schema_region_stmt}: ok
  | {name dep_region}

The statement ending at line XXXX

CREATE TABLE a_table_in_dep_region(
  id INTEGER
);

  {create_table_stmt}: a_table_in_dep_region: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE VIEW a_view_in_dep_region AS
SELECT T1.id AS id1, T2.id AS id2
  FROM a_table_in_root_region AS T1
  INNER JOIN a_table_in_dep_region AS T2 USING (id);

  {create_view_stmt}: a_view_in_dep_region: { id1: integer, id2: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name a_view_in_dep_region}
      | {select_stmt}: a_view_in_dep_region: { id1: integer, id2: integer }
        | {select_core_list}: a_view_in_dep_region: { id1: integer, id2: integer }
        | | {select_core}: a_view_in_dep_region: { id1: integer, id2: integer }
        |   | {select_expr_list_con}: a_view_in_dep_region: { id1: integer, id2: integer }
        |     | {select_expr_list}: a_view_in_dep_region: { id1: integer, id2: integer }
        |     | | {select_expr}: id1: integer
        |     | | | {dot}: id: integer
        |     | | | | {name T1}
        |     | | | | {name id}
        |     | | | {opt_as_alias}
        |     | |   | {name id1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: id2: integer
        |     |     | {dot}: id: integer
        |     |     | | {name T2}
        |     |     | | {name id}
        |     |     | {opt_as_alias}
        |     |       | {name id2}
        |     | {select_from_etc}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       | {join_clause}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       | | {table_or_subquery}: TABLE { T1: a_table_in_root_region }
        |       | | | {name a_table_in_root_region}: TABLE { T1: a_table_in_root_region }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       |     | {int 1}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { T2: a_table_in_dep_region }
        |       |       | | {name a_table_in_dep_region}: TABLE { T2: a_table_in_dep_region }
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       |         | {using}
        |       |         | {name_list}: id: integer
        |       |           | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DROP TRIGGER trigger2;

Error at test/sem_test.sql:XXXX : in str : CQL0113: trigger in drop statement was not declared (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'trigger2'

  {drop_trigger_stmt}: err
  | {name trigger2}

The statement ending at line XXXX

DROP VIEW MyView;

Error at test/sem_test.sql:XXXX : in str : CQL0110: view in drop statement does not exist (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'MyView'

  {drop_view_stmt}: err
  | {name MyView}

The statement ending at line XXXX

DROP TABLE foo;

Error at test/sem_test.sql:XXXX : in str : CQL0108: table in drop statement does not exist (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'foo'

  {drop_table_stmt}: err
  | {name foo}

The statement ending at line XXXX

DROP INDEX index_1;

Error at test/sem_test.sql:XXXX : in str : CQL0112: index in drop statement was not declared (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'index_1'

  {drop_index_stmt}: err
  | {name index_1}

The statement ending at line XXXX

CREATE TABLE a_table_like_table_in_dep_region(
  id INTEGER NOT NULL
);

  {create_table_stmt}: a_table_like_table_in_dep_region: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_table_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE a_table_like_table_in_dep_region_2(
  id1 INTEGER,
  id2 INTEGER
);

  {create_table_stmt}: a_table_like_table_in_dep_region_2: { id1: integer, id2: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_table_in_dep_region_2}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name id2}
            | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE a_table_like_view_in_dep_region(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

  {create_table_stmt}: a_table_like_view_in_dep_region: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_view_in_dep_region}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
          | {col_def_type_attrs}
            | {col_def_name_type}
            | | {name f3}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE a_table_like_proc_in_dep_region(
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: a_table_like_proc_in_dep_region: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_proc_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: longint
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name rate}
              | {type_long}: longint

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION dep2_region;

  {begin_schema_region_stmt}: ok
  | {name dep2_region}

The statement ending at line XXXX

CREATE VIEW ok_view_in_dep2_region AS
SELECT *
  FROM a_table_in_root_region;

  {create_view_stmt}: ok_view_in_dep2_region: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name ok_view_in_dep2_region}
      | {select_stmt}: ok_view_in_dep2_region: { id: integer }
        | {select_core_list}: ok_view_in_dep2_region: { id: integer }
        | | {select_core}: ok_view_in_dep2_region: { id: integer }
        |   | {select_expr_list_con}: ok_view_in_dep2_region: { id: integer }
        |     | {select_expr_list}: ok_view_in_dep2_region: { id: integer }
        |     | | {star}: ok_view_in_dep2_region: { id: integer }
        |     | {select_from_etc}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | {table_or_subquery_list}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | | {table_or_subquery}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       |   | {name a_table_in_root_region}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW bogus_view_in_dep2_region AS
SELECT T1.id AS id1, T2.id AS id2
  FROM a_table_in_root_region AS T1
  INNER JOIN a_table_in_dep_region AS T2 USING (id);

Error at test/sem_test.sql:XXXX : in table_or_subquery : CQL0095: table/view not defined (object is in schema region 'dep_region' not accessible from region 'dep2_region') 'a_table_in_dep_region'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name bogus_view_in_dep2_region}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}
        |     | | | {dot}
        |     | | | | {name T1}
        |     | | | | {name id}
        |     | | | {opt_as_alias}
        |     | |   | {name id1}
        |     | | {select_expr_list}
        |     |   | {select_expr}
        |     |     | {dot}
        |     |     | | {name T2}
        |     |     | | {name id}
        |     |     | {opt_as_alias}
        |     |       | {name id2}
        |     | {select_from_etc}: err
        |       | {join_clause}: err
        |       | | {table_or_subquery}: TABLE { T1: a_table_in_root_region }
        |       | | | {name a_table_in_root_region}: TABLE { T1: a_table_in_root_region }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: err
        |       |     | {int 1}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: err
        |       |       | | {name a_table_in_dep_region}
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}
        |       |         | {using}
        |       |         | {name_list}
        |       |           | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW bogus_due_to_non_region_object AS
SELECT *
  FROM bar;

Error at test/sem_test.sql:XXXX : in table_or_subquery : CQL0095: table/view not defined (while in schema region 'dep2_region', accessing an object that isn't in a region is invalid) 'bar'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name bogus_due_to_non_region_object}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {name bar}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION diamond_region;

  {begin_schema_region_stmt}: ok
  | {name diamond_region}

The statement ending at line XXXX

DROP TABLE a_table_like_proc_in_dep_region;

  {drop_table_stmt}: ok
  | {name a_table_like_proc_in_dep_region}: a_table_like_proc_in_dep_region: { id: integer notnull, name: text, rate: longint }

The statement ending at line XXXX

DROP TABLE a_table_in_root_region;

  {drop_table_stmt}: ok
  | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }

The statement ending at line XXXX

DROP VIEW a_view_in_dep_region;

  {drop_view_stmt}: ok
  | {name a_view_in_dep_region}: a_view_in_dep_region: { id1: integer, id2: integer }

The statement ending at line XXXX

DROP TRIGGER a_trigger_in_root_region;

  {drop_trigger_stmt}: ok
  | {name a_trigger_in_root_region}

The statement ending at line XXXX

DROP INDEX a_index_in_root_region;

  {drop_index_stmt}: ok
  | {name a_index_in_root_region}

The statement ending at line XXXX

CREATE TABLE diamond_region_table(
  id INTEGER
) @RECREATE(d_group);

  {create_table_stmt}: diamond_region_table: { id: integer } @recreate(d_group)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name d_group}
  | | {name diamond_region_table}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

CREATE INDEX invalid_wrong_group_index ON diamond_region_table (id);

Error at test/sem_test.sql:XXXX : in create_index_stmt : CQL0066: if a table is marked @recreate, its indices must be in its schema region 'invalid_wrong_group_index'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name invalid_wrong_group_index}
  | | {name diamond_region_table}
  | {flags_names_attrs}
    | {int 0}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}

The statement ending at line XXXX

SET x := ( WITH
threads2 (count) AS (SELECT 1 AS foo)
SELECT COUNT(*)
  FROM threads2 );

  {assign}: X: integer variable
  | {name x}: X: integer variable
  | {with_select_stmt}: _anon: integer notnull
    | {with}
    | | {cte_tables}: ok
    |   | {cte_table}: threads2: { count: integer notnull }
    |     | {cte_decl}: threads2: { count: integer notnull }
    |     | | {name threads2}
    |     | | {name_list}
    |     |   | {name count}
    |     | {select_stmt}: select: { foo: integer notnull }
    |       | {select_core_list}: select: { foo: integer notnull }
    |       | | {select_core}: select: { foo: integer notnull }
    |       |   | {select_expr_list_con}: select: { foo: integer notnull }
    |       |     | {select_expr_list}: select: { foo: integer notnull }
    |       |     | | {select_expr}: foo: integer notnull
    |       |     |   | {int 1}: integer notnull
    |       |     |   | {opt_as_alias}
    |       |     |     | {name foo}
    |       |     | {select_from_etc}: ok
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {select_stmt}: select: { _anon: integer notnull }
      | {select_core_list}: select: { _anon: integer notnull }
      | | {select_core}: select: { _anon: integer notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull }
      |     | | {select_expr}: integer notnull
      |     |   | {call}: integer notnull
      |     |     | {name COUNT}: integer notnull
      |     |     | {call_arg_list}
      |     |       | {call_filter_clause}
      |     |       | {arg_list}: ok
      |     |         | {star}: integer
      |     | {select_from_etc}: TABLE { threads2: threads2 }
      |       | {table_or_subquery_list}: TABLE { threads2: threads2 }
      |       | | {table_or_subquery}: TABLE { threads2: threads2 }
      |       |   | {name threads2}: TABLE { threads2: threads2 }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC tvf (id INTEGER) (foo TEXT);

  {declare_select_func_stmt}: select: { foo: text } select_func
  | {name tvf}: select: { foo: text }
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: select: { foo: text }
      | {typed_name}: foo: text
        | {name foo}
        | {type_text}: foo: text

The statement ending at line XXXX

CREATE PROC using_tvf ()
BEGIN
  SELECT *
    FROM tvf(1);
END;

  {create_proc_stmt}: select: { foo: text } dml_proc
  | {name using_tvf}: select: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { tvf: select }
        |       | {table_or_subquery_list}: TABLE { tvf: select }
        |       | | {table_or_subquery}: TABLE { tvf: select }
        |       |   | {table_function}: TABLE { tvf: select }
        |       |     | {name tvf}: TABLE { tvf: select }
        |       |     | {arg_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_invalid_arg ()
BEGIN
  SELECT *
    FROM tvf(NOT 'x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name using_tvf_invalid_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name tvf}
        |       |     | {arg_list}: err
        |       |       | {not}: err
        |       |         | {strlit 'x'}: text notnull
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_arg_mismatch ()
BEGIN
  SELECT *
    FROM tvf('x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'id'

  {create_proc_stmt}: err
  | {name using_tvf_arg_mismatch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name tvf}
        |       |     | {arg_list}: ok
        |       |       | {strlit 'x'}: err
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_unaliased ()
BEGIN
  SELECT *
    FROM tvf(1)
    WHERE tvf.foo = 'x';
END;

  {create_proc_stmt}: select: { foo: text } dml_proc
  | {name using_tvf_unaliased}: select: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { tvf: select }
        |       | {table_or_subquery_list}: TABLE { tvf: select }
        |       | | {table_or_subquery}: TABLE { tvf: select }
        |       |   | {table_function}: TABLE { tvf: select }
        |       |     | {name tvf}: TABLE { tvf: select }
        |       |     | {arg_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: foo: text
        |         |   | | {name tvf}
        |         |   | | {name foo}
        |         |   | {strlit 'x'}: text notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_aliased ()
BEGIN
  SELECT *
    FROM tvf(1) AS T1
    WHERE T1.foo = 'x';
END;

  {create_proc_stmt}: select: { foo: text } dml_proc
  | {name using_tvf_aliased}: select: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { T1: select }
        |       | {table_or_subquery_list}: TABLE { T1: select }
        |       | | {table_or_subquery}: TABLE { T1: select }
        |       |   | {table_function}: TABLE { T1: select }
        |       |   | | {name tvf}: TABLE { T1: select }
        |       |   | | {arg_list}: ok
        |       |   |   | {int 1}: integer notnull
        |       |   | {opt_as_alias}
        |       |     | {name T1}
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: foo: text
        |         |   | | {name T1}
        |         |   | | {name foo}
        |         |   | {strlit 'x'}: text notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_not_a_tvf ()
BEGIN
  SELECT *
    FROM SqlUserFunc(1);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0249: function is not a table-valued-function 'SqlUserFunc'

  {create_proc_stmt}: err
  | {name using_not_a_tvf}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name SqlUserFunc}
        |       |     | {arg_list}
        |       |       | {int 1}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_not_a_func ()
BEGIN
  SELECT *
    FROM ThisDoesNotExist(1);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0250: table-valued function not declared 'ThisDoesNotExist'

  {create_proc_stmt}: err
  | {name using_not_a_func}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name ThisDoesNotExist}
        |       |     | {arg_list}
        |       |       | {int 1}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC ReadFromRowset (rowset OBJECT<rowset>) (id INTEGER);

  {declare_select_func_stmt}: select: { id: integer } select_func
  | {name ReadFromRowset}: select: { id: integer }
  | {func_params_return}
    | {params}: ok
    | | {param}: rowset: object<rowset> variable in
    |   | {param_detail}: rowset: object<rowset> variable in
    |     | {name rowset}: rowset: object<rowset> variable in
    |     | {type_object}: object<rowset>
    |       | {name rowset}
    | {typed_names}: select: { id: integer }
      | {typed_name}: id: integer
        | {name id}
        | {type_int}: id: integer

The statement ending at line XXXX

CREATE PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  SELECT *
    FROM ReadFromRowset(rowset);
END;

  {create_proc_stmt}: select: { id: integer } dml_proc
  | {name rowset_object_reader}: select: { id: integer } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: rowset: object<rowset> variable in
    |   | {param_detail}: rowset: object<rowset> variable in
    |     | {name rowset}: rowset: object<rowset> variable in
    |     | {type_object}: object<rowset>
    |       | {name rowset}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer }
        | {select_core_list}: select: { id: integer }
        | | {select_core}: select: { id: integer }
        |   | {select_expr_list_con}: select: { id: integer }
        |     | {select_expr_list}: select: { id: integer }
        |     | | {star}: select: { id: integer }
        |     | {select_from_etc}: TABLE { ReadFromRowset: select }
        |       | {table_or_subquery_list}: TABLE { ReadFromRowset: select }
        |       | | {table_or_subquery}: TABLE { ReadFromRowset: select }
        |       |   | {table_function}: TABLE { ReadFromRowset: select }
        |       |     | {name ReadFromRowset}: TABLE { ReadFromRowset: select }
        |       |     | {arg_list}: ok
        |       |       | {name rowset}: rowset: object<rowset> variable in
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SET ll := ( SELECT ptr(obj_var) );

  {assign}: ll: longint notnull variable
  | {name ll}: ll: longint notnull variable
  | {select_stmt}: _anon: longint notnull
    | {select_core_list}: select: { _anon: longint notnull }
    | | {select_core}: select: { _anon: longint notnull }
    |   | {select_expr_list_con}: select: { _anon: longint notnull }
    |     | {select_expr_list}: select: { _anon: longint notnull }
    |     | | {select_expr}: longint notnull
    |     |   | {call}: longint notnull
    |     |     | {name ptr}: longint notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name obj_var}: obj_var: object variable
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET ll := ( SELECT ptr(NOT 'x') );

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {assign}: err
  | {name ll}: ll: longint notnull variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name ptr}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: err
    |     |         | {not}: err
    |     |           | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET ll := ptr(obj_var);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'ptr'

  {assign}: err
  | {name ll}: ll: longint notnull variable
  | {call}: err
    | {name ptr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET ll := ptr(obj_var, 1);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'ptr'

  {assign}: err
  | {name ll}: ll: longint notnull variable
  | {call}: err
    | {name ptr}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC variable_conflict ()
BEGIN
  DECLARE id INTEGER;
  SET id := ( SELECT id
    FROM foo );
END;

Error at test/sem_test.sql:XXXX : in str : CQL0059: a variable name might be ambiguous with a column name, this is an anti-pattern 'id'

  {create_proc_stmt}: err
  | {name variable_conflict}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: id: integer variable
      | | | {name id}: id: integer variable
      | | {type_int}: integer
      | {assign}: err
        | {name id}: id: integer variable
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {name id}: err
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT group_concat(name) AS gc
  FROM with_sensitive;

  {select_stmt}: select: { gc: text sensitive }
  | {select_core_list}: select: { gc: text sensitive }
  | | {select_core}: select: { gc: text sensitive }
  |   | {select_expr_list_con}: select: { gc: text sensitive }
  |     | {select_expr_list}: select: { gc: text sensitive }
  |     | | {select_expr}: gc: text sensitive
  |     |   | {call}: name: text sensitive
  |     |   | | {name group_concat}: name: text sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name name}: name: text sensitive
  |     |   | {opt_as_alias}
  |     |     | {name gc}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT group_concat('not-null') AS gc
  FROM foo;

  {select_stmt}: select: { gc: text }
  | {select_core_list}: select: { gc: text }
  | | {select_core}: select: { gc: text }
  |   | {select_expr_list_con}: select: { gc: text }
  |     | {select_expr_list}: select: { gc: text }
  |     | | {select_expr}: gc: text
  |     |   | {call}: text
  |     |   | | {name group_concat}: text
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {strlit 'not-null'}: text notnull
  |     |   | {opt_as_alias}
  |     |     | {name gc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC min_gets_blob (a_blob BLOB)
BEGIN
  SELECT min(a_blob)
    FROM foo;
END;

Error at test/sem_test.sql:XXXX : in call : CQL0257: argument must be a string or numeric in 'min'

  {create_proc_stmt}: err
  | {name min_gets_blob}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_blob: blob variable in
    |   | {param_detail}: a_blob: blob variable in
    |     | {name a_blob}: a_blob: blob variable in
    |     | {type_blob}: blob
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name min}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name a_blob}: a_blob: blob variable in
        |     | {select_from_etc}: TABLE { foo: foo }
        |       | {table_or_subquery_list}: TABLE { foo: foo }
        |       | | {table_or_subquery}: TABLE { foo: foo }
        |       |   | {name foo}: TABLE { foo: foo }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SET my_real := ( SELECT min(1.2, 2, 3) AS min_stuff );

  {assign}: my_real: real variable
  | {name my_real}: my_real: real variable
  | {select_stmt}: min_stuff: real notnull
    | {select_core_list}: select: { min_stuff: real notnull }
    | | {select_core}: select: { min_stuff: real notnull }
    |   | {select_expr_list_con}: select: { min_stuff: real notnull }
    |     | {select_expr_list}: select: { min_stuff: real notnull }
    |     | | {select_expr}: min_stuff: real notnull
    |     |   | {call}: real notnull
    |     |   | | {name min}: real notnull
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {dbl 1.2}: real notnull
    |     |   |     | {arg_list}
    |     |   |       | {int 2}: integer notnull
    |     |   |       | {arg_list}
    |     |   |         | {int 3}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name min_stuff}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT sum(1 AND 1)
  FROM foo;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {call}: integer
  |     |     | {name sum}: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {and}: bool notnull
  |     |           | {int 1}: integer notnull
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(1L)
  FROM foo;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {call}: longint
  |     |     | {name sum}: longint
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {longint 1}: longint notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(1.2)
  FROM foo;

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name sum}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dbl 1.2}: real notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(1, 'x');

Error at test/sem_test.sql:XXXX : in call : CQL0012: incompatible types in expression 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(NULL, 'x');

Error at test/sem_test.sql:XXXX : in call : CQL0257: argument must be a string or numeric in 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {null}: null
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min('x', NULL, 'y');

Error at test/sem_test.sql:XXXX : in call : CQL0257: argument must be a string or numeric in 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {null}: null
  |     |           | {arg_list}
  |     |             | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min('x', 'y');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name min}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(1, 1.2);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name min}: real notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(_sens, 1L);

  {select_stmt}: select: { _anon: longint sensitive }
  | {select_core_list}: select: { _anon: longint sensitive }
  | | {select_core}: select: { _anon: longint sensitive }
  |   | {select_expr_list_con}: select: { _anon: longint sensitive }
  |     | {select_expr_list}: select: { _anon: longint sensitive }
  |     | | {select_expr}: longint sensitive
  |     |   | {call}: longint sensitive
  |     |     | {name min}: longint sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name _sens}: _sens: integer variable sensitive
  |     |         | {arg_list}
  |     |           | {longint 1}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_1(
  id INTEGER PRIMARY KEY REFERENCES recreatable (id),
  name TEXT
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0060: referenced table can be independently be recreated so it cannot be used in a foreign key 'recreatable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name recreatable_reference_1}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name recreatable}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 0}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_2(
  id INTEGER PRIMARY KEY REFERENCES recreatable (id),
  name TEXT
) @RECREATE;

Error at test/sem_test.sql:XXXX : in col_def : CQL0060: referenced table can be independently be recreated so it cannot be used in a foreign key 'recreatable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable_reference_2}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name recreatable}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 0}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE in_group_test(
  id INTEGER PRIMARY KEY,
  name TEXT
) @RECREATE(rtest);

  {create_table_stmt}: in_group_test: { id: integer notnull primary_key, name: text } @recreate(rtest)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest}
  | | {name in_group_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE recreatable_reference_3(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id),
  name TEXT
) @RECREATE;

Error at test/sem_test.sql:XXXX : in col_def : CQL0060: referenced table can be independently be recreated so it cannot be used in a foreign key 'in_group_test'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable_reference_3}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 0}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_4(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id),
  name TEXT
) @RECREATE(rtest_other_group);

Error at test/sem_test.sql:XXXX : in col_def : CQL0060: referenced table can be independently be recreated so it cannot be used in a foreign key 'in_group_test'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest_other_group}
  | | {name recreatable_reference_4}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 0}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_5(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE(rtest);

  {create_table_stmt}: recreatable_reference_5: { id: integer notnull primary_key foreign_key, name: text } @recreate(rtest)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest}
  | | {name recreatable_reference_5}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_fk}: ok
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}: id: integer notnull
    |         | {int 51}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE early_out_on_errs(
  result_index INTEGER NOT NULL,
  query TEXT NOT NULL,
  FOREIGN KEY (query) REFERENCES table_not_found (q),
  PRIMARY KEY (garbonzo)
) @RECREATE;

Error at test/sem_test.sql:XXXX : in fk_def : CQL0021: foreign key refers to non-existent table 'table_not_found'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name early_out_on_errs}
  | {col_key_list}
    | {col_def}: result_index: integer notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name result_index}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: query: text notnull
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name query}
      |   | | {type_text}: text
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {fk_def}
        | | {name_list}
        | | | {name query}: query: text notnull
        | | {fk_target_options}
        |   | {fk_target}
        |   | | {name table_not_found}
        |   | | {name_list}
        |   |   | {name q}
        |   | {int 0}
        | {col_key_list}
          | {pk_def}
            | {name_list}
              | {name garbonzo}

The statement ending at line XXXX

CREATE PROC some_fake_upgrader ()
BEGIN
  CREATE TABLE recreatable_reference_6(
    id INTEGER PRIMARY KEY REFERENCES in_group_test (id) ON UPDATE CASCADE ON DELETE CASCADE,
    name TEXT
  ) @RECREATE(rtest_other_group);
END;

  {create_proc_stmt}: ok dml_proc
  | {name some_fake_upgrader}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {create_table_stmt}: recreatable_reference_6: { id: integer notnull primary_key foreign_key, name: text } @recreate(rtest_other_group)
        | {create_table_name_flags}
        | | {table_flags_attrs}
        | | | {int 0}
        | | | {recreate_attr}
        | |   | {name rtest_other_group}
        | | {name recreatable_reference_6}
        | {col_key_list}
          | {col_def}: id: integer notnull primary_key foreign_key
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |   | | {name id}
          |   | | {type_int}: integer
          |   | {col_attrs_pk}: ok
          |     | {col_attrs_fk}: ok
          |       | {fk_target_options}
          |         | {fk_target}
          |         | | {name in_group_test}
          |         | | {name_list}
          |         |   | {name id}: id: integer notnull
          |         | {int 51}
          | {col_key_list}
            | {col_def}: name: text
              | {col_def_type_attrs}
                | {col_def_name_type}
                  | {name name}
                  | {type_text}: text

The statement ending at line XXXX

@ENFORCE_STRICT JOIN;

  {enforce_strict_stmt}: ok
  | {int 3}

The statement ending at line XXXX

SELECT *
  FROM foo,
bar;

Error at test/sem_test.sql:XXXX : in table_or_subquery_list : CQL0263: non-ANSI joins are forbidden if strict join mode is enabled

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}
  |       |   | {table_or_subquery}
  |       |     | {name bar}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC bar ()
BEGIN
  DECLARE C CURSOR FOR CALL out_cursor_proc();
END;

Error at test/sem_test.sql:XXXX : in declare_cursor : CQL0270: use FETCH FROM for procedures that returns a cursor with OUT 'C'

  {create_proc_stmt}: err
  | {name bar}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
          | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out

The statement ending at line XXXX

SELECT *
  FROM foo
OFFSET 1;

Error at test/sem_test.sql:XXXX : in opt_offset : CQL0271: the OFFSET clause may only be used if LIMIT is also present

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {select_offset}
        | {opt_offset}: err
          | {int 1}

The statement ending at line XXXX

CREATE PROC upsert_do_nothing ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_do_nothing}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: select: { id: integer notnull }
        |       | {select_core_list}: select: { id: integer notnull }
        |       | | {select_core}: select: { id: integer notnull }
        |       |   | {select_expr_list_con}: select: { id: integer notnull }
        |       |     | {select_expr_list}: select: { id: integer notnull }
        |       |     | | {select_expr}: id: integer notnull
        |       |     |   | {name id}: id: integer notnull
        |       |     | {select_from_etc}: TABLE { bar: bar }
        |       |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |       |   | {name bar}: TABLE { bar: bar }
        |       |       | {select_where}
        |       |         | {opt_where}: integer notnull
        |       |         | | {int 1}: integer notnull
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }
            | {indexed_columns}
              | {indexed_column}
                | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE PROC with_upsert_do_nothing ()
BEGIN
  WITH
  data (id) AS (VALUES(1), (2), (3))
  INSERT INTO foo(id) SELECT id
    FROM data
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_upsert_do_nothing}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_upsert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: data: { id: integer notnull }
        |     | {cte_decl}: data: { id: integer notnull }
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |     | | {int 1}: integer notnull
        |       |     | {values}
        |       |       | {insert_list}
        |       |       | | {int 2}: integer notnull
        |       |       | {values}
        |       |         | {insert_list}
        |       |           | {int 3}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}: ok
          | {insert_stmt}: ok
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name id}: id: integer notnull
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {select_expr}: id: integer notnull
          |       |     |   | {name id}: id: integer notnull
          |       |     | {select_from_etc}: TABLE { data: data }
          |       |       | {table_or_subquery_list}: TABLE { data: data }
          |       |       | | {table_or_subquery}: TABLE { data: data }
          |       |       |   | {name data}: TABLE { data: data }
          |       |       | {select_where}
          |       |         | {opt_where}: integer notnull
          |       |         | | {int 1}: integer notnull
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}: ok
            | {conflict_target}: excluded: { id: integer notnull }
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE PROC with_upsert_cte_err ()
BEGIN
  WITH
  data (id) AS (VALUES(NOT 'x'))
  INSERT INTO foo SELECT id
    FROM data
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_upsert_cte_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_upsert_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}: err
        |       |   | {select_values}
        |       |   | {values}: err
        |       |     | {insert_list}
        |       |       | {not}: err
        |       |         | {strlit 'x'}: text notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}
          | {insert_stmt}
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}
          |   | {columns_values}
          |     | {select_stmt}
          |       | {select_core_list}
          |       | | {select_core}
          |       |   | {select_expr_list_con}
          |       |     | {select_expr_list}
          |       |     | | {select_expr}
          |       |     |   | {name id}
          |       |     | {select_from_etc}
          |       |       | {table_or_subquery_list}
          |       |       | | {table_or_subquery}
          |       |       |   | {name data}
          |       |       | {select_where}
          |       |         | {opt_where}
          |       |         | | {int 1}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}
            | {conflict_target}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}

The statement ending at line XXXX

CREATE PROC with_upsert_insert_err ()
BEGIN
  WITH
  data (id) AS (VALUES(1))
  INSERT INTO foo(id) SELECT id
    FROM data
    WHERE NOT 'x'
  ON CONFLICT (id) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_upsert_insert_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_upsert_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: data: { id: integer notnull }
        |     | {cte_decl}: data: { id: integer notnull }
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}: err
          | {insert_stmt}: err
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: err
          |       | {select_core_list}: err
          |       | | {select_core}: err
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: err
          |       |     | | {select_expr}: id: integer notnull
          |       |     |   | {name id}: id: integer notnull
          |       |     | {select_from_etc}: err
          |       |       | {table_or_subquery_list}: TABLE { data: data }
          |       |       | | {table_or_subquery}: TABLE { data: data }
          |       |       |   | {name data}: TABLE { data: data }
          |       |       | {select_where}
          |       |         | {opt_where}: err
          |       |         | | {not}: err
          |       |         |   | {strlit 'x'}: text notnull
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}
            | {conflict_target}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}

The statement ending at line XXXX

CREATE PROC upsert_without_conflict_target ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_without_conflict_target}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }

The statement ending at line XXXX

CREATE PROC upsert_update ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) 
    WHERE id = 10 DO UPDATE
  SET id = id + 1
    WHERE id = 20;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_update}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }
          | | {indexed_columns}
          | | | {indexed_column}
          | |   | {name id}: id: integer notnull
          | | {opt_where}: bool notnull
          |   | {eq}: bool notnull
          |     | {name id}: id: integer notnull
          |     | {int 10}: integer notnull
          | {update_stmt}: foo: { id: integer notnull primary_key autoinc }
            | {update_set}
              | {update_list}: ok
              | | {update_entry}: id: integer notnull
              |   | {name id}: id: integer notnull
              |   | {add}: integer notnull
              |     | {name id}: id: integer notnull
              |     | {int 1}: integer notnull
              | {update_where}
                | {opt_where}: bool notnull
                | | {eq}: bool notnull
                |   | {name id}: id: integer notnull
                |   | {int 20}: integer notnull
                | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_conflict_on_unknown_column ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id, bogus) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'bogus'

  {create_proc_stmt}: err
  | {name upsert_conflict_on_unknown_column}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}: err
              | {indexed_column}
              | | {name id}: id: integer notnull
              | {indexed_columns}
                | {indexed_column}
                  | {name bogus}: err

The statement ending at line XXXX

CREATE PROC upsert_invalid_update_stmt ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) DO UPDATE foo
  SET id = 0;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0281: upsert statement does not include table name in the update statement 'foo'

  {create_proc_stmt}: err
  | {name upsert_invalid_update_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: excluded: { id: integer notnull }
          | | {indexed_columns}
          |   | {indexed_column}
          |     | {name id}: id: integer notnull
          | {update_stmt}: err
            | {name foo}: foo: { id: integer notnull primary_key autoinc }
            | {update_set}
              | {update_list}
              | | {update_entry}
              |   | {name id}
              |   | {int 0}
              | {update_where}
                | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_no_where_stmt ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM (SELECT *
    FROM bar)
  ON CONFLICT (id) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in insert_stmt : CQL0280: upsert statement requires a where clause if the insert clause uses select

  {create_proc_stmt}: err
  | {name upsert_no_where_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: err
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: select: { id: integer notnull }
        |       | {select_core_list}: select: { id: integer notnull }
        |       | | {select_core}: select: { id: integer notnull }
        |       |   | {select_expr_list_con}: select: { id: integer notnull }
        |       |     | {select_expr_list}: select: { id: integer notnull }
        |       |     | | {select_expr}: id: integer notnull
        |       |     |   | {name id}: id: integer notnull
        |       |     | {select_from_etc}: TABLE { select: select }
        |       |       | {table_or_subquery_list}: TABLE { select: select }
        |       |       | | {table_or_subquery}: TABLE { select: select }
        |       |       |   | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | {select_from_etc}: TABLE { bar: bar }
        |       |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |       |     |       |   | {name bar}: TABLE { bar: bar }
        |       |       |     |       | {select_where}
        |       |       |     |         | {select_groupby}
        |       |       |     |           | {select_having}
        |       |       |     | {select_orderby}
        |       |       |       | {select_limit}
        |       |       |         | {select_offset}
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}
          | {conflict_target}: excluded: { id: integer notnull }
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE PROC upsert_or_ignore ()
BEGIN
  INSERT OR IGNORE INTO foo SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in insert_or_ignore : CQL0283: upsert syntax only supports INSERT INTO 'foo'

  {create_proc_stmt}: err
  | {name upsert_or_ignore}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: err
        | | {insert_or_ignore}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}
        |       |   | {select_expr_list_con}
        |       |     | {select_expr_list}
        |       |     | | {select_expr}
        |       |     |   | {name id}
        |       |     | {select_from_etc}
        |       |       | {table_or_subquery_list}
        |       |       | | {table_or_subquery}
        |       |       |   | {name bar}
        |       |       | {select_where}
        |       |         | {opt_where}
        |       |         | | {int 1}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}
          | {conflict_target}
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE PROC upsert_with_bogus_where_stmt ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) 
    WHERE bogus = 1 DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {create_proc_stmt}: err
  | {name upsert_with_bogus_where_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}
            | | {indexed_column}
            |   | {name id}: id: integer notnull
            | {opt_where}: err
              | {eq}: err
                | {name bogus}: err
                | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC update_without_table_name ()
BEGIN
  CREATE TEMP TRIGGER update_without_table_name_trigger
    BEFORE DELETE ON bar
  BEGIN
    UPDATE
    SET id = 1
      WHERE id = 9;
  END;
END;

Error at test/sem_test.sql:XXXX : in update_stmt : CQL0282: update statement require table name

  {create_proc_stmt}: err
  | {name update_without_table_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_trigger_stmt}: err
        | {int 1}
        | {trigger_body_vers}
          | {trigger_def}
            | {name update_without_table_name_trigger}
            | {trigger_condition}
              | {int 4}
              | {trigger_op_target}
                | {trigger_operation}
                | | {int 64}
                | {trigger_target_action}
                  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | {trigger_action}
                    | {int 0}
                    | {trigger_when_stmts}
                      | {stmt_list}: err
                        | {update_stmt}: err
                          | {update_set}
                            | {update_list}
                            | | {update_entry}
                            |   | {name id}
                            |   | {int 1}
                            | {update_where}
                              | {opt_where}
                              | | {eq}
                              |   | {name id}
                              |   | {int 9}
                              | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_conflict_target_column_not_unique_key ()
BEGIN
  INSERT INTO bar(id) VALUES(1)
  ON CONFLICT (name) DO NOTHING;
END;

Error at test/sem_test.sql:XXXX : in indexed_columns : CQL0279: the set of columns referenced in the conflict target should match exactly a unique key in table we apply upsert

  {create_proc_stmt}: err
  | {name upsert_conflict_target_column_not_unique_key}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}
              | {indexed_column}
                | {name name}: name: text

The statement ending at line XXXX

CREATE PROC upsert_conflict_target_columns_valid ()
BEGIN
  INSERT INTO simple_ak_table_2(a, b, c, d) VALUES(1, "t", 1.7, 1)
  ON CONFLICT (a, b) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_conflict_target_columns_valid}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name simple_ak_table_2}: simple_ak_table_2: { a: integer notnull, b: text, c: real, d: longint }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name a}: a: integer notnull
        |     |   | {name_list}
        |     |     | {name b}: b: text
        |     |     | {name_list}
        |     |       | {name c}: c: real
        |     |       | {name_list}
        |     |         | {name d}: d: longint
        |     | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       |     | {insert_list}
        |       |       | {int 1}: integer notnull
        |       |       | {insert_list}
        |       |         | {strlit 't'}: text notnull
        |       |         | {insert_list}
        |       |           | {dbl 1.7}: real notnull
        |       |           | {insert_list}
        |       |             | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { a: integer notnull, b: text, c: real, d: longint }
            | {indexed_columns}
              | {indexed_column}
              | | {name a}: a: integer notnull
              | {indexed_columns}
                | {indexed_column}
                  | {name b}: b: text

The statement ending at line XXXX

@ENFORCE_STRICT UPSERT STATEMENT;

  {enforce_strict_stmt}: ok
  | {int 4}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES(1)
ON CONFLICT DO NOTHING;

Error at test/sem_test.sql:XXXX : in upsert_stmt : CQL0289: upsert statement are forbidden if strict upsert statement mode is enabled

  {upsert_stmt}: err
  | {insert_stmt}
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name bar}
  |   | {columns_values}
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}
  |       |   | {select_values}
  |       |   | {values}
  |       |     | {insert_list}
  |       |       | {int 1}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}
    | {conflict_target}

The statement ending at line XXXX

@ENFORCE_NORMAL UPSERT STATEMENT;

  {enforce_normal_stmt}: ok
  | {int 4}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES(1)
ON CONFLICT DO NOTHING;

  {upsert_stmt}: ok
  | {insert_stmt}: ok
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  |   | {columns_values}: ok
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}: id: integer notnull
  |     | {select_stmt}: values: { column1: integer notnull }
  |       | {select_core_list}: values: { column1: integer notnull }
  |       | | {select_core}: values: { column1: integer notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull }
  |       |     | {insert_list}
  |       |       | {int 1}: integer notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}: ok
    | {conflict_target}: excluded: { id: integer notnull }

The statement ending at line XXXX

@ENFORCE_STRICT WINDOW FUNCTION;

  {enforce_strict_stmt}: ok
  | {int 5}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in window_func_inv : CQL0312: window function invocation are forbidden if strict window function mode is enabled

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}
  |     |       | | {name rank}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL WINDOW FUNCTION;

  {enforce_normal_stmt}: ok
  | {int 5}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := max(1, 2);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'max'

  {assign}: err
  | {name X}: X: integer variable
  | {call}: err
    | {name max}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 2}: integer notnull

The statement ending at line XXXX

SET a_string := substr('x', 1, 2);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'substr'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name substr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull
          | {arg_list}
            | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC substr_test_notnull (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, 1, 2);
END;

  {create_proc_stmt}: select: { t: text notnull } dml_proc
  | {name substr_test_notnull}: select: { t: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text notnull }
        | {select_core_list}: select: { t: text notnull }
        | | {select_core}: select: { t: text notnull }
        |   | {select_expr_list_con}: select: { t: text notnull }
        |     | {select_expr_list}: select: { t: text notnull }
        |     | | {select_expr}: t: text notnull
        |     |   | {call}: t: text notnull
        |     |     | {name substr}: t: text notnull
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name t}: t: text notnull variable in
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_onearg (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, 1);
END;

  {create_proc_stmt}: select: { t: text notnull } dml_proc
  | {name substr_test_onearg}: select: { t: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text notnull }
        | {select_core_list}: select: { t: text notnull }
        | | {select_core}: select: { t: text notnull }
        |   | {select_expr_list_con}: select: { t: text notnull }
        |     | {select_expr_list}: select: { t: text notnull }
        |     | | {select_expr}: t: text notnull
        |     |   | {call}: t: text notnull
        |     |     | {name substr}: t: text notnull
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name t}: t: text notnull variable in
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_nullable (t TEXT)
BEGIN
  SELECT substr(t, 1, 2);
END;

  {create_proc_stmt}: select: { t: text } dml_proc
  | {name substr_test_nullable}: select: { t: text } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in
    |   | {param_detail}: t: text variable in
    |     | {name t}: t: text variable in
    |     | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text }
        | {select_core_list}: select: { t: text }
        | | {select_core}: select: { t: text }
        |   | {select_expr_list_con}: select: { t: text }
        |     | {select_expr_list}: select: { t: text }
        |     | | {select_expr}: t: text
        |     |   | {call}: t: text
        |     |     | {name substr}: t: text
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name t}: t: text variable in
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_sensitive (t TEXT @SENSITIVE)
BEGIN
  SELECT substr(t, 1, 2);
END;

  {create_proc_stmt}: select: { t: text sensitive } dml_proc
  | {name substr_test_sensitive}: select: { t: text sensitive } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in sensitive
    |   | {param_detail}: t: text variable in sensitive
    |     | {name t}: t: text variable in sensitive
    |     | {sensitive_attr}: text sensitive
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text sensitive }
        | {select_core_list}: select: { t: text sensitive }
        | | {select_core}: select: { t: text sensitive }
        |   | {select_expr_list_con}: select: { t: text sensitive }
        |     | {select_expr_list}: select: { t: text sensitive }
        |     | | {select_expr}: t: text sensitive
        |     |   | {call}: t: text sensitive
        |     |     | {name substr}: t: text sensitive
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name t}: t: text variable in sensitive
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_notstring ()
BEGIN
  SELECT substr(3, 1, 2);
END;

Error at test/sem_test.sql:XXXX : in call : CQL0086: first argument must be a string in function 'substr'

  {create_proc_stmt}: err
  | {name substr_test_notstring}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {int 3}: integer notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_arg2string ()
BEGIN
  SELECT substr('x', '1', 2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0083: argument must be numeric 'substr'

  {create_proc_stmt}: err
  | {name substr_test_arg2string}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {strlit '1'}: text notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_arg3string ()
BEGIN
  SELECT substr('x', 1, '2');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0083: argument must be numeric 'substr'

  {create_proc_stmt}: err
  | {name substr_test_arg3string}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {strlit '2'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_toofew ()
BEGIN
  SELECT substr('x');
END;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'substr'

  {create_proc_stmt}: err
  | {name substr_test_toofew}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}: err
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_toomany ()
BEGIN
  SELECT substr('x', 1, 2, 4);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'substr'

  {create_proc_stmt}: err
  | {name substr_test_toomany}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}: err
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     |             | {arg_list}
        |     |               | {int 4}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, MyAdHocMigration);

  {schema_ad_hoc_migration_stmt}: ok @create(5)
  | {version_annotation}
    | {int 5}
    | {name MyAdHocMigration}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, not_allowed_crc);

Error at test/sem_test.sql:XXXX : in schema_ad_hoc_migration_stmt : CQL0338: the name of a migration procedure may not end in '_crc' 'not_allowed_crc'

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name not_allowed_crc}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, MyAdHocMigration);

Error at test/sem_test.sql:XXXX : in str : CQL0027: a procedure can appear in only one annotation 'MyAdHocMigration'

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name MyAdHocMigration}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(2);

Error at test/sem_test.sql:XXXX : in schema_ad_hoc_migration_stmt : CQL0284: ad hoc schema migration directive must provide a procedure to run

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 2}

The statement ending at line XXXX

CREATE TABLE upsert_test(
  id INTEGER PRIMARY KEY,
  name TEXT,
  rate REAL
);

  {create_table_stmt}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name upsert_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: real
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name rate}
              | {type_real}: real

The statement ending at line XXXX

INSERT INTO upsert_test(id, name) VALUES(1, 'name')
ON CONFLICT (id) DO UPDATE
SET name = excluded.name,
rate = id + 1;

  {upsert_stmt}: ok
  | {insert_stmt}: ok
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name upsert_test}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
  |   | {columns_values}: ok
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}: id: integer notnull
  |     |   | {name_list}
  |     |     | {name name}: name: text
  |     | {select_stmt}: values: { column1: integer notnull, column2: text notnull }
  |       | {select_core_list}: values: { column1: integer notnull, column2: text notnull }
  |       | | {select_core}: values: { column1: integer notnull, column2: text notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull, column2: text notnull }
  |       |     | {insert_list}
  |       |       | {int 1}: integer notnull
  |       |       | {insert_list}
  |       |         | {strlit 'name'}: text notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}: ok
    | {conflict_target}: excluded: { id: integer notnull, name: text }
    | | {indexed_columns}
    |   | {indexed_column}
    |     | {name id}: id: integer notnull
    | {update_stmt}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
      | {update_set}
        | {update_list}: ok
        | | {update_entry}: name: text
        | | | {name name}: name: text
        | | | {dot}: name: text
        | |   | {name excluded}
        | |   | {name name}
        | | {update_list}
        |   | {update_entry}: rate: real
        |     | {name rate}: rate: real
        |     | {add}: integer notnull
        |       | {name id}: id: integer notnull
        |       | {int 1}: integer notnull
        | {update_where}
          | {update_orderby}

The statement ending at line XXXX

INSERT INTO foo DEFAULT VALUES
ON CONFLICT DO NOTHING;

Error at test/sem_test.sql:XXXX : in insert_normal : CQL0316: the upsert-clause is not compatible with DEFAULT VALUES 'foo'

  {upsert_stmt}: err
  | {insert_stmt}: err
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
  |   | {default_columns_values}
  | {upsert_update}
    | {conflict_target}

The statement ending at line XXXX

DECLARE PROC val_fetch (seed INTEGER NOT NULL) OUT (id TEXT);

  {declare_proc_stmt}: select: { id: text } uses_out
  | {proc_name_type}
  | | {name val_fetch}: select: { id: text } uses_out
  | | {int 5}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: seed: integer notnull variable in
    |   | {param_detail}: seed: integer notnull variable in
    |     | {name seed}: seed: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {typed_names}: select: { id: text }
      | {typed_name}: id: text
        | {name id}
        | {type_text}: id: text

The statement ending at line XXXX

DECLARE PROC val_fetch_dml (seed INTEGER NOT NULL) OUT (id TEXT) USING TRANSACTION;

  {declare_proc_stmt}: select: { id: text } dml_proc uses_out
  | {proc_name_type}
  | | {name val_fetch_dml}: select: { id: text } dml_proc uses_out
  | | {int 7}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: seed: integer notnull variable in
    |   | {param_detail}: seed: integer notnull variable in
    |     | {name seed}: seed: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {typed_names}: select: { id: text }
      | {typed_name}: id: text
        | {name id}
        | {type_text}: id: text

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION root_deployable_region;

  {declare_deployable_region_stmt}: root_deployable_region: region deployable
  | {name root_deployable_region}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION root_deployable_region;

Error at test/sem_test.sql:XXXX : in declare_deployable_region_stmt : CQL0245: schema region already defined 'root_deployable_region'

  {declare_deployable_region_stmt}: err
  | {name root_deployable_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf1;

  {declare_schema_region_stmt}: leaf1: region
  | {name leaf1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf2;

  {declare_schema_region_stmt}: leaf2: region
  | {name leaf2}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf3;

  {declare_schema_region_stmt}: leaf3: region
  | {name leaf3}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION pending_leaf_user USING leaf3;

  {declare_schema_region_stmt}: err
  | {name pending_leaf_user}
  | {region_list}
    | {region_spec}
      | {name leaf3}
      | {int 0}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION uses_leaf_3 USING leaf3;

Error at test/sem_test.sql:XXXX : in declare_schema_region_stmt : CQL0291: region links into the middle of a deployable region; you must point to the root of 'uses_leaf_3' not into the middle: 'pending_leaf_user'

  {declare_deployable_region_stmt}: err
  | {name uses_leaf_3}
  | {region_list}
    | {region_spec}
      | {name leaf3}
      | {int 0}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION depl1 USING leaf1, leaf2;

  {declare_deployable_region_stmt}: depl1: region deployable
  | {name depl1}
  | {region_list}
    | {region_spec}
    | | {name leaf1}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name leaf2}
        | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION error_region USING leaf1;

Error at test/sem_test.sql:XXXX : in declare_schema_region_stmt : CQL0291: region links into the middle of a deployable region; you must point to the root of 'depl1' not into the middle: 'error_region'

  {declare_schema_region_stmt}: err
  | {name error_region}
  | {region_list}
    | {region_spec}
      | {name leaf1}
      | {int 0}

The statement ending at line XXXX

CREATE PROC many_row_emitter ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
  OUT UNION C;
  OUT UNION C;
END;

  {create_proc_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out_union value_cursor
  | {name many_row_emitter}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {like}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {fetch_call_stmt}: ok
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {call_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      |   | {name out_cursor_proc}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc auto_cursor uses_out
      | {out_union_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
      | {out_union_stmt}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC compound_select_expr ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
  LIMIT 1 );
END;

  {create_proc_stmt}: ok dml_proc
  | {name compound_select_expr}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: x: integer variable
      | | | {name x}: x: integer variable
      | | {type_int}: integer
      | {assign}: x: integer variable
        | {name x}: x: integer variable
        | {select_stmt}: _anon: integer notnull
          | {select_core_list}: UNION: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          | | | {select_expr_list_con}: select: { _anon: integer notnull }
          | |   | {select_expr_list}: select: { _anon: integer notnull }
          | |   | | {select_expr}: integer notnull
          | |   |   | {int 1}: integer notnull
          | |   | {select_from_etc}: ok
          | |     | {select_where}
          | |       | {opt_where}: integer notnull
          | |       | | {int 0}: integer notnull
          | |       | {select_groupby}
          | |         | {select_having}
          | | {select_core_compound}
          |   | {int 1}
          |   | {select_core_list}: select: { _anon: integer notnull }
          |     | {select_core}: select: { _anon: integer notnull }
          |       | {select_expr_list_con}: select: { _anon: integer notnull }
          |         | {select_expr_list}: select: { _anon: integer notnull }
          |         | | {select_expr}: integer notnull
          |         |   | {int 2}: integer notnull
          |         | {select_from_etc}: ok
          |           | {select_where}
          |             | {select_groupby}
          |               | {select_having}
          | {select_orderby}
            | {select_limit}
              | {opt_limit}: integer notnull
              | | {int 1}: integer notnull
              | {select_offset}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION region_hiding_something USING depl1 PRIVATE;

  {declare_schema_region_stmt}: region_hiding_something: region
  | {name region_hiding_something}
  | {region_list}
    | {region_spec}
      | {name depl1}
      | {int 1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION region_not_hiding_something USING depl1;

  {declare_schema_region_stmt}: region_not_hiding_something: region
  | {name region_not_hiding_something}
  | {region_list}
    | {region_spec}
      | {name depl1}
      | {int 0}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON UPDATE;

  {enforce_normal_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON DELETE;

  {enforce_normal_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION private_region;

  {declare_schema_region_stmt}: private_region: region
  | {name private_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION containing_region USING private_region PRIVATE;

  {declare_schema_region_stmt}: containing_region: region
  | {name containing_region}
  | {region_list}
    | {region_spec}
      | {name private_region}
      | {int 1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION client_region USING containing_region;

  {declare_schema_region_stmt}: client_region: region
  | {name client_region}
  | {region_list}
    | {region_spec}
      | {name containing_region}
      | {int 0}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION private_region;

  {begin_schema_region_stmt}: ok
  | {name private_region}

The statement ending at line XXXX

CREATE TABLE private_region_table(
  id INTEGER PRIMARY KEY
);

  {create_table_stmt}: private_region_table: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name private_region_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION containing_region;

  {begin_schema_region_stmt}: ok
  | {name containing_region}

The statement ending at line XXXX

CREATE TABLE containing_region_table(
  id INTEGER PRIMARY KEY REFERENCES private_region_table (id)
);

  {create_table_stmt}: containing_region_table: { id: integer notnull primary_key foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name containing_region_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name private_region_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION client_region;

  {begin_schema_region_stmt}: ok
  | {name client_region}

The statement ending at line XXXX

CREATE TABLE client_region_table_1(
  id INTEGER PRIMARY KEY REFERENCES private_region_table (id)
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0021: foreign key refers to non-existent table (object is in schema region 'private_region' not accessible from region 'client_region') 'private_region_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name client_region_table_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: err
          | {col_attrs_fk}: err
            | {fk_target_options}
              | {fk_target}
              | | {name private_region_table}
              | | {name_list}
              |   | {name id}
              | {int 0}

The statement ending at line XXXX

CREATE TABLE client_region_table_2(
  id INTEGER PRIMARY KEY REFERENCES containing_region_table (id)
);

  {create_table_stmt}: client_region_table_2: { id: integer notnull primary_key foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name client_region_table_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name containing_region_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

EXPLAIN
SELECT 1;

Error at test/sem_test.sql:XXXX : in explain_stmt : CQL0293: Only [EXPLAIN QUERY PLAN ...] statement is supported

  {explain_stmt}: err
  | {int 1}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
SELECT *
  FROM foo
  INNER JOIN bar
  WHERE foo.id = 1;

  {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
  | {int 2}
  | {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
    |       | {join_clause}: JOIN { foo: foo, bar: bar }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       | | | {name foo}: TABLE { foo: foo }
    |       | | {join_target_list}
    |       |   | {join_target}: JOIN { foo: foo, bar: bar }
    |       |     | {int 1}
    |       |     | {table_join}
    |       |       | {table_or_subquery}: TABLE { bar: bar }
    |       |         | {name bar}: TABLE { bar: bar }
    |       | {select_where}
    |         | {opt_where}: bool notnull
    |         | | {eq}: bool notnull
    |         |   | {dot}: id: integer notnull
    |         |   | | {name foo}
    |         |   | | {name id}
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
UPDATE bar
SET id = 1
  WHERE name = 'Stella';

  {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
  | {int 2}
  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {update_set}
      | {update_list}: ok
      | | {update_entry}: id: integer notnull
      |   | {name id}: id: integer notnull
      |   | {int 1}: integer notnull
      | {update_where}
        | {opt_where}: bool
        | | {eq}: bool
        |   | {name name}: name: text
        |   | {strlit 'Stella'}: text notnull
        | {update_orderby}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
SELECT bogus;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {explain_stmt}: err
  | {int 2}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {name bogus}: err
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC explain_query ()
BEGIN
  EXPLAIN QUERY PLAN
  SELECT 1;
END;

  {create_proc_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } dml_proc
  | {name explain_query}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
        | {int 2}
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 1}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE c CURSOR FOR EXPLAIN QUERY PLAN
SELECT *
  FROM foo
  INNER JOIN bar;

  {declare_cursor}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable
  | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable
  | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
    | {int 2}
    | {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
      |       | {join_clause}: JOIN { foo: foo, bar: bar }
      |       | | {table_or_subquery}: TABLE { foo: foo }
      |       | | | {name foo}: TABLE { foo: foo }
      |       | | {join_target_list}
      |       |   | {join_target}: JOIN { foo: foo, bar: bar }
      |       |     | {int 1}
      |       |     | {table_join}
      |       |       | {table_or_subquery}: TABLE { bar: bar }
      |       |         | {name bar}: TABLE { bar: bar }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC explain_query_with_cursor ()
BEGIN
  DECLARE c CURSOR FOR EXPLAIN QUERY PLAN
  SELECT 1;
  FETCH c;
END;

  {create_proc_stmt}: ok dml_proc
  | {name explain_query_with_cursor}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable
      | | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable auto_cursor
      | | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
      |   | {int 2}
      |   | {select_stmt}: select: { _anon: integer notnull }
      |     | {select_core_list}: select: { _anon: integer notnull }
      |     | | {select_core}: select: { _anon: integer notnull }
      |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     |     | {select_expr_list}: select: { _anon: integer notnull }
      |     |     | | {select_expr}: integer notnull
      |     |     |   | {int 1}: integer notnull
      |     |     | {select_from_etc}: ok
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {fetch_stmt}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable auto_cursor
        | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable auto_cursor

The statement ending at line XXXX

SELECT "x" AS X
UNION ALL
SELECT NULL AS X;

  {select_stmt}: UNION ALL: { X: text }
  | {select_core_list}: UNION ALL: { X: text }
  | | {select_core}: select: { X: text notnull }
  | | | {select_expr_list_con}: select: { X: text notnull }
  | |   | {select_expr_list}: select: { X: text notnull }
  | |   | | {select_expr}: X: text notnull
  | |   |   | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name X}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { X: null }
  |     | {select_core}: select: { X: null }
  |       | {select_expr_list_con}: select: { X: null }
  |         | {select_expr_list}: select: { X: null }
  |         | | {select_expr}: X: null
  |         |   | {null}: null
  |         |   | {opt_as_alias}
  |         |     | {name X}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC mixed_union ()
BEGIN
  SELECT "x" AS X
  UNION ALL
  SELECT NULL AS X;
END;

  {create_proc_stmt}: UNION ALL: { X: text } dml_proc
  | {name mixed_union}: UNION ALL: { X: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: UNION ALL: { X: text }
        | {select_core_list}: UNION ALL: { X: text }
        | | {select_core}: select: { X: text notnull }
        | | | {select_expr_list_con}: select: { X: text notnull }
        | |   | {select_expr_list}: select: { X: text notnull }
        | |   | | {select_expr}: X: text notnull
        | |   |   | {strlit 'x'}: text notnull
        | |   |   | {opt_as_alias}
        | |   |     | {name X}
        | |   | {select_from_etc}: ok
        | |     | {select_where}
        | |       | {select_groupby}
        | |         | {select_having}
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { X: null }
        |     | {select_core}: select: { X: null }
        |       | {select_expr_list_con}: select: { X: null }
        |         | {select_expr_list}: select: { X: null }
        |         | | {select_expr}: X: null
        |         |   | {null}: null
        |         |   | {opt_as_alias}
        |         |     | {name X}
        |         | {select_from_etc}: ok
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC mixed_union_cte ()
BEGIN
  WITH
  core (x) AS (SELECT "x" AS X
  UNION ALL
  SELECT NULL AS X)
  SELECT *
    FROM core;
END;

  {create_proc_stmt}: select: { x: text } dml_proc
  | {name mixed_union_cte}: select: { x: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { x: text }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: core: { x: text }
        |     | {cte_decl}: core: { x: text }
        |     | | {name core}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: UNION ALL: { X: text }
        |       | {select_core_list}: UNION ALL: { X: text }
        |       | | {select_core}: select: { X: text notnull }
        |       | | | {select_expr_list_con}: select: { X: text notnull }
        |       | |   | {select_expr_list}: select: { X: text notnull }
        |       | |   | | {select_expr}: X: text notnull
        |       | |   |   | {strlit 'x'}: text notnull
        |       | |   |   | {opt_as_alias}
        |       | |   |     | {name X}
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { X: null }
        |       |     | {select_core}: select: { X: null }
        |       |       | {select_expr_list_con}: select: { X: null }
        |       |         | {select_expr_list}: select: { X: null }
        |       |         | | {select_expr}: X: null
        |       |         |   | {null}: null
        |       |         |   | {opt_as_alias}
        |       |         |     | {name X}
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { x: text }
          | {select_core_list}: select: { x: text }
          | | {select_core}: select: { x: text }
          |   | {select_expr_list_con}: select: { x: text }
          |     | {select_expr_list}: select: { x: text }
          |     | | {star}: select: { x: text }
          |     | {select_from_etc}: TABLE { core: core }
          |       | {table_or_subquery_list}: TABLE { core: core }
          |       | | {table_or_subquery}: TABLE { core: core }
          |       |   | {name core}: TABLE { core: core }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER () AS row_num
  FROM foo;

  {select_stmt}: select: { id: integer notnull, row_num: integer notnull }
  | {select_core_list}: select: { id: integer notnull, row_num: integer notnull }
  | | {select_core}: select: { id: integer notnull, row_num: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, row_num: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, row_num: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: row_num: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |     | | {call}: integer notnull
  |     |     | | | {name row_number}: integer notnull
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, row_number() AS row_num
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |     | | {name row_number}
  |     |     | | {call_arg_list}
  |     |     |   | {call_filter_clause}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1
  WHERE 
  row_number() OVER ();

Error at test/sem_test.sql:XXXX : in window_func_inv : CQL0294: Window function invocations can only appear in the select list of a select statement

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: integer notnull
  |     |   | {int 1}: integer notnull
  |     | {select_from_etc}: err
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {window_func_inv}: err
  |         |   | {call}
  |         |   | | {name row_number}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   | {window_defn}
  |         |     | {window_defn_orderby}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number(1) OVER () AS row_num
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |     | | {call}: err
  |     |     | | | {name row_number}: err
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {int 1}: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER win1, 
  row_number() OVER win2
  FROM foo
  WINDOW 
    win1 AS (), 
    win2 AS ()
ORDER BY id;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |   | | {window_func_inv}: integer notnull
  |     |   |   | {call}: integer notnull
  |     |   |   | | {name row_number}: integer notnull
  |     |   |   | | {call_arg_list}
  |     |   |   |   | {call_filter_clause}
  |     |   |   | {name win1}: ok
  |     |   | {select_expr_list}
  |     |     | {select_expr}: integer notnull
  |     |       | {window_func_inv}: integer notnull
  |     |         | {call}: integer notnull
  |     |         | | {name row_number}: integer notnull
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {name win2}: ok
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: ok
  |               | {window_clause}: ok
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: ok
  |                   | | {name win1}
  |                   | | {window_defn}: ok
  |                   |   | {window_defn_orderby}
  |                   | {window_name_defn_list}
  |                     | {window_name_defn}: ok
  |                       | {name win2}
  |                       | {window_defn}: ok
  |                         | {window_defn_orderby}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |     | {name id}: id: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER bogus
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0295: Window name is not defined 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {name bogus}: err
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WINDOW 
    win AS ();

Error at test/sem_test.sql:XXXX : in str : CQL0296: Window name definition is not used 'win'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: err
  |               | {window_clause}: err
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: err
  |                     | {name win}: err
  |                     | {window_defn}
  |                       | {window_defn_orderby}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  group_concat(id, '.') FILTER (WHERE id >= 99) OVER () AS row_num
  FROM foo;

  {select_stmt}: select: { id: integer notnull, row_num: text }
  | {select_core_list}: select: { id: integer notnull, row_num: text }
  | | {select_core}: select: { id: integer notnull, row_num: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, row_num: text }
  |     | {select_expr_list}: select: { id: integer notnull, row_num: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: row_num: text
  |     |     | {window_func_inv}: id: text
  |     |     | | {call}: id: text
  |     |     | | | {name group_concat}: id: text
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | | {opt_filter_clause}: bool notnull
  |     |     | |   |   | {opt_where}: bool notnull
  |     |     | |   |     | {ge}: bool notnull
  |     |     | |   |       | {name id}: id: integer notnull
  |     |     | |   |       | {int 99}: integer notnull
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {name id}: id: integer notnull
  |     |     | |     | {arg_list}
  |     |     | |       | {strlit '.'}: text notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS alias, 
  avg(id) FILTER (WHERE alias = 0) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'alias'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: alias: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name alias}
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name avg}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | | {opt_filter_clause}: err
  |     |       |   |   | {opt_where}: err
  |     |       |   |     | {eq}: err
  |     |       |   |       | {name alias}: err
  |     |       |   |       | {int 0}: integer notnull
  |     |       |   | {arg_list}
  |     |       |     | {name id}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1, 
  row_number() FILTER (WHERE 1) OVER ();

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'row_number'
Error at test/sem_test.sql:XXXX : in call : CQL0306: FILTER clause may only be used in function that are aggregated or user defined 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name row_number}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |     | {opt_filter_clause}: integer notnull
  |     |       |       | {opt_where}: integer notnull
  |     |       |         | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (PARTITION BY id)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {opt_partition_by}: ok
  |     |         | | {expr_list}
  |     |         |   | {name id}: id: integer notnull
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ORDER BY id ASC)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_orderby}: ok
  |     |             | {groupby_list}: ok
  |     |               | {groupby_item}
  |     |                 | {name id}: id: integer notnull
  |     |                 | {asc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ORDER BY bogus ASC)
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: err
  |     |         | {window_defn_orderby}
  |     |           | {opt_orderby}: err
  |     |             | {groupby_list}: err
  |     |               | {groupby_item}
  |     |                 | {name bogus}: err
  |     |                 | {asc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  avg(id) FILTER (WHERE id > 0) OVER (GROUPS UNBOUNDED PRECEDING EXCLUDE TIES) AS avg, 
  row_number() OVER (ROWS BETWEEN id = 1 PRECEDING AND id = 45 FOLLOWING EXCLUDE CURRENT ROW)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: avg: real
  |     |   | | {window_func_inv}: id: real
  |     |   | | | {call}: id: real
  |     |   | | | | {name avg}: id: real
  |     |   | | | | {call_arg_list}
  |     |   | | |   | {call_filter_clause}
  |     |   | | |   | | {opt_filter_clause}: bool notnull
  |     |   | | |   |   | {opt_where}: bool notnull
  |     |   | | |   |     | {gt}: bool notnull
  |     |   | | |   |       | {name id}: id: integer notnull
  |     |   | | |   |       | {int 0}: integer notnull
  |     |   | | |   | {arg_list}: ok
  |     |   | | |     | {name id}: id: integer notnull
  |     |   | | | {window_defn}: ok
  |     |   | |   | {window_defn_orderby}
  |     |   | |     | {opt_frame_spec}: ok
  |     |   | |       | {int 131084}
  |     |   | |       | {expr_list}
  |     |   | | {opt_as_alias}
  |     |   |   | {name avg}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: integer notnull
  |     |       | {window_func_inv}: integer notnull
  |     |         | {call}: integer notnull
  |     |         | | {name row_number}: integer notnull
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {window_defn}: ok
  |     |           | {window_defn_orderby}
  |     |             | {opt_frame_spec}: ok
  |     |               | {int 36994}
  |     |               | {expr_list}
  |     |                 | {eq}: bool notnull
  |     |                 | | {name id}: id: integer notnull
  |     |                 | | {int 1}: integer notnull
  |     |                 | {eq}: bool notnull
  |     |                   | {name id}: id: integer notnull
  |     |                   | {int 45}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING EXCLUDE GROUP)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: ok
  |     |             | {int 73986}
  |     |             | {expr_list}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS id > 0 PRECEDING EXCLUDE TIES)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: ok
  |     |             | {int 131090}
  |     |             | {expr_list}
  |     |               | {gt}: bool notnull
  |     |                 | {name id}: id: integer notnull
  |     |                 | {int 0}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS bogus = NULL PRECEDING EXCLUDE TIES)
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: err
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: err
  |     |             | {int 131090}
  |     |             | {expr_list}
  |     |               | {eq}: err
  |     |                 | {name bogus}: err
  |     |                 | {null}: null
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  dense_rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name dense_rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  percent_rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: real notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: real notnull }
  | | {select_core}: select: { id: integer notnull, _anon: real notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: real notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: real notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: real notnull
  |     |     | {window_func_inv}: real notnull
  |     |       | {call}: real notnull
  |     |       | | {name percent_rank}: real notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  cume_dist() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: real notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: real notnull }
  | | {select_core}: select: { id: integer notnull, _anon: real notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: real notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: real notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: real notnull
  |     |     | {window_func_inv}: real notnull
  |     |       | {call}: real notnull
  |     |       | | {name cume_dist}: real notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(7) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {int 7}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(9898989889989L) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0300: Argument must be an integer (between 1 and max integer) in function 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {longint 9898989889989}: longint notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(0) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0300: Argument must be an integer (between 1 and max integer) in function 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(1, 2) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {int 1}: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 2}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE ntile(7);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name ntile}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 1, 0) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name lag}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 1) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer }
  | {select_core_list}: select: { id: integer notnull, id: integer }
  | | {select_core}: select: { id: integer notnull, id: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer
  |     |     | {window_func_inv}: id: integer
  |     |       | {call}: id: integer
  |     |       | | {name lag}: id: integer
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(info, 1) OVER ()
  FROM with_sensitive;

  {select_stmt}: select: { id: integer, info: integer sensitive }
  | {select_core_list}: select: { id: integer, info: integer sensitive }
  | | {select_core}: select: { id: integer, info: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer, info: integer sensitive }
  |     | {select_expr_list}: select: { id: integer, info: integer sensitive }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: info: integer sensitive
  |     |     | {window_func_inv}: info: integer sensitive
  |     |       | {call}: info: integer sensitive
  |     |       | | {name lag}: info: integer sensitive
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name info}: info: integer sensitive
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id * 3, 1, info) OVER ()
  FROM with_sensitive;

  {select_stmt}: select: { id: integer, _anon: integer sensitive }
  | {select_core_list}: select: { id: integer, _anon: integer sensitive }
  | | {select_core}: select: { id: integer, _anon: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer, _anon: integer sensitive }
  |     | {select_expr_list}: select: { id: integer, _anon: integer sensitive }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer sensitive
  |     |     | {window_func_inv}: integer sensitive
  |     |       | {call}: integer sensitive
  |     |       | | {name lag}: integer sensitive
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {mul}: integer
  |     |       |     | | {name id}: id: integer
  |     |       |     | | {int 3}: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {name info}: info: integer sensitive
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, -1) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0301: The second argument must be an integer (between 0 and max integer) in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {uminus}: integer notnull
  |     |       |         | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id | " ") OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0008: right operand cannot be a string in '|'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {bin_or}: err
  |     |       |       | {name id}: id: integer notnull
  |     |       |       | {strlit ' '}: text notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 0, 0.7) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0302: The first and third arguments must be of the same type in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 0}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {dbl 0.7}: real notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag() OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lead(id, 1, id * 3) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name lead}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {mul}: integer notnull
  |     |       |           | {name id}: id: integer notnull
  |     |       |           | {int 3}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  first_value(id) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name first_value}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE first_value(7);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'first_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name first_value}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  last_value(id) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name last_value}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id, 1) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer }
  | {select_core_list}: select: { id: integer notnull, id: integer }
  | | {select_core}: select: { id: integer notnull, id: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer
  |     |     | {window_func_inv}: id: integer
  |     |       | {call}: id: integer
  |     |       | | {name nth_value}: id: integer
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE nth_value(7, 1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name nth_value}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         |       | {arg_list}
  |         |         | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name nth_value}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id, 0) OVER ()
  FROM foo;

Error at test/sem_test.sql:XXXX : in call : CQL0303: The second argument must be an integer between 1 and max integer in function 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name nth_value}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(info)
  FROM with_sensitive;

  {select_stmt}: select: { info: real notnull sensitive }
  | {select_core_list}: select: { info: real notnull sensitive }
  | | {select_core}: select: { info: real notnull sensitive }
  |   | {select_expr_list_con}: select: { info: real notnull sensitive }
  |     | {select_expr_list}: select: { info: real notnull sensitive }
  |     | | {select_expr}: info: real notnull sensitive
  |     |   | {call}: info: real notnull sensitive
  |     |     | {name total}: info: real notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name info}: info: integer sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC insert_using_args_with_dummy (x INTEGER NOT NULL, y REAL NOT NULL)
BEGIN
  INSERT INTO referenceable(a, b, c, d, e) VALUES(x, y, printf('c_%d', _seed_), printf('d_%d', _seed_), _seed_) @DUMMY_SEED(1) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_using_args_with_dummy}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: real notnull variable in
    |     | {param_detail}: y: real notnull variable in
    |       | {name y}: y: real notnull variable in
    |       | {notnull}: real notnull
    |         | {type_real}: real
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | | {insert_dummy_spec}: integer notnull
        |   | {int 1}: integer notnull
        |   | {int 2}
        | {name_columns_values}
          | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real
            |     | {name_list}
            |       | {name c}: c: text
            |       | {name_list}
            |         | {name d}: d: text
            |         | {name_list}
            |           | {name e}: e: longint
            | {insert_list}
              | {name x}: x: integer notnull variable in
              | {insert_list}
                | {name y}: y: real notnull variable in
                | {insert_list}
                  | {call}: text notnull
                  | | {name printf}: text notnull
                  | | {call_arg_list}
                  |   | {call_filter_clause}
                  |   | {arg_list}: ok
                  |     | {strlit 'c_%d'}: text notnull
                  |     | {arg_list}
                  |       | {name _seed_}: _seed_: integer notnull variable
                  | {insert_list}
                    | {call}: text notnull
                    | | {name printf}: text notnull
                    | | {call_arg_list}
                    |   | {call_filter_clause}
                    |   | {arg_list}: ok
                    |     | {strlit 'd_%d'}: text notnull
                    |     | {arg_list}
                    |       | {name _seed_}: _seed_: integer notnull variable
                    | {insert_list}
                      | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_using_args_with_dummy (x INTEGER NOT NULL, y REAL NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE referenceable;
  FETCH C(a, b, c, d, e) FROM VALUES(x, y, printf('c_%d', _seed_), printf('d_%d', _seed_), _seed_) @DUMMY_SEED(1) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok
  | {name fetch_using_args_with_dummy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: real notnull variable in
    |     | {param_detail}: y: real notnull variable in
    |       | {name y}: y: real notnull variable in
    |       | {notnull}: real notnull
    |         | {type_real}: real
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
      | | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
      | | {like}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      |   | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 1}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real
            |     | {name_list}
            |       | {name c}: c: text
            |       | {name_list}
            |         | {name d}: d: text
            |         | {name_list}
            |           | {name e}: e: longint
            | {insert_list}
              | {name x}: x: integer notnull variable in
              | {insert_list}
                | {name y}: y: real notnull variable in
                | {insert_list}
                  | {call}: text notnull
                  | | {name printf}: text notnull
                  | | {call_arg_list}
                  |   | {call_filter_clause}
                  |   | {arg_list}: ok
                  |     | {strlit 'c_%d'}: text notnull
                  |     | {arg_list}
                  |       | {name _seed_}: _seed_: integer notnull variable
                  | {insert_list}
                    | {call}: text notnull
                    | | {name printf}: text notnull
                    | | {call_arg_list}
                    |   | {call_filter_clause}
                    |   | {arg_list}: ok
                    |     | {strlit 'd_%d'}: text notnull
                    |     | {arg_list}
                    |       | {name _seed_}: _seed_: integer notnull variable
                    | {insert_list}
                      | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_from_empty_col_list ()
BEGIN
  DECLARE C CURSOR LIKE referenceable;
  FETCH C(a, b, c, d, e) FROM VALUES(1, 2, 'x', 'y', 5);
  OUT C;
END;

  {create_proc_stmt}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor uses_out value_cursor
  | {name fetch_from_empty_col_list}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
      | | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
      | | {like}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      |   | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name a}: a: integer notnull
      |     |   | {name_list}
      |     |     | {name b}: b: real
      |     |     | {name_list}
      |     |       | {name c}: c: text
      |     |       | {name_list}
      |     |         | {name d}: d: text
      |     |         | {name_list}
      |     |           | {name e}: e: longint
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      |         | {insert_list}
      |           | {strlit 'x'}: text notnull
      |           | {insert_list}
      |             | {strlit 'y'}: text notnull
      |             | {insert_list}
      |               | {int 5}: integer notnull
      | {out_stmt}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
        | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor

The statement ending at line XXXX

DECLARE c_bar CURSOR LIKE referenceable;

  {declare_cursor_like_name}: c_bar: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
  | {name c_bar}: c_bar: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable auto_cursor value_cursor
  | {like}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) VALUES(c_bar.a, c_bar.b, c_bar.c, c_bar.d, c_bar.e);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name a}: a: integer notnull
      |   | {name_list}
      |     | {name b}: b: real
      |     | {name_list}
      |       | {name c}: c: text
      |       | {name_list}
      |         | {name d}: d: text
      |         | {name_list}
      |           | {name e}: e: longint
      | {insert_list}
        | {dot}: c_bar_.a: integer notnull variable primary_key
        | | {name c_bar}
        | | {name a}
        | {insert_list}
          | {dot}: c_bar_.b: real variable unique_key
          | | {name c_bar}
          | | {name b}
          | {insert_list}
            | {dot}: c_bar_.c: text variable
            | | {name c_bar}
            | | {name c}
            | {insert_list}
              | {dot}: c_bar_.d: text variable
              | | {name c_bar}
              | | {name d}
              | {insert_list}
                | {dot}: c_bar_.e: longint variable
                  | {name c_bar}
                  | {name e}

The statement ending at line XXXX

INSERT INTO referenceable() FROM CURSOR c_bar;

Error at test/sem_test.sql:XXXX : in from_cursor : CQL0297: FROM CURSOR is redundant if column list is empty

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | {from_cursor}
        | {name c_bar}

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM CURSOR fetch_cursor(_anon, _anon, _anon);

Error at test/sem_test.sql:XXXX : in str : CQL0298: cannot insert from a cursor without fields 'fetch_cursor'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_cursor}: ok
        | {column_spec}
        | | {name_list}
        |   | {name _anon}
        |   | {name_list}
        |     | {name _anon}
        |     | {name_list}
        |       | {name _anon}
        | {name fetch_cursor}: err

The statement ending at line XXXX

DECLARE small_cursor CURSOR LIKE SELECT 1 AS x;

  {declare_cursor_like_select}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {select_stmt}: select: { x: integer notnull }
    | {select_core_list}: select: { x: integer notnull }
    | | {select_core}: select: { x: integer notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull }
    |     | {select_expr_list}: select: { x: integer notnull }
    |     | | {select_expr}: x: integer notnull
    |     |   | {int 1}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name x}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM CURSOR small_cursor(x);

Error at test/sem_test.sql:XXXX : in columns_values : CQL0299: cursor has too few fields for this insert 'small_cursor'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_cursor}: ok
        | {column_spec}
        | | {name_list}
        |   | {name x}
        | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM CURSOR X;

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'X'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_cursor}
        | {name X}: err

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES(2);

  {update_cursor_stmt}: ok
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}
      | {int 2}: integer notnull

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES('x');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'x'

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}
      | {strlit 'x'}: err

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES(1, 2);

Error at test/sem_test.sql:XXXX : in update_cursor_stmt : CQL0157: count of columns differs from count of values

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}
      | {int 1}
      | {insert_list}
        | {int 2}

The statement ending at line XXXX

UPDATE CURSOR small_cursor(w) FROM VALUES(1);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'w'

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}: err
    |   | {name w}: err
    | {insert_list}
      | {int 1}

The statement ending at line XXXX

UPDATE CURSOR my_cursor(one) FROM VALUES(2);

Error at test/sem_test.sql:XXXX : in str : CQL0067: cursor was not used with 'fetch [cursor]' 'my_cursor'

  {update_cursor_stmt}: err
  | {name my_cursor}: err
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name one}
    | {insert_list}
      | {int 2}

The statement ending at line XXXX

UPDATE CURSOR my_cursor(LIKE not_a_symbol) FROM VALUES(1);

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {update_cursor_stmt}: err
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable
  | {columns_values}: err
    | {column_spec}
    | | {like}: err
    |   | {name not_a_symbol}: err
    | {insert_list}
      | {int 1}

The statement ending at line XXXX

UPDATE CURSOR X(one) FROM VALUES(2);

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'X'

  {update_cursor_stmt}: err
  | {name X}: err
  | {columns_values}
    | {column_spec}
    | | {name_list}
    |   | {name one}
    | {insert_list}
      | {int 2}

The statement ending at line XXXX

WITH
foo (a, b, c) AS (SELECT 1 AS a, 'b' AS b, 3.0 AS c)
SELECT *
  FROM foo;

  {with_select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: foo: { a: integer notnull, b: text notnull, c: real notnull }
  |     | {cte_decl}: foo: { a: integer notnull, b: text notnull, c: real notnull }
  |     | | {name foo}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     |     | {name_list}
  |     |       | {name c}
  |     | {select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       | {select_core_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       | | {select_core}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |   | {select_expr_list_con}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |     | {select_expr_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |     | | {select_expr}: a: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | | {opt_as_alias}
  |       |     | |   | {name a}
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: b: text notnull
  |       |     |   | | {strlit 'b'}: text notnull
  |       |     |   | | {opt_as_alias}
  |       |     |   |   | {name b}
  |       |     |   | {select_expr_list}
  |       |     |     | {select_expr}: c: real notnull
  |       |     |       | {dbl 3.0}: real notnull
  |       |     |       | {opt_as_alias}
  |       |     |         | {name c}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
    | {select_core_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
    | | {select_core}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | | {star}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (*) AS (SELECT 1)
SELECT *
  FROM foo;

Error at test/sem_test.sql:XXXX : in select_core : CQL0055: all columns in the select must have a name

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name foo}
  |     | | {star}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE TEMP TABLE foo_data(
  c1 TEXT NOT NULL,
  c2 INTEGER,
  c3 REAL,
  c4 REAL,
  c5 REAL,
  c6 REAL,
  c7 REAL,
  c8 REAL,
  c9 REAL,
  c10 REAL
);

  {create_table_stmt}: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name foo_data}
  | {col_key_list}
    | {col_def}: c1: text notnull
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name c1}
    |   | | {type_text}: text
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: c2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name c2}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: c3: real
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name c3}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: c4: real
          | | {col_def_type_attrs}
          |   | {col_def_name_type}
          |     | {name c4}
          |     | {type_real}: real
          | {col_key_list}
            | {col_def}: c5: real
            | | {col_def_type_attrs}
            |   | {col_def_name_type}
            |     | {name c5}
            |     | {type_real}: real
            | {col_key_list}
              | {col_def}: c6: real
              | | {col_def_type_attrs}
              |   | {col_def_name_type}
              |     | {name c6}
              |     | {type_real}: real
              | {col_key_list}
                | {col_def}: c7: real
                | | {col_def_type_attrs}
                |   | {col_def_name_type}
                |     | {name c7}
                |     | {type_real}: real
                | {col_key_list}
                  | {col_def}: c8: real
                  | | {col_def_type_attrs}
                  |   | {col_def_name_type}
                  |     | {name c8}
                  |     | {type_real}: real
                  | {col_key_list}
                    | {col_def}: c9: real
                    | | {col_def_type_attrs}
                    |   | {col_def_name_type}
                    |     | {name c9}
                    |     | {type_real}: real
                    | {col_key_list}
                      | {col_def}: c10: real
                        | {col_def_type_attrs}
                          | {col_def_name_type}
                            | {name c10}
                            | {type_real}: real

The statement ending at line XXXX

DECLARE nully_cursor CURSOR LIKE foo_data;

  {declare_cursor_like_name}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
  | {like}: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real }
    | {name foo_data}: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real }

The statement ending at line XXXX

FETCH nully_cursor(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) FROM VALUES('x', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c2}: c2: integer
      |     | {name_list}
      |       | {name c3}: c3: real
      |       | {name_list}
      |         | {name c4}: c4: real
      |         | {name_list}
      |           | {name c5}: c5: real
      |           | {name_list}
      |             | {name c6}: c6: real
      |             | {name_list}
      |               | {name c7}: c7: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}
        | {strlit 'x'}: text notnull
        | {insert_list}
          | {null}: null
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c2) FROM VALUES('x');

Error at test/sem_test.sql:XXXX : in fetch_values_stmt : CQL0167: required column missing in FETCH statement 'c1'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c2}: c2: integer
      | {insert_list}
        | {strlit 'x'}

The statement ending at line XXXX

DECLARE c1c7 CURSOR LIKE SELECT 'x' AS c1, nullable(3.2) AS c7;

  {declare_cursor_like_select}: c1c7: select: { c1: text notnull, c7: real } variable auto_cursor value_cursor
  | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable auto_cursor value_cursor
  | {select_stmt}: select: { c1: text notnull, c7: real }
    | {select_core_list}: select: { c1: text notnull, c7: real }
    | | {select_core}: select: { c1: text notnull, c7: real }
    |   | {select_expr_list_con}: select: { c1: text notnull, c7: real }
    |     | {select_expr_list}: select: { c1: text notnull, c7: real }
    |     | | {select_expr}: c1: text notnull
    |     | | | {strlit 'x'}: text notnull
    |     | | | {opt_as_alias}
    |     | |   | {name c1}
    |     | | {select_expr_list}
    |     |   | {select_expr}: c7: real
    |     |     | {call}: real
    |     |     | | {name nullable}: real
    |     |     | | {call_arg_list}
    |     |     |   | {call_filter_clause}
    |     |     |   | {arg_list}: ok
    |     |     |     | {dbl 3.2}: real notnull
    |     |     | {opt_as_alias}
    |     |       | {name c7}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM VALUES('x', 3.2);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      | {insert_list}
        | {strlit 'x'}: text notnull
        | {insert_list}
          | {dbl 3.2}: real notnull

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM VALUES(c1c7.c1, c1c7.c7);

  {update_cursor_stmt}: ok
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}: c1: text notnull
    |   | {name_list}
    |     | {name c7}: c7: real
    | {insert_list}
      | {dot}: c1c7_.c1: text notnull variable
      | | {name c1c7}
      | | {name c1}
      | {insert_list}
        | {dot}: c1c7_.c7: real variable
          | {name c1c7}
          | {name c7}

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM VALUES(c1c7.c1, c1c7.c7);

  {update_cursor_stmt}: ok
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}: c1: text notnull
    |   | {name_list}
    |     | {name c7}: c7: real
    | {insert_list}
      | {dot}: c1c7_.c1: text notnull variable
      | | {name c1c7}
      | | {name c1}
      | {insert_list}
        | {dot}: c1c7_.c7: real variable
          | {name c1c7}
          | {name c7}

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM CURSOR not_a_symbol;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_symbol'

  {update_cursor_stmt}: err
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}
    |   | {name_list}
    |     | {name c7}
    | {from_cursor}
      | {name not_a_symbol}: err

The statement ending at line XXXX

FETCH nully_cursor(c1, c7, c2, c3, c4, c5, c6, c8, c9, c10) FROM VALUES(c1c7.c1, c1c7.c7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      |     | {name_list}
      |       | {name c2}: c2: integer
      |       | {name_list}
      |         | {name c3}: c3: real
      |         | {name_list}
      |           | {name c4}: c4: real
      |           | {name_list}
      |             | {name c5}: c5: real
      |             | {name_list}
      |               | {name c6}: c6: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}
        | {dot}: c1c7_.c1: text notnull variable
        | | {name c1c7}
        | | {name c1}
        | {insert_list}
          | {dot}: c1c7_.c7: real variable
          | | {name c1c7}
          | | {name c7}
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c1, c7, c2, c3, c4, c5, c6, c8, c9, c10) FROM VALUES(c1c7.c1, c1c7.c7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      |     | {name_list}
      |       | {name c2}: c2: integer
      |       | {name_list}
      |         | {name c3}: c3: real
      |         | {name_list}
      |           | {name c4}: c4: real
      |           | {name_list}
      |             | {name c5}: c5: real
      |             | {name_list}
      |               | {name c6}: c6: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}
        | {dot}: c1c7_.c1: text notnull variable
        | | {name c1c7}
        | | {name c1}
        | {insert_list}
          | {dot}: c1c7_.c7: real variable
          | | {name c1c7}
          | | {name c7}
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c1, c7) FROM CURSOR not_a_symbol;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}
      |   | {name_list}
      |     | {name c7}
      | {from_cursor}
        | {name not_a_symbol}: err

The statement ending at line XXXX

FETCH nully_cursor(LIKE not_a_symbol) FROM VALUES(1, 2);

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor
    | {columns_values}: err
      | {column_spec}
      | | {like}: err
      |   | {name not_a_symbol}: err
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}

The statement ending at line XXXX

DECLARE id_name_cursor CURSOR LIKE SELECT 1 AS id, 'x' AS name;

  {declare_cursor_like_select}: id_name_cursor: select: { id: integer notnull, name: text notnull } variable auto_cursor value_cursor
  | {name id_name_cursor}: id_name_cursor: select: { id: integer notnull, name: text notnull } variable auto_cursor value_cursor
  | {select_stmt}: select: { id: integer notnull, name: text notnull }
    | {select_core_list}: select: { id: integer notnull, name: text notnull }
    | | {select_core}: select: { id: integer notnull, name: text notnull }
    |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
    |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
    |     | | {select_expr}: id: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name id}
    |     | | {select_expr_list}
    |     |   | {select_expr}: name: text notnull
    |     |     | {strlit 'x'}: text notnull
    |     |     | {opt_as_alias}
    |     |       | {name name}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name) VALUES(1, 'x');

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull }
        |     | {insert_list}
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(LIKE not_a_symbol) VALUES(1, 'x');

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {like}: err
      |   | {name not_a_symbol}: err
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        |       | {insert_list}
        |         | {strlit 'x'}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM VALUES(nully_cursor.c1, nully_cursor.c7);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      | {insert_list}
        | {dot}: nully_cursor_.c1: text notnull variable
        | | {name nully_cursor}
        | | {name c1}
        | {insert_list}
          | {dot}: nully_cursor_.c7: real variable
            | {name nully_cursor}
            | {name c7}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM CURSOR nully_cursor(LIKE not_a_symbol);

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable auto_cursor value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}
      |   | {name_list}
      |     | {name c7}
      | {from_cursor}: err
        | {column_spec}
        | | {like}: err
        |   | {name not_a_symbol}: err
        | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable auto_cursor value_cursor

The statement ending at line XXXX

DECLARE PROC out_union_user (x INTEGER) OUT UNION (id INTEGER, x TEXT);

  {declare_proc_stmt}: select: { id: integer, x: text } uses_out_union
  | {proc_name_type}
  | | {name out_union_user}: select: { id: integer, x: text } uses_out_union
  | | {int 9}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {typed_names}: select: { id: integer, x: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: x: text
          | {name x}
          | {type_text}: x: text

The statement ending at line XXXX

DECLARE out_union_cursor CURSOR FOR CALL out_union_user(2);

  {declare_cursor}: out_union_cursor: select: { id: integer, x: text } variable uses_out_union
  | {name out_union_cursor}: out_union_cursor: select: { id: integer, x: text } variable uses_out_union
  | {call_stmt}: select: { id: integer, x: text } uses_out_union
    | {name out_union_user}: select: { id: integer, x: text } uses_out_union
    | {expr_list}: ok
      | {int 2}: integer notnull

The statement ending at line XXXX

CREATE TABLE sens_table(
  t TEXT @SENSITIVE
);

  {create_table_stmt}: sens_table: { t: text sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name sens_table}
  | {col_key_list}
    | {col_def}: t: text sensitive
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name t}
        | | {type_text}: text
        | {sensitive_attr}: ok

The statement ending at line XXXX

DECLARE PROC sens_result_proc () (t TEXT @SENSITIVE);

  {declare_proc_stmt}: select: { t: text sensitive } dml_proc
  | {proc_name_type}
  | | {name sens_result_proc}: select: { t: text sensitive } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { t: text sensitive }
      | {typed_name}: t: text sensitive
        | {name t}
        | {sensitive_attr}: t: text sensitive
          | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test))
CREATE PROC sens_result_proc ()
BEGIN
  SELECT *
    FROM sens_table;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_test}: ok
  | {create_proc_stmt}: select: { t: text sensitive } dml_proc
    | {name sens_result_proc}: select: { t: text sensitive } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { t: text sensitive }
          | {select_core_list}: select: { t: text sensitive }
          | | {select_core}: select: { t: text sensitive }
          |   | {select_expr_list_con}: select: { t: text sensitive }
          |     | {select_expr_list}: select: { t: text sensitive }
          |     | | {star}: select: { t: text sensitive }
          |     | {select_from_etc}: TABLE { sens_table: sens_table }
          |       | {table_or_subquery_list}: TABLE { sens_table: sens_table }
          |       | | {table_or_subquery}: TABLE { sens_table: sens_table }
          |       |   | {name sens_table}: TABLE { sens_table: sens_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE PROC incompatible_result_proc () (t TEXT);

  {declare_proc_stmt}: select: { t: text } dml_proc
  | {proc_name_type}
  | | {name incompatible_result_proc}: select: { t: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { t: text }
      | {typed_name}: t: text
        | {name t}
        | {type_text}: t: text

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test))
CREATE PROC incompatible_result_proc ()
BEGIN
  SELECT 1 AS t;
END;

Incompatible declarations found
Error at test/sem_test.sql:XXXX : in declare_proc_stmt : DECLARE PROC incompatible_result_proc () (t TEXT)
Error at test/sem_test.sql:XXXX : in create_proc_stmt : DECLARE PROC incompatible_result_proc () (t INTEGER NOT NULL)
The above must be identical.
Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0189: procedure declarations/definitions do not match 'incompatible_result_proc'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {name dummy_test}
  | {create_proc_stmt}: err
    | {name incompatible_result_proc}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { t: integer notnull }
          | {select_core_list}: select: { t: integer notnull }
          | | {select_core}: select: { t: integer notnull }
          |   | {select_expr_list_con}: select: { t: integer notnull }
          |     | {select_expr_list}: select: { t: integer notnull }
          |     | | {select_expr}: t: integer notnull
          |     |   | {int 1}: integer notnull
          |     |   | {opt_as_alias}
          |     |     | {name t}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM bar
ORDER BY name COLLATE nocase;

  {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {groupby_list}: ok
    |   | {groupby_item}
    |     | {collate}: name: text
    |       | {name name}: name: text
    |       | {name nocase}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := 'x' COLLATE nocase;

Error at test/sem_test.sql:XXXX : in collate : CQL0241: COLLATE may only appear in the context of a SQL statement

  {assign}: err
  | {name a_string}: a_string: text variable
  | {collate}: err
    | {strlit 'x'}: text notnull
    | {name nocase}

The statement ending at line XXXX

SELECT (NOT 'x') COLLATE nocase;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {collate}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {name nocase}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE IF NOT EXISTS foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 2}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE VIEW IF NOT EXISTS MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 2}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER IF NOT EXISTS trigger2
  AFTER INSERT ON bar
BEGIN
  DELETE FROM bar WHERE rate > new.id;
END;

  {create_trigger_stmt}: ok
  | {int 2}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name new}
                          | {name id}

The statement ending at line XXXX

CREATE INDEX IF NOT EXISTS index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 2}
    | {index_names_and_attrs}
      | {indexed_columns}
        | {indexed_column}
          | {name id}: id: integer notnull

The statement ending at line XXXX

SELECT x'FAB1';

  {select_stmt}: select: { _anon: blob notnull }
  | {select_core_list}: select: { _anon: blob notnull }
  | | {select_core}: select: { _anon: blob notnull }
  |   | {select_expr_list_con}: select: { _anon: blob notnull }
  |     | {select_expr_list}: select: { _anon: blob notnull }
  |     | | {select_expr}: blob notnull
  |     |   | {blob x'FAB1'}: blob notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=blob_stuff)
CREATE PROC blob_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT id_ AS id, x'123456' AS bl)
  SELECT *
    FROM blob_stuff;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name blob_stuff}
  | {create_proc_stmt}: select: { id: integer notnull, bl: blob notnull } dml_proc
    | {name blob_base_fragment}: select: { id: integer notnull, bl: blob notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |     | {cte_decl}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |     | | {name blob_stuff}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name bl}
          |     | {select_stmt}: select: { id: integer notnull variable in, bl: blob notnull }
          |       | {select_core_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |       | | {select_core}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |     | | {select_expr}: id: integer notnull variable in
          |       |     | | | {name id_}: id_: integer notnull variable in
          |       |     | | | {opt_as_alias}
          |       |     | |   | {name id}
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: bl: blob notnull
          |       |     |     | {blob x'123456'}: blob notnull
          |       |     |     | {opt_as_alias}
          |       |     |       | {name bl}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull }
            |     | {select_from_etc}: TABLE { blob_stuff: blob_stuff }
            |       | {table_or_subquery_list}: TABLE { blob_stuff: blob_stuff }
            |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
            |       |   | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=blob_stuff)
CREATE PROC blob_ext_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT 1 AS id, x'123456' AS bl),
  blob_ext (id, bl, bl2) AS (SELECT blob_stuff.*, T2.*
    FROM blob_stuff
    LEFT OUTER JOIN (SELECT x'abcd' AS bl2) AS T2)
  SELECT *
    FROM blob_ext;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name blob_stuff}
  | {create_proc_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {name blob_ext_fragment}: select: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull, bl: blob notnull }
          |   | | {cte_decl}: blob_stuff: { id: integer notnull, bl: blob notnull }
          |   | | | {name blob_stuff}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | |   | {name_list}
          |   | |     | {name bl}
          |   | | {select_stmt}: select: { id: integer notnull, bl: blob notnull }
          |   |   | {select_core_list}: select: { id: integer notnull, bl: blob notnull }
          |   |   | | {select_core}: select: { id: integer notnull, bl: blob notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | | {opt_as_alias}
          |   |   |     | |   | {name id}
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: bl: blob notnull
          |   |   |     |     | {blob x'123456'}: blob notnull
          |   |   |     |     | {opt_as_alias}
          |   |   |     |       | {name bl}
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | {cte_decl}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | | {name blob_ext}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name bl}
          |       |     | {name_list}
          |       |       | {name bl2}
          |       | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | | {table_star}: blob_stuff: blob_stuff: { id: integer notnull, bl: blob notnull }
          |         |     | | | {name blob_stuff}
          |         |     | | {select_expr_list}
          |         |     |   | {table_star}: T2: select: { bl2: blob }
          |         |     |     | {name T2}
          |         |     | {select_from_etc}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | {join_clause}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
          |         |       | | | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { T2: select }
          |         |       |         | {select_stmt}: select: { bl2: blob notnull }
          |         |       |         | | {select_core_list}: select: { bl2: blob notnull }
          |         |       |         | | | {select_core}: select: { bl2: blob notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { bl2: blob notnull }
          |         |       |         | |     | {select_expr_list}: select: { bl2: blob notnull }
          |         |       |         | |     | | {select_expr}: bl2: blob notnull
          |         |       |         | |     |   | {blob x'abcd'}: blob notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name bl2}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name T2}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_from_etc}: TABLE { blob_ext: blob_ext }
            |       | {table_or_subquery_list}: TABLE { blob_ext: blob_ext }
            |       | | {table_or_subquery}: TABLE { blob_ext: blob_ext }
            |       |   | {name blob_ext}: TABLE { blob_ext: blob_ext }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=blob_stuff)
CREATE PROC blob_stuff (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT id_ AS id, x'123456' AS bl),
  blob_ext (id, bl, bl2) AS (SELECT blob_stuff.*, T2.*
    FROM blob_stuff
    LEFT OUTER JOIN (SELECT x'abcd' AS bl2) AS T2)
  SELECT *
    FROM blob_ext;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name blob_stuff}
  | {create_proc_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {name blob_stuff}: select: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |   | | {cte_decl}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |   | | | {name blob_stuff}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | |   | {name_list}
          |   | |     | {name bl}
          |   | | {select_stmt}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   | {select_core_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   | | {select_core}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |     | | {select_expr}: id: integer notnull variable in
          |   |   |     | | | {name id_}: id_: integer notnull variable in
          |   |   |     | | | {opt_as_alias}
          |   |   |     | |   | {name id}
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: bl: blob notnull
          |   |   |     |     | {blob x'123456'}: blob notnull
          |   |   |     |     | {opt_as_alias}
          |   |   |     |       | {name bl}
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | {cte_decl}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | | {name blob_ext}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name bl}
          |       |     | {name_list}
          |       |       | {name bl2}
          |       | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | | {table_star}: blob_stuff: blob_stuff: { id: integer notnull, bl: blob notnull }
          |         |     | | | {name blob_stuff}
          |         |     | | {select_expr_list}
          |         |     |   | {table_star}: T2: select: { bl2: blob }
          |         |     |     | {name T2}
          |         |     | {select_from_etc}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | {join_clause}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
          |         |       | | | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       |     | {int 3}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { T2: select }
          |         |       |         | {select_stmt}: select: { bl2: blob notnull }
          |         |       |         | | {select_core_list}: select: { bl2: blob notnull }
          |         |       |         | | | {select_core}: select: { bl2: blob notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { bl2: blob notnull }
          |         |       |         | |     | {select_expr_list}: select: { bl2: blob notnull }
          |         |       |         | |     | | {select_expr}: bl2: blob notnull
          |         |       |         | |     |   | {blob x'abcd'}: blob notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name bl2}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name T2}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_from_etc}: TABLE { blob_ext: blob_ext }
            |       | {table_or_subquery_list}: TABLE { blob_ext: blob_ext }
            |       | | {table_or_subquery}: TABLE { blob_ext: blob_ext }
            |       |   | {name blob_ext}: TABLE { blob_ext: blob_ext }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_literal_out (OUT b BLOB)
BEGIN
  SET b := x'12abcdef';
END;

Error at test/sem_test.sql:XXXX : in blb : CQL0313: blob literals may only appear in the context of a SQL statement

  {create_proc_stmt}: err
  | {name blob_literal_out}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: b: blob variable out
    |   | {out}
    |   | {param_detail}: b: blob variable out
    |     | {name b}: b: blob variable out
    |     | {type_blob}: blob
    | {stmt_list}: err
      | {assign}: err
        | {name b}: b: blob variable out
        | {blob x'12abcdef'}: err

The statement ending at line XXXX

SELECT nullif(id)
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'nullif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name nullif}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullif(id, 1)
  FROM bar;

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {call}: id: integer
  |     |     | {name nullif}: id: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     |         | {arg_list}
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, nullif(name, 1)
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0009: incompatible types in expression 'NULLIF'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {call}
  |     |       | {name nullif}
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: err
  |     |           | {arg_list}
  |     |             | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := nullif('x', 1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'nullif'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name nullif}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

SELECT nullif(name, 'a')
  FROM with_sensitive;

  {select_stmt}: select: { name: text sensitive }
  | {select_core_list}: select: { name: text sensitive }
  | | {select_core}: select: { name: text sensitive }
  |   | {select_expr_list_con}: select: { name: text sensitive }
  |     | {select_expr_list}: select: { name: text sensitive }
  |     | | {select_expr}: name: text sensitive
  |     |   | {call}: name: text sensitive
  |     |     | {name nullif}: name: text sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text sensitive
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC nullif (value INTEGER, defaultValue INTEGER NOT NULL) INTEGER;

Error at test/sem_test.sql:XXXX : in str : CQL0314: select function does not require a declaration, it is a CQL built-in 'nullif'

  {declare_select_func_stmt}: err
  | {name nullif}: integer
  | {func_params_return}
    | {params}: ok
    | | {param}: value: integer variable in
    | | | {param_detail}: value: integer variable in
    | |   | {name value}: value: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: defaultValue: integer notnull variable in
    |     | {param_detail}: defaultValue: integer notnull variable in
    |       | {name defaultValue}: defaultValue: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {type_int}: integer

The statement ending at line XXXX

SELECT upper(name)
  FROM with_sensitive;

  {select_stmt}: select: { name: text sensitive }
  | {select_core_list}: select: { name: text sensitive }
  | | {select_core}: select: { name: text sensitive }
  |   | {select_expr_list_con}: select: { name: text sensitive }
  |     | {select_expr_list}: select: { name: text sensitive }
  |     | | {select_expr}: name: text sensitive
  |     |   | {call}: name: text sensitive
  |     |     | {name upper}: name: text sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT upper(id)
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0086: first argument must be a string in function 'upper'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name upper}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT upper(name, 1)
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'upper'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name upper}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text
  |     |         | {arg_list}
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := upper('x');

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'upper'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name upper}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

SELECT char(id, info)
  FROM with_sensitive;

  {select_stmt}: select: { id: text sensitive }
  | {select_core_list}: select: { id: text sensitive }
  | | {select_core}: select: { id: text sensitive }
  |   | {select_expr_list_con}: select: { id: text sensitive }
  |     | {select_expr_list}: select: { id: text sensitive }
  |     | | {select_expr}: id: text sensitive
  |     |   | {call}: id: text sensitive
  |     |     | {name char}: id: text sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer
  |     |         | {arg_list}
  |     |           | {name info}: info: integer sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT char(name)
  FROM bar;

Error at test/sem_test.sql:XXXX : in call : CQL0317: char function arguments must be integer 'char'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name char}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT char()
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'char'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name char}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := char(1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'char'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name char}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT abs(info)
  FROM with_sensitive;

  {select_stmt}: select: { info: integer sensitive }
  | {select_core_list}: select: { info: integer sensitive }
  | | {select_core}: select: { info: integer sensitive }
  |   | {select_expr_list_con}: select: { info: integer sensitive }
  |     | {select_expr_list}: select: { info: integer sensitive }
  |     | | {select_expr}: info: integer sensitive
  |     |   | {call}: info: integer sensitive
  |     |     | {name abs}: info: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name info}: info: integer sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT abs()
  FROM bar;

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'abs'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name abs}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET an_int := abs(1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'abs'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name abs}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT abs('Horty');

Error at test/sem_test.sql:XXXX : in str : CQL0082: argument must be numeric 'abs'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name abs}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'Horty'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT abs(NULL);

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {call}: null
  |     |     | {name abs}: null
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET an_int := instr(1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'instr'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name instr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT instr();

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'instr'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name instr}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr(name, 'a')
  FROM with_sensitive;

  {select_stmt}: select: { name: integer sensitive }
  | {select_core_list}: select: { name: integer sensitive }
  | | {select_core}: select: { name: integer sensitive }
  |   | {select_expr_list_con}: select: { name: integer sensitive }
  |     | {select_expr_list}: select: { name: integer sensitive }
  |     | | {select_expr}: name: integer sensitive
  |     |   | {call}: name: integer sensitive
  |     |     | {name instr}: name: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text sensitive
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr('a', 'a');

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name instr}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr(1, 'a');

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'instr'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name instr}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=1)
CREATE PROC wonky_value_type (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {int 1}
  | {create_proc_stmt}: ok
    | {name wonky_value_type}: ok
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC dup_base (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0318: more than one fragment annotation on procedure 'dup_base'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name base_fragment}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}
  | {create_proc_stmt}: err
    | {name dup_base}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC mixed_frag_types1 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types1'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name extension_fragment}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}
  | {create_proc_stmt}: err
    | {name mixed_frag_types1}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=foo)
@ATTRIBUTE(cql:assembly_fragment=goo)
CREATE PROC mixed_frag_types2 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types2'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name extension_fragment}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name assembly_fragment}
  |     | {name goo}
  | {create_proc_stmt}: err
    | {name mixed_frag_types2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC mixed_frag_types3 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types3'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name assembly_fragment}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}
  | {create_proc_stmt}: err
    | {name mixed_frag_types3}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=core)
CREATE PROC wrong_assembly_frag_name (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

Error at test/sem_test.sql:XXXX : in create_proc_stmt : CQL0319: the name of the assembly procedure must match the name of the base fragment 'wrong_assembly_frag_name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name wrong_assembly_frag_name}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_1 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT 1 AS x;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name base_frag_broken_1}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {select_expr}: x: integer notnull
            |     |   | {int 1}: integer notnull
            |     |   | {opt_as_alias}
            |     |     | {name x}
            |     | {select_from_etc}: ok
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_2 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM (SELECT 1 AS x) AS y;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name base_frag_broken_2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { y: select }
            |       | {table_or_subquery_list}: TABLE { y: select }
            |       | | {table_or_subquery}: TABLE { y: select }
            |       |   | {select_stmt}: select: { x: integer notnull }
            |       |   | | {select_core_list}: select: { x: integer notnull }
            |       |   | | | {select_core}: select: { x: integer notnull }
            |       |   | |   | {select_expr_list_con}: select: { x: integer notnull }
            |       |   | |     | {select_expr_list}: select: { x: integer notnull }
            |       |   | |     | | {select_expr}: x: integer notnull
            |       |   | |     |   | {int 1}: integer notnull
            |       |   | |     |   | {opt_as_alias}
            |       |   | |     |     | {name x}
            |       |   | |     | {select_from_etc}: ok
            |       |   | |       | {select_where}
            |       |   | |         | {select_groupby}
            |       |   | |           | {select_having}
            |       |   | | {select_orderby}
            |       |   |   | {select_limit}
            |       |   |     | {select_offset}
            |       |   | {opt_as_alias}
            |       |     | {name y}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL JOIN;

  {enforce_normal_stmt}: ok
  | {int 3}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_3 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM foo,
  (SELECT 1 AS xyz);
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name base_frag_broken_3}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, xyz: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, xyz: integer notnull }
            | | {select_core}: select: { id: integer notnull, xyz: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, xyz: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull, xyz: integer notnull }
            |     | | {star}: select: { id: integer notnull, xyz: integer notnull }
            |     | {select_from_etc}: JOIN { foo: foo, select: select }
            |       | {table_or_subquery_list}: JOIN { foo: foo, select: select }
            |       | | {table_or_subquery}: TABLE { foo: foo }
            |       | | | {name foo}: TABLE { foo: foo }
            |       | | {table_or_subquery_list}: TABLE { select: select }
            |       |   | {table_or_subquery}: TABLE { select: select }
            |       |     | {select_stmt}: select: { xyz: integer notnull }
            |       |       | {select_core_list}: select: { xyz: integer notnull }
            |       |       | | {select_core}: select: { xyz: integer notnull }
            |       |       |   | {select_expr_list_con}: select: { xyz: integer notnull }
            |       |       |     | {select_expr_list}: select: { xyz: integer notnull }
            |       |       |     | | {select_expr}: xyz: integer notnull
            |       |       |     |   | {int 1}: integer notnull
            |       |       |     |   | {opt_as_alias}
            |       |       |     |     | {name xyz}
            |       |       |     | {select_from_etc}: ok
            |       |       |       | {select_where}
            |       |       |         | {select_groupby}
            |       |       |           | {select_having}
            |       |       | {select_orderby}
            |       |         | {select_limit}
            |       |           | {select_offset}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_4 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM foo
    INNER JOIN (SELECT 2 AS x) AS T;
END;

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}
  | {create_proc_stmt}: err
    | {name base_frag_broken_4}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, x: integer notnull }
            | | {select_core}: select: { id: integer notnull, x: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, x: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull, x: integer notnull }
            |     | | {star}: select: { id: integer notnull, x: integer notnull }
            |     | {select_from_etc}: JOIN { foo: foo, T: select }
            |       | {join_clause}: JOIN { foo: foo, T: select }
            |       | | {table_or_subquery}: TABLE { foo: foo }
            |       | | | {name foo}: TABLE { foo: foo }
            |       | | {join_target_list}
            |       |   | {join_target}: JOIN { foo: foo, T: select }
            |       |     | {int 1}
            |       |     | {table_join}
            |       |       | {table_or_subquery}: TABLE { T: select }
            |       |         | {select_stmt}: select: { x: integer notnull }
            |       |         | | {select_core_list}: select: { x: integer notnull }
            |       |         | | | {select_core}: select: { x: integer notnull }
            |       |         | |   | {select_expr_list_con}: select: { x: integer notnull }
            |       |         | |     | {select_expr_list}: select: { x: integer notnull }
            |       |         | |     | | {select_expr}: x: integer notnull
            |       |         | |     |   | {int 2}: integer notnull
            |       |         | |     |   | {opt_as_alias}
            |       |         | |     |     | {name x}
            |       |         | |     | {select_from_etc}: ok
            |       |         | |       | {select_where}
            |       |         | |         | {select_groupby}
            |       |         | |           | {select_having}
            |       |         | | {select_orderby}
            |       |         |   | {select_limit}
            |       |         |     | {select_offset}
            |       |         | {opt_as_alias}
            |       |           | {name T}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE bogus_reference_in_fk(
  col1 TEXT,
  col2 INTEGER,
  FOREIGN KEY (col2) REFERENCES this_table_does_not_exist (col1) ON UPDATE CASCADE ON DELETE CASCADE
) @DELETE(1);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0021: foreign key refers to non-existent table 'this_table_does_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_reference_in_fk}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: col2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name col2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}
          | {name_list}
          | | {name col2}: col2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name this_table_does_not_exist}
            | | {name_list}
            |   | {name col1}
            | {int 51}

The statement ending at line XXXX

@ENFORCE_STRICT PROCEDURE;

  {enforce_strict_stmt}: ok
  | {int 6}

The statement ending at line XXXX

CALL some_external_thing();

Error at test/sem_test.sql:XXXX : in call_stmt : CQL0323: calls to undeclared procedures are forbidden if strict procedure mode is enabled 'some_external_thing'

  {call_stmt}: err
  | {name some_external_thing}

The statement ending at line XXXX

@ENFORCE_NORMAL PROCEDURE;

  {enforce_normal_stmt}: ok
  | {int 6}

The statement ending at line XXXX

CALL some_external_thing();

  {call_stmt}: ok
  | {name some_external_thing}: ok

The statement ending at line XXXX

DECLARE PROC _stuff () (id INTEGER, name TEXT);

  {declare_proc_stmt}: select: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff}: select: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff1 () (id INTEGER, name TEXT);

  {declare_proc_stmt}: select: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff1}: select: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff2 () (h1 INTEGER, id INTEGER, name TEXT, t1 INTEGER);

  {declare_proc_stmt}: select: { h1: integer, id: integer, name: text, t1: integer } dml_proc
  | {proc_name_type}
  | | {name _stuff2}: select: { h1: integer, id: integer, name: text, t1: integer } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { h1: integer, id: integer, name: text, t1: integer }
      | {typed_name}: h1: integer
      | | {name h1}
      | | {type_int}: h1: integer
      | {typed_names}
        | {typed_name}: id: integer
        | | {name id}
        | | {type_int}: id: integer
        | {typed_names}
          | {typed_name}: name: text
          | | {name name}
          | | {type_text}: name: text
          | {typed_names}
            | {typed_name}: t1: integer
              | {name t1}
              | {type_int}: t1: integer

The statement ending at line XXXX

DECLARE PROC _stuff3 () (h2 INTEGER, h1 INTEGER, id INTEGER, name TEXT, t1 INTEGER, t2 INTEGER);

  {declare_proc_stmt}: select: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer } dml_proc
  | {proc_name_type}
  | | {name _stuff3}: select: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer }
      | {typed_name}: h2: integer
      | | {name h2}
      | | {type_int}: h2: integer
      | {typed_names}
        | {typed_name}: h1: integer
        | | {name h1}
        | | {type_int}: h1: integer
        | {typed_names}
          | {typed_name}: id: integer
          | | {name id}
          | | {type_int}: id: integer
          | {typed_names}
            | {typed_name}: name: text
            | | {name name}
            | | {type_text}: name: text
            | {typed_names}
              | {typed_name}: t1: integer
              | | {name t1}
              | | {type_int}: t1: integer
              | {typed_names}
                | {typed_name}: t2: integer
                  | {name t2}
                  | {type_int}: t2: integer

The statement ending at line XXXX

DECLARE PROC _stuff4 () (LIKE invalid_type_name);

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'invalid_type_name'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name _stuff4}
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: err
      | {typed_name}: err
        | {like}: err
          | {name invalid_type_name}: err

The statement ending at line XXXX

DECLARE PROC _stuff5 () (id INTEGER, name TEXT);

  {declare_proc_stmt}: select: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff5}: select: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff6 () (x_id INTEGER, x_name TEXT, y_id INTEGER, y_name TEXT);

  {declare_proc_stmt}: select: { x_id: integer, x_name: text, y_id: integer, y_name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff6}: select: { x_id: integer, x_name: text, y_id: integer, y_name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { x_id: integer, x_name: text, y_id: integer, y_name: text }
      | {typed_name}: x_id: integer
      | | {name x_id}
      | | {type_int}: x_id: integer
      | {typed_names}
        | {typed_name}: x_name: text
        | | {name x_name}
        | | {type_text}: x_name: text
        | {typed_names}
          | {typed_name}: y_id: integer
          | | {name y_id}
          | | {type_int}: y_id: integer
          | {typed_names}
            | {typed_name}: y_name: text
              | {name y_name}
              | {type_text}: y_name: text

The statement ending at line XXXX

CREATE PROC using_like_shape (x_id INTEGER, x_name TEXT)
BEGIN
  CALL printf("%s\n", x.id);
END;

  {create_proc_stmt}: ok
  | {name using_like_shape}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_id: integer variable in
    | | | {param_detail}: x_id: integer variable in
    | |   | {name x_id}: x_id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: x_name: text variable in
    |     | {param_detail}: x_name: text variable in
    |       | {name x_name}: x_name: text variable in
    |       | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {strlit '%s
'}: text notnull
          | {expr_list}
            | {dot}: x_id: integer variable
              | {name x}
              | {name id}

The statement ending at line XXXX

CREATE PROC using_like_shape_bad_name (x_id INTEGER, x_name TEXT)
BEGIN
  CALL printf("%s\n", x.xyzzy);
END;

Error at test/sem_test.sql:XXXX : in dot : CQL0068: field not found in shape 'xyzzy'

  {create_proc_stmt}: err
  | {name using_like_shape_bad_name}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_id: integer variable in
    | | | {param_detail}: x_id: integer variable in
    | |   | {name x_id}: x_id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: x_name: text variable in
    |     | {param_detail}: x_name: text variable in
    |       | {name x_name}: x_name: text variable in
    |       | {type_text}: text
    | {stmt_list}: err
      | {call_stmt}: err
        | {name printf}
        | {expr_list}: err
          | {strlit '%s
'}: text notnull
          | {expr_list}
            | {dot}: err
              | {name x}
              | {name xyzzy}

The statement ending at line XXXX

CREATE PROC arg_shape_forwarder (args_arg1 INTEGER, args_arg2 TEXT, extra_args_id INTEGER, extra_args_name TEXT)
BEGIN
  CALL proc2(args.arg1, args.arg2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_shape_forwarder}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: args_arg1: integer variable in
    | | | {param_detail}: args_arg1: integer variable in
    | |   | {name args_arg1}: args_arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: args_arg2: text variable in
    |   | | {param_detail}: args_arg2: text variable in
    |   |   | {name args_arg2}: args_arg2: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: extra_args_id: integer variable in
    |     | | {param_detail}: extra_args_id: integer variable in
    |     |   | {name extra_args_id}: extra_args_id: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: extra_args_name: text variable in
    |         | {param_detail}: extra_args_name: text variable in
    |           | {name extra_args_name}: extra_args_name: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok dml_proc
        | {name proc2}: ok dml_proc
        | {expr_list}: ok
          | {dot}: args_arg1: integer variable in
          | | {name args}
          | | {name arg1}
          | {expr_list}
            | {dot}: args_arg2: text variable in
              | {name args}
              | {name arg2}

The statement ending at line XXXX

CREATE TABLE from_the_future(
  col1 TEXT PRIMARY KEY
) @CREATE(5);

  {create_table_stmt}: from_the_future: { col1: text notnull primary_key } @create(5)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 5}
  | | {name from_the_future}
  | {col_key_list}
    | {col_def}: col1: text notnull primary_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name col1}
        | | {type_text}: text
        | {col_attrs_pk}: ok

The statement ending at line XXXX

CREATE TABLE in_the_past(
  col1 TEXT,
  FOREIGN KEY (col1) REFERENCES from_the_future (col1)
) @CREATE(4);

Error at test/sem_test.sql:XXXX : in fk_def : CQL0324: referenced table was created in a later version so it cannot be used in a foreign key 'from_the_future'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 4}
  | | {name in_the_past}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: err
        | {name_list}
        | | {name col1}: col1: text
        | {fk_target_options}
          | {fk_target}
          | | {name from_the_future}
          | | {name_list}
          |   | {name col1}
          | {int 0}

The statement ending at line XXXX

CREATE TABLE in_the_future(
  col1 TEXT,
  FOREIGN KEY (col1) REFERENCES from_the_future (col1)
) @CREATE(5);

  {create_table_stmt}: in_the_future: { col1: text foreign_key } @create(5)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 5}
  | | {name in_the_future}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: ok
        | {name_list}
        | | {name col1}: col1: text
        | {fk_target_options}
          | {fk_target}
          | | {name from_the_future}
          | | {name_list}
          |   | {name col1}: col1: text notnull
          | {int 0}

The statement ending at line XXXX

DECLARE PROC basic_source () OUT UNION (id INTEGER, name TEXT);

  {declare_proc_stmt}: select: { id: integer, name: text } uses_out_union
  | {proc_name_type}
  | | {name basic_source}: select: { id: integer, name: text } uses_out_union
  | | {int 9}
  | {proc_params_stmts}
    | {typed_names}: select: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

CREATE PROC basic_wrapper_out ()
BEGIN
  DECLARE C CURSOR FOR CALL basic_source();
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: select: { id: integer, name: text } variable dml_proc auto_cursor uses_out
  | {name basic_wrapper_out}: C: select: { id: integer, name: text } variable dml_proc auto_cursor uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { id: integer, name: text } variable uses_out_union
      | | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | | {call_stmt}: select: { id: integer, name: text } uses_out_union
      |   | {name basic_source}: select: { id: integer, name: text } uses_out_union
      | {fetch_stmt}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | {out_stmt}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
        | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union

The statement ending at line XXXX

CREATE PROC basic_wrapper_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL basic_source();
  FETCH C;
  OUT UNION C;
END;

  {create_proc_stmt}: C: select: { id: integer, name: text } variable dml_proc auto_cursor uses_out_union
  | {name basic_wrapper_out_union}: C: select: { id: integer, name: text } variable dml_proc auto_cursor uses_out_union
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { id: integer, name: text } variable uses_out_union
      | | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | | {call_stmt}: select: { id: integer, name: text } uses_out_union
      |   | {name basic_source}: select: { id: integer, name: text } uses_out_union
      | {fetch_stmt}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
      | {out_union_stmt}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union
        | {name C}: C: select: { id: integer, name: text } variable auto_cursor uses_out_union

The statement ending at line XXXX

CREATE TABLE self_ref1(
  id INTEGER PRIMARY KEY,
  id2 INTEGER REFERENCES self_ref1 (id)
);

  {create_table_stmt}: self_ref1: { id: integer notnull primary_key, id2: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref1}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: id2: integer foreign_key
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref1}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref2(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref2 (id)
);

  {create_table_stmt}: self_ref2: { id: integer notnull primary_key, id2: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: ok
          | {name_list}
          | | {name id2}: id2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name self_ref2}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref3(
  id INTEGER PRIMARY KEY,
  id2 INTEGER REFERENCES self_ref3 (idx)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'idx'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref3}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_fk}: err
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref3}
              | | {name_list}: err
              |   | {name idx}: err
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref4(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref4 (idx)
);

Error at test/sem_test.sql:XXXX : in str : CQL0171: name not found 'idx'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref4}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}
          | {name_list}
          | | {name id2}: id2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name self_ref4}
            | | {name_list}: err
            |   | {name idx}: err
            | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref5(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref5 (id2)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'self_ref5'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref5}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: err
          | {name_list}
          | | {name id2}: id2: integer
          | {fk_target_options}
            | {fk_target}
            | | {name self_ref5}
            | | {name_list}
            |   | {name id2}: id2: integer
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_to_non_key(
  id INTEGER REFERENCES self_ref2 (id2)
);

Error at test/sem_test.sql:XXXX : in name_list : CQL0272: the set of columns referenced in the foreign key statement should match exactly a unique key in the parent table 'self_ref2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_to_non_key}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name self_ref2}
            | | {name_list}
            |   | {name id2}: id2: integer foreign_key
            | {int 0}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (self_ref1, (id, id2), (1, NULL), (2, 1)))))
CREATE PROC self_ref_proc_table ()
BEGIN
  SELECT *
    FROM self_ref1;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}
  |     | {misc_attr_value_list}
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}
  |           | {name self_ref1}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}
  |             | | {name id}: ok
  |             | | {misc_attr_value_list}
  |             |   | {name id2}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}
  |               | | {int 1}: ok
  |               | | {misc_attr_value_list}
  |               |   | {null}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}
  |                   | {int 2}: ok
  |                   | {misc_attr_value_list}
  |                     | {int 1}: ok
  | {create_proc_stmt}: select: { id: integer notnull, id2: integer } dml_proc
    | {name self_ref_proc_table}: select: { id: integer notnull, id2: integer } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, id2: integer }
          | {select_core_list}: select: { id: integer notnull, id2: integer }
          | | {select_core}: select: { id: integer notnull, id2: integer }
          |   | {select_expr_list_con}: select: { id: integer notnull, id2: integer }
          |     | {select_expr_list}: select: { id: integer notnull, id2: integer }
          |     | | {star}: select: { id: integer notnull, id2: integer }
          |     | {select_from_etc}: TABLE { self_ref1: self_ref1 }
          |       | {table_or_subquery_list}: TABLE { self_ref1: self_ref1 }
          |       | | {table_or_subquery}: TABLE { self_ref1: self_ref1 }
          |       |   | {name self_ref1}: TABLE { self_ref1: self_ref1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=foo)
CREATE PROC ok_table_scan ()
BEGIN
  SELECT *
    FROM foo;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {name foo}: ok
  | {create_proc_stmt}: select: { id: integer notnull } dml_proc
    | {name ok_table_scan}: select: { id: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull }
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {star}: select: { id: integer notnull }
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=(foo, 1))
CREATE PROC ok_table_scan_value ()
BEGIN
  SELECT *
    FROM foo;
END;

Error at test/sem_test.sql:XXXX : in num : CQL0325: ok_table_scan attribute must be a name

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {misc_attr_value_list}
  |     | {name foo}: ok
  |     | {misc_attr_value_list}
  |       | {int 1}: err
  | {create_proc_stmt}: err
    | {name ok_table_scan_value}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=bogus)
@ATTRIBUTE(cql:attr)
CREATE PROC ok_table_scan_bogus ()
BEGIN
  SELECT *
    FROM foo;
END;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0326: the table name in ok_table_scan does not exist 'bogus'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name ok_table_scan}
  | | | {name bogus}: err
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |       | {name cql}
  |       | {name attr}
  | {create_proc_stmt}: err
    | {name ok_table_scan_bogus}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=1)
CREATE PROC ok_table_scan_value_int ()
BEGIN
  SELECT *
    FROM foo;
END;

Error at test/sem_test.sql:XXXX : in num : CQL0325: ok_table_scan attribute must be a name

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {int 1}: err
  | {create_proc_stmt}: err
    | {name ok_table_scan_value_int}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=foo)
SELECT *
  FROM foo;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0329: ok_table_scan attribute can only be used in a create procedure statement

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {name foo}
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan)
SELECT *
  FROM foo;

Error at test/sem_test.sql:XXXX : in misc_attrs : CQL0328: no_table_scan attribute may only be added to a create table statement

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name no_table_scan}
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan)
CREATE TABLE no_table_scan(
  id TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name no_table_scan}
  | {create_table_stmt}: no_table_scan: { id: text }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name no_table_scan}
    | {col_key_list}
      | {col_def}: id: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name id}
            | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan=1)
SELECT *
  FROM foo;

Error at test/sem_test.sql:XXXX : in num : CQL0327: a value should not be assigned to no_table_scan attribute

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name no_table_scan}
  |   | {int 1}: err
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

VALUES(1);

  {select_stmt}: values: { column1: integer notnull }
  | {select_core_list}: values: { column1: integer notnull }
  | | {select_core}: values: { column1: integer notnull }
  |   | {select_values}
  |   | {values}: values: { column1: integer notnull }
  |     | {insert_list}
  |       | {int 1}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (5);

  {select_stmt}: values: { column1: integer notnull }
  | {select_core_list}: values: { column1: integer notnull }
  | | {select_core}: values: { column1: integer notnull }
  |   | {select_values}
  |   | {values}: values: { column1: integer notnull }
  |     | {insert_list}
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}
  |         | {int 5}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (_sens);

  {select_stmt}: values: { column1: integer sensitive }
  | {select_core_list}: values: { column1: integer sensitive }
  | | {select_core}: values: { column1: integer sensitive }
  |   | {select_values}
  |   | {values}: values: { column1: integer sensitive }
  |     | {insert_list}
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}
  |         | {name _sens}: _sens: integer variable sensitive
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (3, 4.5);

Error at test/sem_test.sql:XXXX : in num : CQL0337: the number of columns values for each row should be identical in VALUES clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}
  |         | {int 3}: integer notnull
  |         | {insert_list}
  |           | {dbl 4.5}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES("ok"), (1);

Error at test/sem_test.sql:XXXX : in num : CQL0009: incompatible types in expression 'VALUES clause'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}
  |     | | {strlit 'ok'}: text notnull
  |     | {values}
  |       | {insert_list}
  |         | {int 1}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1)
UNION
VALUES(2) @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        | | | {select_values}
        | | | {values}
        | |   | {insert_list}
        | |     | {int 1}
        | | {select_core_compound}
        |   | {int 1}
        |   | {select_core_list}
        |     | {select_core}
        |       | {select_values}
        |       | {values}
        |         | {insert_list}
        |           | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) WITH
T (x) AS (VALUES(1), (2), (3))
SELECT *
  FROM T @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in with_select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {with_select_stmt}: err
        | {with}
        | | {cte_tables}
        |   | {cte_table}
        |     | {cte_decl}
        |     | | {name T}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}
        |       |   | {select_values}
        |       |   | {values}
        |       |     | {insert_list}
        |       |     | | {int 1}
        |       |     | {values}
        |       |       | {insert_list}
        |       |       | | {int 2}
        |       |       | {values}
        |       |         | {insert_list}
        |       |           | {int 3}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name T}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) WITH
T (x) AS (VALUES(1), (2), (3))
SELECT *
  FROM T;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {with_select_stmt}: select: { x: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: T: { x: integer notnull }
        |     | {cte_decl}: T: { x: integer notnull }
        |     | | {name T}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}
        |       |     | | {int 1}: integer notnull
        |       |     | {values}
        |       |       | {insert_list}
        |       |       | | {int 2}: integer notnull
        |       |       | {values}
        |       |         | {insert_list}
        |       |           | {int 3}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { x: integer notnull }
          | {select_core_list}: select: { x: integer notnull }
          | | {select_core}: select: { x: integer notnull }
          |   | {select_expr_list_con}: select: { x: integer notnull }
          |     | {select_expr_list}: select: { x: integer notnull }
          |     | | {star}: select: { x: integer notnull }
          |     | {select_from_etc}: TABLE { T: T }
          |       | {table_or_subquery_list}: TABLE { T: T }
          |       | | {table_or_subquery}: TABLE { T: T }
          |       |   | {name T}: TABLE { T: T }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT 1 @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1), (2) @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |     | | {int 1}
        |     | {values}
        |       | {insert_list}
        |         | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(bogus) @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: integer notnull
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {name bogus}: err

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL) @DUMMY_SEED(1);

  {insert_stmt}: ok
  | {insert_normal}
  | | {insert_dummy_spec}: integer notnull
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {null}: null

The statement ending at line XXXX

INSERT INTO foo(id) VALUES("k") @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: integer notnull
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {strlit 'k'}: err

The statement ending at line XXXX

VALUES(l);

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'l'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}
  |       | {name l}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1)
UNION ALL
SELECT 2 AS column1;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: UNION ALL: { column1: integer notnull }
        | {select_core_list}: UNION ALL: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        | | | {select_values}
        | | | {values}: values: { column1: integer notnull }
        | |   | {insert_list}
        | |     | {int 1}: integer notnull
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { column1: integer notnull }
        |     | {select_core}: select: { column1: integer notnull }
        |       | {select_expr_list_con}: select: { column1: integer notnull }
        |         | {select_expr_list}: select: { column1: integer notnull }
        |         | | {select_expr}: column1: integer notnull
        |         |   | {int 2}: integer notnull
        |         |   | {opt_as_alias}
        |         |     | {name column1}
        |         | {select_from_etc}: ok
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1), (2) @DUMMY_SEED(1);

Error at test/sem_test.sql:XXXX : in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |     | | {int 1}
        |     | {values}
        |       | {insert_list}
        |         | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

VALUES(1, 2), (10);

Error at test/sem_test.sql:XXXX : in num : CQL0337: the number of columns values for each row should be identical in VALUES clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}
  |     | | {int 1}: integer notnull
  |     | | {insert_list}
  |     |   | {int 2}: integer notnull
  |     | {values}
  |       | {insert_list}
  |         | {int 10}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES("ok"), (bogus);

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}
  |     | | {strlit 'ok'}: text notnull
  |     | {values}
  |       | {insert_list}
  |         | {name bogus}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE values_table(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT
);

  {create_table_stmt}: values_table: { id: integer notnull primary_key autoinc, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name values_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {col_attrs_autoinc}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

INSERT INTO values_table(name, id) VALUES("ok", NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name values_table}: values_table: { id: integer notnull primary_key autoinc, name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      |   | {name_list}
      |     | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: text notnull, column2: null }
        | {select_core_list}: values: { column1: text notnull, column2: null }
        | | {select_core}: values: { column1: text notnull, column2: null }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull, column2: null }
        |     | {insert_list}
        |       | {strlit 'ok'}: text notnull
        |       | {insert_list}
        |         | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT WITHOUT ROWID;

  {enforce_strict_stmt}: ok
  | {int 7}

The statement ending at line XXXX

CREATE TABLE table_with_invalid_without_rowid_mode(
  id INTEGER PRIMARY KEY
) WITHOUT ROWID;

Error at test/sem_test.sql:XXXX : in create_table_stmt : CQL0339: WITHOUT ROWID tables are forbidden if strict without rowid mode is enabled 'table_with_invalid_without_rowid_mode'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name table_with_invalid_without_rowid_mode}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok

The statement ending at line XXXX

@ENFORCE_NORMAL WITHOUT ROWID;

  {enforce_normal_stmt}: ok
  | {int 7}

The statement ending at line XXXX

CREATE TABLE table_with_valid_without_rowid_mode(
  id INTEGER PRIMARY KEY
) WITHOUT ROWID;

  {create_table_stmt}: table_with_valid_without_rowid_mode: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name table_with_valid_without_rowid_mode}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok

The statement ending at line XXXX

CREATE PROC min_int_64_test ()
BEGIN
  SELECT -9223372036854775808L AS x;
END;

  {create_proc_stmt}: select: { x: longint notnull } dml_proc
  | {name min_int_64_test}: select: { x: longint notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { x: longint notnull }
        | {select_core_list}: select: { x: longint notnull }
        | | {select_core}: select: { x: longint notnull }
        |   | {select_expr_list_con}: select: { x: longint notnull }
        |     | {select_expr_list}: select: { x: longint notnull }
        |     | | {select_expr}: x: longint notnull
        |     |   | {uminus}: longint notnull
        |     |   | | {longint 9223372036854775808}: longint notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC exotic_literals ()
BEGIN
  SELECT 2147483647 AS a, 2147483648L AS b, 3.4e11 AS c, .001e+5 AS d, .4e-9 AS e;
END;

  {create_proc_stmt}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull } dml_proc
  | {name exotic_literals}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        | {select_core_list}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        | | {select_core}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |   | {select_expr_list_con}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |     | {select_expr_list}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |     | | {select_expr}: a: integer notnull
        |     | | | {int 2147483647}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: longint notnull
        |     |   | | {longint 2147483648}: longint notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: real notnull
        |     |     | | {dbl 3.4e11}: real notnull
        |     |     | | {opt_as_alias}
        |     |     |   | {name c}
        |     |     | {select_expr_list}
        |     |       | {select_expr}: d: real notnull
        |     |       | | {dbl .001e+5}: real notnull
        |     |       | | {opt_as_alias}
        |     |       |   | {name d}
        |     |       | {select_expr_list}
        |     |         | {select_expr}: e: real notnull
        |     |           | {dbl .4e-9}: real notnull
        |     |           | {opt_as_alias}
        |     |             | {name e}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC hex_literals ()
BEGIN
  SELECT 0x13aF AS a, 0x234L AS b, 0x123456789L AS c;
END;

  {create_proc_stmt}: select: { a: integer notnull, b: longint notnull, c: longint notnull } dml_proc
  | {name hex_literals}: select: { a: integer notnull, b: longint notnull, c: longint notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        | {select_core_list}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        | | {select_core}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |   | {select_expr_list_con}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |     | {select_expr_list}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |     | | {select_expr}: a: integer notnull
        |     | | | {int 0x13aF}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: longint notnull
        |     |   | | {longint 0x234}: longint notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: longint notnull
        |     |       | {longint 0x123456789}: longint notnull
        |     |       | {opt_as_alias}
        |     |         | {name c}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE PROC shape () (x INTEGER NOT NULL, y TEXT NOT NULL);

  {declare_proc_stmt}: select: { x: integer notnull, y: text notnull } dml_proc
  | {proc_name_type}
  | | {name shape}: select: { x: integer notnull, y: text notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { x: integer notnull, y: text notnull }
      | {typed_name}: x: integer notnull
      | | {name x}
      | | {notnull}: x: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: y: text notnull
          | {name y}
          | {notnull}: y: text notnull
            | {type_text}: text

The statement ending at line XXXX

DECLARE PROC small_shape () (y TEXT NOT NULL);

  {declare_proc_stmt}: select: { y: text notnull } dml_proc
  | {proc_name_type}
  | | {name small_shape}: select: { y: text notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: select: { y: text notnull }
      | {typed_name}: y: text notnull
        | {name y}
        | {notnull}: y: text notnull
          | {type_text}: text

The statement ending at line XXXX

DECLARE PROC shape_consumer (x_ INTEGER NOT NULL, y_ TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name shape_consumer}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_: integer notnull variable in
      | | {param_detail}: x_: integer notnull variable in
      |   | {name x_}: x_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: y_: text notnull variable in
          | {param_detail}: y_: text notnull variable in
            | {name y_}: y_: text notnull variable in
            | {notnull}: text notnull
              | {type_text}: text

The statement ending at line XXXX

CREATE PROC shape_all_columns ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_consumer(C.x, C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_all_columns}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {like}: select: { x: integer notnull, y: text notnull } dml_proc
      |   | {name shape}: select: { x: integer notnull, y: text notnull } dml_proc
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: ok
        | {name shape_consumer}: ok
        | {expr_list}: ok
          | {dot}: C_.x: integer notnull variable
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}: C_.y: text notnull variable
              | {name C}
              | {name y}

The statement ending at line XXXX

CREATE PROC shape_thing_bogus_cursor ()
BEGIN
  CALL shape_consumer(FROM not_a_cursor);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name shape_thing_bogus_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name shape_consumer}
        | {expr_list}: err
          | {from_cursor}
            | {name not_a_cursor}: err

The statement ending at line XXXX

CREATE PROC shape_some_columns_statement_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x, 'y' AS y;
  CALL shape_consumer(C.x, C.y);
END;

Error at test/sem_test.sql:XXXX : in dot : CQL0067: cursor was not used with 'fetch [cursor]' 'C'

  {create_proc_stmt}: err
  | {name shape_some_columns_statement_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { x: integer notnull, y: text notnull } variable
      | | {name C}: C: select: { x: integer notnull, y: text notnull } variable
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {call_stmt}: err
        | {name shape_consumer}
        | {expr_list}: err
          | {dot}: err
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}
              | {name C}
              | {name y}

The statement ending at line XXXX

DECLARE PROC shape_y_only (y_ TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name shape_y_only}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: y_: text notnull variable in
        | {param_detail}: y_: text notnull variable in
          | {name y_}: y_: text notnull variable in
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC shape_some_columns ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_y_only(C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_some_columns}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {like}: select: { x: integer notnull, y: text notnull } dml_proc
      |   | {name shape}: select: { x: integer notnull, y: text notnull } dml_proc
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: ok
        | {name shape_y_only}: ok
        | {expr_list}: ok
          | {dot}: C_.y: text notnull variable
            | {name C}
            | {name y}

The statement ending at line XXXX

CREATE PROC shape_some_columns_bogus_name ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_y_only(FROM C LIKE not_a_real_shape);
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_real_shape'

  {create_proc_stmt}: err
  | {name shape_some_columns_bogus_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      | | {like}: select: { x: integer notnull, y: text notnull } dml_proc
      |   | {name shape}: select: { x: integer notnull, y: text notnull } dml_proc
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: err
        | {name shape_y_only}
        | {expr_list}: err
          | {from_cursor}
            | {name C}: C: select: { x: integer notnull, y: text notnull } variable auto_cursor value_cursor
            | {like}: err
              | {name not_a_real_shape}: err

The statement ending at line XXXX

DECLARE PROC lotsa_ints (a INTEGER NOT NULL, b INTEGER NOT NULL, c INTEGER NOT NULL, d INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name lotsa_ints}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable in
      | | {param_detail}: a: integer notnull variable in
      |   | {name a}: a: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: b: integer notnull variable in
        | | {param_detail}: b: integer notnull variable in
        |   | {name b}: b: integer notnull variable in
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: c: integer notnull variable in
          | | {param_detail}: c: integer notnull variable in
          |   | {name c}: c: integer notnull variable in
          |   | {notnull}: integer notnull
          |     | {type_int}: integer
          | {params}
            | {param}: d: integer notnull variable in
              | {param_detail}: d: integer notnull variable in
                | {name d}: d: integer notnull variable in
                | {notnull}: integer notnull
                  | {type_int}: integer

The statement ending at line XXXX

CREATE PROC shape_args_middle ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, 2 AS y;
  FETCH C(x, y) FROM VALUES(1, 2);
  CALL lotsa_ints(C.x, C.y, 1, 2);
  CALL lotsa_ints(1, C.x, C.y, 2);
  CALL lotsa_ints(1, 2, C.x, C.y);
  CALL lotsa_ints(C.x, C.y, C.x, C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_args_middle}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C: select: { x: integer notnull, y: integer notnull } variable auto_cursor value_cursor
      | | {name C}: C: select: { x: integer notnull, y: integer notnull } variable auto_cursor value_cursor
      | | {select_stmt}: select: { x: integer notnull, y: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: integer notnull }
      |   | | {select_core}: select: { x: integer notnull, y: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { x: integer notnull, y: integer notnull } variable auto_cursor value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: integer notnull
      |     | {insert_list}
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: C_.x: integer notnull variable
      |   | | {name C}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: C_.y: integer notnull variable
      |     | | {name C}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: C_.x: integer notnull variable
      |     | | {name C}
      |     | | {name x}
      |     | {expr_list}
      |       | {dot}: C_.y: integer notnull variable
      |       | | {name C}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: C_.x: integer notnull variable
      |       | | {name C}
      |       | | {name x}
      |       | {expr_list}
      |         | {dot}: C_.y: integer notnull variable
      |           | {name C}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: C_.x: integer notnull variable
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}: C_.y: integer notnull variable
            | | {name C}
            | | {name y}
            | {expr_list}
              | {dot}: C_.x: integer notnull variable
              | | {name C}
              | | {name x}
              | {expr_list}
                | {dot}: C_.y: integer notnull variable
                  | {name C}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_rewrite_simple (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(x, y, 1, 2);
  CALL lotsa_ints(1, x, y, 2);
  CALL lotsa_ints(1, 2, x, y);
  CALL lotsa_ints(x, y, x, y);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_simple}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: integer notnull variable in
    |     | {param_detail}: y: integer notnull variable in
    |       | {name y}: y: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {name x}: x: integer notnull variable in
      |   | {expr_list}
      |     | {name y}: y: integer notnull variable in
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {name x}: x: integer notnull variable in
      |     | {expr_list}
      |       | {name y}: y: integer notnull variable in
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {name x}: x: integer notnull variable in
      |       | {expr_list}
      |         | {name y}: y: integer notnull variable in
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {name x}: x: integer notnull variable in
          | {expr_list}
            | {name y}: y: integer notnull variable in
            | {expr_list}
              | {name x}: x: integer notnull variable in
              | {expr_list}
                | {name y}: y: integer notnull variable in

The statement ending at line XXXX

CREATE PROC arg_rewrite_no_args ()
BEGIN
  CALL lotsa_ints(FROM ARGUMENTS, 1, 2);
END;

Error at test/sem_test.sql:XXXX : in expr_list : CQL0340: FROM ARGUMENTS used in a procedure with no arguments 'arg_rewrite_no_args'

  {create_proc_stmt}: err
  | {name arg_rewrite_no_args}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}
        | {expr_list}: err
          | {from_arguments}
          | {expr_list}
            | {int 1}
            | {expr_list}
              | {int 2}

The statement ending at line XXXX

CALL lotsa_ints(FROM ARGUMENTS, 1, 2);

Error at test/sem_test.sql:XXXX : in expr_list : CQL0163: FROM ARGUMENTS construct is only valid inside a procedure

  {call_stmt}: err
  | {name lotsa_ints}
  | {expr_list}: err
    | {from_arguments}
    | {expr_list}
      | {int 1}
      | {expr_list}
        | {int 2}

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(y, 1, 2, 3);
  CALL lotsa_ints(1, y, 2, 3);
  CALL lotsa_ints(1, 2, y, 3);
  CALL lotsa_ints(1, 2, 3, y);
  CALL lotsa_ints(y, y, y, y);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: integer notnull variable in
    |     | {param_detail}: y: integer notnull variable in
    |       | {name y}: y: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {name y}: y: integer notnull variable in
      |   | {expr_list}
      |     | {int 1}: integer notnull
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {name y}: y: integer notnull variable in
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {name y}: y: integer notnull variable in
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {int 3}: integer notnull
      |       | {expr_list}
      |         | {name y}: y: integer notnull variable in
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {name y}: y: integer notnull variable in
          | {expr_list}
            | {name y}: y: integer notnull variable in
            | {expr_list}
              | {name y}: y: integer notnull variable in
              | {expr_list}
                | {name y}: y: integer notnull variable in

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like_with_underscore (x INTEGER NOT NULL, y_ INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(y_, 1, 2, 3);
  CALL lotsa_ints(1, y_, 2, 3);
  CALL lotsa_ints(1, 2, y_, 3);
  CALL lotsa_ints(1, 2, 3, y_);
  CALL lotsa_ints(y_, y_, y_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like_with_underscore}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: integer notnull variable in
    |     | {param_detail}: y_: integer notnull variable in
    |       | {name y_}: y_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {name y_}: y_: integer notnull variable in
      |   | {expr_list}
      |     | {int 1}: integer notnull
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {name y_}: y_: integer notnull variable in
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {name y_}: y_: integer notnull variable in
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {int 3}: integer notnull
      |       | {expr_list}
      |         | {name y_}: y_: integer notnull variable in
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {name y_}: y_: integer notnull variable in
          | {expr_list}
            | {name y_}: y_: integer notnull variable in
            | {expr_list}
              | {name y_}: y_: integer notnull variable in
              | {expr_list}
                | {name y_}: y_: integer notnull variable in

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like_many_cols_with_underscore (x_ INTEGER NOT NULL, y_ INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(x_, y_, 1, 2);
  CALL lotsa_ints(1, x_, y_, 2);
  CALL lotsa_ints(1, 2, x_, y_);
  CALL lotsa_ints(x_, y_, x_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like_many_cols_with_underscore}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: integer notnull variable in
    |     | {param_detail}: y_: integer notnull variable in
    |       | {name y_}: y_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {name x_}: x_: integer notnull variable in
      |   | {expr_list}
      |     | {name y_}: y_: integer notnull variable in
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {name x_}: x_: integer notnull variable in
      |     | {expr_list}
      |       | {name y_}: y_: integer notnull variable in
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {name x_}: x_: integer notnull variable in
      |       | {expr_list}
      |         | {name y_}: y_: integer notnull variable in
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {name x_}: x_: integer notnull variable in
          | {expr_list}
            | {name y_}: y_: integer notnull variable in
            | {expr_list}
              | {name x_}: x_: integer notnull variable in
              | {expr_list}
                | {name y_}: y_: integer notnull variable in

The statement ending at line XXXX

CREATE PROC call_with_missing_type (x INTEGER)
BEGIN
  CALL lotsa_ints(1, 2, 3, FROM ARGUMENTS LIKE foo);
END;

Error at test/sem_test.sql:XXXX : in expr_list : CQL0201: expanding FROM ARGUMENTS, there is no argument matching 'id'

  {create_proc_stmt}: err
  | {name call_with_missing_type}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}
        | {expr_list}: err
          | {int 1}
          | {expr_list}
            | {int 2}
            | {expr_list}
              | {int 3}
              | {expr_list}
                | {from_arguments}
                  | {like}: ok
                    | {name foo}

The statement ending at line XXXX

CREATE PROC call_from_arguments_bogus_type (x INTEGER)
BEGIN
  CALL lotsa_ints(1, 2, 3, FROM ARGUMENTS LIKE no_such_type_dude);
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'no_such_type_dude'

  {create_proc_stmt}: err
  | {name call_from_arguments_bogus_type}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}
        | {expr_list}: err
          | {int 1}
          | {expr_list}
            | {int 2}
            | {expr_list}
              | {int 3}
              | {expr_list}
                | {from_arguments}
                  | {like}: err
                    | {name no_such_type_dude}: err

The statement ending at line XXXX

DECLARE PROC funclike (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name funclike}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_: integer notnull variable in
      | | {param_detail}: x_: integer notnull variable in
      |   | {name x_}: x_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: y_: text notnull variable in
        | | {param_detail}: y_: text notnull variable in
        |   | {name y_}: y_: text notnull variable in
        |   | {notnull}: text notnull
        |     | {type_text}: text
        | {params}
          | {param}: z: integer notnull variable out
            | {out}
            | {param_detail}: z: integer notnull variable out
              | {name z}: z: integer notnull variable out
              | {notnull}: integer notnull
                | {type_int}: integer

The statement ending at line XXXX

CREATE PROC arg_caller (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL)
BEGIN
  SET z := funclike(x_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_caller}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: text notnull variable in
    |   | | {param_detail}: y_: text notnull variable in
    |   |   | {name y_}: y_: text notnull variable in
    |   |   | {notnull}: text notnull
    |   |     | {type_text}: text
    |   | {params}
    |     | {param}: z: integer notnull variable out
    |       | {out}
    |       | {param_detail}: z: integer notnull variable out
    |         | {name z}: z: integer notnull variable out
    |         | {notnull}: integer notnull
    |           | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: z: integer notnull variable out
        | {name z}: z: integer notnull variable out
        | {call}: integer notnull
          | {name funclike}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name x_}: x_: integer notnull variable in
              | {arg_list}
                | {name y_}: y_: text notnull variable in

The statement ending at line XXXX

CREATE PROC arg_caller_bogus_shape (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL)
BEGIN
  SET z := funclike(FROM ARGUMENTS LIKE not_a_shape);
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_shape'

  {create_proc_stmt}: err
  | {name arg_caller_bogus_shape}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: text notnull variable in
    |   | | {param_detail}: y_: text notnull variable in
    |   |   | {name y_}: y_: text notnull variable in
    |   |   | {notnull}: text notnull
    |   |     | {type_text}: text
    |   | {params}
    |     | {param}: z: integer notnull variable out
    |       | {out}
    |       | {param_detail}: z: integer notnull variable out
    |         | {name z}: z: integer notnull variable out
    |         | {notnull}: integer notnull
    |           | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name z}: z: integer notnull variable out
        | {call}: err
          | {name funclike}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: err
              | {from_arguments}
                | {like}: err
                  | {name not_a_shape}: err

The statement ending at line XXXX

SET a_string := @PROC;

Error at test/sem_test.sql:XXXX : in str : CQL0252: @PROC literal can only appear inside of procedures

  {assign}: err
  | {name a_string}: a_string: text variable
  | {name @PROC}: err

The statement ending at line XXXX

SAVEPOINT @PROC;

Error at test/sem_test.sql:XXXX : in str : CQL0252: @PROC literal can only appear inside of procedures

  {savepoint_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

RELEASE SAVEPOINT @PROC;

Error at test/sem_test.sql:XXXX : in str : CQL0252: @PROC literal can only appear inside of procedures

  {release_savepoint_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

ROLLBACK TRANSACTION TO SAVEPOINT @PROC;

Error at test/sem_test.sql:XXXX : in str : CQL0252: @PROC literal can only appear inside of procedures

  {rollback_trans_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

CREATE PROC savepoint_proc_stuff ()
BEGIN
  DECLARE p TEXT;
  SET p := 'savepoint_proc_stuff';
  SAVEPOINT savepoint_proc_stuff;
  ROLLBACK TRANSACTION TO SAVEPOINT savepoint_proc_stuff;
  RELEASE SAVEPOINT savepoint_proc_stuff;
END;

  {create_proc_stmt}: ok dml_proc
  | {name savepoint_proc_stuff}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text
      | | {name_list}: p: text variable
      | | | {name p}: p: text variable
      | | {type_text}: text
      | {assign}: p: text variable
      | | {name p}: p: text variable
      | | {strlit 'savepoint_proc_stuff'}: text notnull
      | {savepoint_stmt}: ok
      | | {name savepoint_proc_stuff}: ok
      | {rollback_trans_stmt}: ok
      | | {name savepoint_proc_stuff}: ok
      | {release_savepoint_stmt}: ok
        | {name savepoint_proc_stuff}: ok

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(1, "bogus");

Error at test/sem_test.sql:XXXX : in num : CQL0341: argument must be a variable in function 'cql_cursor_diff_col'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_diff_col}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: err
        | {arg_list}
          | {strlit 'bogus'}: text notnull

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(an_int, an_int2);

Error at test/sem_test.sql:XXXX : in str : CQL0205: variable is not a cursor 'an_int'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_diff_col}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: err
        | {arg_list}
          | {name an_int2}: an_int2: integer variable

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(an_int, an_int2, 1);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'cql_cursor_diff_col'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_diff_col}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: an_int: integer variable
        | {arg_list}
          | {name an_int2}: an_int2: integer variable
          | {arg_list}
            | {int 1}: integer notnull

The statement ending at line XXXX

SET a_string := cql_cursor_diff_val(an_int, an_int2, 1);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'cql_cursor_diff_val'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_diff_val}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: an_int: integer variable
        | {arg_list}
          | {name an_int2}: an_int2: integer variable
          | {arg_list}
            | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_without_cursor_arg ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0067: cursor was not used with 'fetch [cursor]' 'c1'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_without_cursor_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {assign}: err
        | {name a_string}: a_string: text variable
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: err
              | {arg_list}
                | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_wrong_cursor_type ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x;
  DECLARE c2 CURSOR FOR SELECT '1' AS x;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0061: in cql_cursor_diff_col, all columns must be an exact type match (expected integer notnull; found text notnull) 'x'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_wrong_cursor_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull } variable
      | | {name c1}: c1: select: { x: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: text notnull } variable
      | | {name c2}: c2: select: { x: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: text notnull }
      |   | {select_core_list}: select: { x: text notnull }
      |   | | {select_core}: select: { x: text notnull }
      |   |   | {select_expr_list_con}: select: { x: text notnull }
      |   |     | {select_expr_list}: select: { x: text notnull }
      |   |     | | {select_expr}: x: text notnull
      |   |     |   | {strlit '1'}: text notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { x: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: text notnull } variable auto_cursor
      | {assign}: err
        | {name a_string}: a_string: text variable
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: err
              | {arg_list}
                | {name c2}: err

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_with_wrong_col_count_arg ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'z' AS z;
  DECLARE c2 CURSOR FOR SELECT 1 AS x;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

Error at test/sem_test.sql:XXXX : in call : CQL0342: the cursor arguments must have identical column count 'cql_cursor_diff_col'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_with_wrong_col_count_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull, z: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, z: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, z: text notnull }
      |   | | {select_core}: select: { x: integer notnull, z: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, z: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, z: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: z: text notnull
      |   |     |     | {strlit 'z'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name z}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull } variable
      | | {name c2}: c2: select: { x: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, z: text notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { x: integer notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: integer notnull } variable auto_cursor
      | {assign}: err
        | {name a_string}: a_string: text variable
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable auto_cursor
              | {arg_list}
                | {name c2}: c2: select: { x: integer notnull } variable auto_cursor

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_compatible_cursor_with_diff_col_name ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS z, 'v' AS v;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0058: in cql_cursor_diff_col, all column names must be identical so they have unambiguous names 'z'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_compatible_cursor_with_diff_col_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { z: integer notnull, v: text notnull } variable
      | | {name c2}: c2: select: { z: integer notnull, v: text notnull } variable auto_cursor
      | | {select_stmt}: select: { z: integer notnull, v: text notnull }
      |   | {select_core_list}: select: { z: integer notnull, v: text notnull }
      |   | | {select_core}: select: { z: integer notnull, v: text notnull }
      |   |   | {select_expr_list_con}: select: { z: integer notnull, v: text notnull }
      |   |     | {select_expr_list}: select: { z: integer notnull, v: text notnull }
      |   |     | | {select_expr}: z: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name z}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: v: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name v}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { z: integer notnull, v: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { z: integer notnull, v: text notnull } variable auto_cursor
      | {assign}: err
        | {name a_string}: a_string: text variable
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: err
              | {arg_list}
                | {name c2}: err

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_with_auto_cursor ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  FETCH c1;
  FETCH c2;
  SET a_string := CASE WHEN c1.x IS NOT c2.x THEN 'x'
  WHEN c1.y IS NOT c2.y THEN 'y'
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name cql_cursor_diff_col_with_auto_cursor}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {assign}: a_string: text variable
        | {name a_string}: a_string: text variable
        | {case_expr}: text
          | {connector}: text
            | {case_list}: text notnull
              | {when}: text notnull
              | | {is_not}: bool notnull
              | | | {dot}: c1_.x: integer notnull variable
              | | | | {name c1}
              | | | | {name x}
              | | | {dot}: c2_.x: integer notnull variable
              | |   | {name c2}
              | |   | {name x}
              | | {strlit 'x'}: text notnull
              | {case_list}: text notnull
                | {when}: text notnull
                  | {is_not}: bool notnull
                  | | {dot}: c1_.y: text notnull variable
                  | | | {name c1}
                  | | | {name y}
                  | | {dot}: c2_.y: text notnull variable
                  |   | {name c2}
                  |   | {name y}
                  | {strlit 'y'}: text notnull

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_diff_col ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'v' AS y;
  FETCH c1;
  FETCH c2;
  CALL printf(CASE WHEN c1.x IS NOT c2.x THEN 'x'
  WHEN c1.y IS NOT c2.y THEN 'y'
  END);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_diff_col}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {case_expr}: text
            | {connector}: text
              | {case_list}: text notnull
                | {when}: text notnull
                | | {is_not}: bool notnull
                | | | {dot}: c1_.x: integer notnull variable
                | | | | {name c1}
                | | | | {name x}
                | | | {dot}: c2_.x: integer notnull variable
                | |   | {name c2}
                | |   | {name x}
                | | {strlit 'x'}: text notnull
                | {case_list}: text notnull
                  | {when}: text notnull
                    | {is_not}: bool notnull
                    | | {dot}: c1_.y: text notnull variable
                    | | | {name c1}
                    | | | {name y}
                    | | {dot}: c2_.y: text notnull variable
                    |   | {name c2}
                    |   | {name y}
                    | {strlit 'y'}: text notnull

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_diff_val ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'v' AS y;
  FETCH c1;
  FETCH c2;
  CALL printf(CASE WHEN c1.x IS NOT c2.x THEN printf('column:%s c1:%s c2:%s', 'x', CASE WHEN c1.x IS NULL THEN 'null'
  ELSE printf('%d', c1.x)
  END, CASE WHEN c2.x IS NULL THEN 'null'
  ELSE printf('%d', c2.x)
  END)
  WHEN c1.y IS NOT c2.y THEN printf('column:%s c1:%s c2:%s', 'y', CASE WHEN c1.y IS NULL THEN 'null'
  ELSE printf('%s', c1.y)
  END, CASE WHEN c2.y IS NULL THEN 'null'
  ELSE printf('%s', c2.y)
  END)
  END);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_diff_val}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable auto_cursor
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {case_expr}: text
            | {connector}: text
              | {case_list}: text notnull
                | {when}: text notnull
                | | {is_not}: bool notnull
                | | | {dot}: c1_.x: integer notnull variable
                | | | | {name c1}
                | | | | {name x}
                | | | {dot}: c2_.x: integer notnull variable
                | |   | {name c2}
                | |   | {name x}
                | | {call}: text notnull
                |   | {name printf}: text notnull
                |   | {call_arg_list}
                |     | {call_filter_clause}
                |     | {arg_list}: ok
                |       | {strlit 'column:%s c1:%s c2:%s'}: text notnull
                |       | {arg_list}
                |         | {strlit 'x'}: text notnull
                |         | {arg_list}
                |           | {case_expr}: text notnull
                |           | | {connector}: text notnull
                |           |   | {case_list}: text notnull
                |           |   | | {when}: text notnull
                |           |   |   | {is}: bool notnull
                |           |   |   | | {dot}: c1_.x: integer notnull variable
                |           |   |   | | | {name c1}
                |           |   |   | | | {name x}
                |           |   |   | | {null}: null
                |           |   |   | {strlit 'null'}: text notnull
                |           |   | {call}: text notnull
                |           |     | {name printf}: text notnull
                |           |     | {call_arg_list}
                |           |       | {call_filter_clause}
                |           |       | {arg_list}: ok
                |           |         | {strlit '%d'}: text notnull
                |           |         | {arg_list}
                |           |           | {dot}: c1_.x: integer notnull variable
                |           |             | {name c1}
                |           |             | {name x}
                |           | {arg_list}
                |             | {case_expr}: text notnull
                |               | {connector}: text notnull
                |                 | {case_list}: text notnull
                |                 | | {when}: text notnull
                |                 |   | {is}: bool notnull
                |                 |   | | {dot}: c2_.x: integer notnull variable
                |                 |   | | | {name c2}
                |                 |   | | | {name x}
                |                 |   | | {null}: null
                |                 |   | {strlit 'null'}: text notnull
                |                 | {call}: text notnull
                |                   | {name printf}: text notnull
                |                   | {call_arg_list}
                |                     | {call_filter_clause}
                |                     | {arg_list}: ok
                |                       | {strlit '%d'}: text notnull
                |                       | {arg_list}
                |                         | {dot}: c2_.x: integer notnull variable
                |                           | {name c2}
                |                           | {name x}
                | {case_list}: text notnull
                  | {when}: text notnull
                    | {is_not}: bool notnull
                    | | {dot}: c1_.y: text notnull variable
                    | | | {name c1}
                    | | | {name y}
                    | | {dot}: c2_.y: text notnull variable
                    |   | {name c2}
                    |   | {name y}
                    | {call}: text notnull
                      | {name printf}: text notnull
                      | {call_arg_list}
                        | {call_filter_clause}
                        | {arg_list}: ok
                          | {strlit 'column:%s c1:%s c2:%s'}: text notnull
                          | {arg_list}
                            | {strlit 'y'}: text notnull
                            | {arg_list}
                              | {case_expr}: text notnull
                              | | {connector}: text notnull
                              |   | {case_list}: text notnull
                              |   | | {when}: text notnull
                              |   |   | {is}: bool notnull
                              |   |   | | {dot}: c1_.y: text notnull variable
                              |   |   | | | {name c1}
                              |   |   | | | {name y}
                              |   |   | | {null}: null
                              |   |   | {strlit 'null'}: text notnull
                              |   | {call}: text notnull
                              |     | {name printf}: text notnull
                              |     | {call_arg_list}
                              |       | {call_filter_clause}
                              |       | {arg_list}: ok
                              |         | {strlit '%s'}: text notnull
                              |         | {arg_list}
                              |           | {dot}: c1_.y: text notnull variable
                              |             | {name c1}
                              |             | {name y}
                              | {arg_list}
                                | {case_expr}: text notnull
                                  | {connector}: text notnull
                                    | {case_list}: text notnull
                                    | | {when}: text notnull
                                    |   | {is}: bool notnull
                                    |   | | {dot}: c2_.y: text notnull variable
                                    |   | | | {name c2}
                                    |   | | | {name y}
                                    |   | | {null}: null
                                    |   | {strlit 'null'}: text notnull
                                    | {call}: text notnull
                                      | {name printf}: text notnull
                                      | {call_arg_list}
                                        | {call_filter_clause}
                                        | {arg_list}: ok
                                          | {strlit '%s'}: text notnull
                                          | {arg_list}
                                            | {dot}: c2_.y: text notnull variable
                                              | {name c2}
                                              | {name y}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x", "y") );

  {assign}: a_string: text variable
  | {name a_string}: a_string: text variable
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name trim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x") );

  {assign}: a_string: text variable
  | {name a_string}: a_string: text variable
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name trim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT ltrim("x", "y") );

  {assign}: a_string: text variable
  | {name a_string}: a_string: text variable
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name ltrim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT rtrim("x", "y") );

  {assign}: a_string: text variable
  | {name a_string}: a_string: text variable
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name rtrim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim() );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim(1, 2, 3) );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim(1, "x") );

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x", 1) );

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := trim("x", 1);

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name trim}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

SET sens_text := ( SELECT trim(name)
  FROM with_sensitive );

  {assign}: sens_text: text variable sensitive
  | {name sens_text}: sens_text: text variable sensitive
  | {select_stmt}: _anon: text sensitive
    | {select_core_list}: select: { _anon: text sensitive }
    | | {select_core}: select: { _anon: text sensitive }
    |   | {select_expr_list_con}: select: { _anon: text sensitive }
    |     | {select_expr_list}: select: { _anon: text sensitive }
    |     | | {select_expr}: text sensitive
    |     |   | {call}: text sensitive
    |     |     | {name trim}: text sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name name}: name: text sensitive
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET sens_text := ( SELECT trim("xyz", name) AS result
  FROM with_sensitive );

  {assign}: sens_text: text variable sensitive
  | {name sens_text}: sens_text: text variable sensitive
  | {select_stmt}: result: text notnull sensitive
    | {select_core_list}: select: { result: text notnull sensitive }
    | | {select_core}: select: { result: text notnull sensitive }
    |   | {select_expr_list_con}: select: { result: text notnull sensitive }
    |     | {select_expr_list}: select: { result: text notnull sensitive }
    |     | | {select_expr}: result: text notnull sensitive
    |     |   | {call}: text notnull sensitive
    |     |   | | {name trim}: text notnull sensitive
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {strlit 'xyz'}: text notnull
    |     |   |     | {arg_list}
    |     |   |       | {name name}: name: text sensitive
    |     |   | {opt_as_alias}
    |     |     | {name result}
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_format ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT CAST(1 AS BOOL) AS a, 1 AS b, 99L AS c, 'x' AS d, 1.1 AS e, CAST('y' AS BLOB) AS f;
  FETCH c1;
  SET a_string := printf('a:%s|b:%s|c:%s|d:%s|e:%s|f:%s', CASE WHEN c1.a IS NULL THEN 'null'
  ELSE printf('%d', c1.a)
  END, CASE WHEN c1.b IS NULL THEN 'null'
  ELSE printf('%d', c1.b)
  END, CASE WHEN c1.c IS NULL THEN 'null'
  ELSE printf('%lld', c1.c)
  END, CASE WHEN c1.d IS NULL THEN 'null'
  ELSE printf('%s', c1.d)
  END, CASE WHEN c1.e IS NULL THEN 'null'
  ELSE printf('%f', c1.e)
  END, CASE WHEN c1.f IS NULL THEN 'null'
  ELSE printf('length %lld blob', cql_get_blob_size(c1.f))
  END);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_format}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull } variable
      | | {name c1}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull } variable auto_cursor
      | | {select_stmt}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull }
      |   | {select_core_list}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull }
      |   | | {select_core}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull }
      |   |   | {select_expr_list_con}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull }
      |   |     | {select_expr_list}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull }
      |   |     | | {select_expr}: a: bool notnull
      |   |     | | | {cast_expr}: bool notnull
      |   |     | | | | {int 1}: integer notnull
      |   |     | | | | {type_bool}: bool
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name a}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: b: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name b}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: c: longint notnull
      |   |     |     | | {longint 99}: longint notnull
      |   |     |     | | {opt_as_alias}
      |   |     |     |   | {name c}
      |   |     |     | {select_expr_list}
      |   |     |       | {select_expr}: d: text notnull
      |   |     |       | | {strlit 'x'}: text notnull
      |   |     |       | | {opt_as_alias}
      |   |     |       |   | {name d}
      |   |     |       | {select_expr_list}
      |   |     |         | {select_expr}: e: real notnull
      |   |     |         | | {dbl 1.1}: real notnull
      |   |     |         | | {opt_as_alias}
      |   |     |         |   | {name e}
      |   |     |         | {select_expr_list}
      |   |     |           | {select_expr}: f: blob notnull
      |   |     |             | {cast_expr}: blob notnull
      |   |     |             | | {strlit 'y'}: text notnull
      |   |     |             | | {type_blob}: blob
      |   |     |             | {opt_as_alias}
      |   |     |               | {name f}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull } variable auto_cursor
      | | {name c1}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real notnull, f: blob notnull } variable auto_cursor
      | {assign}: a_string: text variable
        | {name a_string}: a_string: text variable
        | {call}: text notnull
          | {name printf}: text notnull
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {strlit 'a:%s|b:%s|c:%s|d:%s|e:%s|f:%s'}: text notnull
              | {arg_list}
                | {case_expr}: text notnull
                | | {connector}: text notnull
                |   | {case_list}: text notnull
                |   | | {when}: text notnull
                |   |   | {is}: bool notnull
                |   |   | | {dot}: c1_.a: bool notnull variable
                |   |   | | | {name c1}
                |   |   | | | {name a}
                |   |   | | {null}: null
                |   |   | {strlit 'null'}: text notnull
                |   | {call}: text notnull
                |     | {name printf}: text notnull
                |     | {call_arg_list}
                |       | {call_filter_clause}
                |       | {arg_list}: ok
                |         | {strlit '%d'}: text notnull
                |         | {arg_list}
                |           | {dot}: c1_.a: bool notnull variable
                |             | {name c1}
                |             | {name a}
                | {arg_list}
                  | {case_expr}: text notnull
                  | | {connector}: text notnull
                  |   | {case_list}: text notnull
                  |   | | {when}: text notnull
                  |   |   | {is}: bool notnull
                  |   |   | | {dot}: c1_.b: integer notnull variable
                  |   |   | | | {name c1}
                  |   |   | | | {name b}
                  |   |   | | {null}: null
                  |   |   | {strlit 'null'}: text notnull
                  |   | {call}: text notnull
                  |     | {name printf}: text notnull
                  |     | {call_arg_list}
                  |       | {call_filter_clause}
                  |       | {arg_list}: ok
                  |         | {strlit '%d'}: text notnull
                  |         | {arg_list}
                  |           | {dot}: c1_.b: integer notnull variable
                  |             | {name c1}
                  |             | {name b}
                  | {arg_list}
                    | {case_expr}: text notnull
                    | | {connector}: text notnull
                    |   | {case_list}: text notnull
                    |   | | {when}: text notnull
                    |   |   | {is}: bool notnull
                    |   |   | | {dot}: c1_.c: longint notnull variable
                    |   |   | | | {name c1}
                    |   |   | | | {name c}
                    |   |   | | {null}: null
                    |   |   | {strlit 'null'}: text notnull
                    |   | {call}: text notnull
                    |     | {name printf}: text notnull
                    |     | {call_arg_list}
                    |       | {call_filter_clause}
                    |       | {arg_list}: ok
                    |         | {strlit '%lld'}: text notnull
                    |         | {arg_list}
                    |           | {dot}: c1_.c: longint notnull variable
                    |             | {name c1}
                    |             | {name c}
                    | {arg_list}
                      | {case_expr}: text notnull
                      | | {connector}: text notnull
                      |   | {case_list}: text notnull
                      |   | | {when}: text notnull
                      |   |   | {is}: bool notnull
                      |   |   | | {dot}: c1_.d: text notnull variable
                      |   |   | | | {name c1}
                      |   |   | | | {name d}
                      |   |   | | {null}: null
                      |   |   | {strlit 'null'}: text notnull
                      |   | {call}: text notnull
                      |     | {name printf}: text notnull
                      |     | {call_arg_list}
                      |       | {call_filter_clause}
                      |       | {arg_list}: ok
                      |         | {strlit '%s'}: text notnull
                      |         | {arg_list}
                      |           | {dot}: c1_.d: text notnull variable
                      |             | {name c1}
                      |             | {name d}
                      | {arg_list}
                        | {case_expr}: text notnull
                        | | {connector}: text notnull
                        |   | {case_list}: text notnull
                        |   | | {when}: text notnull
                        |   |   | {is}: bool notnull
                        |   |   | | {dot}: c1_.e: real notnull variable
                        |   |   | | | {name c1}
                        |   |   | | | {name e}
                        |   |   | | {null}: null
                        |   |   | {strlit 'null'}: text notnull
                        |   | {call}: text notnull
                        |     | {name printf}: text notnull
                        |     | {call_arg_list}
                        |       | {call_filter_clause}
                        |       | {arg_list}: ok
                        |         | {strlit '%f'}: text notnull
                        |         | {arg_list}
                        |           | {dot}: c1_.e: real notnull variable
                        |             | {name c1}
                        |             | {name e}
                        | {arg_list}
                          | {case_expr}: text notnull
                            | {connector}: text notnull
                              | {case_list}: text notnull
                              | | {when}: text notnull
                              |   | {is}: bool notnull
                              |   | | {dot}: c1_.f: blob notnull variable
                              |   | | | {name c1}
                              |   | | | {name f}
                              |   | | {null}: null
                              |   | {strlit 'null'}: text notnull
                              | {call}: text notnull
                                | {name printf}: text notnull
                                | {call_arg_list}
                                  | {call_filter_clause}
                                  | {arg_list}: ok
                                    | {strlit 'length %lld blob'}: text notnull
                                    | {arg_list}
                                      | {call}: longint notnull
                                        | {name cql_get_blob_size}: longint notnull
                                        | {call_arg_list}
                                          | {call_filter_clause}
                                          | {arg_list}: ok
                                            | {dot}: c1_.f: blob notnull variable
                                              | {name c1}
                                              | {name f}

The statement ending at line XXXX

CREATE PROC select_cql_cursor_format ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS a;
  FETCH c1;
  SELECT cql_cursor_format(c1) AS p;
END;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'cql_cursor_format'

  {create_proc_stmt}: err
  | {name select_cql_cursor_format}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { a: integer notnull } variable
      | | {name c1}: c1: select: { a: integer notnull } variable auto_cursor
      | | {select_stmt}: select: { a: integer notnull }
      |   | {select_core_list}: select: { a: integer notnull }
      |   | | {select_core}: select: { a: integer notnull }
      |   |   | {select_expr_list_con}: select: { a: integer notnull }
      |   |     | {select_expr_list}: select: { a: integer notnull }
      |   |     | | {select_expr}: a: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name a}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { a: integer notnull } variable auto_cursor
      | | {name c1}: c1: select: { a: integer notnull } variable auto_cursor
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name cql_cursor_format}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name c1}: c1_._has_row_: bool notnull variable
        |     |   | {opt_as_alias}
        |     |     | {name p}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC print_call_cql_not_fetch_cursor_format ()
BEGIN
  DECLARE c CURSOR FOR SELECT 1;
  SET a_string := cql_cursor_format(c);
END;

Error at test/sem_test.sql:XXXX : in str : CQL0067: cursor was not used with 'fetch [cursor]' 'c'

  {create_proc_stmt}: err
  | {name print_call_cql_not_fetch_cursor_format}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { _anon: integer notnull } variable
      | | {name c}: c: select: { _anon: integer notnull } variable
      | | {select_stmt}: select: { _anon: integer notnull }
      |   | {select_core_list}: select: { _anon: integer notnull }
      |   | | {select_core}: select: { _anon: integer notnull }
      |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |   |     | {select_expr_list}: select: { _anon: integer notnull }
      |   |     | | {select_expr}: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {assign}: err
        | {name a_string}: a_string: text variable
        | {call}: err
          | {name cql_cursor_format}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c}: err

The statement ending at line XXXX

SET a_string := cql_cursor_format(1);

Error at test/sem_test.sql:XXXX : in num : CQL0341: argument must be a variable in function 'cql_cursor_format'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_format}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: err

The statement ending at line XXXX

SET a_string := cql_cursor_format(1, 2);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'cql_cursor_format'

  {assign}: err
  | {name a_string}: a_string: text variable
  | {call}: err
    | {name cql_cursor_format}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 2}: integer notnull

The statement ending at line XXXX

SET an_int := 1L;

Error at test/sem_test.sql:XXXX : in num : CQL0242: lossy conversion from type 'LONG_INT' in 1L

  {assign}: err
  | {name an_int}: err
  | {longint 1}: longint notnull

The statement ending at line XXXX

SET an_int := 1.0;

Error at test/sem_test.sql:XXXX : in num : CQL0242: lossy conversion from type 'REAL' in 1.0

  {assign}: err
  | {name an_int}: err
  | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET ll := 1.0;

Error at test/sem_test.sql:XXXX : in num : CQL0242: lossy conversion from type 'REAL' in 1.0

  {assign}: err
  | {name ll}: err
  | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET an_int := ( SELECT length() );

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name length}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := ( SELECT length(1) );

Error at test/sem_test.sql:XXXX : in call : CQL0085: all arguments must be strings 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name length}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := length("x");

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable
  | {call}: err
    | {name length}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET _sens := ( SELECT length(name)
  FROM with_sensitive );

  {assign}: _sens: integer variable sensitive
  | {name _sens}: _sens: integer variable sensitive
  | {select_stmt}: _anon: integer sensitive
    | {select_core_list}: select: { _anon: integer sensitive }
    | | {select_core}: select: { _anon: integer sensitive }
    |   | {select_expr_list_con}: select: { _anon: integer sensitive }
    |     | {select_expr_list}: select: { _anon: integer sensitive }
    |     | | {select_expr}: integer sensitive
    |     |   | {call}: integer sensitive
    |     |     | {name length}: integer sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name name}: name: text sensitive
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := ( SELECT length("x") );

  {assign}: an_int: integer variable
  | {name an_int}: an_int: integer variable
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name length}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC cursor_box (OUT B OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET B FROM CURSOR C;
END;

  {create_proc_stmt}: ok dml_proc
  | {name cursor_box}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: B: object<bar CURSOR> variable out
    |   | {out}
    |   | {param_detail}: B: object<bar CURSOR> variable out
    |     | {name B}: B: object<bar CURSOR> variable out
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable boxed
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable boxed
        | {name B}: B: object<bar CURSOR> variable out
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable

The statement ending at line XXXX

CREATE PROC cursor_unbox (box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

  {create_proc_stmt}: ok
  | {name cursor_unbox}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable in
    |   | {param_detail}: box: object<bar CURSOR> variable in
    |     | {name box}: box: object<bar CURSOR> variable in
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: ok
      | {declare_cursor}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
        | {name box}: box: object<bar CURSOR> variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_untyped (box OBJECT)
BEGIN
  DECLARE C CURSOR FOR box;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0346: the variable must be of type object<T cursor> where T is a valid shape name 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_untyped}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object variable in
    |   | {param_detail}: box: object variable in
    |     | {name box}: box: object variable in
    |     | {type_object}: object
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: box: object variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_cursor (box OBJECT<bar>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0343: the variable must be of type object<T cursor> where T is a valid shape name 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_cursor}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar> variable in
    |   | {param_detail}: box: object<bar> variable in
    |     | {name box}: box: object<bar> variable in
    |     | {type_object}: object<bar>
    |       | {name bar}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: box: object<bar> variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_a_type (box OBJECT<not_a_type CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'not_a_type'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_a_type}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<not_a_type CURSOR> variable in
    |   | {param_detail}: box: object<not_a_type CURSOR> variable in
    |     | {name box}: box: object<not_a_type CURSOR> variable in
    |     | {type_object}: object<not_a_type CURSOR>
    |       | {name not_a_type CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: err

The statement ending at line XXXX

CREATE PROC cursor_unbox_duplicate (box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
  DECLARE C CURSOR FOR box;
END;

Error at test/sem_test.sql:XXXX : in declare_cursor : CQL0197: duplicate variable name in the same scope 'C'

  {create_proc_stmt}: err
  | {name cursor_unbox_duplicate}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable in
    |   | {param_detail}: box: object<bar CURSOR> variable in
    |     | {name box}: box: object<bar CURSOR> variable in
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
      | | {name box}: box: object<bar CURSOR> variable in
      | {declare_cursor}: err
        | {name C}: err
        | {name box}

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_exists ()
BEGIN
  DECLARE C CURSOR FOR box;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_exists}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: err

The statement ending at line XXXX

CREATE PROC cursor_box_value (OUT box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR LIKE bar;
  SET box FROM CURSOR C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0261: the cursor did not originate from a SQLite statement, it only has values 'C'

  {create_proc_stmt}: err
  | {name cursor_box_value}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<bar CURSOR> variable out
    |     | {name box}: box: object<bar CURSOR> variable out
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {like}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
      | {set_from_cursor}: err
        | {name box}: box: object<bar CURSOR> variable out
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor

The statement ending at line XXXX

CREATE PROC cursor_box_not_a_shape (OUT box OBJECT<barf CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

Error at test/sem_test.sql:XXXX : in like : CQL0202: must be a cursor, proc, table, or view 'barf'

  {create_proc_stmt}: err
  | {name cursor_box_not_a_shape}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: err
    |   | {out}
    |   | {param_detail}: box: object<barf CURSOR> variable out
    |     | {name box}: box: object<barf CURSOR> variable out
    |     | {type_object}: object<barf CURSOR>
    |       | {name barf CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: err
        | {name box}: box: object<barf CURSOR> variable out
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable

The statement ending at line XXXX

CREATE PROC cursor_box_wrong_shape (OUT box OBJECT<foo CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0057: in the cursor and the variable type, all must have the same column count

  {create_proc_stmt}: err
  | {name cursor_box_wrong_shape}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<foo CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<foo CURSOR> variable out
    |     | {name box}: box: object<foo CURSOR> variable out
    |     | {type_object}: object<foo CURSOR>
    |       | {name foo CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: err
        | {name box}: box: object<foo CURSOR> variable out
        | {name C}: err

The statement ending at line XXXX

CREATE PROC cursor_box_not_a_cursor (OUT box OBJECT<foo CURSOR>)
BEGIN
  SET box FROM CURSOR XYZZY;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0204: cursor not found 'XYZZY'

  {create_proc_stmt}: err
  | {name cursor_box_not_a_cursor}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<foo CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<foo CURSOR> variable out
    |     | {name box}: box: object<foo CURSOR> variable out
    |     | {type_object}: object<foo CURSOR>
    |       | {name foo CURSOR}
    | {stmt_list}: err
      | {set_from_cursor}: err
        | {name box}
        | {name XYZZY}: err

The statement ending at line XXXX

CREATE PROC cursor_box_var_not_found ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

Error at test/sem_test.sql:XXXX : in set_from_cursor : CQL0173: variable not found 'box'

  {create_proc_stmt}: err
  | {name cursor_box_var_not_found}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: err
        | {name box}
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable

The statement ending at line XXXX

SET an_long := cql_get_blob_size(blob_var);

  {assign}: an_long: longint variable
  | {name an_long}: an_long: longint variable
  | {call}: longint
    | {name cql_get_blob_size}: longint
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET an_long := cql_get_blob_size(blob_var, 0);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable
  | {call}: err
    | {name cql_get_blob_size}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name blob_var}: blob_var: blob variable
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET an_long := cql_get_blob_size(an_int);

Error at test/sem_test.sql:XXXX : in call : CQL0345: the argument must be of type blob 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable
  | {call}: err
    | {name cql_get_blob_size}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: an_int: integer variable

The statement ending at line XXXX

SET an_long := ( SELECT cql_get_blob_size(an_int) );

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name cql_get_blob_size}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name an_int}: an_int: integer variable
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE PROC some_proc (id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
      | | {param_detail}: id: integer variable in
      |   | {name id}: id: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: t: text variable in
        | | {param_detail}: t: text variable in
        |   | {name t}: t: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: t1: text notnull variable in
          | | {param_detail}: t1: text notnull variable in
          |   | {name t1}: t1: text notnull variable in
          |   | {notnull}: text notnull
          |     | {type_text}: text
          | {params}
            | {param}: b: blob variable in
            | | {param_detail}: b: blob variable in
            |   | {name b}: b: blob variable in
            |   | {type_blob}: blob
            | {params}
              | {param}: x: integer notnull variable out
                | {out}
                | {param_detail}: x: integer notnull variable out
                  | {name x}: x: integer notnull variable out
                  | {notnull}: integer notnull
                    | {type_int}: integer

The statement ending at line XXXX

DECLARE Q CURSOR LIKE some_proc ARGUMENTS;

  {declare_cursor_like_name}: Q: proc_args: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull out } variable auto_cursor value_cursor
  | {name Q}: Q: proc_args: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull out } variable auto_cursor value_cursor
  | {like}: proc_args: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull out }
    | {name some_proc}: proc_args: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull out }
    | {name some_proc}: proc_args: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull out }

The statement ending at line XXXX

CREATE PROC some_proc_proxy (id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL)
BEGIN
  CALL some_proc(id, t, t1, b, x);
END;

  {create_proc_stmt}: ok
  | {name some_proc_proxy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    | | | {param_detail}: id: integer variable in
    | |   | {name id}: id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |   | | {param_detail}: t: text variable in
    |   |   | {name t}: t: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: t1: text notnull variable in
    |     | | {param_detail}: t1: text notnull variable in
    |     |   | {name t1}: t1: text notnull variable in
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: b: blob variable in
    |       | | {param_detail}: b: blob variable in
    |       |   | {name b}: b: blob variable in
    |       |   | {type_blob}: blob
    |       | {params}
    |         | {param}: x: integer notnull variable out
    |           | {out}
    |           | {param_detail}: x: integer notnull variable out
    |             | {name x}: x: integer notnull variable out
    |             | {notnull}: integer notnull
    |               | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name some_proc}: ok
        | {expr_list}: ok
          | {name id}: id: integer variable in
          | {expr_list}
            | {name t}: t: text variable in
            | {expr_list}
              | {name t1}: t1: text notnull variable in
              | {expr_list}
                | {name b}: b: blob variable in
                | {expr_list}
                  | {name x}: x: integer notnull variable out

The statement ending at line XXXX

DECLARE PROC some_proc2 (INOUT id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc2}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in out
      | | {inout}
      | | {param_detail}: id: integer variable in out
      |   | {name id}: id: integer variable in out
      |   | {type_int}: integer
      | {params}
        | {param}: t: text variable in
        | | {param_detail}: t: text variable in
        |   | {name t}: t: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: t1: text notnull variable in
          | | {param_detail}: t1: text notnull variable in
          |   | {name t1}: t1: text notnull variable in
          |   | {notnull}: text notnull
          |     | {type_text}: text
          | {params}
            | {param}: b: blob variable in
            | | {param_detail}: b: blob variable in
            |   | {name b}: b: blob variable in
            |   | {type_blob}: blob
            | {params}
              | {param}: x: integer notnull variable out
                | {out}
                | {param_detail}: x: integer notnull variable out
                  | {name x}: x: integer notnull variable out
                  | {notnull}: integer notnull
                    | {type_int}: integer

The statement ending at line XXXX

CREATE PROC some_proc2_proxy (INOUT id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL)
BEGIN
  CALL some_proc(id, t, t1, b, x);
END;

  {create_proc_stmt}: ok
  | {name some_proc2_proxy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in out
    | | | {inout}
    | | | {param_detail}: id: integer variable in out
    | |   | {name id}: id: integer variable in out
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |   | | {param_detail}: t: text variable in
    |   |   | {name t}: t: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: t1: text notnull variable in
    |     | | {param_detail}: t1: text notnull variable in
    |     |   | {name t1}: t1: text notnull variable in
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: b: blob variable in
    |       | | {param_detail}: b: blob variable in
    |       |   | {name b}: b: blob variable in
    |       |   | {type_blob}: blob
    |       | {params}
    |         | {param}: x: integer notnull variable out
    |           | {out}
    |           | {param_detail}: x: integer notnull variable out
    |             | {name x}: x: integer notnull variable out
    |             | {notnull}: integer notnull
    |               | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name some_proc}: ok
        | {expr_list}: ok
          | {name id}: id: integer variable in out
          | {expr_list}
            | {name t}: t: text variable in
            | {expr_list}
              | {name t1}: t1: text notnull variable in
              | {expr_list}
                | {name b}: b: blob variable in
                | {expr_list}
                  | {name x}: x: integer notnull variable out

The statement ending at line XXXX

CREATE PROC some_proc3_proxy (LIKE some_proc3 ARGUMENTS)
BEGIN
  CALL some_proc(FROM ARGUMENTS);
END;

Error at test/sem_test.sql:XXXX : in like : CQL0069: name not found 'some_proc3'

  {create_proc_stmt}: err
  | {name some_proc3_proxy}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {like}: err
    |       | {name some_proc3}: err
    |       | {name some_proc3}: err
    | {stmt_list}
      | {call_stmt}
        | {name some_proc}
        | {expr_list}
          | {from_arguments}

The statement ending at line XXXX

CREATE PROC some_proc4_proxy (LIKE proc1 ARGUMENTS)
BEGIN
END;

Error at test/sem_test.sql:XXXX : in like : CQL0262: LIKE ... ARGUMENTS used on a procedure with no arguments 'proc1'

  {create_proc_stmt}: err
  | {name some_proc4_proxy}: err
  | {proc_params_stmts}
    | {params}: err
      | {param}: err
        | {param_detail}
          | {like}: err
            | {name proc1}: err
            | {name proc1}: err

The statement ending at line XXXX

DECLARE invalid_object_cursor CURSOR LIKE obj_proc ARGUMENTS;

Error at test/sem_test.sql:XXXX : in like : CQL0335: the procedure has an object argument, this is not yet supported 'obj_proc'

  {declare_cursor_like_name}: err
  | {name invalid_object_cursor}
  | {like}: err
    | {name obj_proc}: err
    | {name obj_proc}: err

The statement ending at line XXXX

CREATE PROC test_fetch_using ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  FETCH C(id, name, rate) FROM VALUES(1, NULL, 99);
END;

  {create_proc_stmt}: ok
  | {name test_fetch_using}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {like}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {int 99}: integer notnull

The statement ending at line XXXX

CREATE PROC test_fetch_using_with_dummy_seed ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  FETCH C(id, name, rate) FROM VALUES(1, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(9) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok
  | {name test_fetch_using_with_dummy_seed}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
      | | {like}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 9}: integer notnull
        | | {int 3}
        | {name_columns_values}
          | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable auto_cursor value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {call}: text notnull
                | | {name printf}: text notnull
                | | {call_arg_list}
                |   | {call_filter_clause}
                |   | {arg_list}: ok
                |     | {strlit 'name_%d'}: text notnull
                |     | {arg_list}
                |       | {name _seed_}: _seed_: integer notnull variable
                | {insert_list}
                  | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

DECLARE SELECT FUNC returns_object_is_bogus () OBJECT;

Error at test/sem_test.sql:XXXX : in str : CQL0347: select function may not return type OBJECT 'returns_object_is_bogus'

  {declare_select_func_stmt}: err
  | {name returns_object_is_bogus}: object
  | {func_params_return}
    | {type_object}: object

The statement ending at line XXXX

CREATE TABLE with_check(
  id INTEGER,
  lo INTEGER CHECK(lo <= hi) ,
  hi INTEGER
);

  {create_table_stmt}: with_check: { id: integer, lo: integer has_check, hi: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: lo: integer has_check
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name lo}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: ok
      |     | {le}: bool
      |       | {name lo}: lo: integer has_check
      |       | {name hi}: hi: integer
      | {col_key_list}
        | {col_def}: hi: integer
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name hi}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE with_check_bogus_column(
  id INTEGER,
  lo INTEGER CHECK(lo <= hip) ,
  hi INTEGER
);

Error at test/sem_test.sql:XXXX : in str : CQL0069: name not found 'hip'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_bogus_column}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: lo: integer has_check
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name lo}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: err
      |     | {le}: err
      |       | {name lo}: lo: integer has_check
      |       | {name hip}: err
      | {col_key_list}
        | {col_def}: hi: integer
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name hi}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE with_collate(
  id INTEGER,
  t TEXT COLLATE garbonzo
);

  {create_table_stmt}: with_collate: { id: integer, t: text has_collate }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_collate}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: t: text has_collate
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name t}
          | | {type_text}: text
          | {col_attrs_collate}: ok
            | {name garbonzo}

The statement ending at line XXXX

CREATE TABLE with_collate(
  id INTEGER,
  i REAL COLLATE garbonzo
);

Error at test/sem_test.sql:XXXX : in str : CQL0348: collate applied to a non-text column 'i'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_collate}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}
          | {col_def_name_type}
          | | {name i}
          | | {type_real}: real
          | {col_attrs_collate}: err
            | {name garbonzo}

The statement ending at line XXXX

CREATE TABLE bad_order(
  id INTEGER,
  PRIMARY KEY (id),
  t TEXT
);

Error at test/sem_test.sql:XXXX : in col_def : CQL0349: column definitions may not come after constraints 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_order}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
      | | {name_list}
      |   | {name id}
      | {col_key_list}
        | {col_def}
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name t}
              | {type_text}

The statement ending at line XXXX

CREATE PROC test_insert_using ()
BEGIN
  INSERT INTO foo(id) VALUES(1);
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_insert_using}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name foo}: foo: { id: integer notnull primary_key autoinc }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {insert_list}
              | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC test_insert_using_with_dummy_seed ()
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(1, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(9) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_insert_using_with_dummy_seed}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | | {insert_dummy_spec}: integer notnull
        |   | {int 9}: integer notnull
        |   | {int 3}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {call}: text notnull
                | | {name printf}: text notnull
                | | {call_arg_list}
                |   | {call_filter_clause}
                |   | {arg_list}: ok
                |     | {strlit 'name_%d'}: text notnull
                |     | {arg_list}
                |       | {name _seed_}: _seed_: integer notnull variable
                | {insert_list}
                  | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC test_insert_using ()
BEGIN
  INSERT INTO foo USING 1 AS bogus;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0186: duplicate stored proc name 'test_insert_using'

  {create_proc_stmt}: err
  | {name test_insert_using}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {insert_stmt}
        | {insert_normal}
        | {name_columns_values}
          | {name foo}
          | {expr_names}
            | {expr_name}
              | {int 1}
              | {opt_as_alias}
                | {name bogus}

The statement ending at line XXXX

SELECT CASE WHEN an_int IS NULL THEN 3
ELSE 2
END;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {case_expr}: integer notnull
  |     |     | {connector}: integer notnull
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {is}: bool notnull
  |     |       |   | | {name an_int}: an_int: integer variable
  |     |       |   | | {null}: null
  |     |       |   | {int 3}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT iif(an_int IS NULL, 2, 3, 4);

Error at test/sem_test.sql:XXXX : in str : CQL0079: function got incorrect number of arguments 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name iif}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {is}: bool notnull
  |     |         | | {name an_int}: an_int: integer variable
  |     |         | | {null}: null
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 3}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT iif('x', 2, 3);

Error at test/sem_test.sql:XXXX : in str : CQL0082: argument must be numeric 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name iif}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT iif(an_int IS NULL, 2, x'23');

Error at test/sem_test.sql:XXXX : in str : CQL0012: incompatible types in expression 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name iif}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {is}: bool notnull
  |     |         | | {name an_int}: an_int: integer variable
  |     |         | | {null}: null
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     |           | {arg_list}
  |     |             | {blob x'23'}: blob notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET an_int := CASE WHEN an_int IS NULL THEN CASE WHEN 1 THEN 3
ELSE 2
END
ELSE 2
END;

  {assign}: an_int: integer variable
  | {name an_int}: an_int: integer variable
  | {case_expr}: integer notnull
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {is}: bool notnull
      |   | | {name an_int}: an_int: integer variable
      |   | | {null}: null
      |   | {case_expr}: integer notnull
      |     | {connector}: integer notnull
      |       | {case_list}: integer notnull
      |       | | {when}: integer notnull
      |       |   | {int 1}: integer notnull
      |       |   | {int 3}: integer notnull
      |       | {int 2}: integer notnull
      | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC test_update_cursor_using ()
BEGIN
  UPDATE CURSOR small_cursor(x) FROM VALUES(2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_update_cursor_using}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {update_cursor_stmt}: ok
        | {name small_cursor}: small_cursor: select: { x: integer notnull } variable auto_cursor value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name x}: x: integer notnull
          | {insert_list}
            | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC proc_savepoint_basic ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    ELSE
      COMMIT RETURN;
    END IF;
  END;
END;

  {create_proc_stmt}: ok dml_proc uses_throw
  | {name proc_savepoint_basic}: ok dml_proc uses_throw
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {proc_savepoint_stmt}: ok
        | {stmt_list}: ok
          | {if_stmt}: integer notnull
            | {cond_action}: integer notnull
            | | {int 1}: integer notnull
            | | {stmt_list}: ok
            |   | {rollback_return_stmt}: ok
            | {if_alt}: ok
              | {else}: ok
                | {stmt_list}: ok
                  | {commit_return_stmt}: ok

The statement ending at line XXXX

CREATE PROC proc_savepoint_error_in_stmt_list ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    SET X := NOT 'x';
  END;
END;

Error at test/sem_test.sql:XXXX : in str : CQL0050: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name proc_savepoint_error_in_stmt_list}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {proc_savepoint_stmt}: err
        | {stmt_list}: err
          | {assign}: err
            | {name X}: X: integer variable
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

PROC SAVEPOINT
BEGIN
END;

Error at test/sem_test.sql:XXXX : in proc_savepoint_stmt : CQL0351: statement should be in a procedure and at the top level

  {proc_savepoint_stmt}: err

The statement ending at line XXXX

CREATE PROC savepoint_nested ()
BEGIN
  IF 1 THEN
    PROC SAVEPOINT
    BEGIN
    END;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in proc_savepoint_stmt : CQL0351: statement should be in a procedure and at the top level

  {create_proc_stmt}: err
  | {name savepoint_nested}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {proc_savepoint_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC rollback_return_invalid ()
BEGIN
  IF 1 THEN
    ROLLBACK RETURN;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in rollback_return_stmt : CQL0350: statement must appear inside of a PROC SAVEPOINT block

  {create_proc_stmt}: err
  | {name rollback_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {rollback_return_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC commit_return_invalid ()
BEGIN
  IF 1 THEN
    COMMIT RETURN;
  END IF;
END;

Error at test/sem_test.sql:XXXX : in commit_return_stmt : CQL0350: statement must appear inside of a PROC SAVEPOINT block

  {create_proc_stmt}: err
  | {name commit_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {commit_return_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC regular_return_invalid ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    RETURN;
  END;
END;

Error at test/sem_test.sql:XXXX : in return_stmt : CQL0352: use COMMIT RETURN or ROLLBACK RETURN in within a proc savepoint block

  {create_proc_stmt}: err
  | {name regular_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {proc_savepoint_stmt}: err
        | {stmt_list}: err
          | {return_stmt}: err

The statement ending at line XXXX

CREATE TABLE SalesInfo(
  month INTEGER,
  amount REAL
);

  {create_table_stmt}: SalesInfo: { month: integer, amount: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name SalesInfo}
  | {col_key_list}
    | {col_def}: month: integer
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name month}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: amount: real
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name amount}
            | {type_real}: real

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND sum(month) FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: amount: real
  |     |       | | | {name AVG}: amount: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {groupby_list}: ok
  |     |       |     |   | {groupby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: err
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {call}: err
  |     |       |           | {name sum}
  |     |       |           | {call_arg_list}
  |     |       |             | {call_filter_clause}
  |     |       |             | {arg_list}: ok
  |     |       |               | {name month}: month: integer
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (PARTITION BY sum(month) ROWS BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: amount: real
  |     |       | | | {name AVG}: amount: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {opt_partition_by}: err
  |     |       |   | | {expr_list}: err
  |     |       |   |   | {call}: err
  |     |       |   |     | {name sum}
  |     |       |   |     | {call_arg_list}
  |     |       |   |       | {call_filter_clause}
  |     |       |   |       | {arg_list}: ok
  |     |       |   |         | {name month}: month: integer
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_frame_spec}: ok
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {int 3}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (ORDER BY month ROWS BETWEEN sum(month) PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: amount: real
  |     |       | | | {name AVG}: amount: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {groupby_list}: ok
  |     |       |     |   | {groupby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: err
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {call}: err
  |     |       |         | | {name sum}
  |     |       |         | | {call_arg_list}
  |     |       |         |   | {call_filter_clause}
  |     |       |         |   | {arg_list}: ok
  |     |       |         |     | {name month}: month: integer
  |     |       |         | {int 1}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) FILTER (WHERE sum(month) = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
  FROM SalesInfo;

Error at test/sem_test.sql:XXXX : in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: err
  |     |       | | | {name AVG}
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | | {opt_filter_clause}: err
  |     |       | |   |   | {opt_where}: err
  |     |       | |   |     | {eq}: err
  |     |       | |   |       | {call}: err
  |     |       | |   |       | | {name sum}
  |     |       | |   |       | | {call_arg_list}
  |     |       | |   |       |   | {call_filter_clause}
  |     |       | |   |       |   | {arg_list}: ok
  |     |       | |   |       |     | {name month}: month: integer
  |     |       | |   |       | {int 1}: integer notnull
  |     |       | |   | {arg_list}
  |     |       | |     | {name amount}
  |     |       | | {window_defn}: ok
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {groupby_list}: ok
  |     |       |     |   | {groupby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: ok
  |     |       |       | {int 20610}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {int 2}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

