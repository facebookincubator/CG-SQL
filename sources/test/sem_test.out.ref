{stmt_list}: err

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_partition_create () CREATE OBJECT<partitioning> NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: object<partitioning> notnull create_func
    | {name cql_partition_create}: object<partitioning> notnull create_func
    | {func_params_return}
      | {create_data_type}: object<partitioning> notnull create_func
        | {notnull}: object<partitioning> notnull
          | {type_object}: object<partitioning>
            | {name partitioning}

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_partition_cursor (p OBJECT<partitioning> NOT NULL, key CURSOR, value CURSOR) BOOL NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: bool notnull
    | {name cql_partition_cursor}: bool notnull
    | {func_params_return}
      | {params}: ok
      | | {param}: p: object<partitioning> notnull variable in
      | | | {param_detail}: p: object<partitioning> notnull variable in
      | |   | {name p}: p: object<partitioning> notnull variable in
      | |   | {notnull}: object<partitioning> notnull
      | |     | {type_object}: object<partitioning>
      | |       | {name partitioning}
      | | {params}
      |   | {param}: key: cursor variable in
      |   | | {param_detail}: key: cursor variable in
      |   |   | {name key}: key: cursor variable in
      |   |   | {type_cursor}: cursor
      |   | {params}
      |     | {param}: value: cursor variable in
      |       | {param_detail}: value: cursor variable in
      |         | {name value}: value: cursor variable in
      |         | {type_cursor}: cursor
      | {notnull}: bool notnull
        | {type_bool}: bool

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_extract_partition (p OBJECT<partitioning> NOT NULL, key CURSOR) CREATE OBJECT NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: object notnull create_func
    | {name cql_extract_partition}: object notnull create_func
    | {func_params_return}
      | {params}: ok
      | | {param}: p: object<partitioning> notnull variable in
      | | | {param_detail}: p: object<partitioning> notnull variable in
      | |   | {name p}: p: object<partitioning> notnull variable in
      | |   | {notnull}: object<partitioning> notnull
      | |     | {type_object}: object<partitioning>
      | |       | {name partitioning}
      | | {params}
      |   | {param}: key: cursor variable in
      |     | {param_detail}: key: cursor variable in
      |       | {name key}: key: cursor variable in
      |       | {type_cursor}: cursor
      | {create_data_type}: object notnull create_func
        | {notnull}: object notnull
          | {type_object}: object

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_string_dictionary_create () CREATE OBJECT<string_dictionary> NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: object<string_dictionary> notnull create_func
    | {name cql_string_dictionary_create}: object<string_dictionary> notnull create_func
    | {func_params_return}
      | {create_data_type}: object<string_dictionary> notnull create_func
        | {notnull}: object<string_dictionary> notnull
          | {type_object}: object<string_dictionary>
            | {name string_dictionary}

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_string_dictionary_add (dict OBJECT<string_dictionary> NOT NULL, key TEXT NOT NULL, value TEXT NOT NULL) BOOL NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: bool notnull
    | {name cql_string_dictionary_add}: bool notnull
    | {func_params_return}
      | {params}: ok
      | | {param}: dict: object<string_dictionary> notnull variable in
      | | | {param_detail}: dict: object<string_dictionary> notnull variable in
      | |   | {name dict}: dict: object<string_dictionary> notnull variable in
      | |   | {notnull}: object<string_dictionary> notnull
      | |     | {type_object}: object<string_dictionary>
      | |       | {name string_dictionary}
      | | {params}
      |   | {param}: key: text notnull variable in
      |   | | {param_detail}: key: text notnull variable in
      |   |   | {name key}: key: text notnull variable in
      |   |   | {notnull}: text notnull
      |   |     | {type_text}: text
      |   | {params}
      |     | {param}: value: text notnull variable in
      |       | {param_detail}: value: text notnull variable in
      |         | {name value}: value: text notnull variable in
      |         | {notnull}: text notnull
      |           | {type_text}: text
      | {notnull}: bool notnull
        | {type_bool}: bool

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_string_dictionary_find (dict OBJECT<string_dictionary> NOT NULL, key TEXT) TEXT;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: text
    | {name cql_string_dictionary_find}: text
    | {func_params_return}
      | {params}: ok
      | | {param}: dict: object<string_dictionary> notnull variable in
      | | | {param_detail}: dict: object<string_dictionary> notnull variable in
      | |   | {name dict}: dict: object<string_dictionary> notnull variable in
      | |   | {notnull}: object<string_dictionary> notnull
      | |     | {type_object}: object<string_dictionary>
      | |       | {name string_dictionary}
      | | {params}
      |   | {param}: key: text variable in
      |     | {param_detail}: key: text variable in
      |       | {name key}: key: text variable in
      |       | {type_text}: text
      | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:builtin)
DECLARE FUNC cql_cursor_format (C CURSOR) CREATE TEXT NOT NULL;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name builtin}
  | {declare_func_stmt}: text notnull create_func
    | {name cql_cursor_format}: text notnull create_func
    | {func_params_return}
      | {params}: ok
      | | {param}: C: cursor variable in
      |   | {param_detail}: C: cursor variable in
      |     | {name C}: C: cursor variable in
      |     | {type_cursor}: cursor
      | {create_data_type}: text notnull create_func
        | {notnull}: text notnull
          | {type_text}: text

The statement ending at line XXXX

DECLARE PROC printf NO CHECK;

  {declare_proc_no_check_stmt}: ok
  | {name printf}

The statement ending at line XXXX

DECLARE PROC printf ();

test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0404: procedure cannot be both a normal procedure and an unchecked procedure 'printf'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name printf}
  | | {int 0}
  | {proc_params_stmts}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
            | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
            | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE with_kind(
  id INTEGER<some_key>,
  cost REAL<dollars>,
  value REAL<dollars>
);

  {create_table_stmt}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_kind}
  | {col_key_list}
    | {col_def}: id: integer<some_key>
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer<some_key>
    |       | {name some_key}
    | {col_key_list}
      | {col_def}: cost: real<dollars>
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name cost}
      |     | {type_real}: real<dollars>
      |       | {name dollars}
      | {col_key_list}
        | {col_def}: value: real<dollars>
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name value}
              | {type_real}: real<dollars>
                | {name dollars}

The statement ending at line XXXX

DECLARE price_d REAL<dollars>;

  {declare_vars_type}: real<dollars>
  | {name_list}: price_d: real<dollars> variable was_set
  | | {name price_d}: price_d: real<dollars> variable was_set
  | {type_real}: real<dollars>
    | {name dollars}

The statement ending at line XXXX

DECLARE price_e REAL<euros>;

  {declare_vars_type}: real<euros>
  | {name_list}: price_e: real<euros> variable
  | | {name price_e}: price_e: real<euros> variable
  | {type_real}: real<euros>
    | {name euros}

The statement ending at line XXXX

CREATE TABLE bar(
  id INTEGER NOT NULL,
  name TEXT @CREATE(2),
  rate LONG_INT @CREATE(2)
);

  {create_table_stmt}: bar: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bar}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text @create(2)
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name name}
      |   | | {type_text}: text
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 2}
      | {col_key_list}
        | {col_def}: rate: longint @create(2)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name rate}
            | | {type_long}: longint
            | {create_attr}: ok
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER
);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
)
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE foo(
  id INTEGER
)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'foo'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}: err
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  id INTEGER
);

test/sem_test.sql:XXXX:1: error: in str : CQL0142: duplicate column name 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name id}
            | {type_int}: integer

The statement ending at line XXXX

SELECT ID
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name ID}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM with_kind;

  {select_stmt}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | {select_core_list}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | | {select_core}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  |   | {select_expr_list_con}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  |     | {select_expr_list}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  |     | | {star}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  |     | {select_from_etc}: TABLE { with_kind: with_kind }
  |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
  |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
  |       |   | {name with_kind}: TABLE { with_kind: with_kind }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id, name
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE rate > 0;

  {select_stmt}: select: { id: integer notnull, name: text }
  | {select_core_list}: select: { id: integer notnull, name: text }
  | | {select_core}: select: { id: integer notnull, name: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
  |     | {select_expr_list}: select: { id: integer notnull, name: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {dot}: id: integer notnull
  |     | |   | {name T1}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: name: text
  |     |     | {name name}: name: text
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool
  |         | | {gt}: bool
  |         |   | {name rate}: rate: longint
  |         |   | {int 0}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  LEFT JOIN foo AS T2;

  {select_stmt}: select: { id: integer notnull, id: integer }
  | {select_core_list}: select: { id: integer notnull, id: integer }
  | | {select_core}: select: { id: integer notnull, id: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer }
  |     | | {star}: select: { id: integer notnull, id: integer }
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {join_clause}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: foo }
  |       |     | {int 5} {join_left}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |         | {name foo}: TABLE { T2: foo }
  |       |         | {opt_as_alias}
  |       |           | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  CROSS JOIN foo AS T2 ON T1.id = T2.id;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {join_clause}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: foo }
  |       |     | {int 2} {join_cross}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM foo,
bar;

  {select_stmt}: select: { name: text }
  | {select_core_list}: select: { name: text }
  | | {select_core}: select: { name: text }
  |   | {select_expr_list_con}: select: { name: text }
  |     | {select_expr_list}: select: { name: text }
  |     | | {select_expr}: name: text
  |     |   | {name name}: name: text
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM foo AS T1,
bar AS T1,
bar AS T1;

test/sem_test.sql:XXXX:1: error: in table_or_subquery_list : CQL0016: duplicate table name in join 'T1'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: err
  |       |   | {table_or_subquery}: TABLE { T1: bar }
  |       |   | | {name bar}: TABLE { T1: bar }
  |       |   | | {opt_as_alias}
  |       |   |   | {name T1}
  |       |   | {table_or_subquery_list}: TABLE { T1: bar }
  |       |     | {table_or_subquery}: TABLE { T1: bar }
  |       |       | {name bar}: TABLE { T1: bar }
  |       |       | {opt_as_alias}
  |       |         | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo,
bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0065: identifier is ambiguous 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name id}: err
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT not_found
  FROM foo,
bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_found'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name not_found}: err
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' + 'bar' + 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0007: left operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {add}: err
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | | {strlit 'bar'}: text notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' LIKE 'baz';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {like}: bool notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' NOT LIKE 'baz';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_like}: bool notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 LIKE 'baz';

test/sem_test.sql:XXXX:1: error: in num : CQL0042: left operand must be a string in 'LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT LIKE 'baz';

test/sem_test.sql:XXXX:1: error: in num : CQL0042: left operand must be a string in 'NOT LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_like}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' LIKE 2;

test/sem_test.sql:XXXX:1: error: in num : CQL0043: right operand must be a string in 'LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' || 'baz';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' || 1;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1.0 || 'baz';

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {dbl 1.0}: real notnull
  |     |     | {strlit 'baz'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 + 2.0;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {add}: real notnull
  |     |     | {int 1}: integer notnull
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 3 + 4;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {int 3}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id + 'foo'
  FROM foo AS T1;

test/sem_test.sql:XXXX:1: error: in str : CQL0008: right operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {dot}: id: integer notnull
  |     |     | | {name T1}
  |     |     | | {name id}
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' + T1.id
  FROM foo AS T1;

test/sem_test.sql:XXXX:1: error: in str : CQL0007: left operand cannot be a string in '+'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {dot}: id: integer notnull
  |     |       | {name T1}
  |     |       | {name id}
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {and}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL OR 1;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {or}: bool
  |     |     | {null}: null
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL AND 1;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {and}: bool
  |     |     | {null}: null
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (1 = 2) + 1;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' AND 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0007: left operand cannot be a string in 'AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {and}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AND 'foo' OR 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0008: right operand cannot be a string in 'AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {or}: err
  |     |     | {and}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'foo' < 1;

test/sem_test.sql:XXXX:1: error: in lt : CQL0009: incompatible types in expression '<'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {lt}: err
  |     |     | {strlit 'foo'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 > 'foo';

test/sem_test.sql:XXXX:1: error: in gt : CQL0012: incompatible types in expression '>'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {gt}: err
  |     |     | {int 1}: integer notnull
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'baz' <> 'foo';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {ne}: bool notnull
  |     |     | {strlit 'baz'}: text notnull
  |     |     | {strlit 'foo'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 > 'foo' > 2;

test/sem_test.sql:XXXX:1: error: in gt : CQL0012: incompatible types in expression '>'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {gt}: err
  |     |     | {gt}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {strlit 'foo'}: text notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo LIKE 'bar';

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'foo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {like}: err
  |     |     | {name foo}: err
  |     |     | {strlit 'bar'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -1;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {uminus}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {uminus}: err
  |     |     | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1.2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IS NULL;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is}: bool notnull
  |     |     | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IS 1.2;

test/sem_test.sql:XXXX:1: error: in is : CQL0009: incompatible types in expression 'IS'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IS NOT NULL;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is_not}: bool notnull
  |     |     | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -(NOT 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {uminus}: err
  |     |     | {not}: err
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT -'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {uminus}: err
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE real_result2 REAL;

  {declare_vars_type}: real
  | {name_list}: real_result2: real variable was_set
  | | {name real_result2}: real_result2: real variable was_set
  | {type_real}: real

The statement ending at line XXXX

DECLARE FUNC simple_func2 (arg1 INTEGER NOT NULL, arg2 INTEGER NOT NULL, arg3 INTEGER NOT NULL) REAL NOT NULL;

  {declare_func_stmt}: real notnull
  | {name simple_func2}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer notnull variable in
    | | | {param_detail}: arg1: integer notnull variable in
    | |   | {name arg1}: arg1: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: arg2: integer notnull variable in
    |   | | {param_detail}: arg2: integer notnull variable in
    |   |   | {name arg2}: arg2: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: arg3: integer notnull variable in
    |       | {param_detail}: arg3: integer notnull variable in
    |         | {name arg3}: arg3: integer notnull variable in
    |         | {notnull}: integer notnull
    |           | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

SET real_result2 := simple_func2(2, 3, 4);

  {assign}: real_result2: real variable was_set
  | {name real_result2}: real_result2: real variable was_set
  | {call}: real notnull
    | {name simple_func2}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 2}: integer notnull
        | {arg_list}
          | {int 3}: integer notnull
          | {arg_list}
            | {int 4}: integer notnull

The statement ending at line XXXX

DECLARE int_result INTEGER;

  {declare_vars_type}: integer
  | {name_list}: int_result: integer variable was_set
  | | {name int_result}: int_result: integer variable was_set
  | {type_int}: integer

The statement ending at line XXXX

DECLARE FUNC simple_func3 (arg1 INTEGER NOT NULL) INTEGER NOT NULL;

  {declare_func_stmt}: integer notnull
  | {name simple_func3}: integer notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer notnull variable in
    |   | {param_detail}: arg1: integer notnull variable in
    |     | {name arg1}: arg1: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {notnull}: integer notnull
      | {type_int}: integer

The statement ending at line XXXX

SET int_result := simple_func3(2);

  {assign}: int_result: integer variable was_set
  | {name int_result}: int_result: integer variable was_set
  | {call}: integer notnull
    | {name simple_func3}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 2}: integer notnull

The statement ending at line XXXX

DECLARE real_result4 REAL;

  {declare_vars_type}: real
  | {name_list}: real_result4: real variable was_set
  | | {name real_result4}: real_result4: real variable was_set
  | {type_real}: real

The statement ending at line XXXX

SET real_result4 := simple_func2(simple_func3(1), 2, 3);

  {assign}: real_result4: real variable was_set
  | {name real_result4}: real_result4: real variable was_set
  | {call}: real notnull
    | {name simple_func2}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {call}: integer notnull
        | | {name simple_func3}
        | | {call_arg_list}
        |   | {call_filter_clause}
        |   | {arg_list}: ok
        |     | {int 1}: integer notnull
        | {arg_list}
          | {int 2}: integer notnull
          | {arg_list}
            | {int 3}: integer notnull

The statement ending at line XXXX

SET real_result4 := simple_func2(1, 2);

test/sem_test.sql:XXXX:1: error: in call : CQL0212: too few arguments provided to procedure 'simple_func2'

  {assign}: err
  | {name real_result4}: real_result4: real variable was_set
  | {call}: err
    | {name simple_func2}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 2}: integer notnull

The statement ending at line XXXX

SELECT -'x' IS NULL;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {uminus}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -(NOT 1);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {uminus}: integer notnull
  |     |     | {not}: bool notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -1.2;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {uminus}: real notnull
  |     |     | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 * 2;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mul}: integer notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 3 - 4;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {sub}: integer notnull
  |     |     | {int 3}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 6 / 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {div}: integer notnull
  |     |     | {int 6}: integer notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 6 % 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mod}: integer notnull
  |     |     | {int 6}: integer notnull
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 2 >= 1;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {ge}: bool notnull
  |     |     | {int 2}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 <= 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {le}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 2 = 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {int 2}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo,
bar;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}: TABLE { bar: bar }
  |       |   | {table_or_subquery}: TABLE { bar: bar }
  |       |     | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS one, 2 AS two;

  {select_stmt}: select: { one: integer notnull, two: integer notnull }
  | {select_core_list}: select: { one: integer notnull, two: integer notnull }
  | | {select_core}: select: { one: integer notnull, two: integer notnull }
  |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
  |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
  |     | | {select_expr}: one: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name one}
  |     | | {select_expr_list}
  |     |   | {select_expr}: two: integer notnull
  |     |     | {int 2}: integer notnull
  |     |     | {opt_as_alias}
  |     |       | {name two}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *;

test/sem_test.sql:XXXX:1: error: in star : CQL0052: select * cannot be used with no FROM clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT *
  FROM (SELECT 1);

test/sem_test.sql:XXXX:1: error: in star : CQL0055: all columns in the select must have a name

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}: err
        |     | {select_from_etc}: TABLE { select: select }
        |       | {table_or_subquery_list}: TABLE { select: select }
        |       | | {table_or_subquery}: TABLE { select: select }
        |       |   | {select_stmt}: select: { _anon: integer notnull }
        |       |     | {select_core_list}: select: { _anon: integer notnull }
        |       |     | | {select_core}: select: { _anon: integer notnull }
        |       |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     |     | | {select_expr}: integer notnull
        |       |     |     |   | {int 1}: integer notnull
        |       |     |     | {select_from_etc}: ok
        |       |     |       | {select_where}
        |       |     |         | {select_groupby}
        |       |     |           | {select_having}
        |       |     | {select_orderby}
        |       |       | {select_limit}
        |       |         | {select_offset}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT T.*
  FROM (SELECT 1) AS T;

test/sem_test.sql:XXXX:1: error: in table_star : CQL0055: all columns in the select must have a name

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {table_star}: err
        |     |   | {name T}
        |     | {select_from_etc}: TABLE { T: select }
        |       | {table_or_subquery_list}: TABLE { T: select }
        |       | | {table_or_subquery}: TABLE { T: select }
        |       |   | {select_stmt}: select: { _anon: integer notnull }
        |       |   | | {select_core_list}: select: { _anon: integer notnull }
        |       |   | | | {select_core}: select: { _anon: integer notnull }
        |       |   | |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |   | |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |   | |     | | {select_expr}: integer notnull
        |       |   | |     |   | {int 1}: integer notnull
        |       |   | |     | {select_from_etc}: ok
        |       |   | |       | {select_where}
        |       |   | |         | {select_groupby}
        |       |   | |           | {select_having}
        |       |   | | {select_orderby}
        |       |   |   | {select_limit}
        |       |   |     | {select_offset}
        |       |   | {opt_as_alias}
        |       |     | {name T}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT 10 AS T
  WHERE 1;

  {select_stmt}: select: { T: integer notnull }
  | {select_core_list}: select: { T: integer notnull }
  | | {select_core}: select: { T: integer notnull }
  |   | {select_expr_list_con}: select: { T: integer notnull }
  |     | {select_expr_list}: select: { T: integer notnull }
  |     | | {select_expr}: T: integer notnull
  |     |   | {int 10}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name T}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {opt_where}: integer notnull
  |         | | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT c
  WHERE 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'c'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name c}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {opt_where}: integer notnull
  |         | | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE id > 1000;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {int 1000}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS x
  FROM foo
  WHERE x > 1000;

test/sem_test.sql:XXXX:1: error: in str : CQL0436: alias referenced from WHERE, GROUP BY, HAVING, or WINDOW clause 'x'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     |   | {opt_as_alias}
  |     |     | {name x}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {gt}: err
  |         |   | {name x}: err
  |         |   | {int 1000}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, name AS y
  FROM bar
  GROUP BY y
  HAVING count(name) > 10;

test/sem_test.sql:XXXX:1: error: in str : CQL0436: alias referenced from WHERE, GROUP BY, HAVING, or WINDOW clause 'y'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {name name}
  |     |     | {opt_as_alias}
  |     |       | {name y}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |     | {name y}: err
  |           | {select_having}
  |             | {opt_having}: bool notnull
  |               | {gt}: bool notnull
  |                 | {call}: integer notnull
  |                 | | {name count}: integer notnull
  |                 | | {call_arg_list}
  |                 |   | {call_filter_clause}
  |                 |   | {arg_list}: ok
  |                 |     | {name name}: name: text
  |                 | {int 10}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, name AS y
  FROM bar
  GROUP BY name
  HAVING count(y) > 10;

test/sem_test.sql:XXXX:1: error: in str : CQL0436: alias referenced from WHERE, GROUP BY, HAVING, or WINDOW clause 'y'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {name name}
  |     |     | {opt_as_alias}
  |     |       | {name y}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name name}: name: text
  |           | {select_having}
  |             | {opt_having}: err
  |               | {gt}: err
  |                 | {call}: err
  |                 | | {name count}
  |                 | | {call_arg_list}
  |                 |   | {call_filter_clause}
  |                 |   | {arg_list}: err
  |                 |     | {name y}: err
  |                 | {int 10}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, name AS y, 
  row_number() OVER w
  FROM bar
  WINDOW 
    w AS (ORDER BY y);

test/sem_test.sql:XXXX:1: error: in str : CQL0436: alias referenced from WHERE, GROUP BY, HAVING, or WINDOW clause 'y'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |   | | {name name}
  |     |   | | {opt_as_alias}
  |     |   |   | {name y}
  |     |   | {select_expr_list}
  |     |     | {select_expr}
  |     |       | {window_func_inv}
  |     |         | {call}
  |     |         | | {name row_number}
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {name w}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: err
  |               | {window_clause}: err
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: err
  |                     | {name w}
  |                     | {window_defn}: err
  |                       | {window_defn_orderby}
  |                         | {opt_orderby}: err
  |                           | {orderby_list}: err
  |                             | {orderby_item}
  |                               | {name y}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  GROUP BY count(id);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |     | {call}: err
  |           |       | {name count}
  |           |       | {call_arg_list}
  |           |         | {call_filter_clause}
  |           |         | {arg_list}: ok
  |           |           | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
ORDER BY count(id);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {call}: integer notnull
    |       | {name count}: integer notnull
    |       | {call_arg_list}
    |         | {call_filter_clause}
    |         | {arg_list}: ok
    |           | {name id}: id: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name
  FROM bar
  WHERE name LIKE "%foo%";

test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     |   | {opt_as_alias}
  |     |     | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {like}: err
  |         |   | {name name}: err
  |         |   | {strlit '%foo%'}: text notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name
  FROM bar
  WHERE bar.name LIKE "%foo%";

  {select_stmt}: select: { name: integer notnull }
  | {select_core_list}: select: { name: integer notnull }
  | | {select_core}: select: { name: integer notnull }
  |   | {select_expr_list_con}: select: { name: integer notnull }
  |     | {select_expr_list}: select: { name: integer notnull }
  |     | | {select_expr}: name: integer notnull
  |     |   | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name name}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: bool
  |         | | {like}: bool
  |         |   | {dot}: name: text
  |         |   | | {name bar}
  |         |   | | {name name}
  |         |   | {strlit '%foo%'}: text notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name
  FROM bar
  WHERE id > ( SELECT count(rate)
  FROM bar
  WHERE name LIKE "%foo%" );

test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     |   | {opt_as_alias}
  |     |     | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {gt}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: err
  |         |     | {select_core_list}: err
  |         |     | | {select_core}: err
  |         |     |   | {select_expr_list_con}: err
  |         |     |     | {select_expr_list}: err
  |         |     |     | | {select_expr}
  |         |     |     |   | {call}
  |         |     |     |     | {name count}
  |         |     |     |     | {call_arg_list}
  |         |     |     |       | {call_filter_clause}
  |         |     |     |       | {arg_list}
  |         |     |     |         | {name rate}
  |         |     |     | {select_from_etc}: err
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {opt_where}: err
  |         |     |         | | {like}: err
  |         |     |         |   | {name name}: err
  |         |     |         |   | {strlit '%foo%'}: text notnull
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name
  FROM bar
  WHERE id > ( SELECT count(rate)
  FROM bar
  WHERE bar.name LIKE "%foo%" );

  {select_stmt}: select: { name: integer notnull }
  | {select_core_list}: select: { name: integer notnull }
  | | {select_core}: select: { name: integer notnull }
  |   | {select_expr_list_con}: select: { name: integer notnull }
  |     | {select_expr_list}: select: { name: integer notnull }
  |     | | {select_expr}: name: integer notnull
  |     |   | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name name}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: _anon: integer notnull
  |         |     | {select_core_list}: select: { _anon: integer notnull }
  |         |     | | {select_core}: select: { _anon: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |         |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |         |     |     | | {select_expr}: integer notnull
  |         |     |     |   | {call}: integer notnull
  |         |     |     |     | {name count}: integer notnull
  |         |     |     |     | {call_arg_list}
  |         |     |     |       | {call_filter_clause}
  |         |     |     |       | {arg_list}: ok
  |         |     |     |         | {name rate}: rate: longint
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {opt_where}: bool
  |         |     |         | | {like}: bool
  |         |     |         |   | {dot}: name: text
  |         |     |         |   | | {name bar}
  |         |     |         |   | | {name name}
  |         |     |         |   | {strlit '%foo%'}: text notnull
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name, name
  FROM bar
  GROUP BY name
  HAVING count(name) > 10;

test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'
test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | | {opt_as_alias}
  |     | |   | {name name}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |     | {name name}: err
  |           | {select_having}
  |             | {opt_having}: err
  |               | {gt}: err
  |                 | {call}: err
  |                 | | {name count}
  |                 | | {call_arg_list}
  |                 |   | {call_filter_clause}
  |                 |   | {arg_list}: err
  |                 |     | {name name}: err
  |                 | {int 10}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name, name
  FROM bar
  GROUP BY name
  HAVING count(name) > 10;

test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'
test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | | {opt_as_alias}
  |     | |   | {name name}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {name name}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |     | {name name}: err
  |           | {select_having}
  |             | {opt_having}: err
  |               | {gt}: err
  |                 | {call}: err
  |                 | | {name count}
  |                 | | {call_arg_list}
  |                 |   | {call_filter_clause}
  |                 |   | {arg_list}: err
  |                 |     | {name name}: err
  |                 | {int 10}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS name, name, 
  row_number() OVER w
  FROM bar
  WINDOW 
    w AS (ORDER BY name);

test/sem_test.sql:XXXX:1: error: in str : CQL0435: must use qualified form to avoid ambiguity with alias 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | | {opt_as_alias}
  |     | |   | {name name}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |   | | {name name}
  |     |   | {select_expr_list}
  |     |     | {select_expr}
  |     |       | {window_func_inv}
  |     |         | {call}
  |     |         | | {name row_number}
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {name w}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: err
  |               | {window_clause}: err
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: err
  |                     | {name w}
  |                     | {window_defn}: err
  |                       | {window_defn_orderby}
  |                         | {opt_orderby}: err
  |                           | {orderby_list}: err
  |                             | {orderby_item}
  |                               | {name name}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM goo;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined 'goo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name goo}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE big(
  l LONG_INT,
  r REAL
);

  {create_table_stmt}: big: { l: longint, r: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name big}
  | {col_key_list}
    | {col_def}: l: longint
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name l}
    |     | {type_long}: longint
    | {col_key_list}
      | {col_def}: r: real
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name r}
            | {type_real}: real

The statement ending at line XXXX

SELECT l
  FROM big;

  {select_stmt}: select: { l: longint }
  | {select_core_list}: select: { l: longint }
  | | {select_core}: select: { l: longint }
  |   | {select_expr_list_con}: select: { l: longint }
  |     | {select_expr_list}: select: { l: longint }
  |     | | {select_expr}: l: longint
  |     |   | {name l}: l: longint
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * 1
  FROM big;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {mul}: longint
  |     |     | {name l}: l: longint
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * (1 = 1)
  FROM big;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {mul}: longint
  |     |     | {name l}: l: longint
  |     |     | {eq}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT l * 2.0
  FROM big;

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {mul}: real
  |     |     | {name l}: l: longint
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: TABLE { big: big }
  |       | {table_or_subquery_list}: TABLE { big: big }
  |       | | {table_or_subquery}: TABLE { big: big }
  |       |   | {name big}: TABLE { big: big }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x' = 1;

test/sem_test.sql:XXXX:1: error: in eq : CQL0009: incompatible types in expression '='

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {eq}: err
  |     |       | {strlit 'x'}: text notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 'x' LIKE 42 THEN 'foo'
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0043: right operand must be a string in 'LIKE'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |         | {when}
  |     |           | {like}: err
  |     |           | | {strlit 'x'}: text notnull
  |     |           | | {int 42}: integer notnull
  |     |           | {strlit 'foo'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 = 2 THEN 'foo'
WHEN 3 = 4 THEN 'bar'
END;

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {case_expr}: text
  |     |     | {connector}: text
  |     |       | {case_list}: text notnull
  |     |         | {when}: text notnull
  |     |         | | {eq}: bool notnull
  |     |         | | | {int 1}: integer notnull
  |     |         | | | {int 2}: integer notnull
  |     |         | | {strlit 'foo'}: text notnull
  |     |         | {case_list}: text notnull
  |     |           | {when}: text notnull
  |     |             | {eq}: bool notnull
  |     |             | | {int 3}: integer notnull
  |     |             | | {int 4}: integer notnull
  |     |             | {strlit 'bar'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 = 2 THEN 'foo'
WHEN 3 = 4 THEN 2
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'then'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |         | {when}: text notnull
  |     |         | | {eq}: bool notnull
  |     |         | | | {int 1}: integer notnull
  |     |         | | | {int 2}: integer notnull
  |     |         | | {strlit 'foo'}: text notnull
  |     |         | {case_list}: err
  |     |           | {when}
  |     |             | {eq}: bool notnull
  |     |             | | {int 3}: integer notnull
  |     |             | | {int 4}: integer notnull
  |     |             | {int 2}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 'x' THEN 'foo'
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'when'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |         | {when}
  |     |           | {strlit 'x'}: err
  |     |           | {strlit 'foo'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 'x' WHEN 'y' THEN 1
WHEN 'z' THEN 2
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {strlit 'x'}: text notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer notnull
  |     |         | {when}: integer notnull
  |     |         | | {strlit 'y'}: text notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {strlit 'z'}: text notnull
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 2 WHEN 1.0 THEN 1
WHEN 3 THEN 2
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {int 2}: integer notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer notnull
  |     |         | {when}: integer notnull
  |     |         | | {dbl 1.0}: real notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {int 3}: integer notnull
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 3 WHEN 'x' THEN 1
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'when'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {int 3}: integer notnull
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |         | {when}
  |     |           | {strlit 'x'}: err
  |     |           | {int 1}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 4 WHEN 1 THEN 1
ELSE 2.0
END;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {case_expr}: real notnull
  |     |     | {int 4}: integer notnull
  |     |     | {connector}: real notnull
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 5 WHEN 0 THEN NULL
WHEN 1 THEN 1
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {int 5}: integer notnull
  |     |     | {connector}: integer
  |     |       | {case_list}: integer
  |     |         | {when}: null
  |     |         | | {int 0}: integer notnull
  |     |         | | {null}: null
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {int 1}: integer notnull
  |     |             | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 6 WHEN 0 THEN 1.0
ELSE 2.0
END;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {case_expr}: real notnull
  |     |     | {int 6}: integer notnull
  |     |     | {connector}: real notnull
  |     |       | {case_list}: real notnull
  |     |       | | {when}: real notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {dbl 1.0}: real notnull
  |     |       | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 7 WHEN 0 THEN 1 = 2
ELSE NULL
END;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {case_expr}: bool
  |     |     | {int 7}: integer notnull
  |     |     | {connector}: bool
  |     |       | {case_list}: bool notnull
  |     |       | | {when}: bool notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {eq}: bool notnull
  |     |       |     | {int 1}: integer notnull
  |     |       |     | {int 2}: integer notnull
  |     |       | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE 8 WHEN 0 THEN 1
ELSE 'bar'
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'else'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {int 8}: integer notnull
  |     |     | {connector}
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 0}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       | {strlit 'bar'}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE NOT 'x' WHEN 1 THEN 0
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {connector}
  |     |       | {case_list}
  |     |         | {when}
  |     |           | {int 1}
  |     |           | {int 0}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 BETWEEN 0 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN 'a' AND 'z';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {strlit 'a'}: text notnull
  |     |       | {strlit 'z'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN 2 AND 3;

test/sem_test.sql:XXXX:1: error: in between : CQL0009: incompatible types in expression 'BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' BETWEEN NULL AND 3;

test/sem_test.sql:XXXX:1: error: in between : CQL0009: incompatible types in expression 'BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {null}: null
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL BETWEEN 1 AND 2;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {between}: bool
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL BETWEEN 1 AND 'x';

test/sem_test.sql:XXXX:1: error: in between : CQL0012: incompatible types in expression 'BETWEEN/AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 'x') BETWEEN 1122 AND 3344;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {between}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 1122}: integer notnull
  |     |       | {int 3344}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT BETWEEN 0 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN 'a' AND 'z';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {strlit 'a'}: text notnull
  |     |       | {strlit 'z'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN 2 AND 3;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0009: incompatible types in expression 'NOT BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT BETWEEN NULL AND 3;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0009: incompatible types in expression 'NOT BETWEEN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {null}: null
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT BETWEEN 1 AND 2;

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_between}: bool
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT BETWEEN 1 AND 'x';

test/sem_test.sql:XXXX:1: error: in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN/AND'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {null}: null
  |     |     | {range}
  |     |       | {int 1}: integer notnull
  |     |       | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 'x') NOT BETWEEN 1122 AND 3344;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_between}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {range}
  |     |       | {int 1122}: integer notnull
  |     |       | {int 3344}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (SELECT 1 AS id, 'x' AS name) AS Item;

  {select_stmt}: select: { id: integer notnull, name: text notnull }
  | {select_core_list}: select: { id: integer notnull, name: text notnull }
  | | {select_core}: select: { id: integer notnull, name: text notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
  |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
  |     | | {star}: select: { id: integer notnull, name: text notnull }
  |     | {select_from_etc}: TABLE { Item: select }
  |       | {table_or_subquery_list}: TABLE { Item: select }
  |       | | {table_or_subquery}: TABLE { Item: select }
  |       |   | {select_stmt}: select: { id: integer notnull, name: text notnull }
  |       |   | | {select_core_list}: select: { id: integer notnull, name: text notnull }
  |       |   | | | {select_core}: select: { id: integer notnull, name: text notnull }
  |       |   | |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
  |       |   | |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
  |       |   | |     | | {select_expr}: id: integer notnull
  |       |   | |     | | | {int 1}: integer notnull
  |       |   | |     | | | {opt_as_alias}
  |       |   | |     | |   | {name id}
  |       |   | |     | | {select_expr_list}
  |       |   | |     |   | {select_expr}: name: text notnull
  |       |   | |     |     | {strlit 'x'}: text notnull
  |       |   | |     |     | {opt_as_alias}
  |       |   | |     |       | {name name}
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name Item}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (SELECT 1 AS id1, 'x' AS name) AS Item
  INNER JOIN (SELECT 1 AS id2, 'b' AS brand) AS ItemBrand ON ItemBrand.id2 = Item.id1;

  {select_stmt}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  | {select_core_list}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  | | {select_core}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |   | {select_expr_list_con}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | {select_expr_list}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | | {star}: select: { id1: integer notnull, name: text notnull, id2: integer notnull, brand: text notnull }
  |     | {select_from_etc}: JOIN { Item: select, ItemBrand: select }
  |       | {join_clause}: JOIN { Item: select, ItemBrand: select }
  |       | | {table_or_subquery}: TABLE { Item: select }
  |       | | | {select_stmt}: select: { id1: integer notnull, name: text notnull }
  |       | | | | {select_core_list}: select: { id1: integer notnull, name: text notnull }
  |       | | | | | {select_core}: select: { id1: integer notnull, name: text notnull }
  |       | | | |   | {select_expr_list_con}: select: { id1: integer notnull, name: text notnull }
  |       | | | |     | {select_expr_list}: select: { id1: integer notnull, name: text notnull }
  |       | | | |     | | {select_expr}: id1: integer notnull
  |       | | | |     | | | {int 1}: integer notnull
  |       | | | |     | | | {opt_as_alias}
  |       | | | |     | |   | {name id1}
  |       | | | |     | | {select_expr_list}
  |       | | | |     |   | {select_expr}: name: text notnull
  |       | | | |     |     | {strlit 'x'}: text notnull
  |       | | | |     |     | {opt_as_alias}
  |       | | | |     |       | {name name}
  |       | | | |     | {select_from_etc}: ok
  |       | | | |       | {select_where}
  |       | | | |         | {select_groupby}
  |       | | | |           | {select_having}
  |       | | | | {select_orderby}
  |       | | |   | {select_limit}
  |       | | |     | {select_offset}
  |       | | | {opt_as_alias}
  |       | |   | {name Item}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { Item: select, ItemBrand: select }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { ItemBrand: select }
  |       |       | | {select_stmt}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | | {select_core_list}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | | | {select_core}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |   | {select_expr_list_con}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |     | {select_expr_list}: select: { id2: integer notnull, brand: text notnull }
  |       |       | | |     | | {select_expr}: id2: integer notnull
  |       |       | | |     | | | {int 1}: integer notnull
  |       |       | | |     | | | {opt_as_alias}
  |       |       | | |     | |   | {name id2}
  |       |       | | |     | | {select_expr_list}
  |       |       | | |     |   | {select_expr}: brand: text notnull
  |       |       | | |     |     | {strlit 'b'}: text notnull
  |       |       | | |     |     | {opt_as_alias}
  |       |       | | |     |       | {name brand}
  |       |       | | |     | {select_from_etc}: ok
  |       |       | | |       | {select_where}
  |       |       | | |         | {select_groupby}
  |       |       | | |           | {select_having}
  |       |       | | | {select_orderby}
  |       |       | |   | {select_limit}
  |       |       | |     | {select_offset}
  |       |       | | {opt_as_alias}
  |       |       |   | {name ItemBrand}
  |       |       | {join_cond}: JOIN { Item: select, ItemBrand: select }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id2: integer notnull
  |       |           | | {name ItemBrand}
  |       |           | | {name id2}
  |       |           | {dot}: id1: integer notnull
  |       |             | {name Item}
  |       |             | {name id1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 AS unused ) AS result;

  {select_stmt}: select: { result: integer notnull }
  | {select_core_list}: select: { result: integer notnull }
  | | {select_core}: select: { result: integer notnull }
  |   | {select_expr_list_con}: select: { result: integer notnull }
  |     | {select_expr_list}: select: { result: integer notnull }
  |     | | {select_expr}: result: integer notnull
  |     |   | {select_stmt}: unused: integer notnull
  |     |   | | {select_core_list}: select: { unused: integer notnull }
  |     |   | | | {select_core}: select: { unused: integer notnull }
  |     |   | |   | {select_expr_list_con}: select: { unused: integer notnull }
  |     |   | |     | {select_expr_list}: select: { unused: integer notnull }
  |     |   | |     | | {select_expr}: unused: integer notnull
  |     |   | |     |   | {int 1}: integer notnull
  |     |   | |     |   | {opt_as_alias}
  |     |   | |     |     | {name unused}
  |     |   | |     | {select_from_etc}: ok
  |     |   | |       | {select_where}
  |     |   | |         | {select_groupby}
  |     |   | |           | {select_having}
  |     |   | | {select_orderby}
  |     |   |   | {select_limit}
  |     |   |     | {select_offset}
  |     |   | {opt_as_alias}
  |     |     | {name result}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1, 2 );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0232: nested select expression must return exactly one column

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {select_stmt}: err
  |     |     | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |     |     | | {select_expr}: integer notnull
  |     |     |     | | | {int 1}: integer notnull
  |     |     |     | | {select_expr_list}
  |     |     |     |   | {select_expr}: integer notnull
  |     |     |     |     | {int 2}: integer notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 * ( SELECT 1 );

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {mul}: integer notnull
  |     |     | {int 1}: integer notnull
  |     |     | {select_stmt}: _anon: integer notnull
  |     |       | {select_core_list}: select: { _anon: integer notnull }
  |     |       | | {select_core}: select: { _anon: integer notnull }
  |     |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |       |     | | {select_expr}: integer notnull
  |     |       |     |   | {int 1}: integer notnull
  |     |       |     | {select_from_etc}: ok
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 ) || ( SELECT 2 );

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {select_stmt}: _anon: integer notnull
  |     |     | | {select_core_list}: select: { _anon: integer notnull }
  |     |     | | | {select_core}: select: { _anon: integer notnull }
  |     |     | |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | |     | | {select_expr}: integer notnull
  |     |     | |     |   | {int 1}: integer notnull
  |     |     | |     | {select_from_etc}: ok
  |     |     | |       | {select_where}
  |     |     | |         | {select_groupby}
  |     |     | |           | {select_having}
  |     |     | | {select_orderby}
  |     |     |   | {select_limit}
  |     |     |     | {select_offset}
  |     |     | {select_stmt}: _anon: integer notnull
  |     |       | {select_core_list}: select: { _anon: integer notnull }
  |     |       | | {select_core}: select: { _anon: integer notnull }
  |     |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |       |     | | {select_expr}: integer notnull
  |     |       |     |   | {int 2}: integer notnull
  |     |       |     | {select_from_etc}: ok
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo,
bar);

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
  |       | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       | | {table_or_subquery}: JOIN { foo: foo, bar: bar }
  |       |   | {table_or_subquery_list}: JOIN { foo: foo, bar: bar }
  |       |     | {table_or_subquery}: TABLE { foo: foo }
  |       |     | | {name foo}: TABLE { foo: foo }
  |       |     | {table_or_subquery_list}: TABLE { bar: bar }
  |       |       | {table_or_subquery}: TABLE { bar: bar }
  |       |         | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo,
foo);

test/sem_test.sql:XXXX:1: error: in table_or_subquery_list : CQL0016: duplicate table name in join 'foo'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {table_or_subquery_list}: err
  |       |     | {table_or_subquery}: TABLE { foo: foo }
  |       |     | | {name foo}: TABLE { foo: foo }
  |       |     | {table_or_subquery_list}: TABLE { foo: foo }
  |       |       | {table_or_subquery}: TABLE { foo: foo }
  |       |         | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {dot}: name: text
  |           |       | {name T2}
  |           |       | {name name}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  INNER JOIN bar AS T2 ON 'v'
  WHERE 'w'
  HAVING 'x'
LIMIT 'y';

test/sem_test.sql:XXXX:1: error: in on : CQL0015: expected numeric expression 'ON'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {on}: err
  |       |         | {strlit 'v'}: err
  |       | {select_where}
  |         | {opt_where}
  |         | | {strlit 'w'}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_having}
  |               | {strlit 'x'}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {strlit 'y'}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE 'w'
  HAVING 'x'
LIMIT 'y';

test/sem_test.sql:XXXX:1: error: in opt_where : CQL0015: expected numeric expression 'WHERE'
test/sem_test.sql:XXXX:1: error: in opt_having : CQL0099: HAVING clause requires GROUP BY clause
test/sem_test.sql:XXXX:1: error: in opt_having : CQL0015: expected numeric expression 'HAVING'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {strlit 'w'}: err
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_having}: err
  |               | {strlit 'x'}: err
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {strlit 'y'}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
ORDER BY bogus
LIMIT 'y';

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'
test/sem_test.sql:XXXX:1: error: in opt_limit : CQL0015: expected numeric expression 'LIMIT'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {orderby_list}: err
    |   | {orderby_item}
    |     | {name bogus}: err
    | {select_limit}
      | {opt_limit}: err
      | | {strlit 'y'}: err
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT NOT 'x' );

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {select_stmt}: err
  |     |     | {select_core_list}: err
  |     |     | | {select_core}: err
  |     |     |   | {select_expr_list_con}: err
  |     |     |     | {select_expr_list}: err
  |     |     |     | | {select_expr}: err
  |     |     |     |   | {not}: err
  |     |     |     |     | {strlit 'x'}: text notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IN (1, 2, NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IN ('x', 2);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}
  |     |         | {int 2}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' IN ('x', 1);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0009: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN (1, 2);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {in_pred}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {in_pred}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL IN (1, 'x');

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 'x') IN (1, 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {expr_list}
  |     |       | {int 1}
  |     |       | {expr_list}
  |     |         | {strlit 'x'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT DISTINCT 1 IN (1, NOT 'x', 'y');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_opts}
  |   | | {distinct}
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {in_pred}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: err
  |     |         | {not}: err
  |     |         | | {strlit 'x'}: text notnull
  |     |         | {expr_list}
  |     |           | {strlit 'y'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT IN (1, 2, NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_in}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 NOT IN ('x', 2);

test/sem_test.sql:XXXX:1: error: in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {int 1}: integer notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}
  |     |         | {int 2}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_in}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT IN ('x', 1);

test/sem_test.sql:XXXX:1: error: in not_in : CQL0009: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN (1, 2);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_in}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN ('x', 'y', NULL);

  {select_stmt}: select: { _anon: bool }
  | {select_core_list}: select: { _anon: bool }
  | | {select_core}: select: { _anon: bool }
  |   | {select_expr_list_con}: select: { _anon: bool }
  |     | {select_expr_list}: select: { _anon: bool }
  |     | | {select_expr}: bool
  |     |   | {not_in}: bool
  |     |     | {null}: null
  |     |     | {expr_list}: text notnull
  |     |       | {strlit 'x'}: text notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'y'}: text notnull
  |     |         | {expr_list}: null
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL NOT IN (1, 'x');

test/sem_test.sql:XXXX:1: error: in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_in}: err
  |     |     | {null}: null
  |     |     | {expr_list}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {expr_list}: text notnull
  |     |         | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT f1, f2, ViewAlias.f3
  FROM MyView AS ViewAlias;

  {select_stmt}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {select_core_list}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | | {select_core}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |   | {select_expr_list_con}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |     | {select_expr_list}: select: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  |     | | {select_expr}: f1: integer notnull
  |     | | | {name f1}: f1: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: f2: integer notnull
  |     |   | | {name f2}: f2: integer notnull
  |     |   | {select_expr_list}
  |     |     | {select_expr}: f3: integer notnull
  |     |       | {dot}: f3: integer notnull
  |     |         | {name ViewAlias}
  |     |         | {name f3}
  |     | {select_from_etc}: TABLE { ViewAlias: MyView }
  |       | {table_or_subquery_list}: TABLE { ViewAlias: MyView }
  |       | | {table_or_subquery}: TABLE { ViewAlias: MyView }
  |       |   | {name MyView}: TABLE { ViewAlias: MyView }
  |       |   | {opt_as_alias}
  |       |     | {name ViewAlias}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT 1 AS y;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_view_stmt : CREATE VIEW MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3
test/sem_test.sql:XXXX:1: error: in create_view_stmt : CREATE VIEW MyView AS
SELECT 1 AS y
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'MyView'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}: err
      | {select_stmt}: MyView: { y: integer notnull }
        | {select_core_list}: MyView: { y: integer notnull }
        | | {select_core}: MyView: { y: integer notnull }
        |   | {select_expr_list_con}: MyView: { y: integer notnull }
        |     | {select_expr_list}: MyView: { y: integer notnull }
        |     | | {select_expr}: y: integer notnull
        |     |   | {int 1}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name y}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW foo AS
SELECT 2 AS x;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
)
test/sem_test.sql:XXXX:1: error: in create_view_stmt : CREATE VIEW foo AS
SELECT 2 AS x
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'foo'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name foo}: err
      | {select_stmt}: foo: { x: integer notnull }
        | {select_core_list}: foo: { x: integer notnull }
        | | {select_core}: foo: { x: integer notnull }
        |   | {select_expr_list_con}: foo: { x: integer notnull }
        |     | {select_expr_list}: foo: { x: integer notnull }
        |     | | {select_expr}: x: integer notnull
        |     |   | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyView AS
SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW V AS
SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name V}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM V;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined 'V'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name V}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE INDEX index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_4 ON foo (id) @DELETE(1, AMigrateProc);

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0321: migration proc not allowed on object 'index_4'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_4}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
      | | {indexed_columns}
      |   | {indexed_column}
      |     | {name id}
      | {delete_attr}
        | {version_annotation}
          | {int 1}
          | {name AMigrateProc}

The statement ending at line XXXX

CREATE INDEX index_1 ON bar (id);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_index_stmt : CREATE INDEX index_1 ON foo (id)
test/sem_test.sql:XXXX:1: error: in create_index_stmt : CREATE INDEX index_1 ON bar (id)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0018: duplicate index name 'index_1'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_1}: err
  | | {name bar}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_2 ON doesNotExist (id);

test/sem_test.sql:XXXX:1: error: in str : CQL0019: create index table name not found 'doesNotExist'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_2}
  | | {name doesNotExist}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

CREATE INDEX index_3 ON foo (doesNotExist);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'doesNotExist'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_3}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}: err
          | {indexed_column}
            | {name doesNotExist}: err

The statement ending at line XXXX

CREATE INDEX index_4 ON foo (id + id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_4}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {add}: integer notnull
              | {name id}: id: integer notnull
              | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_5 ON foo (NOT 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_5}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}: err
          | {indexed_column}
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE INDEX index_6 ON foo (id + id, id + id);

test/sem_test.sql:XXXX:1: error: in add : CQL0172: name list has duplicate name 'id + id'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_6}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}: err
          | {indexed_column}
          | | {add}: integer notnull
          |   | {name id}: id: integer notnull
          |   | {name id}: id: integer notnull
          | {indexed_columns}
            | {indexed_column}
              | {add}: err
                | {name id}: id: integer notnull
                | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE INDEX index_7 ON foo (id + id)
  WHERE id < 100;

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_7}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
        | | {indexed_column}
        |   | {add}: integer notnull
        |     | {name id}: id: integer notnull
        |     | {name id}: id: integer notnull
        | {opt_where}: bool notnull
          | {lt}: bool notnull
            | {name id}: id: integer notnull primary_key autoinc
            | {int 100}: integer notnull

The statement ending at line XXXX

CREATE INDEX index_8 ON foo (id)
  WHERE NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_8}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
        | | {indexed_column}
        |   | {name id}: id: integer notnull
        | {opt_where}: err
          | {not}: err
            | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE INDEX index_9 ON foo (id)
  WHERE x = 5;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'x'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_9}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
        | | {indexed_column}
        |   | {name id}: id: integer notnull
        | {opt_where}: err
          | {eq}: err
            | {name x}: err
            | {int 5}: integer notnull

The statement ending at line XXXX

CREATE INDEX index_10 ON foo (id)
  WHERE 'hi';

test/sem_test.sql:XXXX:1: error: in str : CQL0015: expected numeric expression 'WHERE'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_10}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
        | | {indexed_column}
        |   | {name id}: id: integer notnull
        | {opt_where}: err
          | {strlit 'hi'}: err

The statement ending at line XXXX

CREATE TABLE simple_pk_table(
  id INTEGER NOT NULL,
  PRIMARY KEY (id)
);

  {create_table_stmt}: simple_pk_table: { id: integer notnull partial_pk }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_pk_table}
  | {col_key_list}
    | {col_def}: id: integer notnull partial_pk
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER NOT NULL,
  PRIMARY KEY (pk_col_not_exist)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'pk_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
              | {name pk_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER NOT NULL,
  PRIMARY KEY (id),
  PRIMARY KEY (id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0143: more than one primary key in table 'baz'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
      | | {indexed_columns_conflict_clause}
      |   | {indexed_columns}
      |     | {indexed_column}
      |       | {name id}: id: integer notnull
      | {col_key_list}
        | {pk_def}
          | {indexed_columns_conflict_clause}
            | {indexed_columns}
              | {indexed_column}
                | {name id}: id: integer notnull partial_pk

The statement ending at line XXXX

CREATE TABLE simple_ak_table(
  id INTEGER NOT NULL,
  CONSTRAINT ak1 UNIQUE (id)
);

  {create_table_stmt}: simple_ak_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE TABLE simple_ak_table_2(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (a, c),
  UNIQUE (d)
);

  {create_table_stmt}: simple_ak_table_2: { a: integer notnull, b: text, c: real, d: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_2}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {indexed_columns_conflict_clause}
            |   | {indexed_columns}
            |     | {indexed_column}
            |     | | {name a}: a: integer notnull
            |     | {indexed_columns}
            |       | {indexed_column}
            |         | {name b}: b: text
            | {col_key_list}
              | {unq_def}
              | | {indexed_columns_conflict_clause}
              |   | {indexed_columns}
              |     | {indexed_column}
              |     | | {name a}: a: integer notnull
              |     | {indexed_columns}
              |       | {indexed_column}
              |         | {name c}: c: real
              | {col_key_list}
                | {unq_def}
                  | {indexed_columns_conflict_clause}
                    | {indexed_columns}
                      | {indexed_column}
                        | {name d}: d: longint

The statement ending at line XXXX

CREATE TABLE simple_ak_table_3(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (b, d)
);

  {create_table_stmt}: simple_ak_table_3: { a: integer notnull, b: text, c: real, d: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_3}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {indexed_columns_conflict_clause}
            |   | {indexed_columns}
            |     | {indexed_column}
            |     | | {name a}: a: integer notnull
            |     | {indexed_columns}
            |       | {indexed_column}
            |         | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {indexed_columns_conflict_clause}
                  | {indexed_columns}
                    | {indexed_column}
                    | | {name b}: b: text
                    | {indexed_columns}
                      | {indexed_column}
                        | {name d}: d: longint

The statement ending at line XXXX

CREATE TABLE simple_ak_table_4(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  UNIQUE (a, b),
  UNIQUE (a, b, c)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_4}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {unq_def}
          | | {indexed_columns_conflict_clause}
          |   | {indexed_columns}
          |     | {indexed_column}
          |     | | {name a}: a: integer notnull
          |     | {indexed_columns}
          |       | {indexed_column}
          |         | {name b}: b: text
          | {col_key_list}
            | {unq_def}
              | {indexed_columns_conflict_clause}
                | {indexed_columns}
                  | {indexed_column}
                  | | {name a}
                  | {indexed_columns}
                    | {indexed_column}
                    | | {name b}
                    | {indexed_columns}
                      | {indexed_column}
                        | {name c}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_5(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (b, a)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_5}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {indexed_columns_conflict_clause}
            |   | {indexed_columns}
            |     | {indexed_column}
            |     | | {name a}: a: integer notnull
            |     | {indexed_columns}
            |       | {indexed_column}
            |         | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {indexed_columns_conflict_clause}
                  | {indexed_columns}
                    | {indexed_column}
                    | | {name b}
                    | {indexed_columns}
                      | {indexed_column}
                        | {name a}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_6(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (c, d, b, a)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_6}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {indexed_columns_conflict_clause}
            |   | {indexed_columns}
            |     | {indexed_column}
            |     | | {name a}: a: integer notnull
            |     | {indexed_columns}
            |       | {indexed_column}
            |         | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {indexed_columns_conflict_clause}
                  | {indexed_columns}
                    | {indexed_column}
                    | | {name c}
                    | {indexed_columns}
                      | {indexed_column}
                      | | {name d}
                      | {indexed_columns}
                        | {indexed_column}
                        | | {name b}
                        | {indexed_columns}
                          | {indexed_column}
                            | {name a}

The statement ending at line XXXX

CREATE TABLE simple_ak_table_7(
  a INTEGER NOT NULL,
  b TEXT,
  c REAL,
  d LONG_INT,
  UNIQUE (a, b),
  UNIQUE (a)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_ak_table_7}
  | {col_key_list}
    | {col_def}: a: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: c: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: d: longint
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_long}: longint
          | {col_key_list}
            | {unq_def}
            | | {indexed_columns_conflict_clause}
            |   | {indexed_columns}
            |     | {indexed_column}
            |     | | {name a}: a: integer notnull
            |     | {indexed_columns}
            |       | {indexed_column}
            |         | {name b}: b: text
            | {col_key_list}
              | {unq_def}
                | {indexed_columns_conflict_clause}
                  | {indexed_columns}
                    | {indexed_column}
                      | {name a}

The statement ending at line XXXX

CREATE TABLE baz_expr_uk(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (id / 2)
);

  {create_table_stmt}: baz_expr_uk: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_expr_uk}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {div}: integer notnull
                | {name id}: id: integer notnull
                | {int 2}: integer notnull

The statement ending at line XXXX

CREATE TABLE baz_expr_uk_bogus(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (random())
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'random'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_expr_uk_bogus}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
              | {call}: err
                | {name random}
                | {call_arg_list}
                  | {call_filter_clause}

The statement ending at line XXXX

CREATE TABLE baz_expr_pk(
  id INTEGER,
  CONSTRAINT pk1 PRIMARY KEY (id / 2)
);

  {create_table_stmt}: baz_expr_pk: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_expr_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
        | {name pk1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {div}: integer
                | {name id}: id: integer
                | {int 2}: integer notnull

The statement ending at line XXXX

CREATE TABLE baz_expr_uk_bogus(
  id INTEGER,
  CONSTRAINT pk1 PRIMARY KEY (random())
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'random'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_expr_uk_bogus}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
        | {name pk1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
              | {call}: err
                | {name random}
                | {call_arg_list}
                  | {call_filter_clause}

The statement ending at line XXXX

CREATE TABLE baz_dup_uk(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (id),
  CONSTRAINT ak1 UNIQUE (id)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0020: duplicate constraint name in table 'ak1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_dup_uk}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
      | | {name ak1}
      | | {indexed_columns_conflict_clause}
      |   | {indexed_columns}
      |     | {indexed_column}
      |       | {name id}: id: integer notnull
      | {col_key_list}
        | {unq_def}
          | {name ak1}
          | {indexed_columns_conflict_clause}
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE TABLE baz_dup_pk(
  id INTEGER NOT NULL,
  CONSTRAINT pk1 PRIMARY KEY (id),
  CONSTRAINT pk1 PRIMARY KEY (id)
);

test/sem_test.sql:XXXX:1: error: in pk_def : CQL0020: duplicate constraint name in table 'pk1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_dup_pk}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
      | | {name pk1}
      | | {indexed_columns_conflict_clause}
      |   | {indexed_columns}
      |     | {indexed_column}
      |       | {name id}: id: integer notnull
      | {col_key_list}
        | {pk_def}
          | {name pk1}
          | {indexed_columns_conflict_clause}
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE TABLE baz_2(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  name TEXT,
  UNIQUE (id, name),
  UNIQUE (name, id)
);

test/sem_test.sql:XXXX:1: error: in unq_def : CQL0269: at least part of this unique key is redundant with previous unique keys

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {unq_def}
        | | {indexed_columns_conflict_clause}
        |   | {indexed_columns}
        |     | {indexed_column}
        |     | | {name id}: id: integer notnull
        |     | {indexed_columns}
        |       | {indexed_column}
        |         | {name name}: name: text
        | {col_key_list}
          | {unq_def}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                | | {name name}
                | {indexed_columns}
                  | {indexed_column}
                    | {name id}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (ak_col_not_exist)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'ak_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
              | {name ak_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE baz_3(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  UNIQUE (ak_col_not_exist)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'ak_col_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz_3}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
              | {name ak_col_not_exist}: err

The statement ending at line XXXX

CREATE TABLE fk_table(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id)
);

  {create_table_stmt}: fk_table: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_table_dup(
  id INTEGER,
  CONSTRAINT x FOREIGN KEY (id) REFERENCES foo (id),
  CONSTRAINT x FOREIGN KEY (id) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0020: duplicate constraint name in table 'x'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table_dup}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
      | | {name x}
      | | {fk_info}
      |   | {name_list}
      |   | | {name id}: id: integer
      |   | {fk_target_options}
      |     | {fk_target}
      |     | | {name foo}
      |     | | {name_list}
      |     |   | {name id}: id: integer notnull
      |     | {int 0}
      | {col_key_list}
        | {fk_def}
          | {name x}
          | {fk_info}
            | {name_list}
            | | {name id}
            | {fk_target_options}
              | {fk_target}
              | | {name foo}
              | | {name_list}
              |   | {name id}
              | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (bogus) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {fk_info}
          | {name_list}: err
          | | {name bogus}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}
            | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (bogus)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}: err
            |   | {name bogus}: err
            | {int 0}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES bogus (id)
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0021: foreign key refers to non-existent table 'bogus'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name bogus}
            | | {name_list}
            |   | {name id}
            | {int 0}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE
  SELECT 2;
END IF;

  {if_stmt}: integer notnull
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: ok
    | {else}: ok
      | {stmt_list}: ok
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 2}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 'x' THEN
  SELECT 1;
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: err
  | | {strlit 'x'}: text notnull
  | | {stmt_list}
  |   | {select_stmt}
  |     | {select_core_list}
  |     | | {select_core}
  |     |   | {select_expr_list_con}
  |     |     | {select_expr_list}
  |     |     | | {select_expr}
  |     |     |   | {int 1}
  |     |     | {select_from_etc}
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF NOT 'x' THEN
  SELECT 1;
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: err
  | | {not}: err
  | | | {strlit 'x'}: text notnull
  | | {stmt_list}
  |   | {select_stmt}
  |     | {select_core_list}
  |     | | {select_core}
  |     |   | {select_expr_list_con}
  |     |     | {select_expr_list}
  |     |     | | {select_expr}
  |     |     |   | {int 1}
  |     |     | {select_from_etc}
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF 1 THEN
  SELECT NOT 'x';
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: err
  | | {int 1}: integer notnull
  | | {stmt_list}: err
  |   | {select_stmt}: err
  |     | {select_core_list}: err
  |     | | {select_core}: err
  |     |   | {select_expr_list_con}: err
  |     |     | {select_expr_list}: err
  |     |     | | {select_expr}: err
  |     |     |   | {not}: err
  |     |     |     | {strlit 'x'}: text notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE
  SELECT NOT 'x';
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {else}: err
      | {stmt_list}: err
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {not}: err
          |     |     | {strlit 'x'}: text notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF 2 THEN
  SELECT 2;
ELSE
  SELECT 3;
END IF;

  {if_stmt}: integer notnull
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: ok
    | {elseif}: integer notnull
    | | {cond_action}: integer notnull
    |   | {int 2}: integer notnull
    |   | {stmt_list}: ok
    |     | {select_stmt}: select: { _anon: integer notnull }
    |       | {select_core_list}: select: { _anon: integer notnull }
    |       | | {select_core}: select: { _anon: integer notnull }
    |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |       |     | {select_expr_list}: select: { _anon: integer notnull }
    |       |     | | {select_expr}: integer notnull
    |       |     |   | {int 2}: integer notnull
    |       |     | {select_from_etc}: ok
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {else}: ok
      | {stmt_list}: ok
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 3}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF '2' THEN
  SELECT 2;
ELSE
  SELECT 3;
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {elseif}: err
    | | {cond_action}: err
    |   | {strlit '2'}: text notnull
    |   | {stmt_list}
    |     | {select_stmt}
    |       | {select_core_list}
    |       | | {select_core}
    |       |   | {select_expr_list_con}
    |       |     | {select_expr_list}
    |       |     | | {select_expr}
    |       |     |   | {int 2}
    |       |     | {select_from_etc}
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {else}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {select_expr}
          |     |   | {int 3}
          |     | {select_from_etc}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

IF 1 THEN
  SELECT 1;
ELSE IF 2 THEN
  SELECT 2;
ELSE IF 3 THEN
  SELECT 3;
ELSE IF '4' THEN
  SELECT 4;
END IF;

test/sem_test.sql:XXXX:1: error: in str : CQL0150: expected numeric expression in IF predicate

  {if_stmt}: err
  | {cond_action}: integer notnull
  | | {int 1}: integer notnull
  | | {stmt_list}: ok
  |   | {select_stmt}: select: { _anon: integer notnull }
  |     | {select_core_list}: select: { _anon: integer notnull }
  |     | | {select_core}: select: { _anon: integer notnull }
  |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     | | {select_expr}: integer notnull
  |     |     |   | {int 1}: integer notnull
  |     |     | {select_from_etc}: ok
  |     |       | {select_where}
  |     |         | {select_groupby}
  |     |           | {select_having}
  |     | {select_orderby}
  |       | {select_limit}
  |         | {select_offset}
  | {if_alt}: err
    | {elseif}: err
      | {cond_action}: integer notnull
      | | {int 2}: integer notnull
      | | {stmt_list}: ok
      |   | {select_stmt}: select: { _anon: integer notnull }
      |     | {select_core_list}: select: { _anon: integer notnull }
      |     | | {select_core}: select: { _anon: integer notnull }
      |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     |     | {select_expr_list}: select: { _anon: integer notnull }
      |     |     | | {select_expr}: integer notnull
      |     |     |   | {int 2}: integer notnull
      |     |     | {select_from_etc}: ok
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {elseif}: integer notnull
        | {cond_action}: integer notnull
        | | {int 3}: integer notnull
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { _anon: integer notnull }
        |     | {select_core_list}: select: { _anon: integer notnull }
        |     | | {select_core}: select: { _anon: integer notnull }
        |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     |     | {select_expr_list}: select: { _anon: integer notnull }
        |     |     | | {select_expr}: integer notnull
        |     |     |   | {int 3}: integer notnull
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {elseif}: err
          | {cond_action}: err
            | {strlit '4'}: text notnull
            | {stmt_list}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {select_expr}
                |     |   | {int 4}
                |     | {select_from_etc}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  GROUP BY id, NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: err
  |           | | {groupby_list}: err
  |           |   | {groupby_item}
  |           |   | | {name id}: id: integer notnull
  |           |   | {groupby_list}
  |           |     | {groupby_item}
  |           |       | {not}: err
  |           |         | {strlit 'x'}: text notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
ORDER BY id, NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {orderby_list}: err
    |   | {orderby_item}
    |   | | {name id}: id: integer notnull
    |   | {orderby_list}
    |     | {orderby_item}
    |       | {not}: err
    |         | {strlit 'x'}: text notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE booly(
  id INTEGER DEFAULT 8675309,
  flag BOOL
);

  {create_table_stmt}: booly: { id: integer has_default, flag: bool }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name booly}
  | {col_key_list}
    | {col_def}: id: integer has_default
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_default}: ok
    |     | {int 8675309}: integer notnull
    | {col_key_list}
      | {col_def}: flag: bool
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name flag}
            | {type_bool}: bool

The statement ending at line XXXX

DECLARE ENUM ints INTEGER (
  negative_one = -1,
  postive_one = 1
);

  {declare_enum_stmt}: ints: integer<ints> notnull
  | {typed_name}: ints: integer<ints> notnull
  | | {name ints}
  | | {type_int}: ints: integer<ints> notnull
  | {enum_values}
    | {enum_value}
    | | {name negative_one}: integer = -1 notnull
    | | {uminus}: integer notnull
    |   | {int 1}: integer notnull
    | {enum_values}
      | {enum_value}
        | {name postive_one}: integer = 1 notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

CREATE TABLE bad_constants_table(
  x INTEGER DEFAULT -1,
  y INTEGER DEFAULT CONST(1 / 0)
);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_constants_table}
  | {col_key_list}
    | {col_def}: x: integer has_default
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name x}
    |   | | {type_int}: integer
    |   | {col_attrs_default}: ok
    |     | {int -1}: integer notnull
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name y}
          | | {type_int}: integer
          | {col_attrs_default}: err
            | {const}: err
              | {div}: integer notnull
                | {int 1}: integer notnull
                | {int 0}: integer notnull

The statement ending at line XXXX

LET bool_x := TRUE;

  {let_stmt}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 1}: bool notnull

The statement ending at line XXXX

@ENFORCE_STRICT IS TRUE;

  {enforce_strict_stmt}: ok
  | {int 20}

The statement ending at line XXXX

SET bool_x := 1 IS TRUE;

test/sem_test.sql:XXXX:1: error: in is_true : CQL0403: operator may not be used because it is not supported on old versions of SQLite 'IS TRUE'

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {is_true}: err
    | {int 1}

The statement ending at line XXXX

SET bool_x := 1 IS FALSE;

test/sem_test.sql:XXXX:1: error: in is_false : CQL0403: operator may not be used because it is not supported on old versions of SQLite 'IS FALSE'

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {is_false}: err
    | {int 1}

The statement ending at line XXXX

SET bool_x := 1 IS NOT TRUE;

test/sem_test.sql:XXXX:1: error: in is_not_true : CQL0403: operator may not be used because it is not supported on old versions of SQLite 'IS NOT TRUE'

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {is_not_true}: err
    | {int 1}

The statement ending at line XXXX

SET bool_x := 1 IS NOT FALSE;

test/sem_test.sql:XXXX:1: error: in is_not_false : CQL0403: operator may not be used because it is not supported on old versions of SQLite 'IS NOT FALSE'

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {is_not_false}: err
    | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL IS TRUE;

  {enforce_normal_stmt}: ok
  | {int 20}

The statement ending at line XXXX

SET bool_x := TRUE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 1}: bool notnull

The statement ending at line XXXX

SET bool_x := FALSE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET bool_x := CONST(1 / 0 IS TRUE);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {const}: err
    | {is_true}: bool notnull
      | {div}: integer notnull
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

SET bool_x := FALSE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET bool_x := FALSE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET bool_x := TRUE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 1}: bool notnull

The statement ending at line XXXX

SET bool_x := TRUE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 1}: bool notnull

The statement ending at line XXXX

SET bool_x := FALSE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET bool_x := TRUE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 1}: bool notnull

The statement ending at line XXXX

SET bool_x := CONST(1 / 0 IS NOT FALSE);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {const}: err
    | {is_not_false}: bool notnull
      | {div}: integer notnull
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

SET bool_x := CONST(1 / 0 IS NOT TRUE);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {const}: err
    | {is_not_true}: bool notnull
      | {div}: integer notnull
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

SET bool_x := FALSE;

  {assign}: bool_x: bool notnull variable was_set
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET bool_x := CONST(1 / 0 IS FALSE);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {assign}: err
  | {name bool_x}: bool_x: bool notnull variable was_set
  | {const}: err
    | {is_false}: bool notnull
      | {div}: integer notnull
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

LET bool_x2 := TRUE;

  {let_stmt}: bool_x2: bool notnull variable
  | {name bool_x2}: bool_x2: bool notnull variable
  | {bool 1}: bool notnull

The statement ending at line XXXX

@ATTRIBUTE(whatever=-1)
@ATTRIBUTE(whatever=CONST(1 / 0))
DECLARE PROC bad_constants_proc ();

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  | | | {name whatever}
  | | | {int -1}: integer notnull
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {name whatever}
  |     | {const}: err
  |       | {div}: integer notnull
  |         | {int 1}: integer notnull
  |         | {int 0}: integer notnull
  | {declare_proc_stmt}: err
    | {proc_name_type}
    | | {name bad_constants_proc}
    | | {int 0}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(whatever=(1, CONST(1 / 0), 1))
DECLARE PROC bad_constants_nested_proc ();

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {name whatever}
  |   | {misc_attr_value_list}: err
  |     | {int 1}: ok
  |     | {misc_attr_value_list}: err
  |       | {const}: err
  |       | | {div}: integer notnull
  |       |   | {int 1}: integer notnull
  |       |   | {int 0}: integer notnull
  |       | {misc_attr_value_list}
  |         | {int 1}
  | {declare_proc_stmt}: err
    | {proc_name_type}
    | | {name bad_constants_nested_proc}
    | | {int 0}
    | {proc_params_stmts}

The statement ending at line XXXX

CREATE TABLE bad_conversions(
  data INTEGER NOT NULL DEFAULT NULL
);

test/sem_test.sql:XXXX:1: error: in null : CQL0013: cannot assign/copy possibly null expression to not null target 'default value'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_conversions}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name data}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {null}: null

The statement ending at line XXXX

CREATE TABLE bad_conversions(
  data INTEGER NOT NULL DEFAULT 2.200000e+00
);

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'REAL' in 2.200000e+00

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_conversions}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name data}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {dbl 2.200000e+00}: real notnull

The statement ending at line XXXX

CREATE TABLE good_conversions(
  data REAL NOT NULL DEFAULT 1
);

  {create_table_stmt}: good_conversions: { data: real notnull has_default }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name good_conversions}
  | {col_key_list}
    | {col_def}: data: real notnull has_default
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name data}
        | | {type_real}: real
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {int 1}: integer notnull

The statement ending at line XXXX

LET tru := TRUE;

  {let_stmt}: tru: bool notnull variable
  | {name tru}: tru: bool notnull variable
  | {bool 1}: bool notnull

The statement ending at line XXXX

LET fal := FALSE;

  {let_stmt}: fal: bool notnull variable was_set
  | {name fal}: fal: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SET fal := FALSE;

  {assign}: fal: bool notnull variable was_set
  | {name fal}: fal: bool notnull variable was_set
  | {bool 0}: bool notnull

The statement ending at line XXXX

SELECT DISTINCTROW id, flag
  FROM booly;

  {select_stmt}: select: { id: integer, flag: bool }
  | {select_core_list}: select: { id: integer, flag: bool }
  | | {select_core}: select: { id: integer, flag: bool }
  |   | {select_opts}
  |   | | {distinctrow}
  |   | {select_expr_list_con}: select: { id: integer, flag: bool }
  |     | {select_expr_list}: select: { id: integer, flag: bool }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: flag: bool
  |     |     | {name flag}: flag: bool
  |     | {select_from_etc}: TABLE { booly: booly }
  |       | {table_or_subquery_list}: TABLE { booly: booly }
  |       | | {table_or_subquery}: TABLE { booly: booly }
  |       |   | {name booly}: TABLE { booly: booly }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE X, Y INTEGER;

  {declare_vars_type}: integer
  | {name_list}: X: integer variable was_set
  | | {name X}: X: integer variable was_set
  | | {name_list}: Y: integer variable was_set
  |   | {name Y}: Y: integer variable was_set
  | {type_int}: integer

The statement ending at line XXXX

DECLARE X_not_null INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: X_not_null: integer notnull variable was_set
  | | {name X_not_null}: X_not_null: integer notnull variable was_set
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

DECLARE X INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0197: duplicate variable name in the same scope 'X'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name X}: err
  | {type_int}: integer

The statement ending at line XXXX

SET X := @RC;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {name @RC}: @rc: integer notnull variable

The statement ending at line XXXX

DECLARE foo INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0198: global variable hides table/view name 'foo'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name foo}: err
  | {type_int}: integer

The statement ending at line XXXX

SELECT Y;

  {select_stmt}: select: { Y: integer variable }
  | {select_core_list}: select: { Y: integer variable }
  | | {select_core}: select: { Y: integer variable }
  |   | {select_expr_list_con}: select: { Y: integer variable }
  |     | {select_expr_list}: select: { Y: integer variable }
  |     | | {select_expr}: Y: integer variable
  |     |   | {name Y}: Y: integer variable
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT 1 AS one, 2 AS two;

  {declare_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | {select_stmt}: select: { one: integer notnull, two: integer notnull }
    | {select_core_list}: select: { one: integer notnull, two: integer notnull }
    | | {select_core}: select: { one: integer notnull, two: integer notnull }
    |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
    |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
    |     | | {select_expr}: one: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name one}
    |     | | {select_expr_list}
    |     |   | {select_expr}: two: integer notnull
    |     |     | {int 2}: integer notnull
    |     |     | {opt_as_alias}
    |     |       | {name two}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE kind_cursor CURSOR FOR SELECT *
  FROM with_kind;

  {declare_cursor}: kind_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> } variable dml_proc
  | {name kind_cursor}: kind_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> } variable dml_proc
  | {select_stmt}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | {select_core_list}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | | {select_core}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    |   | {select_expr_list_con}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    |     | {select_expr_list}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    |     | | {star}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    |     | {select_from_etc}: TABLE { with_kind: with_kind }
    |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
    |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
    |       |   | {name with_kind}: TABLE { with_kind: with_kind }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE kind_value_cursor CURSOR LIKE kind_cursor;

  {declare_cursor_like_name}: kind_value_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> } variable shape_storage value_cursor
  | {name kind_value_cursor}: kind_value_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> } variable shape_storage value_cursor
  | {shape_def}: kind_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> } variable dml_proc
    | {like}: ok
      | {name kind_cursor}

The statement ending at line XXXX

DECLARE extended_cursor CURSOR LIKE (id INTEGER<some_key>, cost REAL<dollars>, value REAL<dollars>, xx REAL, yy TEXT);

  {declare_cursor_like_typed_names}: extended_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars>, xx: real, yy: text } variable shape_storage value_cursor
  | {name extended_cursor}: extended_cursor: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars>, xx: real, yy: text } variable shape_storage value_cursor
  | {typed_names}: select: { id: integer<some_key>, cost: real<dollars>, value: real<dollars>, xx: real, yy: text }
    | {typed_name}: id: integer<some_key>
    | | {name id}
    | | {type_int}: id: integer<some_key>
    |   | {name some_key}
    | {typed_names}
      | {typed_name}: cost: real<dollars>
      | | {name cost}
      | | {type_real}: cost: real<dollars>
      |   | {name dollars}
      | {typed_names}
        | {typed_name}: value: real<dollars>
        | | {name value}
        | | {type_real}: value: real<dollars>
        |   | {name dollars}
        | {typed_names}
          | {typed_name}: xx: real
          | | {name xx}
          | | {type_real}: xx: real
          | {typed_names}
            | {typed_name}: yy: text
              | {name yy}
              | {type_text}: yy: text

The statement ending at line XXXX

DECLARE reduced_cursor CURSOR LIKE extended_cursor(id, id);

test/sem_test.sql:XXXX:1: error: in shape_expr : CQL0206: duplicate name in list 'id'

  {declare_cursor_like_name}: err
  | {name reduced_cursor}
  | {shape_def}: err
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
      | | {name id}
      | | {name id}
      | {shape_exprs}
        | {shape_expr}
          | {name id}
          | {name id}

The statement ending at line XXXX

DECLARE reduced_cursor CURSOR LIKE extended_cursor(id, not_a_valid_name);

test/sem_test.sql:XXXX:1: error: in shape_expr : CQL0069: name not found 'not_a_valid_name'

  {declare_cursor_like_name}: err
  | {name reduced_cursor}
  | {shape_def}: err
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
      | | {name id}
      | | {name id}
      | {shape_exprs}
        | {shape_expr}
          | {name not_a_valid_name}
          | {name not_a_valid_name}

The statement ending at line XXXX

DECLARE reduced_cursor CURSOR LIKE extended_cursor(id, cost);

  {declare_cursor_like_name}: reduced_cursor: select: { id: integer<some_key>, cost: real<dollars> } variable shape_storage value_cursor
  | {name reduced_cursor}: reduced_cursor: select: { id: integer<some_key>, cost: real<dollars> } variable shape_storage value_cursor
  | {shape_def}: select: { id: integer<some_key>, cost: real<dollars> }
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
      | | {name id}
      | | {name id}
      | {shape_exprs}
        | {shape_expr}
          | {name cost}
          | {name cost}

The statement ending at line XXXX

DECLARE reduced_cursor2 CURSOR LIKE extended_cursor(-id, cost);

test/sem_test.sql:XXXX:1: error: in shape_expr : CQL0494: mixing adding and removing columns from a shape 'cost'

  {declare_cursor_like_name}: err
  | {name reduced_cursor2}
  | {shape_def}: err
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
      | | {name id}
      | {shape_exprs}
        | {shape_expr}
          | {name cost}
          | {name cost}

The statement ending at line XXXX

DECLARE reduced_cursor3 CURSOR LIKE extended_cursor(-id);

  {declare_cursor_like_name}: reduced_cursor3: select: { cost: real<dollars>, value: real<dollars>, xx: real, yy: text } variable shape_storage value_cursor
  | {name reduced_cursor3}: reduced_cursor3: select: { cost: real<dollars>, value: real<dollars>, xx: real, yy: text } variable shape_storage value_cursor
  | {shape_def}: select: { cost: real<dollars>, value: real<dollars>, xx: real, yy: text }
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
        | {name id}

The statement ending at line XXXX

DECLARE reduced_cursor4 CURSOR LIKE extended_cursor(-id, -xx, -yy, -value, -cost);

test/sem_test.sql:XXXX:1: error: in shape_exprs : CQL0495: no columns were selected in the LIKE expression

  {declare_cursor_like_name}: err
  | {name reduced_cursor4}
  | {shape_def}: err
    | {like}: ok
    | | {name extended_cursor}
    | {shape_exprs}
      | {shape_expr}
      | | {name id}
      | {shape_exprs}
        | {shape_expr}
        | | {name xx}
        | {shape_exprs}
          | {shape_expr}
          | | {name yy}
          | {shape_exprs}
            | {shape_expr}
            | | {name value}
            | {shape_exprs}
              | {shape_expr}
                | {name cost}

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT 1;

test/sem_test.sql:XXXX:1: error: in declare_cursor : CQL0197: duplicate variable name in the same scope 'my_cursor'

  {declare_cursor}: err
  | {name my_cursor}: err
  | {select_stmt}: select: { _anon: integer notnull }
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE extended_cursor CURSOR LIKE (x INTEGER);

test/sem_test.sql:XXXX:1: error: in declare_cursor_like_typed_names : CQL0197: duplicate variable name in the same scope 'extended_cursor'

  {declare_cursor_like_typed_names}: err
  | {name extended_cursor}: err
  | {typed_names}: select: { x: integer }
    | {typed_name}: x: integer
      | {name x}
      | {type_int}: x: integer

The statement ending at line XXXX

DECLARE my_cursor CURSOR FOR SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {declare_cursor}: err
  | {name my_cursor}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE extended_cursor CURSOR LIKE (x INTEGER, x INTEGER);

test/sem_test.sql:XXXX:1: error: in str : CQL0190: duplicate column name 'x'

  {declare_cursor_like_typed_names}: err
  | {name extended_cursor}
  | {typed_names}: err
    | {typed_name}: x: integer
    | | {name x}
    | | {type_int}: x: integer
    | {typed_names}
      | {typed_name}: err
        | {name x}
        | {type_int}

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  LEAVE;
END;

  {loop_stmt}: ok
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc
  | | {name_list}
  |   | {name X}: X: integer variable was_set
  |   | {name_list}
  |     | {name Y}: Y: integer variable was_set
  | {stmt_list}: ok
    | {leave_stmt}: ok

The statement ending at line XXXX

WHILE 1
BEGIN
  LEAVE;
  LEAVE;
END;

test/sem_test.sql:XXXX:1: error: in leave_stmt : CQL0308: statement should be the last thing in a statement list

  {while_stmt}: err
  | {int 1}: integer notnull
  | {stmt_list}: err
    | {leave_stmt}: err
    | {leave_stmt}: ok

The statement ending at line XXXX

WHILE 1
BEGIN
  CONTINUE;
  LEAVE;
END;

test/sem_test.sql:XXXX:1: error: in continue_stmt : CQL0308: statement should be the last thing in a statement list

  {while_stmt}: err
  | {int 1}: integer notnull
  | {stmt_list}: err
    | {continue_stmt}: err
    | {leave_stmt}: ok

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  CONTINUE;
END;

  {loop_stmt}: ok
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | | {name_list}
  |   | {name X}: X: integer variable was_set
  |   | {name_list}
  |     | {name Y}: Y: integer variable was_set
  | {stmt_list}: ok
    | {continue_stmt}: ok

The statement ending at line XXXX

LOOP FETCH X INTO y
BEGIN
  LEAVE;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'X'

  {loop_stmt}: err
  | {fetch_stmt}: err
  | | {name X}: err
  | | {name_list}
  |   | {name y}
  | {stmt_list}
    | {leave_stmt}

The statement ending at line XXXX

LOOP FETCH not_a_variable INTO x
BEGIN
  LEAVE;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_variable'

  {loop_stmt}: err
  | {fetch_stmt}: err
  | | {name not_a_variable}: err
  | | {name_list}
  |   | {name x}
  | {stmt_list}
    | {leave_stmt}

The statement ending at line XXXX

LEAVE;

test/sem_test.sql:XXXX:1: error: in leave_stmt : CQL0219: leave must be inside of a 'loop', 'while', or 'switch' statement

  {leave_stmt}: err

The statement ending at line XXXX

CONTINUE;

test/sem_test.sql:XXXX:1: error: in continue_stmt : CQL0218: continue must be inside of a 'loop' or 'while' statement

  {continue_stmt}: err

The statement ending at line XXXX

CREATE PROC return_with_attr ()
BEGIN
  IF 1 THEN
    @ATTRIBUTE(goo)
    RETURN;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name return_with_attr}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 1}: integer notnull
        | | {stmt_list}: ok
        |   | {stmt_and_attr}: ok
        |     | {misc_attrs}: ok
        |     | | {misc_attr}
        |     |   | {name goo}
        |     | {return_stmt}: ok
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC using_rc (OUT result_code INTEGER NOT NULL)
BEGIN
  SET result_code := @RC;
END;

  {create_proc_stmt}: ok dml_proc
  | {name using_rc}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: result_code: integer notnull variable out was_set
    |   | {out}
    |   | {param_detail}: result_code: integer notnull variable out was_set
    |     | {name result_code}: result_code: integer notnull variable out was_set
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: result_code: integer notnull variable out was_set
        | {name result_code}: result_code: integer notnull variable out was_set
        | {name @RC}: @rc: integer notnull variable

The statement ending at line XXXX

CREATE PROC return_no_attr ()
BEGIN
  IF 1 THEN
    RETURN;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name return_no_attr}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 1}: integer notnull
        | | {stmt_list}: ok
        |   | {return_stmt}: ok
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC return_not_last_with_attr ()
BEGIN
  IF 1 THEN
    @ATTRIBUTE(goo)
    RETURN;
    RETURN;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name return_not_last_with_attr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {stmt_and_attr}: err
        |   | | {misc_attrs}: ok
        |   | | | {misc_attr}
        |   | |   | {name goo}
        |   | | {return_stmt}: err
        |   | {return_stmt}: ok
        | {if_alt}

The statement ending at line XXXX

CREATE PROC return_not_last_no_attr ()
BEGIN
  IF 1 THEN
    RETURN;
    RETURN;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name return_not_last_no_attr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {return_stmt}: err
        |   | {return_stmt}: ok
        | {if_alt}

The statement ending at line XXXX

RETURN;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0307: return statement should be in a procedure and not at the top level

  {return_stmt}: err

The statement ending at line XXXX

CREATE PROC return_at_top_level ()
BEGIN
  RETURN;
END;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0307: return statement should be in a procedure and not at the top level

  {create_proc_stmt}: err
  | {name return_at_top_level}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {return_stmt}: err

The statement ending at line XXXX

LOOP FETCH my_cursor INTO X, Y
BEGIN
  SELECT NOT 'X';
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {loop_stmt}: err
  | {fetch_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | | {name_list}
  |   | {name X}: X: integer variable was_set
  |   | {name_list}
  |     | {name Y}: Y: integer variable was_set
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'X'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CLOSE my_cursor;

  {close_stmt}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into

The statement ending at line XXXX

CLOSE X;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'X'

  {close_stmt}: err
  | {name X}: err

The statement ending at line XXXX

CREATE PROC close_boxed_cursor (IN box OBJECT<foo CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
  CLOSE C;
END;

test/sem_test.sql:XXXX:1: error: in close_stmt : CQL0391: CLOSE cannot be used on a boxed cursor 'C'

  {create_proc_stmt}: err
  | {name close_boxed_cursor}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<foo CURSOR> variable in
    |   | {in}
    |   | {param_detail}: box: object<foo CURSOR> variable in
    |     | {name box}: box: object<foo CURSOR> variable in
    |     | {type_object}: object<foo CURSOR>
    |       | {name foo CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: foo: { id: integer notnull primary_key autoinc } variable boxed
      | | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable boxed
      | | {name box}: box: object<foo CURSOR> variable in
      | {close_stmt}: err
        | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable boxed

The statement ending at line XXXX

DECLARE FUNC get_boxed_cursor () OBJECT<foo CURSOR>;

  {declare_func_stmt}: object<foo CURSOR>
  | {name get_boxed_cursor}: object<foo CURSOR>
  | {func_params_return}
    | {type_object}: object<foo CURSOR>
      | {name foo CURSOR}

The statement ending at line XXXX

CREATE PROC boxed_cursor_expr ()
BEGIN
  DECLARE C CURSOR FOR get_boxed_cursor();
END;

  {create_proc_stmt}: ok
  | {name boxed_cursor_expr}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: foo: { id: integer notnull primary_key autoinc } variable boxed
        | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable boxed
        | {call}: object<foo CURSOR>
          | {name get_boxed_cursor}
          | {call_arg_list}
            | {call_filter_clause}

The statement ending at line XXXX

CREATE PROC bogus_boxed_cursor_expr ()
BEGIN
  DECLARE C CURSOR FOR 12;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0346: expression must be of type object<T cursor> where T is a valid shape name '12'

  {create_proc_stmt}: err
  | {name bogus_boxed_cursor_expr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {int 12}: integer notnull

The statement ending at line XXXX

DELETE FROM foo WHERE id = 33;

  {delete_stmt}: ok
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {opt_where}: bool notnull
    | {eq}: bool notnull
      | {name id}: id: integer notnull
      | {int 33}: integer notnull

The statement ending at line XXXX

DELETE FROM bogus_table;

test/sem_test.sql:XXXX:1: error: in str : CQL0151: table in delete statement does not exist 'bogus_table'

  {delete_stmt}: err
  | {name bogus_table}

The statement ending at line XXXX

DELETE FROM MyView;

test/sem_test.sql:XXXX:1: error: in str : CQL0152: cannot delete from a view 'MyView'

  {delete_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

DELETE FROM foo WHERE missing_column = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'missing_column'

  {delete_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {opt_where}: err
    | {eq}: err
      | {name missing_column}: err
      | {int 1}: integer notnull

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

REPLACE INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_replace}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR FAIL INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_fail}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR ROLLBACK INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_rollback}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT OR ABORT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3);

  {insert_stmt}: ok
  | {insert_or_abort}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'bazzle'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo DEFAULT VALUES;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {default_columns_values}

The statement ending at line XXXX

INSERT INTO bar DEFAULT VALUES;

test/sem_test.sql:XXXX:1: error: in str : CQL0315: mandatory column with no default value in INSERT INTO name DEFAULT VALUES statement 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {default_columns_values}

The statement ending at line XXXX

INSERT INTO bogus_table VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0160: table in insert statement does not exist 'bogus_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bogus_table}
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO MyView VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0161: cannot insert into a view 'MyView'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(id, 'bazzle', 3);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        |     | {insert_list}: ok
        |       | {name id}: err
        |       | {insert_list}
        |         | {strlit 'bazzle'}
        |         | {insert_list}
        |           | {int 3}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null }
        | {select_core_list}: values: { column1: null }
        | | {select_core}: values: { column1: null }
        |   | {select_values}
        |   | {values}: values: { column1: null }
        |     | {insert_list}: ok
        |       | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES('string is wrong', 'string', 1);

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {strlit 'string is wrong'}: err
        |       | {insert_list}
        |         | {strlit 'string'}: text notnull
        |         | {insert_list}
        |           | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 2, 3);

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'name'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: integer notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {int 2}: err
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL, 2);

test/sem_test.sql:XXXX:1: error: in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null, column2: integer notnull }
        | {select_core_list}: values: { column1: null, column2: integer notnull }
        | | {select_core}: values: { column1: null, column2: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: integer notnull }
        |     | {insert_list}: ok
        |       | {null}: null
        |       | {insert_list}
        |         | {int 2}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES();

test/sem_test.sql:XXXX:1: error: in values : CQL0336: select statement with VALUES clause requires a non empty list of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(NULL, 'string', 1);

test/sem_test.sql:XXXX:1: error: in null : CQL0013: cannot assign/copy possibly null expression to not null target 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: null, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: null, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: null, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {null}: null
        |       | {insert_list}
        |         | {strlit 'string'}: text notnull
        |         | {insert_list}
        |           | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE two_autoincs_is_bad(
  id1 INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  id2 INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL
);

test/sem_test.sql:XXXX:1: error: in str : CQL0040: table can only have one autoinc column 'id2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_autoincs_is_bad}
  | {col_key_list}
    | {col_def}: id1: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id1}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_pk}: ok
            | {autoinc_and_conflict_clause}
            | | {col_attrs_autoinc}
            | {col_attrs_not_null}

The statement ending at line XXXX

SET X := 1;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {int 1}: integer notnull

The statement ending at line XXXX

SET XX := 1;

test/sem_test.sql:XXXX:1: error: in assign : CQL0173: variable not found 'XX'

  {assign}: err
  | {name XX}
  | {int 1}

The statement ending at line XXXX

SET my_cursor := 1;

test/sem_test.sql:XXXX:1: error: in assign : CQL0174: cannot set a cursor 'my_cursor'

  {assign}: err
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | {int 1}

The statement ending at line XXXX

SET X := 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'X'

  {assign}: err
  | {name X}: err
  | {strlit 'x'}: err

The statement ending at line XXXX

SET X := NULL;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {null}: null

The statement ending at line XXXX

SET X := NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not}: err
    | {strlit 'x'}: text notnull

The statement ending at line XXXX

DECLARE fetch_cursor CURSOR FOR SELECT 1, 'foo', NULL;

  {declare_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: null }
    |     | | {select_expr}: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | {select_expr_list}
    |     |   | {select_expr}: text notnull
    |     |   | | {strlit 'foo'}: text notnull
    |     |   | {select_expr_list}
    |     |     | {select_expr}: null
    |     |       | {null}: null
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE an_int INTEGER;

  {declare_vars_type}: integer
  | {name_list}: an_int: integer variable was_set
  | | {name an_int}: an_int: integer variable was_set
  | {type_int}: integer

The statement ending at line XXXX

DECLARE an_int2 INTEGER;

  {declare_vars_type}: integer
  | {name_list}: an_int2: integer variable was_set
  | | {name an_int2}: an_int2: integer variable was_set
  | {type_int}: integer

The statement ending at line XXXX

DECLARE a_string TEXT;

  {declare_vars_type}: text
  | {name_list}: a_string: text variable was_set
  | | {name a_string}: a_string: text variable was_set
  | {type_text}: text

The statement ending at line XXXX

DECLARE a_string2 TEXT;

  {declare_vars_type}: text
  | {name_list}: a_string2: text variable was_set
  | | {name a_string2}: a_string2: text variable was_set
  | {type_text}: text

The statement ending at line XXXX

DECLARE a_nullable TEXT;

  {declare_vars_type}: text
  | {name_list}: a_nullable: text variable was_set
  | | {name a_nullable}: a_nullable: text variable was_set
  | {type_text}: text

The statement ending at line XXXX

DECLARE an_long LONG_INT;

  {declare_vars_type}: longint
  | {name_list}: an_long: longint variable was_set
  | | {name an_long}: an_long: longint variable was_set
  | {type_long}: longint

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string, a_nullable;

  {fetch_stmt}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc
  | {name_list}
    | {name an_int}: an_int: integer variable was_set
    | {name_list}
      | {name a_string}: a_string: text variable was_set
      | {name_list}
        | {name a_nullable}: a_nullable: text variable was_set

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string;

test/sem_test.sql:XXXX:1: error: in fetch_stmt : CQL0217: number of variables did not match count of columns in cursor 'fetch_cursor'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name an_int}: an_int: integer variable was_set
    | {name_list}
      | {name a_string}: a_string: text variable was_set

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, a_string, a_nullable, a_string2;

test/sem_test.sql:XXXX:1: error: in fetch_stmt : CQL0217: number of variables did not match count of columns in cursor 'fetch_cursor'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name an_int}: an_int: integer variable was_set
    | {name_list}
      | {name a_string}: a_string: text variable was_set
      | {name_list}
        | {name a_nullable}: a_nullable: text variable was_set
        | {name_list}
          | {name a_string2}

The statement ending at line XXXX

FETCH fetch_cursor INTO a_string2, a_string, a_nullable;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'a_string2'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name a_string2}: err
    | {name_list}
      | {name a_string}
      | {name_list}
        | {name a_nullable}

The statement ending at line XXXX

FETCH fetch_cursor INTO an_int, an_int2, a_nullable;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'an_int2'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name an_int}: an_int: integer variable was_set
    | {name_list}
      | {name an_int2}: err
      | {name_list}
        | {name a_nullable}

The statement ending at line XXXX

FETCH not_a_cursor INTO i;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {fetch_stmt}: err
  | {name not_a_cursor}: err
  | {name_list}
    | {name i}

The statement ending at line XXXX

FETCH fetch_cursor INTO non_existent_variable;

test/sem_test.sql:XXXX:1: error: in str : CQL0216: FETCH variable not found 'non_existent_variable'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name non_existent_variable}

The statement ending at line XXXX

FETCH fetch_cursor INTO var_id, var_id;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'var_id'

  {fetch_stmt}: err
  | {name fetch_cursor}: fetch_cursor: select: { _anon: integer notnull, _anon: text notnull, _anon: null } variable dml_proc fetch_into
  | {name_list}
    | {name var_id}
    | {name_list}
      | {name var_id}

The statement ending at line XXXX

CREATE INDEX index_7 ON foo (id, id);

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'id'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_7}
  | | {name foo}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}: err
          | {indexed_column}
          | | {name id}: id: integer notnull
          | {indexed_columns}
            | {indexed_column}
              | {name id}: err

The statement ending at line XXXX

CREATE TABLE bad_table(
  key_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  CONSTRAINT ak1 UNIQUE (key_id, key_id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'key_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: key_id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name key_id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {name ak1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
            | | {name key_id}: key_id: integer notnull
            | {indexed_columns}
              | {indexed_column}
                | {name key_id}: err

The statement ending at line XXXX

CREATE TABLE bad_table_2(
  key_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  UNIQUE (key_id, key_id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'key_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table_2}
  | {col_key_list}
    | {col_def}: key_id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name key_id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {unq_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}: err
            | {indexed_column}
            | | {name key_id}: key_id: integer notnull
            | {indexed_columns}
              | {indexed_column}
                | {name key_id}: err

The statement ending at line XXXX

CREATE TABLE bad_table(
  col_id INTEGER,
  FOREIGN KEY (col_id, col_id) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'col_id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: col_id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col_id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {fk_info}
          | {name_list}: err
          | | {name col_id}: col_id: integer
          | | {name_list}
          |   | {name col_id}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}
            | {int 0}

The statement ending at line XXXX

CREATE TABLE ref_target(
  ref_id1 INTEGER,
  ref_id2 INTEGER
);

  {create_table_stmt}: ref_target: { ref_id1: integer, ref_id2: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name ref_target}
  | {col_key_list}
    | {col_def}: ref_id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name ref_id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: ref_id2: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name ref_id2}
            | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE bad_table(
  id1 INTEGER,
  id2 INTEGER,
  FOREIGN KEY (id1, id2) REFERENCES ref_target (ref_id1, ref_id1)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'ref_id1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_table}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}
          | {fk_info}
            | {name_list}
            | | {name id1}: id1: integer
            | | {name_list}
            |   | {name id2}: id2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name ref_target}
              | | {name_list}: err
              |   | {name ref_id1}: ref_id1: integer
              |   | {name_list}
              |     | {name ref_id1}: err
              | {int 0}

The statement ending at line XXXX

SET X := my_cursor;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {name my_cursor}: _my_cursor_has_row_: bool notnull variable

The statement ending at line XXXX

UPDATE foo
SET id = 1
  WHERE id = 2;

  {update_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_from}
      | {update_where}
        | {opt_where}: bool notnull
        | | {eq}: bool notnull
        |   | {name id}: id: integer notnull
        |   | {int 2}: integer notnull
        | {update_orderby}

The statement ending at line XXXX

UPDATE with_kind
SET cost = price_d;

  {update_stmt}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: cost: real<dollars>
    |   | {name cost}: cost: real<dollars>
    |   | {name price_d}: price_d: real<dollars> variable
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE with_kind
SET cost = price_e;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {update_stmt}: err
  | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name cost}: cost: real<dollars>
    |   | {name price_e}: err
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE myView
SET id = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0155: cannot update a view 'myView'

  {update_stmt}: err
  | {name myView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name id}
    |   | {int 1}
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 1
  WHERE NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_from}
      | {update_where}
        | {opt_where}: err
        | | {not}: err
        |   | {strlit 'x'}: text notnull
        | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 1
LIMIT 'x';

test/sem_test.sql:XXXX:1: error: in opt_limit : CQL0015: expected numeric expression 'LIMIT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_from}
      | {update_where}
        | {update_orderby}
          | {opt_limit}: err
            | {strlit 'x'}: err

The statement ending at line XXXX

UPDATE foo
SET id = 1
ORDER BY NOT 'x'
LIMIT 2;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 1}: integer notnull
    | {update_from}
      | {update_where}
        | {update_orderby}
          | {opt_orderby}: err
          | | {orderby_list}: err
          |   | {orderby_item}
          |     | {not}: err
          |       | {strlit 'x'}: text notnull
          | {opt_limit}
            | {int 2}

The statement ending at line XXXX

UPDATE foo
SET non_existent_column = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'non_existent_column'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name non_existent_column}: err
    |   | {int 1}
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {strlit 'x'}: err
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE foo
SET id = 1L
  WHERE id = 2;

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'LONG_INT' in 1L

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {longint 1}: longint notnull
    | {update_from}
      | {update_where}
        | {opt_where}
        | | {eq}
        |   | {name id}
        |   | {int 2}
        | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET name = 2;

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'name'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name name}: name: text
    |   | {int 2}: err
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET id = NULL;

test/sem_test.sql:XXXX:1: error: in null : CQL0013: cannot assign/copy possibly null expression to not null target 'id'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {null}: null
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET X = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'X'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name X}: err
    |   | {int 1}
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET rate = NULL;

  {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: rate: longint
    |   | {name rate}: rate: longint
    |   | {null}: null
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE bar
SET id = NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {not}: err
    |     | {strlit 'x'}: text notnull
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

CREATE PROC proc1 ()
BEGIN
  DELETE FROM foo;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc1}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {delete_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

CREATE PROC proc1 ()
BEGIN
  DELETE FROM foo;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0186: duplicate stored proc name 'proc1'

  {create_proc_stmt}: err
  | {name proc1}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {delete_stmt}
        | {name foo}

The statement ending at line XXXX

CREATE PROC proc2 (arg1 INTEGER, arg2 TEXT)
BEGIN
  DELETE FROM foo WHERE arg1 = ('x' IN (arg2));
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc2}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable in
    |     | {param_detail}: arg2: text variable in
    |       | {name arg2}: arg2: text variable in
    |       | {type_text}: text
    | {stmt_list}: ok
      | {delete_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }
        | {opt_where}: bool
          | {eq}: bool
            | {name arg1}: arg1: integer variable in
            | {in_pred}: bool notnull
              | {strlit 'x'}: text notnull
              | {expr_list}: arg2: text variable in
                | {name arg2}: arg2: text variable in

The statement ending at line XXXX

SELECT arg1;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'arg1'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name arg1}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT arg2;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'arg2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name arg2}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC proc3 (arg1 INTEGER, arg1 TEXT)
BEGIN
  CALL anything(arg1, arg2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0175: duplicate parameter name 'arg1'

  {create_proc_stmt}: err
  | {name proc3}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: arg1: integer variable in
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: err
    |     | {param_detail}
    |       | {name arg1}
    |       | {type_text}
    | {stmt_list}
      | {call_stmt}
        | {name anything}
        | {expr_list}
          | {name arg1}
          | {expr_list}
            | {name arg2}

The statement ending at line XXXX

CREATE PROC proc3 ()
BEGIN
  THROW;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0186: duplicate stored proc name 'proc3'

  {create_proc_stmt}: err
  | {name proc3}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {throw_stmt}

The statement ending at line XXXX

CREATE PROC proc_throw_not_at_end ()
BEGIN
  THROW;
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in throw_stmt : CQL0308: statement should be the last thing in a statement list

  {create_proc_stmt}: err
  | {name proc_throw_not_at_end}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {throw_stmt}: err
      | {declare_vars_type}: integer
        | {name_list}: x: integer variable
        | | {name x}: x: integer variable
        | {type_int}: integer

The statement ending at line XXXX

CREATE PROC throw_before_out ()
BEGIN
  BEGIN TRY
    DECLARE C CURSOR FOR SELECT 1 AS x;
    FETCH C;
  END TRY;
  BEGIN CATCH
    THROW;
  END CATCH;
  OUT C;
END;

  {create_proc_stmt}: C: throw_before_out: { x: integer notnull } variable dml_proc shape_storage uses_out
  | {name throw_before_out}: C: throw_before_out: { x: integer notnull } variable dml_proc shape_storage uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {trycatch_stmt}: ok
      | | {stmt_list}: ok
      | | | {declare_cursor}: C: select: { x: integer notnull } variable dml_proc
      | | | | {name C}: C: select: { x: integer notnull } variable dml_proc shape_storage
      | | | | {select_stmt}: select: { x: integer notnull }
      | | |   | {select_core_list}: select: { x: integer notnull }
      | | |   | | {select_core}: select: { x: integer notnull }
      | | |   |   | {select_expr_list_con}: select: { x: integer notnull }
      | | |   |     | {select_expr_list}: select: { x: integer notnull }
      | | |   |     | | {select_expr}: x: integer notnull
      | | |   |     |   | {int 1}: integer notnull
      | | |   |     |   | {opt_as_alias}
      | | |   |     |     | {name x}
      | | |   |     | {select_from_etc}: ok
      | | |   |       | {select_where}
      | | |   |         | {select_groupby}
      | | |   |           | {select_having}
      | | |   | {select_orderby}
      | | |     | {select_limit}
      | | |       | {select_offset}
      | | | {fetch_stmt}: C: select: { x: integer notnull } variable dml_proc shape_storage
      | |   | {name C}: C: select: { x: integer notnull } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {throw_stmt}: ok
      | {out_stmt}: C: select: { x: integer notnull } variable dml_proc shape_storage
        | {name C}: C: select: { x: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

DECLARE PROC anything NO CHECK;

  {declare_proc_no_check_stmt}: ok
  | {name anything}

The statement ending at line XXXX

CREATE PROC proc4 (IN arg1 INTEGER, OUT arg2 TEXT, INOUT arg3 REAL)
BEGIN
  CALL anything(arg1, arg3);
END;

  {create_proc_stmt}: ok
  | {name proc4}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable out
    |   | | {out}
    |   | | {param_detail}: arg2: text variable out
    |   |   | {name arg2}: arg2: text variable out
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: arg3: real variable in out
    |       | {inout}
    |       | {param_detail}: arg3: real variable in out
    |         | {name arg3}: arg3: real variable in out
    |         | {type_real}: real
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name anything}: ok
        | {expr_list}: ok
          | {name arg1}: arg1: integer variable in
          | {expr_list}
            | {name arg3}: arg3: real variable in out

The statement ending at line XXXX

CREATE PROC proc5 (IN arg1 INTEGER, OUT arg2 TEXT, INOUT arg3 REAL)
BEGIN
  DECLARE arg1 INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0197: duplicate variable name in the same scope 'arg1'

  {create_proc_stmt}: err
  | {name proc5}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: text variable out
    |   | | {out}
    |   | | {param_detail}: arg2: text variable out
    |   |   | {name arg2}: arg2: text variable out
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: arg3: real variable in out
    |       | {inout}
    |       | {param_detail}: arg3: real variable in out
    |         | {name arg3}: arg3: real variable in out
    |         | {type_real}: real
    | {stmt_list}: err
      | {declare_vars_type}: err
        | {name_list}: err
        | | {name arg1}: err
        | {type_int}: integer

The statement ending at line XXXX

SELECT bar
  FROM bar AS T;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bar'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name bar}: err
  |     | {select_from_etc}: TABLE { T: bar }
  |       | {table_or_subquery_list}: TABLE { T: bar }
  |       | | {table_or_subquery}: TABLE { T: bar }
  |       |   | {name bar}: TABLE { T: bar }
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T
  FROM bar AS T;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'T'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name T}: err
  |     | {select_from_etc}: TABLE { T: bar }
  |       | {table_or_subquery_list}: TABLE { T: bar }
  |       | | {table_or_subquery}: TABLE { T: bar }
  |       |   | {name bar}: TABLE { T: bar }
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, rate
  FROM (SELECT id, rate
  FROM bar);

  {select_stmt}: select: { id: integer notnull, rate: longint }
  | {select_core_list}: select: { id: integer notnull, rate: longint }
  | | {select_core}: select: { id: integer notnull, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: rate: longint
  |     |     | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { id: integer notnull, rate: longint }
  |       |     | {select_core_list}: select: { id: integer notnull, rate: longint }
  |       |     | | {select_core}: select: { id: integer notnull, rate: longint }
  |       |     |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |       |     |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |       |     |     | | {select_expr}: id: integer notnull
  |       |     |     | | | {name id}: id: integer notnull
  |       |     |     | | {select_expr_list}
  |       |     |     |   | {select_expr}: rate: longint
  |       |     |     |     | {name rate}: rate: longint
  |       |     |     | {select_from_etc}: TABLE { bar: bar }
  |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |     |       |   | {name bar}: TABLE { bar: bar }
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, rate
  FROM (SELECT *
  FROM bar);

  {select_stmt}: select: { id: integer notnull, rate: longint }
  | {select_core_list}: select: { id: integer notnull, rate: longint }
  | | {select_core}: select: { id: integer notnull, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, rate: longint }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: rate: longint
  |     |     | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
  |       |     | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
  |       |     | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
  |       |     |     | {select_from_etc}: TABLE { bar: bar }
  |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |     |       |   | {name bar}: TABLE { bar: bar }
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo.id
  FROM foo;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {dot}: id: integer notnull
  |     |     | {name foo}
  |     |     | {name id}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT foo.id
  FROM foo AS T1;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'foo.id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name foo}
  |     |     | {name id}
  |     | {select_from_etc}: TABLE { T1: foo }
  |       | {table_or_subquery_list}: TABLE { T1: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       |   | {name foo}: TABLE { T1: foo }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE int_nn INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: int_nn: integer notnull variable was_set
  | | {name int_nn}: int_nn: integer notnull variable was_set
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

SET int_nn := NULL;

test/sem_test.sql:XXXX:1: error: in null : CQL0013: cannot assign/copy possibly null expression to not null target 'int_nn'

  {assign}: err
  | {name int_nn}: err
  | {null}: null

The statement ending at line XXXX

CALL printf('Hello, world');

  {call_stmt}: ok
  | {name printf}: ok
  | {expr_list}: ok
    | {strlit 'Hello, world'}: text notnull

The statement ending at line XXXX

CALL proc1();

  {call_stmt}: ok dml_proc
  | {name proc1}: ok dml_proc

The statement ending at line XXXX

CALL proc2(1, 'foo');

  {call_stmt}: ok dml_proc
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {strlit 'foo'}: text notnull

The statement ending at line XXXX

CALL proc2('bar', 'foo');

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'arg1'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {strlit 'bar'}: err
    | {expr_list}
      | {strlit 'foo'}

The statement ending at line XXXX

CALL proc2(1, 2);

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'arg2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {int 2}: err

The statement ending at line XXXX

CALL proc2(1, 'foo', 1);

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0235: too many arguments provided to procedure 'proc2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {int 1}

The statement ending at line XXXX

CALL proc2(1);

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0212: too few arguments provided to procedure 'proc2'

  {call_stmt}: err
  | {name proc2}: ok dml_proc
  | {expr_list}: ok
    | {int 1}: integer notnull

The statement ending at line XXXX

CALL proc3(1, 'foo');

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0213: procedure had errors, can't call 'proc3'

  {call_stmt}: err
  | {name proc3}
  | {expr_list}
    | {int 1}
    | {expr_list}
      | {strlit 'foo'}

The statement ending at line XXXX

CREATE PROC proc_with_output (IN arg1 INTEGER, INOUT arg2 INTEGER, OUT arg3 INTEGER)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name proc_with_output}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: arg1: integer variable in
      | | {in}
      | | {param_detail}: arg1: integer variable in
      |   | {name arg1}: arg1: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: arg2: integer variable in out
        | | {inout}
        | | {param_detail}: arg2: integer variable in out
        |   | {name arg2}: arg2: integer variable in out
        |   | {type_int}: integer
        | {params}
          | {param}: arg3: integer variable out
            | {out}
            | {param_detail}: arg3: integer variable out
              | {name arg3}: arg3: integer variable out
              | {type_int}: integer

The statement ending at line XXXX

CALL proc_with_output(1, 2, X);

test/sem_test.sql:XXXX:1: error: in num : CQL0207: expected a variable name for OUT or INOUT argument 'arg2'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {int 2}: err
      | {expr_list}
        | {name X}

The statement ending at line XXXX

CALL proc_with_output(1, X, 3);

test/sem_test.sql:XXXX:1: error: in num : CQL0207: expected a variable name for OUT or INOUT argument 'arg3'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {name X}: X: integer variable was_set
      | {expr_list}
        | {int 3}: err

The statement ending at line XXXX

CALL proc_with_output(1, X, Y);

  {call_stmt}: ok
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {name X}: X: integer variable was_set
      | {expr_list}
        | {name Y}: Y: integer variable was_set

The statement ending at line XXXX

CREATE PROC test_proc2 (INOUT arg1 INTEGER)
BEGIN
  CALL proc_with_output(1, X, arg1);
END;

  {create_proc_stmt}: ok
  | {name test_proc2}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in out was_set
    |   | {inout}
    |   | {param_detail}: arg1: integer variable in out was_set
    |     | {name arg1}: arg1: integer variable in out was_set
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name proc_with_output}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {name X}: X: integer variable was_set
            | {expr_list}
              | {name arg1}: arg1: integer variable in out

The statement ending at line XXXX

CREATE PROC test_proc3 (OUT arg1 INTEGER)
BEGIN
  CALL proc_with_output(1, X, arg1);
END;

  {create_proc_stmt}: ok
  | {name test_proc3}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable out was_set
    |   | {out}
    |   | {param_detail}: arg1: integer variable out was_set
    |     | {name arg1}: arg1: integer variable out was_set
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name proc_with_output}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {name X}: X: integer variable was_set
            | {expr_list}
              | {name arg1}: arg1: integer variable out

The statement ending at line XXXX

CALL proc_with_output(1, X, X);

test/sem_test.sql:XXXX:1: error: in str : CQL0426: OUT or INOUT argument cannot be used again in same call 'X'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {int 1}: integer notnull
    | {expr_list}
      | {name X}: X: integer variable was_set
      | {expr_list}
        | {name X}: X: integer variable was_set

The statement ending at line XXXX

CALL proc_with_output(X, X, Y);

test/sem_test.sql:XXXX:1: error: in str : CQL0426: OUT or INOUT argument cannot be used again in same call 'X'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable was_set
    | {expr_list}
      | {name X}: X: integer variable was_set
      | {expr_list}
        | {name Y}: Y: integer variable was_set

The statement ending at line XXXX

CALL proc_with_output(X, Y, X);

test/sem_test.sql:XXXX:1: error: in str : CQL0426: OUT or INOUT argument cannot be used again in same call 'X'

  {call_stmt}: err
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable was_set
    | {expr_list}
      | {name Y}: Y: integer variable was_set
      | {expr_list}
        | {name X}: X: integer variable was_set

The statement ending at line XXXX

CALL proc_with_output(1 + X, Y, X);

  {call_stmt}: ok
  | {name proc_with_output}: ok
  | {expr_list}: ok
    | {add}: integer
    | | {int 1}: integer notnull
    | | {name X}: X: integer variable was_set
    | {expr_list}
      | {name Y}: Y: integer variable was_set
      | {expr_list}
        | {name X}: X: integer variable was_set

The statement ending at line XXXX

CREATE PROC cursors_cannot_be_used_as_out_args ()
BEGIN
  DECLARE c CURSOR FOR SELECT 0 AS x;
  CALL test_proc3(c);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0207: expected a variable name for OUT or INOUT argument 'arg1'

  {create_proc_stmt}: err
  | {name cursors_cannot_be_used_as_out_args}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { x: integer notnull } variable dml_proc
      | | {name c}: c: select: { x: integer notnull } variable dml_proc
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 0}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {call_stmt}: err
        | {name test_proc3}: ok
        | {expr_list}: ok
          | {name c}: err

The statement ending at line XXXX

CREATE PROC enum_cases_cannot_be_used_as_out_args ()
BEGIN
  CALL test_proc3(-1);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0207: expected a variable name for OUT or INOUT argument 'arg1'

  {create_proc_stmt}: err
  | {name enum_cases_cannot_be_used_as_out_args}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name test_proc3}: ok
        | {expr_list}: ok
          | {int -1}: integer<ints> notnull

The statement ending at line XXXX

CREATE PROC unbound_variables_cannot_be_used_as_out_args ()
BEGIN
  CALL test_proc3(unbound);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'unbound'

  {create_proc_stmt}: err
  | {name unbound_variables_cannot_be_used_as_out_args}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name test_proc3}: ok
        | {expr_list}: ok
          | {name unbound}: err

The statement ending at line XXXX

SELECT count(*)
  FROM foo;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name count}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {star}: integer
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(this_does_not_exist)
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'this_does_not_exist'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name count}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {name this_does_not_exist}: err
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT id) AS c
  FROM foo;

  {select_stmt}: select: { c: integer notnull }
  | {select_core_list}: select: { c: integer notnull }
  | | {select_core}: select: { c: integer notnull }
  |   | {select_expr_list_con}: select: { c: integer notnull }
  |     | {select_expr_list}: select: { c: integer notnull }
  |     | | {select_expr}: c: integer notnull
  |     |   | {call}: integer notnull
  |     |   | | {name count}: integer notnull
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | | {distinct}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name c}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT id) FILTER (WHERE id = 0) AS c
  FROM foo;

  {select_stmt}: select: { c: integer notnull }
  | {select_core_list}: select: { c: integer notnull }
  | | {select_core}: select: { c: integer notnull }
  |   | {select_expr_list_con}: select: { c: integer notnull }
  |     | {select_expr_list}: select: { c: integer notnull }
  |     | | {select_expr}: c: integer notnull
  |     |   | {call}: integer notnull
  |     |   | | {name count}: integer notnull
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | | {distinct}
  |     |   |   | | {opt_filter_clause}: bool notnull
  |     |   |   |   | {opt_where}: bool notnull
  |     |   |   |     | {eq}: bool notnull
  |     |   |   |       | {name id}: id: integer notnull
  |     |   |   |       | {int 0}: integer notnull
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name c}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT count(DISTINCT *)
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0304: DISTINCT may only be used with one explicit argument in an aggregate function 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name count}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | {arg_list}: ok
  |     |         | {star}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(id) AS s
  FROM foo;

  {select_stmt}: select: { s: integer }
  | {select_core_list}: select: { s: integer }
  | | {select_core}: select: { s: integer }
  |   | {select_expr_list_con}: select: { s: integer }
  |     | {select_expr_list}: select: { s: integer }
  |     | | {select_expr}: s: integer
  |     |   | {call}: integer
  |     |   | | {name sum}: integer
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name s}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(id) AS t
  FROM foo;

  {select_stmt}: select: { t: real notnull }
  | {select_core_list}: select: { t: real notnull }
  | | {select_core}: select: { t: real notnull }
  |   | {select_expr_list_con}: select: { t: real notnull }
  |     | {select_expr_list}: select: { t: real notnull }
  |     | | {select_expr}: t: real notnull
  |     |   | {call}: real notnull
  |     |   | | {name total}: real notnull
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name t}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(id, rate)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'total'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name total}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     |         | {arg_list}
  |     |           | {name rate}: rate: longint
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(*)
  FROM foo;

test/sem_test.sql:XXXX:1: error: in star : CQL0051: argument can only be used in count(*) '*'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name sum}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {star}: err
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT avg(id) AS a
  FROM foo;

  {select_stmt}: select: { a: real }
  | {select_core_list}: select: { a: real }
  | | {select_core}: select: { a: real }
  |   | {select_expr_list_con}: select: { a: real }
  |     | {select_expr_list}: select: { a: real }
  |     | | {select_expr}: a: real
  |     |   | {call}: real
  |     |   | | {name avg}: real
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name a}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(id) AS m
  FROM foo;

  {select_stmt}: select: { m: integer }
  | {select_core_list}: select: { m: integer }
  | | {select_core}: select: { m: integer }
  |   | {select_expr_list_con}: select: { m: integer }
  |     | {select_expr_list}: select: { m: integer }
  |     | | {select_expr}: m: integer
  |     |   | {call}: integer
  |     |   | | {name min}: integer
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name m}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT count(1, 2)
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'count'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name count}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT max()
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'max'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name max}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT sign() );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'sign'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sign}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT sign(1, 2) );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'sign'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sign}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT sign('x') );

test/sem_test.sql:XXXX:1: error: in str : CQL0082: argument must be numeric 'sign'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sign}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET rs := ( SELECT sign(1.0) );

  {let_stmt}: rs: integer notnull variable
  | {name rs}: rs: integer notnull variable
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name sign}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.0}: real notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET nl := ( SELECT sign(nullable(-1.0)) );

  {let_stmt}: nl: integer variable
  | {name nl}: nl: integer variable
  | {select_stmt}: _anon: integer
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name sign}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: real
    |     |           | {name nullable}: real
    |     |           | {call_arg_list}
    |     |             | {call_filter_clause}
    |     |             | {arg_list}: ok
    |     |               | {uminus}: real notnull
    |     |                 | {dbl 1.0}: real notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET ssnl := ( SELECT sign(sensitive(nullable(1))) );

  {let_stmt}: ssnl: integer variable sensitive
  | {name ssnl}: ssnl: integer variable sensitive
  | {select_stmt}: _anon: integer sensitive
    | {select_core_list}: select: { _anon: integer sensitive }
    | | {select_core}: select: { _anon: integer sensitive }
    |   | {select_expr_list_con}: select: { _anon: integer sensitive }
    |     | {select_expr_list}: select: { _anon: integer sensitive }
    |     | | {select_expr}: integer sensitive
    |     |   | {call}: integer sensitive
    |     |     | {name sign}: integer sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: integer sensitive
    |     |           | {name sensitive}: integer sensitive
    |     |           | {call_arg_list}
    |     |             | {call_filter_clause}
    |     |             | {arg_list}: ok
    |     |               | {call}: integer
    |     |                 | {name nullable}: integer
    |     |                 | {call_arg_list}
    |     |                   | {call_filter_clause}
    |     |                   | {arg_list}: ok
    |     |                     | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT round() );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'round'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name round}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := round();

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'round'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {call}: err
    | {name round}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SET X := ( SELECT round(1, 2, 3) );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'round'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name round}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT round(1.5, 'x') );

test/sem_test.sql:XXXX:1: error: in str : CQL0082: second argument must be numeric 'round'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name round}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.5}: real notnull
    |     |         | {arg_list}
    |     |           | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT round(1, 2) );

test/sem_test.sql:XXXX:1: error: in call : CQL0087: first argument must be of type real 'round'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name round}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET rr := ( SELECT round(1.0, 2) );

  {let_stmt}: rr: real notnull variable
  | {name rr}: rr: real notnull variable
  | {select_stmt}: _anon: real notnull
    | {select_core_list}: select: { _anon: real notnull }
    | | {select_core}: select: { _anon: real notnull }
    |   | {select_expr_list_con}: select: { _anon: real notnull }
    |     | {select_expr_list}: select: { _anon: real notnull }
    |     | | {select_expr}: real notnull
    |     |   | {call}: real notnull
    |     |     | {name round}: real notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.0}: real notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET ll := ( SELECT round(1.0) );

  {let_stmt}: ll: longint notnull variable was_set
  | {name ll}: ll: longint notnull variable was_set
  | {select_stmt}: _anon: longint notnull
    | {select_core_list}: select: { _anon: longint notnull }
    | | {select_core}: select: { _anon: longint notnull }
    |   | {select_expr_list_con}: select: { _anon: longint notnull }
    |     | {select_expr_list}: select: { _anon: longint notnull }
    |     | | {select_expr}: longint notnull
    |     |   | {call}: longint notnull
    |     |     | {name round}: longint notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.0}: real notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET NLL := ( SELECT round(nullable(1.0)) );

  {let_stmt}: NLL: longint variable
  | {name NLL}: NLL: longint variable
  | {select_stmt}: _anon: longint
    | {select_core_list}: select: { _anon: longint }
    | | {select_core}: select: { _anon: longint }
    |   | {select_expr_list_con}: select: { _anon: longint }
    |     | {select_expr_list}: select: { _anon: longint }
    |     | | {select_expr}: longint
    |     |   | {call}: longint
    |     |     | {name round}: longint
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: real
    |     |           | {name nullable}: real
    |     |           | {call_arg_list}
    |     |             | {call_filter_clause}
    |     |             | {arg_list}: ok
    |     |               | {dbl 1.0}: real notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET NRR := ( SELECT round(1.0, nullable(1)) );

  {let_stmt}: NRR: real variable
  | {name NRR}: NRR: real variable
  | {select_stmt}: _anon: real
    | {select_core_list}: select: { _anon: real }
    | | {select_core}: select: { _anon: real }
    |   | {select_expr_list_con}: select: { _anon: real }
    |     | {select_expr_list}: select: { _anon: real }
    |     | | {select_expr}: real
    |     |   | {call}: real
    |     |     | {name round}: real
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.0}: real notnull
    |     |         | {arg_list}
    |     |           | {call}: integer
    |     |             | {name nullable}: integer
    |     |             | {call_arg_list}
    |     |               | {call_filter_clause}
    |     |               | {arg_list}: ok
    |     |                 | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET SNL := ( SELECT round(sensitive(nullable(1.0))) );

  {let_stmt}: SNL: longint variable sensitive
  | {name SNL}: SNL: longint variable sensitive
  | {select_stmt}: _anon: longint sensitive
    | {select_core_list}: select: { _anon: longint sensitive }
    | | {select_core}: select: { _anon: longint sensitive }
    |   | {select_expr_list_con}: select: { _anon: longint sensitive }
    |     | {select_expr_list}: select: { _anon: longint sensitive }
    |     | | {select_expr}: longint sensitive
    |     |   | {call}: longint sensitive
    |     |     | {name round}: longint sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: real sensitive
    |     |           | {name sensitive}: real sensitive
    |     |           | {call_arg_list}
    |     |             | {call_filter_clause}
    |     |             | {arg_list}: ok
    |     |               | {call}: real
    |     |                 | {name nullable}: real
    |     |                 | {call_arg_list}
    |     |                   | {call_filter_clause}
    |     |                   | {arg_list}: ok
    |     |                     | {dbl 1.0}: real notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET SNR := ( SELECT round(nullable(1.0), sensitive(1)) );

  {let_stmt}: SNR: real variable sensitive
  | {name SNR}: SNR: real variable sensitive
  | {select_stmt}: _anon: real sensitive
    | {select_core_list}: select: { _anon: real sensitive }
    | | {select_core}: select: { _anon: real sensitive }
    |   | {select_expr_list_con}: select: { _anon: real sensitive }
    |     | {select_expr_list}: select: { _anon: real sensitive }
    |     | | {select_expr}: real sensitive
    |     |   | {call}: real sensitive
    |     |     | {name round}: real sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: real
    |     |         | | {name nullable}: real
    |     |         | | {call_arg_list}
    |     |         |   | {call_filter_clause}
    |     |         |   | {arg_list}: ok
    |     |         |     | {dbl 1.0}: real notnull
    |     |         | {arg_list}
    |     |           | {call}: integer notnull sensitive
    |     |             | {name sensitive}: integer notnull sensitive
    |     |             | {call_arg_list}
    |     |               | {call_filter_clause}
    |     |               | {arg_list}: ok
    |     |                 | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET ll := ( SELECT round(1.0, 2.0) );

test/sem_test.sql:XXXX:1: error: in num : CQL0001: operands must be an integer type, not real 'ROUND argument 2'

  {assign}: err
  | {name ll}: ll: longint notnull variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name round}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {dbl 1.0}: real notnull
    |     |         | {arg_list}
    |     |           | {dbl 2.0}: err
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg(1, 2)
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'avg'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg('foo')
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0082: argument must be numeric 'avg'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'foo'}: text notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT avg(NULL)
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0082: argument must be numeric 'avg'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name avg}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {null}: null
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT X * 10 AS v
  WHERE 1 );

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {select_stmt}: v: integer
    | {select_core_list}: select: { v: integer }
    | | {select_core}: select: { v: integer }
    |   | {select_expr_list_con}: select: { v: integer }
    |     | {select_expr_list}: select: { v: integer }
    |     | | {select_expr}: v: integer
    |     |   | {mul}: integer
    |     |   | | {name X}: X: integer variable was_set
    |     |   | | {int 10}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name v}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X_not_null := ( SELECT 1
  WHERE 0 );

  {assign}: X_not_null: integer notnull variable was_set
  | {name X_not_null}: X_not_null: integer notnull variable was_set
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT some_unknown_function(NULL) );

test/sem_test.sql:XXXX:1: error: in str : CQL0094: function not yet implemented 'some_unknown_function'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name some_unknown_function}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {null}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WHILE X
BEGIN
  SELECT 1;
END;

  {while_stmt}: ok
  | {name X}: X: integer variable was_set
  | {stmt_list}: ok
    | {select_stmt}: select: { _anon: integer notnull }
      | {select_core_list}: select: { _anon: integer notnull }
      | | {select_core}: select: { _anon: integer notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull }
      |     | | {select_expr}: integer notnull
      |     |   | {int 1}: integer notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

WHILE 'X'
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in while_stmt : CQL0015: expected numeric expression 'WHILE'

  {while_stmt}: err
  | {strlit 'X'}: err
  | {stmt_list}
    | {select_stmt}
      | {select_core_list}
      | | {select_core}
      |   | {select_expr_list_con}
      |     | {select_expr_list}
      |     | | {select_expr}
      |     |   | {int 1}
      |     | {select_from_etc}
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

WHILE X
BEGIN
  SELECT NOT 'x';
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {while_stmt}: err
  | {name X}: X: integer variable was_set
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'x'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC foo ()
BEGIN
  CREATE PROC bar ()
  BEGIN
    SELECT 1;
  END;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0184: stored procedures cannot be nested 'bar'

  {create_proc_stmt}: err
  | {name foo}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_proc_stmt}: err
        | {name bar}: err
        | {proc_params_stmts}
          | {stmt_list}
            | {select_stmt}
              | {select_core_list}
              | | {select_core}
              |   | {select_expr_list_con}
              |     | {select_expr_list}
              |     | | {select_expr}
              |     |   | {int 1}
              |     | {select_from_etc}
              |       | {select_where}
              |         | {select_groupby}
              |           | {select_having}
              | {select_orderby}
                | {select_limit}
                  | {select_offset}

The statement ending at line XXXX

CREATE PROC calls_dml ()
BEGIN
  CALL proc1();
END;

  {create_proc_stmt}: ok dml_proc
  | {name calls_dml}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: ok dml_proc
        | {name proc1}: ok dml_proc

The statement ending at line XXXX

BEGIN TRY
  SELECT 1;
END TRY;
BEGIN CATCH
  THROW;
END CATCH;

  {trycatch_stmt}: ok
  | {stmt_list}: ok
  | | {select_stmt}: select: { _anon: integer notnull }
  |   | {select_core_list}: select: { _anon: integer notnull }
  |   | | {select_core}: select: { _anon: integer notnull }
  |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |   |     | {select_expr_list}: select: { _anon: integer notnull }
  |   |     | | {select_expr}: integer notnull
  |   |     |   | {int 1}: integer notnull
  |   |     | {select_from_etc}: ok
  |   |       | {select_where}
  |   |         | {select_groupby}
  |   |           | {select_having}
  |   | {select_orderby}
  |     | {select_limit}
  |       | {select_offset}
  | {stmt_list}: ok
    | {throw_stmt}: ok

The statement ending at line XXXX

BEGIN TRY
  SELECT NOT 'x';
END TRY;
BEGIN CATCH
  THROW;
END CATCH;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {trycatch_stmt}: err
  | {stmt_list}: err
  | | {select_stmt}: err
  |   | {select_core_list}: err
  |   | | {select_core}: err
  |   |   | {select_expr_list_con}: err
  |   |     | {select_expr_list}: err
  |   |     | | {select_expr}: err
  |   |     |   | {not}: err
  |   |     |     | {strlit 'x'}: text notnull
  |   |     | {select_from_etc}: ok
  |   |       | {select_where}
  |   |         | {select_groupby}
  |   |           | {select_having}
  |   | {select_orderby}
  |     | {select_limit}
  |       | {select_offset}
  | {stmt_list}
    | {throw_stmt}

The statement ending at line XXXX

BEGIN TRY
  THROW;
END TRY;
BEGIN CATCH
  SELECT NOT 'x';
END CATCH;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {trycatch_stmt}: err
  | {stmt_list}: ok
  | | {throw_stmt}: ok
  | {stmt_list}: err
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     |   | {not}: err
      |     |     | {strlit 'x'}: text notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC with_result_set ()
BEGIN
  SELECT *
    FROM bar;
END;

  {create_proc_stmt}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc
  | {name with_result_set}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC with_matching_result (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A, 4.7 AS B;
  END IF;
END;

  {create_proc_stmt}: with_matching_result: { A: integer notnull, B: real notnull } dml_proc
  | {name with_matching_result}: with_matching_result: { A: integer notnull, B: real notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: i: integer variable in
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: ok
          | {else}: ok
            | {stmt_list}: ok
              | {select_stmt}: select: { A: integer notnull, B: real notnull }
                | {select_core_list}: select: { A: integer notnull, B: real notnull }
                | | {select_core}: select: { A: integer notnull, B: real notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
                |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
                |     | | {select_expr}: A: integer notnull
                |     | | | {int 3}: integer notnull
                |     | | | {opt_as_alias}
                |     | |   | {name A}
                |     | | {select_expr_list}
                |     |   | {select_expr}: B: real notnull
                |     |     | {dbl 4.7}: real notnull
                |     |     | {opt_as_alias}
                |     |       | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_types (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A, 4 AS B;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0061: in multiple select/out statements, all columns must be an exact type match (expected real notnull; found integer notnull) 'B'

  {create_proc_stmt}: err
  | {name with_wrong_types}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer notnull, B: integer notnull }
                | | {select_core}: select: { A: integer notnull, B: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     | | | {int 3}: integer notnull
                |     | | | {opt_as_alias}
                |     | |   | {name A}
                |     | | {select_expr_list}
                |     |   | {select_expr}: B: integer notnull
                |     |     | {int 4}: integer notnull
                |     |     | {opt_as_alias}
                |     |       | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_count (i INTEGER)
BEGIN
  IF i THEN
    SELECT 1 AS A, 2.5 AS B;
  ELSE
    SELECT 3 AS A;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0057: in multiple select/out statements, all must have the same column count
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 2 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 1 columns

only in 1st: B real notnull


  {create_proc_stmt}: err
  | {name with_wrong_count}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer variable in
    |   | {param_detail}: i: integer variable in
    |     | {name i}: i: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer variable in
        | | {name i}: i: integer variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull, B: real notnull }
        |     | {select_core_list}: select: { A: integer notnull, B: real notnull }
        |     | | {select_core}: select: { A: integer notnull, B: real notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull, B: real notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     | | | {int 1}: integer notnull
        |     |     | | | {opt_as_alias}
        |     |     | |   | {name A}
        |     |     | | {select_expr_list}
        |     |     |   | {select_expr}: B: real notnull
        |     |     |     | {dbl 2.5}: real notnull
        |     |     |     | {opt_as_alias}
        |     |     |       | {name B}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer notnull }
                | | {select_core}: select: { A: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     |   | {int 3}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_wrong_flags (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT i AS A;
  ELSE
    SELECT X AS A;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0062: in multiple select/out statements, all columns must be an exact type match (including nullability) (expected integer notnull; found integer) 'A'

  {create_proc_stmt}: err
  | {name with_wrong_flags}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull variable in }
        |     | {select_core_list}: select: { A: integer notnull variable in }
        |     | | {select_core}: select: { A: integer notnull variable in }
        |     |   | {select_expr_list_con}: select: { A: integer notnull variable in }
        |     |     | {select_expr_list}: select: { A: integer notnull variable in }
        |     |     | | {select_expr}: A: integer notnull variable in
        |     |     |   | {name i}: i: integer notnull variable in
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { A: integer variable was_set }
                | | {select_core}: select: { A: integer variable was_set }
                |   | {select_expr_list_con}: select: { A: integer variable was_set }
                |     | {select_expr_list}: select: { A: integer variable was_set }
                |     | | {select_expr}: A: integer variable was_set
                |     |   | {name X}: X: integer variable was_set
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_ok_flags (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT i AS A;
  ELSE
    SELECT 2 AS A;
  END IF;
END;

  {create_proc_stmt}: with_ok_flags: { A: integer notnull } dml_proc
  | {name with_ok_flags}: with_ok_flags: { A: integer notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: i: integer notnull variable in
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull variable in }
        |     | {select_core_list}: select: { A: integer notnull variable in }
        |     | | {select_core}: select: { A: integer notnull variable in }
        |     |   | {select_expr_list_con}: select: { A: integer notnull variable in }
        |     |     | {select_expr_list}: select: { A: integer notnull variable in }
        |     |     | | {select_expr}: A: integer notnull variable in
        |     |     |   | {name i}: i: integer notnull variable in
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: ok
          | {else}: ok
            | {stmt_list}: ok
              | {select_stmt}: select: { A: integer notnull }
                | {select_core_list}: select: { A: integer notnull }
                | | {select_core}: select: { A: integer notnull }
                |   | {select_expr_list_con}: select: { A: integer notnull }
                |     | {select_expr_list}: select: { A: integer notnull }
                |     | | {select_expr}: A: integer notnull
                |     |   | {int 2}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name A}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_bad_names (i INTEGER NOT NULL)
BEGIN
  IF i THEN
    SELECT 1 AS A;
  ELSE
    SELECT 2 AS B;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0058: in multiple select/out statements, all column names must be identical so they have unambiguous names; error in column 1: 'A' vs. 'B'
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 1 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 1 columns

only in 1st: A integer notnull
only in 2nd: B integer notnull


  {create_proc_stmt}: err
  | {name with_bad_names}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: i: integer notnull variable in
        | | {name i}: i: integer notnull variable in
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { A: integer notnull }
        |     | {select_core_list}: select: { A: integer notnull }
        |     | | {select_core}: select: { A: integer notnull }
        |     |   | {select_expr_list_con}: select: { A: integer notnull }
        |     |     | {select_expr_list}: select: { A: integer notnull }
        |     |     | | {select_expr}: A: integer notnull
        |     |     |   | {int 1}: integer notnull
        |     |     |   | {opt_as_alias}
        |     |     |     | {name A}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: err
          | {else}: err
            | {stmt_list}: err
              | {select_stmt}: err
                | {select_core_list}: select: { B: integer notnull }
                | | {select_core}: select: { B: integer notnull }
                |   | {select_expr_list_con}: select: { B: integer notnull }
                |     | {select_expr_list}: select: { B: integer notnull }
                |     | | {select_expr}: B: integer notnull
                |     |   | {int 2}: integer notnull
                |     |   | {opt_as_alias}
                |     |     | {name B}
                |     | {select_from_etc}: ok
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_no_names (i INTEGER NOT NULL)
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0055: all columns in the select must have a name

  {create_proc_stmt}: err
  | {name with_no_names}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer notnull variable in
    |   | {param_detail}: i: integer notnull variable in
    |     | {name i}: i: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: select: { _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     |   | {int 1}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE curs CURSOR FOR CALL with_result_set();

  {declare_cursor}: curs: with_result_set: { id: integer notnull, name: text, rate: longint } variable dml_proc
  | {name curs}: curs: with_result_set: { id: integer notnull, name: text, rate: longint } variable dml_proc
  | {call_stmt}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name with_result_set}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc

The statement ending at line XXXX

DECLARE curs2 CURSOR FOR CALL with_result_set(1);

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0235: too many arguments provided to procedure 'with_result_set'

  {declare_cursor}: err
  | {name curs2}
  | {call_stmt}: err
    | {name with_result_set}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc
    | {expr_list}: ok
      | {int 1}

The statement ending at line XXXX

CALL with_result_set();

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0214: procedures with results can only be called using a cursor in global context 'with_result_set'

  {call_stmt}: err
  | {name with_result_set}

The statement ending at line XXXX

DECLARE curs CURSOR FOR CALL proc1();

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0199: cursor requires a procedure that returns a result set via select 'curs'

  {declare_cursor}: err
  | {name curs}
  | {call_stmt}: ok dml_proc
    | {name proc1}: ok dml_proc

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name, T2.id
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5
OFFSET 7;

  {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |   | | {dot}: name: text
  |           |   |   | {name T2}
  |           |   |   | {name name}
  |           |   | {groupby_list}
  |           |     | {groupby_item}
  |           |       | {dot}: id: integer notnull
  |           |         | {name T2}
  |           |         | {name id}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 7}: integer notnull

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN bar AS T2 ON T1.id = T2.id
  WHERE T2.id > 5
  GROUP BY T2.name
  HAVING T2.name = 'x'
ORDER BY T2.rate
LIMIT 5
OFFSET 'x';

test/sem_test.sql:XXXX:1: error: in opt_offset : CQL0015: expected numeric expression 'OFFSET'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {join_clause}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: bar }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: bar }
  |       |       | | {name bar}: TABLE { T2: bar }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
  |       |         | {on}: bool notnull
  |       |         | {eq}: bool notnull
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer notnull
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {gt}: bool notnull
  |         |   | {dot}: id: integer notnull
  |         |   | | {name T2}
  |         |   | | {name id}
  |         |   | {int 5}: integer notnull
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {dot}: name: text
  |           |       | {name T2}
  |           |       | {name name}
  |           | {select_having}
  |             | {opt_having}: bool
  |               | {eq}: bool
  |                 | {dot}: name: text
  |                 | | {name T2}
  |                 | | {name name}
  |                 | {strlit 'x'}: text notnull
  | {select_orderby}: err
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {dot}: rate: longint
    |       | {name T2}
    |       | {name rate}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 5}: integer notnull
      | {select_offset}
        | {opt_offset}: err
          | {strlit 'x'}: err

The statement ending at line XXXX

SELECT count(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0081: aggregates only make sense if there is a FROM clause 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name count}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE count(*) = 1;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'count'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name count}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {star}: integer
  |         |   | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT max(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0081: aggregates only make sense if there is a FROM clause 'max'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name max}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT avg(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0081: aggregates only make sense if there is a FROM clause 'avg'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name avg}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC out_proc (OUT result INTEGER)
BEGIN
  SET result := 5;
END;

  {create_proc_stmt}: ok
  | {name out_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: result: integer variable out was_set
    |   | {out}
    |   | {param_detail}: result: integer variable out was_set
    |     | {name result}: result: integer variable out was_set
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: result: integer variable out was_set
        | {name result}: result: integer variable out was_set
        | {int 5}: integer notnull

The statement ending at line XXXX

DECLARE my_int INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: my_int: integer notnull variable was_set
  | | {name my_int}: my_int: integer notnull variable was_set
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

CALL out_proc(my_int);

test/sem_test.sql:XXXX:1: error: in str : CQL0013: cannot assign/copy possibly null expression to not null target 'my_int'

  {call_stmt}: err
  | {name out_proc}: ok
  | {expr_list}: ok
    | {name my_int}: my_int: integer notnull variable

The statement ending at line XXXX

DECLARE my_real REAL;

  {declare_vars_type}: real
  | {name_list}: my_real: real variable was_set
  | | {name my_real}: my_real: real variable was_set
  | {type_real}: real

The statement ending at line XXXX

CALL out_proc(my_real);

test/sem_test.sql:XXXX:1: error: in str : CQL0209: proc out parameter: arg must be an exact type match (expected integer; found real) 'my_real'

  {call_stmt}: err
  | {name out_proc}: ok
  | {expr_list}: ok
    | {name my_real}: my_real: real variable

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE EXISTS (SELECT *
  FROM foo);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {exists_expr}: bool notnull
  |         |   | {select_stmt}: select: { id: integer notnull }
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {star}: select: { id: integer notnull }
  |         |     |     | {select_from_etc}: TABLE { foo: foo }
  |         |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |     |       |   | {name foo}: TABLE { foo: foo }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE NOT EXISTS (SELECT *
  FROM foo);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {not}: bool notnull
  |         |   | {exists_expr}: bool notnull
  |         |     | {select_stmt}: select: { id: integer notnull }
  |         |       | {select_core_list}: select: { id: integer notnull }
  |         |       | | {select_core}: select: { id: integer notnull }
  |         |       |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |       |     | {select_expr_list}: select: { id: integer notnull }
  |         |       |     | | {star}: select: { id: integer notnull }
  |         |       |     | {select_from_etc}: TABLE { foo: foo }
  |         |       |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |       |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |       |       |   | {name foo}: TABLE { foo: foo }
  |         |       |       | {select_where}
  |         |       |         | {select_groupby}
  |         |       |           | {select_having}
  |         |       | {select_orderby}
  |         |         | {select_limit}
  |         |           | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE EXISTS (SELECT NOT 'x'
  FROM foo);

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {exists_expr}: err
  |         |   | {select_stmt}: err
  |         |     | {select_core_list}: err
  |         |     | | {select_core}: err
  |         |     |   | {select_expr_list_con}: err
  |         |     |     | {select_expr_list}: err
  |         |     |     | | {select_expr}: err
  |         |     |     |   | {not}: err
  |         |     |     |     | {strlit 'x'}: text notnull
  |         |     |     | {select_from_etc}: TABLE { foo: foo }
  |         |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |     |       |   | {name foo}: TABLE { foo: foo }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  WHERE NOT EXISTS (SELECT NOT 'x'
  FROM foo);

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {not}: err
  |         |   | {exists_expr}: err
  |         |     | {select_stmt}: err
  |         |       | {select_core_list}: err
  |         |       | | {select_core}: err
  |         |       |   | {select_expr_list_con}: err
  |         |       |     | {select_expr_list}: err
  |         |       |     | | {select_expr}: err
  |         |       |     |   | {not}: err
  |         |       |     |     | {strlit 'x'}: text notnull
  |         |       |     | {select_from_etc}: TABLE { foo: foo }
  |         |       |       | {table_or_subquery_list}: TABLE { foo: foo }
  |         |       |       | | {table_or_subquery}: TABLE { foo: foo }
  |         |       |       |   | {name foo}: TABLE { foo: foo }
  |         |       |       | {select_where}
  |         |       |         | {select_groupby}
  |         |       |           | {select_having}
  |         |       | {select_orderby}
  |         |         | {select_limit}
  |         |           | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := EXISTS (SELECT *
  FROM foo);

test/sem_test.sql:XXXX:1: error: in exists_expr : CQL0080: function may not appear in this context 'exists'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {exists_expr}: err
    | {select_stmt}
      | {select_core_list}
      | | {select_core}
      |   | {select_expr_list_con}
      |     | {select_expr_list}
      |     | | {star}
      |     | {select_from_etc}
      |       | {table_or_subquery_list}
      |       | | {table_or_subquery}
      |       |   | {name foo}
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

SET X := NOT EXISTS (SELECT *
  FROM foo);

test/sem_test.sql:XXXX:1: error: in exists_expr : CQL0080: function may not appear in this context 'exists'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not}: err
    | {exists_expr}: err
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {star}
        |     | {select_from_etc}
        |       | {table_or_subquery_list}
        |       | | {table_or_subquery}
        |       |   | {name foo}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

RELEASE garbonzo;

test/sem_test.sql:XXXX:1: error: in release_savepoint_stmt : CQL0221: savepoint has not been mentioned yet, probably wrong 'garbonzo'

  {release_savepoint_stmt}: err
  | {name garbonzo}: ok

The statement ending at line XXXX

ROLLBACK TO another_garbonzo;

test/sem_test.sql:XXXX:1: error: in rollback_trans_stmt : CQL0220: savepoint has not been mentioned yet, probably wrong 'another_garbonzo'

  {rollback_trans_stmt}: err
  | {name another_garbonzo}: ok

The statement ending at line XXXX

DECLARE shape_storage CURSOR FOR SELECT 1 AS one, 2 AS two;

  {declare_cursor}: shape_storage: select: { one: integer notnull, two: integer notnull } variable dml_proc
  | {name shape_storage}: shape_storage: select: { one: integer notnull, two: integer notnull } variable dml_proc shape_storage serialize
  | {select_stmt}: select: { one: integer notnull, two: integer notnull }
    | {select_core_list}: select: { one: integer notnull, two: integer notnull }
    | | {select_core}: select: { one: integer notnull, two: integer notnull }
    |   | {select_expr_list_con}: select: { one: integer notnull, two: integer notnull }
    |     | {select_expr_list}: select: { one: integer notnull, two: integer notnull }
    |     | | {select_expr}: one: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name one}
    |     | | {select_expr_list}
    |     |   | {select_expr}: two: integer notnull
    |     |     | {int 2}: integer notnull
    |     |     | {opt_as_alias}
    |     |       | {name two}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

FETCH shape_storage;

  {fetch_stmt}: shape_storage: select: { one: integer notnull, two: integer notnull } variable dml_proc shape_storage
  | {name shape_storage}: shape_storage: select: { one: integer notnull, two: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

SELECT shape_storage.one;

  {select_stmt}: select: { shape_storage.one: integer notnull variable }
  | {select_core_list}: select: { shape_storage.one: integer notnull variable }
  | | {select_core}: select: { shape_storage.one: integer notnull variable }
  |   | {select_expr_list_con}: select: { shape_storage.one: integer notnull variable }
  |     | {select_expr_list}: select: { shape_storage.one: integer notnull variable }
  |     | | {select_expr}: shape_storage.one: integer notnull variable
  |     |   | {dot}: shape_storage.one: integer notnull variable
  |     |     | {name shape_storage}
  |     |     | {name one}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT shape_storage.three;

test/sem_test.sql:XXXX:1: error: in dot : CQL0068: field not found in cursor 'three'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name shape_storage}
  |     |     | {name three}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT my_cursor.one;

test/sem_test.sql:XXXX:1: error: in dot : CQL0067: cursor was not used with 'fetch [cursor]' 'my_cursor'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name my_cursor}
  |     |     | {name one}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id);

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {join_clause}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: foo }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id, id);

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}
  |       |           | {name id}
  |       |           | {name_list}
  |       |             | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  INNER JOIN foo AS T2 USING (id, idx);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0096: join using column not found on the left side of the join 'idx'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       |           | {name_list}
  |       |             | {name idx}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM bar AS T1
  INNER JOIN foo AS T2 USING (id, name);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0097: join using column not found on the right side of the join 'name'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |       | | {name foo}: TABLE { T2: foo }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: err
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       |           | {name_list}: name: text
  |       |             | {name name}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE payload1(
  id INTEGER NOT NULL,
  data1 INTEGER NOT NULL
);

  {create_table_stmt}: payload1: { id: integer notnull, data1: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name payload1}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: data1: integer notnull
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name data1}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE payload2(
  id INTEGER NOT NULL,
  data2 INTEGER NOT NULL
);

  {create_table_stmt}: payload2: { id: integer notnull, data2: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name payload2}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: data2: integer notnull
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name data2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT *
  FROM payload1
  INNER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | {select_core_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | | {select_core}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | | {star}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  LEFT OUTER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  | {select_core_list}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  | | {select_core}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | {select_expr_list}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | | {star}: select: { id: integer notnull, data1: integer notnull, id: integer, data2: integer }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 3} {join_left_outer}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  RIGHT OUTER JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  | {select_core_list}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  | | {select_core}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | {select_expr_list}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | | {star}: select: { id: integer, data1: integer, id: integer notnull, data2: integer notnull }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 4} {join_right_outer}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM payload1
  CROSS JOIN payload2 USING (id);

  {select_stmt}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | {select_core_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  | | {select_core}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | | {star}: select: { id: integer notnull, data1: integer notnull, id: integer notnull, data2: integer notnull }
  |     | {select_from_etc}: JOIN { payload1: payload1, payload2: payload2 }
  |       | {join_clause}: JOIN { payload1: payload1, payload2: payload2 }
  |       | | {table_or_subquery}: TABLE { payload1: payload1 }
  |       | | | {name payload1}: TABLE { payload1: payload1 }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { payload1: payload1, payload2: payload2 }
  |       |     | {int 2} {join_cross}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { payload2: payload2 }
  |       |       | | {name payload2}: TABLE { payload2: payload2 }
  |       |       | {join_cond}: JOIN { payload1: payload1, payload2: payload2 }
  |       |         | {using}
  |       |         | {name_list}: id: integer notnull
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (foo AS A,
foo AS B)
  INNER JOIN (foo AS C,
foo AS D);

  {select_stmt}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull, id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       | {join_clause}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       | | {table_or_subquery}: JOIN { A: foo, B: foo }
  |       | | | {table_or_subquery_list}: JOIN { A: foo, B: foo }
  |       | |   | {table_or_subquery}: TABLE { A: foo }
  |       | |   | | {name foo}: TABLE { A: foo }
  |       | |   | | {opt_as_alias}
  |       | |   |   | {name A}
  |       | |   | {table_or_subquery_list}: TABLE { B: foo }
  |       | |     | {table_or_subquery}: TABLE { B: foo }
  |       | |       | {name foo}: TABLE { B: foo }
  |       | |       | {opt_as_alias}
  |       | |         | {name B}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { A: foo, B: foo, C: foo, D: foo }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: JOIN { C: foo, D: foo }
  |       |         | {table_or_subquery_list}: JOIN { C: foo, D: foo }
  |       |           | {table_or_subquery}: TABLE { C: foo }
  |       |           | | {name foo}: TABLE { C: foo }
  |       |           | | {opt_as_alias}
  |       |           |   | {name C}
  |       |           | {table_or_subquery_list}: TABLE { D: foo }
  |       |             | {table_or_subquery}: TABLE { D: foo }
  |       |               | {name foo}: TABLE { D: foo }
  |       |               | {opt_as_alias}
  |       |                 | {name D}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM (foo
  INNER JOIN bar ON NOT 'x')
  INNER JOIN foo ON 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: err
  |       | | | {join_clause}: err
  |       | |   | {table_or_subquery}: TABLE { foo: foo }
  |       | |   | | {name foo}: TABLE { foo: foo }
  |       | |   | {join_target_list}
  |       | |     | {join_target}: err
  |       | |       | {int 1} {join_inner}
  |       | |       | {table_join}
  |       | |         | {table_or_subquery}: TABLE { bar: bar }
  |       | |         | | {name bar}: TABLE { bar: bar }
  |       | |         | {join_cond}: err
  |       | |           | {on}: err
  |       | |           | {not}: err
  |       | |             | {strlit 'x'}: text notnull
  |       | | {join_target_list}
  |       |   | {join_target}
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { foo: foo }
  |       |       | | {name foo}: TABLE { foo: foo }
  |       |       | {join_cond}
  |       |         | {on}
  |       |         | {int 1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 0);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, Y, 1.5);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {name Y}: Y: integer variable was_set
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, NULL, 1.5);

test/sem_test.sql:XXXX:1: error: in null : CQL0076: NULL literal is useless in function 'coalesce'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {null}: err
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT coalesce(X, 5, 1.5);

test/sem_test.sql:XXXX:1: error: in num : CQL0077: encountered arg known to be not null before the end of the list, rendering the rest useless. '5'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name coalesce}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {int 5}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 5, 1.5);

test/sem_test.sql:XXXX:1: error: in str : CQL0075: incorrect number of arguments 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {int 5}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 1.5}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(5);

test/sem_test.sql:XXXX:1: error: in str : CQL0074: too few arguments provided 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(X, 'hello');

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'ifnull'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name X}: X: integer variable was_set
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ifnull(NOT 'x', NOT 'hello');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name ifnull}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {not}: err
  |     |         | | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {not}
  |     |             | {strlit 'hello'}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE fk_table_2(
  id1 INTEGER,
  id2 INTEGER,
  FOREIGN KEY (id1, id2) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0023: number of columns on both sides of a foreign key must match

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table_2}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: err
          | {fk_info}
            | {name_list}
            | | {name id1}: id1: integer
            | | {name_list}
            |   | {name id2}: id2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name foo}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_table_2(
  id REAL,
  FOREIGN KEY (id) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0022: exact type of both sides of a foreign key must match (expected real; found integer notnull) 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_table_2}
  | {col_key_list}
    | {col_def}: id: real
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_real}: real
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name id}: id: real
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE join_clause_1(
  id REAL
);

  {create_table_stmt}: join_clause_1: { id: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name join_clause_1}
  | {col_key_list}
    | {col_def}: id: real
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_real}: real

The statement ending at line XXXX

CREATE TABLE join_clause_2(
  id INTEGER
);

  {create_table_stmt}: join_clause_2: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name join_clause_2}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

SELECT *
  FROM join_clause_1
  INNER JOIN join_clause_2 USING (id);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0098: left/right column types in join USING(...) do not match exactly 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { join_clause_1: join_clause_1 }
  |       | | | {name join_clause_1}: TABLE { join_clause_1: join_clause_1 }
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { join_clause_2: join_clause_2 }
  |       |       | | {name join_clause_2}: TABLE { join_clause_2: join_clause_2 }
  |       |       | {join_cond}
  |       |         | {using}
  |       |         | {name_list}: id: integer
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT last_insert_rowid();

  {select_stmt}: select: { _anon: longint notnull }
  | {select_core_list}: select: { _anon: longint notnull }
  | | {select_core}: select: { _anon: longint notnull }
  |   | {select_expr_list_con}: select: { _anon: longint notnull }
  |     | {select_expr_list}: select: { _anon: longint notnull }
  |     | | {select_expr}: longint notnull
  |     |   | {call}: longint notnull
  |     |     | {name last_insert_rowid}: longint notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT last_insert_rowid(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'last_insert_rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name last_insert_rowid}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
LIMIT last_insert_rowid();

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'last_insert_rowid'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {call}: err
      |   | {name last_insert_rowid}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {select_offset}

The statement ending at line XXXX

DECLARE rowid_result LONG_INT NOT NULL;

  {declare_vars_type}: longint notnull
  | {name_list}: rowid_result: longint notnull variable was_set
  | | {name rowid_result}: rowid_result: longint notnull variable was_set
  | {notnull}: longint notnull
    | {type_long}: longint

The statement ending at line XXXX

SET rowid_result := last_insert_rowid();

  {assign}: rowid_result: longint notnull variable was_set
  | {name rowid_result}: rowid_result: longint notnull variable was_set
  | {call}: longint notnull
    | {name last_insert_rowid}: longint notnull
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SELECT changes();

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name changes}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT changes(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'changes'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name changes}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
LIMIT changes();

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'changes'

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {call}: err
      |   | {name changes}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {select_offset}

The statement ending at line XXXX

DECLARE changes_result INTEGER NOT NULL;

  {declare_vars_type}: integer notnull
  | {name_list}: changes_result: integer notnull variable was_set
  | | {name changes_result}: changes_result: integer notnull variable was_set
  | {notnull}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

SET changes_result := changes();

  {assign}: changes_result: integer notnull variable was_set
  | {name changes_result}: changes_result: integer notnull variable was_set
  | {call}: integer notnull
    | {name changes}: integer notnull
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SELECT printf('%s %d', 'x', 5);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s %d'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := printf('Hello');

  {assign}: a_string: text variable was_set
  | {name a_string}: a_string: text variable was_set
  | {call}: text notnull
    | {name printf}: text notnull
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'Hello'}: text notnull

The statement ending at line XXXX

SELECT 1
  FROM (SELECT 1)
LIMIT printf('%s %d', 'x', 5) = 'x';

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'printf'

  {select_stmt}: err
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { _anon: integer notnull }
  |       |     | {select_core_list}: select: { _anon: integer notnull }
  |       |     | | {select_core}: select: { _anon: integer notnull }
  |       |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     |     | | {select_expr}: integer notnull
  |       |     |     |   | {int 1}: integer notnull
  |       |     |     | {select_from_etc}: ok
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {opt_limit}: err
      | | {eq}: err
      |   | {call}: err
      |   | | {name printf}
      |   | | {call_arg_list}
      |   |   | {call_filter_clause}
      |   |   | {arg_list}: ok
      |   |     | {strlit '%s %d'}: text notnull
      |   |     | {arg_list}
      |   |       | {strlit 'x'}: text notnull
      |   |       | {arg_list}
      |   |         | {int 5}: integer notnull
      |   | {strlit 'x'}: text notnull
      | {select_offset}

The statement ending at line XXXX

UPDATE foo
SET id = 1,
id = 3
  WHERE id = 2;

test/sem_test.sql:XXXX:1: error: in str : CQL0153: duplicate target column name in update statement 'id'

  {update_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: id: integer notnull
    | | | {name id}: id: integer notnull
    | | | {int 1}: integer notnull
    | | {update_list}
    |   | {update_entry}: err
    |     | {name id}: err
    |     | {int 3}
    | {update_from}
      | {update_where}
        | {opt_where}
        | | {eq}
        |   | {name id}
        |   | {int 2}
        | {update_orderby}

The statement ending at line XXXX

SET X := ( SELECT sum(1, 2)
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'sum'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sum}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT id
  FROM foo
LIMIT sum(1) );

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'sum'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: select: { id: integer notnull }
    | | {select_core}: select: { id: integer notnull }
    |   | {select_expr_list_con}: select: { id: integer notnull }
    |     | {select_expr_list}: select: { id: integer notnull }
    |     | | {select_expr}: id: integer notnull
    |     |   | {name id}: id: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}: err
      | {select_limit}
        | {opt_limit}: err
        | | {call}: err
        |   | {name sum}
        |   | {call_arg_list}
        |     | {call_filter_clause}
        |     | {arg_list}: ok
        |       | {int 1}: integer notnull
        | {select_offset}

The statement ending at line XXXX

SET X := ( SELECT sum('x')
  FROM foo );

test/sem_test.sql:XXXX:1: error: in str : CQL0083: argument must be numeric 'sum'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name sum}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE TABLE A1(
  foo INTEGER
);

  {create_table_stmt}: A1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name A1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE B1(
  foo INTEGER
);

  {create_table_stmt}: B1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name B1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE C1(
  foo INTEGER
);

  {create_table_stmt}: C1: { foo: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name C1}
  | {col_key_list}
    | {col_def}: foo: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name foo}
          | {type_int}: integer

The statement ending at line XXXX

SELECT *
  FROM A1 AS T1
  LEFT OUTER JOIN B1 AS T2 ON T1.foo = t2.foo
  LEFT OUTER JOIN C1 AS T3 ON T2.foo = t3.foo;

  {select_stmt}: select: { foo: integer, foo: integer, foo: integer }
  | {select_core_list}: select: { foo: integer, foo: integer, foo: integer }
  | | {select_core}: select: { foo: integer, foo: integer, foo: integer }
  |   | {select_expr_list_con}: select: { foo: integer, foo: integer, foo: integer }
  |     | {select_expr_list}: select: { foo: integer, foo: integer, foo: integer }
  |     | | {star}: select: { foo: integer, foo: integer, foo: integer }
  |     | {select_from_etc}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       | {join_clause}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       | | {table_or_subquery}: TABLE { T1: A1 }
  |       | | | {name A1}: TABLE { T1: A1 }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: A1, T2: B1 }
  |       |   | | {int 3} {join_left_outer}
  |       |   | | {table_join}
  |       |   |   | {table_or_subquery}: TABLE { T2: B1 }
  |       |   |   | | {name B1}: TABLE { T2: B1 }
  |       |   |   | | {opt_as_alias}
  |       |   |   |   | {name T2}
  |       |   |   | {join_cond}: JOIN { T1: A1, T2: B1 }
  |       |   |     | {on}: bool
  |       |   |     | {eq}: bool
  |       |   |       | {dot}: foo: integer
  |       |   |       | | {name T1}
  |       |   |       | | {name foo}
  |       |   |       | {dot}: foo: integer
  |       |   |         | {name t2}
  |       |   |         | {name foo}
  |       |   | {join_target_list}
  |       |     | {join_target}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       |       | {int 3} {join_left_outer}
  |       |       | {table_join}
  |       |         | {table_or_subquery}: TABLE { T3: C1 }
  |       |         | | {name C1}: TABLE { T3: C1 }
  |       |         | | {opt_as_alias}
  |       |         |   | {name T3}
  |       |         | {join_cond}: JOIN { T1: A1, T2: B1, T3: C1 }
  |       |           | {on}: bool
  |       |           | {eq}: bool
  |       |             | {dot}: foo: integer
  |       |             | | {name T2}
  |       |             | | {name foo}
  |       |             | {dot}: foo: integer
  |       |               | {name t3}
  |       |               | {name foo}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name) AS grp
  FROM bar
  GROUP BY id;

  {select_stmt}: select: { id: integer notnull, grp: text }
  | {select_core_list}: select: { id: integer notnull, grp: text }
  | | {select_core}: select: { id: integer notnull, grp: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, grp: text }
  |     | {select_expr_list}: select: { id: integer notnull, grp: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: grp: text
  |     |     | {call}: text
  |     |     | | {name group_concat}: text
  |     |     | | {call_arg_list}
  |     |     |   | {call_filter_clause}
  |     |     |   | {arg_list}: ok
  |     |     |     | {name name}: name: text
  |     |     | {opt_as_alias}
  |     |       | {name grp}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name, 'x') AS grp
  FROM bar
  GROUP BY id;

  {select_stmt}: select: { id: integer notnull, grp: text }
  | {select_core_list}: select: { id: integer notnull, grp: text }
  | | {select_core}: select: { id: integer notnull, grp: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, grp: text }
  |     | {select_expr_list}: select: { id: integer notnull, grp: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: grp: text
  |     |     | {call}: text
  |     |     | | {name group_concat}: text
  |     |     | | {call_arg_list}
  |     |     |   | {call_filter_clause}
  |     |     |   | {arg_list}: ok
  |     |     |     | {name name}: name: text
  |     |     |     | {arg_list}
  |     |     |       | {strlit 'x'}: text notnull
  |     |     | {opt_as_alias}
  |     |       | {name grp}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat(name, 0)
  FROM bar
  GROUP BY id;

test/sem_test.sql:XXXX:1: error: in call : CQL0084: second argument must be a string in function 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: name: text
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat()
  FROM bar
  GROUP BY id;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}: err
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, group_concat('x', 'y', 'z')
  FROM bar
  GROUP BY id;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name group_concat}: err
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {strlit 'x'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'y'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit 'z'}: text notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {opt_groupby}: ok
  |           | | {groupby_list}: ok
  |           |   | {groupby_item}
  |           |     | {name id}: id: integer notnull
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM bar
  WHERE group_concat(name) = 'foo';

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'group_concat'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name group_concat}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {name name}: name: text
  |         |   | {strlit 'foo'}: text notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 'now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name strftime}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%YYYY-%mm-%DDT%HH:%MM:%SS.SSS', 'now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name strftime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%YYYY-%mm-%DDT%HH:%MM:%SS.SSS'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%W', 'now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name strftime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%W'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit '+1 month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit 'start of month'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit '-3 minutes'}: text notnull
  |     |                 | {arg_list}
  |     |                   | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 'now', 3);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime(42, 'now');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT strftime('%s', 42);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := strftime('%s', 'now');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'strftime'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name strftime}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit '%s'}: text notnull
        | {arg_list}
          | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT strftime('now');

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'strftime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name strftime}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name date}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name date}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name date}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date('now', 3);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT date(42);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := date('now');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'date'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name date}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT date();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'date'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name date}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name time}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name time}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name time}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time('now', 3);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT time(42);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := time('now');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'time'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name time}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT time();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'time'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name time}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name datetime}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', '+1 month');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name datetime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name datetime}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime('now', 3);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT datetime(42);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := datetime('now');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'datetime'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name datetime}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT datetime();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'datetime'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name datetime}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now');

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name julianday}: real notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', '+1 month');

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name julianday}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', '+1 month', 'start of month', '-3 minutes', 'weekday 4');

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name julianday}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit '+1 month'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'start of month'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit '-3 minutes'}: text notnull
  |     |               | {arg_list}
  |     |                 | {strlit 'weekday 4'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday('now', 3);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'now'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT julianday(42);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := julianday('now');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'julianday'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name julianday}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'now'}: text notnull

The statement ending at line XXXX

SELECT julianday();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'julianday'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name julianday}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CAST(1 AS TEXT);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {cast_expr}: text notnull
  |     |     | {int 1}: integer notnull
  |     |     | {type_text}: text
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := CAST(5.0 AS TEXT);

test/sem_test.sql:XXXX:1: error: in cast_expr : CQL0073: CAST may only appear in the context of SQL statement

  {assign}: err
  | {name X}: X: integer variable was_set
  | {cast_expr}: err
    | {dbl 5.0}: real notnull
    | {type_text}: text

The statement ending at line XXXX

@ENFORCE_STRICT CAST;

  {enforce_strict_stmt}: ok
  | {int 6}

The statement ending at line XXXX

LET idx := CAST(1 AS INTEGER);

test/sem_test.sql:XXXX:1: error: in num : CQL0170: cast is redundant, remove to reduce code size 'CAST(1 AS INTEGER)'

  {let_stmt}: err
  | {name idx}
  | {cast_expr}: err
    | {int 1}: integer notnull
    | {type_int}: integer

The statement ending at line XXXX

LET idr := CAST(1.5 AS INTEGER);

  {let_stmt}: idr: integer notnull variable
  | {name idr}: idr: integer notnull variable
  | {cast_expr}: integer notnull
    | {dbl 1.5}: real notnull
    | {type_int}: integer

The statement ending at line XXXX

LET idx := CAST(1 AS INTEGER<x>);

  {let_stmt}: idx: integer<x> notnull variable
  | {name idx}: idx: integer<x> notnull variable
  | {cast_expr}: integer<x> notnull
    | {int 1}: integer notnull
    | {type_int}: integer<x>
      | {name x}

The statement ending at line XXXX

LET idy := CAST(idx AS INTEGER<y>);

  {let_stmt}: idy: integer<y> notnull variable
  | {name idy}: idy: integer<y> notnull variable
  | {cast_expr}: integer<y> notnull
    | {name idx}: idx: integer<x> notnull variable
    | {type_int}: integer<y>
      | {name y}

The statement ending at line XXXX

SET idy := CAST(idy AS INTEGER<y>);

test/sem_test.sql:XXXX:1: error: in str : CQL0170: cast is redundant, remove to reduce code size 'CAST(idy AS INTEGER<y>)'

  {assign}: err
  | {name idy}: idy: integer<y> notnull variable
  | {cast_expr}: err
    | {name idy}: idy: integer<y> notnull variable
    | {type_int}: integer<y>
      | {name y}

The statement ending at line XXXX

@ENFORCE_NORMAL CAST;

  {enforce_normal_stmt}: ok
  | {int 6}

The statement ending at line XXXX

SELECT CAST(NOT 'x' AS INTEGER);

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {cast_expr}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {type_int}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE pk_test(
  id INTEGER PRIMARY KEY
);

  {create_table_stmt}: pk_test: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name pk_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

CREATE TABLE pk_test_2(
  id INTEGER,
  PRIMARY KEY (id)
);

  {create_table_stmt}: pk_test_2: { id: integer notnull partial_pk }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name pk_test_2}
  | {col_key_list}
    | {col_def}: id: integer notnull partial_pk
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {name id}: id: integer

The statement ending at line XXXX

CREATE TABLE AA1(
  id1 INTEGER NOT NULL
);

  {create_table_stmt}: AA1: { id1: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name AA1}
  | {col_key_list}
    | {col_def}: id1: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id1}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE BB2(
  id2 INTEGER NOT NULL
);

  {create_table_stmt}: BB2: { id2: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name BB2}
  | {col_key_list}
    | {col_def}: id2: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id2}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE CC3(
  id3 INTEGER NOT NULL
);

  {create_table_stmt}: CC3: { id3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name CC3}
  | {col_key_list}
    | {col_def}: id3: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id3}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT *
  FROM (AA1 AS A,
BB2 AS B)
  LEFT OUTER JOIN CC3 AS C ON C.id3 = A.id1;

  {select_stmt}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  | {select_core_list}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  | | {select_core}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |   | {select_expr_list_con}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | {select_expr_list}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | | {star}: select: { id1: integer notnull, id2: integer notnull, id3: integer }
  |     | {select_from_etc}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       | {join_clause}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       | | {table_or_subquery}: JOIN { A: AA1, B: BB2 }
  |       | | | {table_or_subquery_list}: JOIN { A: AA1, B: BB2 }
  |       | |   | {table_or_subquery}: TABLE { A: AA1 }
  |       | |   | | {name AA1}: TABLE { A: AA1 }
  |       | |   | | {opt_as_alias}
  |       | |   |   | {name A}
  |       | |   | {table_or_subquery_list}: TABLE { B: BB2 }
  |       | |     | {table_or_subquery}: TABLE { B: BB2 }
  |       | |       | {name BB2}: TABLE { B: BB2 }
  |       | |       | {opt_as_alias}
  |       | |         | {name B}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       |     | {int 3} {join_left_outer}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { C: CC3 }
  |       |       | | {name CC3}: TABLE { C: CC3 }
  |       |       | | {opt_as_alias}
  |       |       |   | {name C}
  |       |       | {join_cond}: JOIN { A: AA1, B: BB2, C: CC3 }
  |       |         | {on}: bool
  |       |         | {eq}: bool
  |       |           | {dot}: id3: integer
  |       |           | | {name C}
  |       |           | | {name id3}
  |       |           | {dot}: id1: integer notnull
  |       |             | {name A}
  |       |             | {name id1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl1 NO CHECK;

test/sem_test.sql:XXXX:1: error: in declare_proc_no_check_stmt : CQL0404: procedure cannot be both a normal procedure and an unchecked procedure 'decl1'

  {declare_proc_no_check_stmt}: err
  | {name decl1}

The statement ending at line XXXX

DECLARE PROC decl2 (id INTEGER) USING TRANSACTION;

  {declare_proc_stmt}: ok dml_proc
  | {proc_name_type}
  | | {name decl2}: ok dml_proc
  | | {int 2}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl3 (id INTEGER) (A INTEGER NOT NULL, B BOOL);

  {declare_proc_stmt}: decl3: { A: integer notnull, B: bool } dml_proc
  | {proc_name_type}
  | | {name decl3}: decl3: { A: integer notnull, B: bool } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: decl3: { A: integer notnull, B: bool }
      | {typed_name}: A: integer notnull
      | | {name A}
      | | {notnull}: A: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: B: bool
          | {name B}
          | {type_bool}: B: bool

The statement ending at line XXXX

DECLARE PROC decl4 (x_A INTEGER NOT NULL, x_B BOOL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name decl4}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_A: integer notnull variable in
      | | {param_detail}: x_A: integer notnull variable in
      |   | {name x_A}: x_A: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: x_B: bool variable in
          | {param_detail}: x_B: bool variable in
            | {name x_B}: x_B: bool variable in
            | {type_bool}: bool

The statement ending at line XXXX

CREATE PROC bogus_nested_declare ()
BEGIN
  DECLARE PROC yy ();
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0194: declared procedures must be top level 'yy'

  {create_proc_stmt}: err
  | {name bogus_nested_declare}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_proc_stmt}: err
        | {proc_name_type}
        | | {name yy}
        | | {int 0}
        | {proc_params_stmts}

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
        | {param_detail}: id: integer variable in
          | {name id}: id: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC decl1 (id INTEGER NOT NULL);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC decl1 (id INTEGER)
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC decl1 (id INTEGER NOT NULL)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0196: procedure declarations/definitions do not match 'decl1'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name decl1}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer notnull variable in
        | {param_detail}: id: integer notnull variable in
          | {name id}: id: integer notnull variable in
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC bogus_duplicate_params (id INTEGER, id INTEGER);

test/sem_test.sql:XXXX:1: error: in str : CQL0175: duplicate parameter name 'id'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name bogus_duplicate_params}
  | | {int 0}
  | {proc_params_stmts}
    | {params}: err
      | {param}: id: integer variable in
      | | {param_detail}: id: integer variable in
      |   | {name id}: id: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: err
          | {param_detail}
            | {name id}
            | {type_int}

The statement ending at line XXXX

DECLARE PROC bogus_select_list (id INTEGER) (id INTEGER, id INTEGER);

test/sem_test.sql:XXXX:1: error: in str : CQL0190: duplicate column name 'id'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name bogus_select_list}
  | | {int 3}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: err
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: err
          | {name id}
          | {type_int}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT id
  FROM bar);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {in_pred}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: id: integer
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     |   | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT id, id
  FROM bar);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0232: nested select expression must return exactly one column

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {in_pred}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: err
  |         |     | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     | | | {name id}: id: integer notnull
  |         |     |     | | {select_expr_list}
  |         |     |     |   | {select_expr}: id: integer notnull
  |         |     |     |     | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id IN (SELECT name
  FROM bar);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0012: incompatible types in expression 'IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {in_pred}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: name: text
  |         |     | {select_core_list}: select: { name: text }
  |         |     | | {select_core}: select: { name: text }
  |         |     |   | {select_expr_list_con}: select: { name: text }
  |         |     |     | {select_expr_list}: select: { name: text }
  |         |     |     | | {select_expr}: name: text
  |         |     |     |   | {name name}: name: text
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id NOT IN (SELECT id
  FROM bar);

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: bool notnull
  |         | | {not_in}: bool notnull
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: id: integer
  |         |     | {select_core_list}: select: { id: integer notnull }
  |         |     | | {select_core}: select: { id: integer notnull }
  |         |     |   | {select_expr_list_con}: select: { id: integer notnull }
  |         |     |     | {select_expr_list}: select: { id: integer notnull }
  |         |     |     | | {select_expr}: id: integer notnull
  |         |     |     |   | {name id}: id: integer notnull
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE id NOT IN (SELECT name
  FROM bar);

test/sem_test.sql:XXXX:1: error: in not_in : CQL0012: incompatible types in expression 'NOT IN'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {not_in}: err
  |         |   | {name id}: id: integer notnull
  |         |   | {select_stmt}: name: text
  |         |     | {select_core_list}: select: { name: text }
  |         |     | | {select_core}: select: { name: text }
  |         |     |   | {select_expr_list_con}: select: { name: text }
  |         |     |     | {select_expr_list}: select: { name: text }
  |         |     |     | | {select_expr}: name: text
  |         |     |     |   | {name name}: name: text
  |         |     |     | {select_from_etc}: TABLE { bar: bar }
  |         |     |       | {table_or_subquery_list}: TABLE { bar: bar }
  |         |     |       | | {table_or_subquery}: TABLE { bar: bar }
  |         |     |       |   | {name bar}: TABLE { bar: bar }
  |         |     |       | {select_where}
  |         |     |         | {select_groupby}
  |         |     |           | {select_having}
  |         |     | {select_orderby}
  |         |       | {select_limit}
  |         |         | {select_offset}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION
SELECT 3 AS A, 4 AS B;

  {select_stmt}: UNION: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 1}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 3 AS A, 4 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS C
UNION ALL
SELECT 3 AS A, 4 AS B;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0058: if multiple selects, all column names must be identical so they have unambiguous names; error in column 2: 'C' vs. 'B'
test/sem_test.sql:XXXX:1: error: in select_core : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 2 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 2 columns

only in 1st: C integer notnull
only in 2nd: B integer notnull


  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: C: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name C}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS x, 2 AS x, 3 AS y
UNION ALL
SELECT 0 AS u, 1 AS x, 2 AS x, 3 AS z;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0057: if multiple selects, all must have the same column count
test/sem_test.sql:XXXX:1: error: in select_core : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 3 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 4 columns

duplicate column in 1st: x integer notnull
duplicate column in 2nd: x integer notnull
only in 1st: y integer notnull
only in 2nd: u integer notnull
only in 2nd: z integer notnull


  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { x: integer notnull, x: integer notnull, y: integer notnull }
  | |   | {select_expr_list}: select: { x: integer notnull, x: integer notnull, y: integer notnull }
  | |   | | {select_expr}: x: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name x}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: x: integer notnull
  | |   |   | | {int 2}: integer notnull
  | |   |   | | {opt_as_alias}
  | |   |   |   | {name x}
  | |   |   | {select_expr_list}
  | |   |     | {select_expr}: y: integer notnull
  | |   |       | {int 3}: integer notnull
  | |   |       | {opt_as_alias}
  | |   |         | {name y}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { u: integer notnull, x: integer notnull, x: integer notnull, z: integer notnull }
  |       | {select_expr_list_con}: select: { u: integer notnull, x: integer notnull, x: integer notnull, z: integer notnull }
  |         | {select_expr_list}: select: { u: integer notnull, x: integer notnull, x: integer notnull, z: integer notnull }
  |         | | {select_expr}: u: integer notnull
  |         | | | {int 0}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name u}
  |         | | {select_expr_list}
  |         |   | {select_expr}: x: integer notnull
  |         |   | | {int 1}: integer notnull
  |         |   | | {opt_as_alias}
  |         |   |   | {name x}
  |         |   | {select_expr_list}
  |         |     | {select_expr}: x: integer notnull
  |         |     | | {int 2}: integer notnull
  |         |     | | {opt_as_alias}
  |         |     |   | {name x}
  |         |     | {select_expr_list}
  |         |       | {select_expr}: z: integer notnull
  |         |         | {int 3}: integer notnull
  |         |         | {opt_as_alias}
  |         |           | {name z}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 3 AS A, 4.3 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: real notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: real notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: integer notnull, B: real notnull }
  |     | {select_core}: select: { A: integer notnull, B: real notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: real notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: real notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: real notnull
  |         |     | {dbl 4.3}: real notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 'x' AS A
UNION ALL
SELECT 1 AS A;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: err
  | |   | {select_expr_list}: err
  | |   | | {select_expr}: err
  | |   |   | {not}: err
  | |   |   | | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}
  |     | {select_core}
  |       | {select_expr_list_con}
  |         | {select_expr_list}
  |         | | {select_expr}
  |         |   | {int 1}
  |         |   | {opt_as_alias}
  |         |     | {name A}
  |         | {select_from_etc}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' AS A
UNION ALL
SELECT NOT 'x' AS A;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: select: { A: text notnull }
  | | | {select_expr_list_con}: select: { A: text notnull }
  | |   | {select_expr_list}: select: { A: text notnull }
  | |   | | {select_expr}: A: text notnull
  | |   |   | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: err
  |       | {select_expr_list_con}: err
  |         | {select_expr_list}: err
  |         | | {select_expr}: err
  |         |   | {not}: err
  |         |   | | {strlit 'x'}: text notnull
  |         |   | {opt_as_alias}
  |         |     | {name A}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
INTERSECT
SELECT 3 AS A, 4 AS B;

  {select_stmt}: INTERSECT: { A: integer notnull, B: integer notnull }
  | {select_core_list}: INTERSECT: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 3}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
EXCEPT
SELECT 3 AS A, 4 AS B;

  {select_stmt}: EXCEPT: { A: integer notnull, B: integer notnull }
  | {select_core_list}: EXCEPT: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 4}
  |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullable(1) AS x;

  {select_stmt}: select: { x: integer }
  | {select_core_list}: select: { x: integer }
  | | {select_core}: select: { x: integer }
  |   | {select_expr_list_con}: select: { x: integer }
  |     | {select_expr_list}: select: { x: integer }
  |     | | {select_expr}: x: integer
  |     |   | {call}: integer
  |     |   | | {name nullable}: integer
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name x}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET nullable_one := nullable(1);

  {let_stmt}: nullable_one: integer variable
  | {name nullable_one}: nullable_one: integer variable
  | {call}: integer
    | {name nullable}: integer
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT sensitive(1) AS x;

  {select_stmt}: select: { x: integer notnull sensitive }
  | {select_core_list}: select: { x: integer notnull sensitive }
  | | {select_core}: select: { x: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { x: integer notnull sensitive }
  |     | {select_expr_list}: select: { x: integer notnull sensitive }
  |     | | {select_expr}: x: integer notnull sensitive
  |     |   | {call}: integer notnull sensitive
  |     |   | | {name sensitive}: integer notnull sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name x}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET sens_one := sensitive(1);

  {let_stmt}: sens_one: integer notnull variable sensitive
  | {name sens_one}: sens_one: integer notnull variable sensitive
  | {call}: integer notnull sensitive
    | {name sensitive}: integer notnull sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

LET sens_notnull := sensitive("some text");

  {let_stmt}: sens_notnull: text notnull variable sensitive
  | {name sens_notnull}: sens_notnull: text notnull variable sensitive
  | {call}: text notnull sensitive
    | {name sensitive}: text notnull sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'some text'}: text notnull

The statement ending at line XXXX

SELECT nullable(sens_notnull);

  {select_stmt}: select: { sens_notnull: text variable sensitive }
  | {select_core_list}: select: { sens_notnull: text variable sensitive }
  | | {select_core}: select: { sens_notnull: text variable sensitive }
  |   | {select_expr_list_con}: select: { sens_notnull: text variable sensitive }
  |     | {select_expr_list}: select: { sens_notnull: text variable sensitive }
  |     | | {select_expr}: sens_notnull: text variable sensitive
  |     |   | {call}: sens_notnull: text variable sensitive
  |     |     | {name nullable}: sens_notnull: text variable sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name sens_notnull}: sens_notnull: text notnull variable sensitive
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullable(price_e);

  {select_stmt}: select: { price_e: real<euros> variable }
  | {select_core_list}: select: { price_e: real<euros> variable }
  | | {select_core}: select: { price_e: real<euros> variable }
  |   | {select_expr_list_con}: select: { price_e: real<euros> variable }
  |     | {select_expr_list}: select: { price_e: real<euros> variable }
  |     | | {select_expr}: price_e: real<euros> variable
  |     |   | {call}: price_e: real<euros> variable
  |     |     | {name nullable}: price_e: real<euros> variable
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name price_e}: price_e: real<euros> variable
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT nullable(price_e) );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_stmt}: err
    | {select_core_list}: select: { price_e: real<euros> variable }
    | | {select_core}: select: { price_e: real<euros> variable }
    |   | {select_expr_list_con}: select: { price_e: real<euros> variable }
    |     | {select_expr_list}: select: { price_e: real<euros> variable }
    |     | | {select_expr}: price_e: real<euros> variable
    |     |   | {call}: price_e: real<euros> variable
    |     |     | {name nullable}: price_e: real<euros> variable
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name price_e}: price_e: real<euros> variable
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT nullable(1, 2);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'nullable'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name nullable}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sensitive(1, 2);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'sensitive'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name sensitive}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 / 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 / 0.0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: real notnull
  |     |       | {int 1}: integer notnull
  |     |       | {dbl 0.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 / 0L);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: longint notnull
  |     |       | {int 1}: integer notnull
  |     |       | {longint 0}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 / (NOT 1));

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {not}: bool notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 % 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mod}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 % 0L);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mod}: longint notnull
  |     |       | {int 1}: integer notnull
  |     |       | {longint 0}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 % (NOT 1));

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mod}: integer notnull
  |     |       | {int 1}: integer notnull
  |     |       | {not}: bool notnull
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(NOT x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {not}: bool
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(CASE x WHEN 1 THEN 2
END);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {case_expr}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {connector}: integer
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {int 1}: integer notnull
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(CASE 1 WHEN x THEN 2
END);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {case_expr}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {connector}: integer
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {name x}: X: integer variable was_set
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(CASE 1 WHEN 1 THEN x
END);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {case_expr}: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     |       | {connector}: integer variable was_set
  |     |         | {case_list}: integer variable was_set
  |     |           | {when}: X: integer variable was_set
  |     |             | {int 1}: integer notnull
  |     |             | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(CASE WHEN x THEN 2
END);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {case_expr}: integer
  |     |       | {connector}: integer
  |     |         | {case_list}: integer notnull
  |     |           | {when}: integer notnull
  |     |             | {name x}: X: integer variable was_set
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(~1.3);

test/sem_test.sql:XXXX:1: error: in tilde : CQL0001: operands must be an integer type, not real '~'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {tilde}: err
  |     |       | {dbl 1.3}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(~(1 / 0));

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {tilde}: integer notnull
  |     |       | {div}: integer notnull
  |     |         | {int 1}: integer notnull
  |     |         | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(-(1 / 0));

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {uminus}: integer notnull
  |     |       | {div}: integer notnull
  |     |         | {int 1}: integer notnull
  |     |         | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x = x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {eq}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x IS x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {is}: bool notnull
  |     |       | {name x}: X: integer variable was_set
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x + 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {add}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(0 + x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {add}: integer
  |     |       | {int 0}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x - 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {sub}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(0 - x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {sub}: integer
  |     |       | {int 0}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x * 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mul}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(0 * x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mul}: integer
  |     |       | {int 0}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x / 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 / x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {div}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x % 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mod}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 % x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {mod}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x = 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {eq}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 = x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {eq}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x <> 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {ne}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 <> x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {ne}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x <= 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {le}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 <= x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {le}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x >= 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {ge}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 >= x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {ge}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x > 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {gt}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 > x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {gt}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x < 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {lt}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 < x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {lt}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x << 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {lshift}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 << x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {lshift}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x >> 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {rshift}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 >> x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {rshift}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x | 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {bin_or}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 | x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {bin_or}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x & 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {bin_and}: integer
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 & x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {bin_and}: integer
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NULL;

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT FALSE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {bool 0}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x IS 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {is}: bool notnull
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 IS x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {is}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x IS NOT 1);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {is_not}: bool notnull
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 IS NOT x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {is_not}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x AND 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {and}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 AND x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {and}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(x OR 0);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {or}: bool
  |     |       | {name x}: X: integer variable was_set
  |     |       | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(0 OR x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {or}: bool
  |     |       | {int 0}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(1 AND x);

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {and}: bool
  |     |       | {int 1}: integer notnull
  |     |       | {name x}: X: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CONST(CAST(x AS REAL));

test/sem_test.sql:XXXX:1: error: in const : CQL0353: evaluation of constant failed

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {const}: err
  |     |     | {cast_expr}: real
  |     |       | {name x}: X: integer variable was_set
  |     |       | {type_real}: real
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a, a) AS (SELECT 1, 2)
SELECT 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'a'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a, b) AS (SELECT 1, 2),
some_cte (a, b) AS (SELECT 1, 2)
SELECT 1;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0100: duplicate common table name 'some_cte'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { a: integer notnull, b: integer notnull }
  |   | | {cte_decl}: some_cte: { a: integer notnull, b: integer notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name a}
  |   | |   | {name_list}
  |   | |     | {name b}
  |   | | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |   |   |     | | {select_expr}: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: integer notnull
  |   |   |     |     | {int 2}: integer notnull
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}: err
  |       | | {name some_cte}
  |       | | {name_list}
  |       |   | {name a}
  |       |   | {name_list}
  |       |     | {name b}
  |       | {select_stmt}
  |         | {select_core_list}
  |         | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |         |     | | {select_expr}: integer notnull
  |         |     | | | {int 1}: integer notnull
  |         |     | | {select_expr_list}
  |         |     |   | {select_expr}: integer notnull
  |         |     |     | {int 2}: integer notnull
  |         |     | {select_from_etc}: ok
  |         |       | {select_where}
  |         |         | {select_groupby}
  |         |           | {select_having}
  |         | {select_orderby}
  |           | {select_limit}
  |             | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a) AS (SELECT 1, 2)
SELECT 1;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0101: too few column names specified in common table expression 'some_cte'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a, b, c) AS (SELECT 1, 2)
SELECT 1;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0102: too many column names specified in common table expression 'some_cte'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     |     | {name_list}
  |     |       | {name c}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a) AS (SELECT NOT 'x')
SELECT 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       |   | {select_expr_list_con}: err
  |       |     | {select_expr_list}: err
  |       |     | | {select_expr}: err
  |       |     |   | {not}: err
  |       |     |     | {strlit 'x'}: text notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a) AS (SELECT 1)
SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { a: integer notnull }
  |     | {cte_decl}: some_cte: { a: integer notnull }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}: select: { _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a, b) AS (SELECT 1, 2)
SELECT a, b
  FROM some_cte;

  {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { a: integer notnull, b: integer notnull }
  |     | {cte_decl}: some_cte: { a: integer notnull, b: integer notnull }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |     | | {select_expr}: a: integer notnull
    |     | | | {name a}: a: integer notnull
    |     | | {select_expr_list}
    |     |   | {select_expr}: b: integer notnull
    |     |     | {name b}: b: integer notnull
    |     | {select_from_etc}: TABLE { some_cte: some_cte }
    |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |   | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (a) AS (SELECT 1 AS x
UNION ALL
SELECT NULL AS x)
SELECT *
  FROM some_cte;

  {with_select_stmt}: select: { a: integer }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { a: integer }
  |     | {cte_decl}: some_cte: { a: integer }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     | {select_stmt}: UNION ALL: { x: integer }
  |       | {select_core_list}: UNION ALL: { x: integer }
  |       | | {select_core}: select: { x: integer notnull }
  |       | | | {select_expr_list_con}: select: { x: integer notnull }
  |       | |   | {select_expr_list}: select: { x: integer notnull }
  |       | |   | | {select_expr}: x: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   |   | {opt_as_alias}
  |       | |   |     | {name x}
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { x: null }
  |       |     | {select_core}: select: { x: null }
  |       |       | {select_expr_list_con}: select: { x: null }
  |       |         | {select_expr_list}: select: { x: null }
  |       |         | | {select_expr}: x: null
  |       |         |   | {null}: null
  |       |         |   | {opt_as_alias}
  |       |         |     | {name x}
  |       |         | {select_from_etc}: ok
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer }
    | {select_core_list}: select: { a: integer }
    | | {select_core}: select: { a: integer }
    |   | {select_expr_list_con}: select: { a: integer }
    |     | {select_expr_list}: select: { a: integer }
    |     | | {star}: select: { a: integer }
    |     | {select_from_etc}: TABLE { some_cte: some_cte }
    |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |   | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
x (a, b) AS (SELECT 1, 2)
SELECT *
  FROM x AS X
  INNER JOIN (WITH
y (a, b) AS (SELECT 1, 3)
SELECT *
  FROM y) AS Y ON X.a = Y.a
  INNER JOIN (WITH
y (a, b) AS (SELECT 1, 3)
SELECT *
  FROM y) AS Z ON X.a = Z.a;

  {with_select_stmt}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: x: { a: integer notnull, b: integer notnull }
  |     | {cte_decl}: x: { a: integer notnull, b: integer notnull }
  |     | | {name x}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: integer notnull
  |       |     |     | {int 2}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    | {select_core_list}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    | | {select_core}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | | {star}: select: { a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull, a: integer notnull, b: integer notnull }
    |     | {select_from_etc}: JOIN { X: x, Y: select, Z: select }
    |       | {join_clause}: JOIN { X: x, Y: select, Z: select }
    |       | | {table_or_subquery}: TABLE { X: x }
    |       | | | {name x}: TABLE { X: x }
    |       | | | {opt_as_alias}
    |       | |   | {name X}
    |       | | {join_target_list}
    |       |   | {join_target}: JOIN { X: x, Y: select }
    |       |   | | {int 1} {join_inner}
    |       |   | | {table_join}
    |       |   |   | {table_or_subquery}: TABLE { Y: select }
    |       |   |   | | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | | | {with}
    |       |   |   | | | | {cte_tables}: ok
    |       |   |   | | |   | {cte_table}: y: { a: integer notnull, b: integer notnull }
    |       |   |   | | |     | {cte_decl}: y: { a: integer notnull, b: integer notnull }
    |       |   |   | | |     | | {name y}
    |       |   |   | | |     | | {name_list}
    |       |   |   | | |     |   | {name a}
    |       |   |   | | |     |   | {name_list}
    |       |   |   | | |     |     | {name b}
    |       |   |   | | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |   |   | | |       |     | | {select_expr}: integer notnull
    |       |   |   | | |       |     | | | {int 1}: integer notnull
    |       |   |   | | |       |     | | {select_expr_list}
    |       |   |   | | |       |     |   | {select_expr}: integer notnull
    |       |   |   | | |       |     |     | {int 3}: integer notnull
    |       |   |   | | |       |     | {select_from_etc}: ok
    |       |   |   | | |       |       | {select_where}
    |       |   |   | | |       |         | {select_groupby}
    |       |   |   | | |       |           | {select_having}
    |       |   |   | | |       | {select_orderby}
    |       |   |   | | |         | {select_limit}
    |       |   |   | | |           | {select_offset}
    |       |   |   | | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
    |       |   |   | |   |     | {select_from_etc}: TABLE { y: y }
    |       |   |   | |   |       | {table_or_subquery_list}: TABLE { y: y }
    |       |   |   | |   |       | | {table_or_subquery}: TABLE { y: y }
    |       |   |   | |   |       |   | {name y}: TABLE { y: y }
    |       |   |   | |   |       | {select_where}
    |       |   |   | |   |         | {select_groupby}
    |       |   |   | |   |           | {select_having}
    |       |   |   | |   | {select_orderby}
    |       |   |   | |     | {select_limit}
    |       |   |   | |       | {select_offset}
    |       |   |   | | {opt_as_alias}
    |       |   |   |   | {name Y}
    |       |   |   | {join_cond}: JOIN { X: x, Y: select }
    |       |   |     | {on}: bool notnull
    |       |   |     | {eq}: bool notnull
    |       |   |       | {dot}: a: integer notnull
    |       |   |       | | {name X}
    |       |   |       | | {name a}
    |       |   |       | {dot}: a: integer notnull
    |       |   |         | {name Y}
    |       |   |         | {name a}
    |       |   | {join_target_list}
    |       |     | {join_target}: JOIN { X: x, Y: select, Z: select }
    |       |       | {int 1} {join_inner}
    |       |       | {table_join}
    |       |         | {table_or_subquery}: TABLE { Z: select }
    |       |         | | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |         | | | {with}
    |       |         | | | | {cte_tables}: ok
    |       |         | | |   | {cte_table}: y: { a: integer notnull, b: integer notnull }
    |       |         | | |     | {cte_decl}: y: { a: integer notnull, b: integer notnull }
    |       |         | | |     | | {name y}
    |       |         | | |     | | {name_list}
    |       |         | | |     |   | {name a}
    |       |         | | |     |   | {name_list}
    |       |         | | |     |     | {name b}
    |       |         | | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
    |       |         | | |       |     | | {select_expr}: integer notnull
    |       |         | | |       |     | | | {int 1}: integer notnull
    |       |         | | |       |     | | {select_expr_list}
    |       |         | | |       |     |   | {select_expr}: integer notnull
    |       |         | | |       |     |     | {int 3}: integer notnull
    |       |         | | |       |     | {select_from_etc}: ok
    |       |         | | |       |       | {select_where}
    |       |         | | |       |         | {select_groupby}
    |       |         | | |       |           | {select_having}
    |       |         | | |       | {select_orderby}
    |       |         | | |         | {select_limit}
    |       |         | | |           | {select_offset}
    |       |         | | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
    |       |         | |   |     | {select_from_etc}: TABLE { y: y }
    |       |         | |   |       | {table_or_subquery_list}: TABLE { y: y }
    |       |         | |   |       | | {table_or_subquery}: TABLE { y: y }
    |       |         | |   |       |   | {name y}: TABLE { y: y }
    |       |         | |   |       | {select_where}
    |       |         | |   |         | {select_groupby}
    |       |         | |   |           | {select_having}
    |       |         | |   | {select_orderby}
    |       |         | |     | {select_limit}
    |       |         | |       | {select_offset}
    |       |         | | {opt_as_alias}
    |       |         |   | {name Z}
    |       |         | {join_cond}: JOIN { X: x, Y: select, Z: select }
    |       |           | {on}: bool notnull
    |       |           | {eq}: bool notnull
    |       |             | {dot}: a: integer notnull
    |       |             | | {name X}
    |       |             | | {name a}
    |       |             | {dot}: a: integer notnull
    |       |               | {name Z}
    |       |               | {name a}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

  {with_select_stmt}: select: { current: integer notnull }
  | {with_recursive}
  | | {cte_tables}: ok
  |   | {cte_table}: cnt: { current: integer notnull }
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
  |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { _anon: integer notnull }
  |       |     | {select_core}: select: { _anon: integer notnull }
  |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |         | {select_expr_list}: select: { _anon: integer notnull }
  |       |         | | {select_expr}: integer notnull
  |       |         |   | {add}: integer notnull
  |       |         |     | {name current}: current: integer notnull
  |       |         |     | {int 1}: integer notnull
  |       |         | {select_from_etc}: TABLE { cnt: cnt }
  |       |           | {table_or_subquery_list}: TABLE { cnt: cnt }
  |       |           | | {table_or_subquery}: TABLE { cnt: cnt }
  |       |           |   | {name cnt}: TABLE { cnt: cnt }
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}: integer notnull
  |           | | {int 10}: integer notnull
  |           | {select_offset}
  | {select_stmt}: select: { current: integer notnull }
    | {select_core_list}: select: { current: integer notnull }
    | | {select_core}: select: { current: integer notnull }
    |   | {select_expr_list_con}: select: { current: integer notnull }
    |     | {select_expr_list}: select: { current: integer notnull }
    |     | | {select_expr}: current: integer notnull
    |     |   | {name current}: current: integer notnull
    |     | {select_from_etc}: TABLE { cnt: cnt }
    |       | {table_or_subquery_list}: TABLE { cnt: cnt }
    |       | | {table_or_subquery}: TABLE { cnt: cnt }
    |       |   | {name cnt}: TABLE { cnt: cnt }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (u, v) AS (SELECT 1 AS u, 2 AS v),
another_cte (x, y) AS (WITH
baz (x, y) AS (SELECT 2.0 AS x, 3.0 AS y
UNION ALL
SELECT *
  FROM baz
LIMIT 5)
SELECT *
  FROM baz)
SELECT *
  FROM another_cte
  INNER JOIN some_cte;

  {with_select_stmt}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { u: integer notnull, v: integer notnull }
  |   | | {cte_decl}: some_cte: { u: integer notnull, v: integer notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name u}
  |   | |   | {name_list}
  |   | |     | {name v}
  |   | | {select_stmt}: select: { u: integer notnull, v: integer notnull }
  |   |   | {select_core_list}: select: { u: integer notnull, v: integer notnull }
  |   |   | | {select_core}: select: { u: integer notnull, v: integer notnull }
  |   |   |   | {select_expr_list_con}: select: { u: integer notnull, v: integer notnull }
  |   |   |     | {select_expr_list}: select: { u: integer notnull, v: integer notnull }
  |   |   |     | | {select_expr}: u: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name u}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: v: integer notnull
  |   |   |     |     | {int 2}: integer notnull
  |   |   |     |     | {opt_as_alias}
  |   |   |     |       | {name v}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}
  |     | {cte_table}: another_cte: { x: real notnull, y: real notnull }
  |       | {cte_decl}: another_cte: { x: real notnull, y: real notnull }
  |       | | {name another_cte}
  |       | | {name_list}
  |       |   | {name x}
  |       |   | {name_list}
  |       |     | {name y}
  |       | {with_select_stmt}: select: { x: real notnull, y: real notnull }
  |         | {with}
  |         | | {cte_tables}: ok
  |         |   | {cte_table}: baz: { x: real notnull, y: real notnull }
  |         |     | {cte_decl}: baz: { x: real notnull, y: real notnull }
  |         |     | | {name baz}
  |         |     | | {name_list}
  |         |     |   | {name x}
  |         |     |   | {name_list}
  |         |     |     | {name y}
  |         |     | {select_stmt}: UNION ALL: { x: real notnull, y: real notnull }
  |         |       | {select_core_list}: UNION ALL: { x: real notnull, y: real notnull }
  |         |       | | {select_core}: select: { x: real notnull, y: real notnull }
  |         |       | | | {select_expr_list_con}: select: { x: real notnull, y: real notnull }
  |         |       | |   | {select_expr_list}: select: { x: real notnull, y: real notnull }
  |         |       | |   | | {select_expr}: x: real notnull
  |         |       | |   | | | {dbl 2.0}: real notnull
  |         |       | |   | | | {opt_as_alias}
  |         |       | |   | |   | {name x}
  |         |       | |   | | {select_expr_list}
  |         |       | |   |   | {select_expr}: y: real notnull
  |         |       | |   |     | {dbl 3.0}: real notnull
  |         |       | |   |     | {opt_as_alias}
  |         |       | |   |       | {name y}
  |         |       | |   | {select_from_etc}: ok
  |         |       | |     | {select_where}
  |         |       | |       | {select_groupby}
  |         |       | |         | {select_having}
  |         |       | | {select_core_compound}
  |         |       |   | {int 2}
  |         |       |   | {select_core_list}: select: { x: real notnull, y: real notnull }
  |         |       |     | {select_core}: select: { x: real notnull, y: real notnull }
  |         |       |       | {select_expr_list_con}: select: { x: real notnull, y: real notnull }
  |         |       |         | {select_expr_list}: select: { x: real notnull, y: real notnull }
  |         |       |         | | {star}: select: { x: real notnull, y: real notnull }
  |         |       |         | {select_from_etc}: TABLE { baz: baz }
  |         |       |           | {table_or_subquery_list}: TABLE { baz: baz }
  |         |       |           | | {table_or_subquery}: TABLE { baz: baz }
  |         |       |           |   | {name baz}: TABLE { baz: baz }
  |         |       |           | {select_where}
  |         |       |             | {select_groupby}
  |         |       |               | {select_having}
  |         |       | {select_orderby}
  |         |         | {select_limit}
  |         |           | {opt_limit}: integer notnull
  |         |           | | {int 5}: integer notnull
  |         |           | {select_offset}
  |         | {select_stmt}: select: { x: real notnull, y: real notnull }
  |           | {select_core_list}: select: { x: real notnull, y: real notnull }
  |           | | {select_core}: select: { x: real notnull, y: real notnull }
  |           |   | {select_expr_list_con}: select: { x: real notnull, y: real notnull }
  |           |     | {select_expr_list}: select: { x: real notnull, y: real notnull }
  |           |     | | {star}: select: { x: real notnull, y: real notnull }
  |           |     | {select_from_etc}: TABLE { baz: baz }
  |           |       | {table_or_subquery_list}: TABLE { baz: baz }
  |           |       | | {table_or_subquery}: TABLE { baz: baz }
  |           |       |   | {name baz}: TABLE { baz: baz }
  |           |       | {select_where}
  |           |         | {select_groupby}
  |           |           | {select_having}
  |           | {select_orderby}
  |             | {select_limit}
  |               | {select_offset}
  | {select_stmt}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    | {select_core_list}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    | | {select_core}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    |   | {select_expr_list_con}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    |     | {select_expr_list}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    |     | | {star}: select: { x: real notnull, y: real notnull, u: integer notnull, v: integer notnull }
    |     | {select_from_etc}: JOIN { another_cte: another_cte, some_cte: some_cte }
    |       | {join_clause}: JOIN { another_cte: another_cte, some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { another_cte: another_cte }
    |       | | | {name another_cte}: TABLE { another_cte: another_cte }
    |       | | {join_target_list}
    |       |   | {join_target}: JOIN { another_cte: another_cte, some_cte: some_cte }
    |       |     | {int 1} {join_inner}
    |       |     | {table_join}
    |       |       | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |         | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
foo (*) AS (SELECT 1 AS x)
SELECT *
  FROM foo;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0437: common table name shadows previously declared table or view 'foo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name foo}
  |     | | {star}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { x: integer notnull }
  |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |       |     | {select_expr_list}: select: { x: integer notnull }
  |       |     | | {select_expr}: x: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     |   | {opt_as_alias}
  |       |     |     | {name x}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
MyView (*) AS (SELECT 1 AS x)
SELECT *
  FROM MyView;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0437: common table name shadows previously declared table or view 'MyView'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name MyView}
  |     | | {star}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { x: integer notnull }
  |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |       |     | {select_expr_list}: select: { x: integer notnull }
  |       |     | | {select_expr}: x: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     |   | {opt_as_alias}
  |       |     |     | {name x}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name MyView}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shadows_an_existing_table ()
BEGIN
  WITH
  foo (*) LIKE (SELECT 1 AS x)
  SELECT *
    FROM foo;
  WITH
  MyView (*) AS (SELECT 1 AS x)
  SELECT *
    FROM MyView;
END;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0437: common table name shadows previously declared table or view 'foo'
test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0437: common table name shadows previously declared table or view 'MyView'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name shadows_an_existing_table}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
        | | {with}
        | | | {cte_tables}: err
        | |   | {cte_table}: err
        | |     | {cte_decl}: err
        | |     | | {name foo}
        | |     | | {star}
        | |     | {like}
        | |       | {select_stmt}
        | |         | {select_core_list}
        | |         | | {select_core}: select: { x: integer notnull }
        | |         |   | {select_expr_list_con}: select: { x: integer notnull }
        | |         |     | {select_expr_list}: select: { x: integer notnull }
        | |         |     | | {select_expr}: x: integer notnull
        | |         |     |   | {int 1}: integer notnull
        | |         |     |   | {opt_as_alias}
        | |         |     |     | {name x}
        | |         |     | {select_from_etc}: ok
        | |         |       | {select_where}
        | |         |         | {select_groupby}
        | |         |           | {select_having}
        | |         | {select_orderby}
        | |           | {select_limit}
        | |             | {select_offset}
        | | {select_stmt}
        |   | {select_core_list}
        |   | | {select_core}
        |   |   | {select_expr_list_con}
        |   |     | {select_expr_list}
        |   |     | | {star}
        |   |     | {select_from_etc}
        |   |       | {table_or_subquery_list}
        |   |       | | {table_or_subquery}
        |   |       |   | {name foo}
        |   |       | {select_where}
        |   |         | {select_groupby}
        |   |           | {select_having}
        |   | {select_orderby}
        |     | {select_limit}
        |       | {select_offset}
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: err
          |     | {cte_decl}: err
          |     | | {name MyView}
          |     | | {star}
          |     | {select_stmt}
          |       | {select_core_list}
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name MyView}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC does_not_shadow_an_existing_table ()
BEGIN
  WITH
  table_not_yet_defined (x) AS (SELECT 1 AS x)
  SELECT *
    FROM table_not_yet_defined;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
    | {name does_not_shadow_an_existing_table}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: table_not_yet_defined: { x: integer notnull }
          |     | {cte_decl}: table_not_yet_defined: { x: integer notnull }
          |     | | {name table_not_yet_defined}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { table_not_yet_defined: table_not_yet_defined }
            |       | {table_or_subquery_list}: TABLE { table_not_yet_defined: table_not_yet_defined }
            |       | | {table_or_subquery}: TABLE { table_not_yet_defined: table_not_yet_defined }
            |       |   | {name table_not_yet_defined}: TABLE { table_not_yet_defined: table_not_yet_defined }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE table_not_yet_defined(
  y TEXT
);

  {create_table_stmt}: table_not_yet_defined: { y: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name table_not_yet_defined}
  | {col_key_list}
    | {col_def}: y: text
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name y}
          | {type_text}: text

The statement ending at line XXXX

WITH
does_not_shadow_an_existing_table (x) AS (CALL does_not_shadow_an_existing_table())
SELECT *
  FROM does_not_shadow_an_existing_table;

  {with_select_stmt}: select: { x: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: does_not_shadow_an_existing_table: { x: integer notnull }
  |     | {cte_decl}: does_not_shadow_an_existing_table: { x: integer notnull }
  |     | | {name does_not_shadow_an_existing_table}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
  |     | | {name_list}
  |     |   | {name x}
  |     | {shared_cte}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
  |       | {call_stmt}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
  |         | {name does_not_shadow_an_existing_table}: does_not_shadow_an_existing_table: { x: integer notnull } dml_proc
  | {select_stmt}: select: { x: integer notnull }
    | {select_core_list}: select: { x: integer notnull }
    | | {select_core}: select: { x: integer notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull }
    |     | {select_expr_list}: select: { x: integer notnull }
    |     | | {star}: select: { x: integer notnull }
    |     | {select_from_etc}: TABLE { does_not_shadow_an_existing_table: does_not_shadow_an_existing_table }
    |       | {table_or_subquery_list}: TABLE { does_not_shadow_an_existing_table: does_not_shadow_an_existing_table }
    |       | | {table_or_subquery}: TABLE { does_not_shadow_an_existing_table: does_not_shadow_an_existing_table }
    |       |   | {name does_not_shadow_an_existing_table}: TABLE { does_not_shadow_an_existing_table: does_not_shadow_an_existing_table }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC empty_fragment ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0440: fragments may not have an empty body 'empty_fragment'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name empty_fragment}: err
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC a_shared_frag (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x: integer notnull variable in
      | | | {param_detail}: x: integer notnull variable in
      | |   | {name x}: x: integer notnull variable in
      | |   | {notnull}: integer notnull
      | |     | {type_int}: integer
      | | {params}
      |   | {param}: y: integer notnull variable in
      |     | {param_detail}: y: integer notnull variable in
      |       | {name y}: y: integer notnull variable in
      |       | {notnull}: integer notnull
      |         | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |     | | {select_expr}: x: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name x}
          |     | | {select_expr_list}
          |     |   | {select_expr}: y: integer notnull
          |     |   | | {int 2}: integer notnull
          |     |   | | {opt_as_alias}
          |     |   |   | {name y}
          |     |   | {select_expr_list}
          |     |     | {select_expr}: z: real notnull
          |     |       | {dbl 3.0}: real notnull
          |     |       | {opt_as_alias}
          |     |         | {name z}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (CALL a_shared_frag(1, 2));

  {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |     | | {star}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |     | {select_from_etc}: TABLE { a_shared_frag: a_shared_frag }
  |       | {table_or_subquery_list}: TABLE { a_shared_frag: a_shared_frag }
  |       | | {table_or_subquery}: TABLE { a_shared_frag: a_shared_frag }
  |       |   | {shared_cte}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       |     | {call_stmt}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       |       | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       |       | {expr_list}: ok
  |       |         | {int 1}: integer notnull
  |       |         | {expr_list}
  |       |           | {int 2}: integer notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM (CALL a_shared_frag());

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0212: too few arguments provided to procedure 'a_shared_frag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {shared_cte}: err
  |       |     | {call_stmt}: err
  |       |       | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_no_else ()
BEGIN
  IF 1 THEN
    SELECT 1 AS x;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in if_stmt : CQL0442: shared fragments with conditionals must include an else clause 'bogus_conditional_no_else'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_no_else}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {select_stmt}: select: { x: integer notnull }
          |     | {select_core_list}: select: { x: integer notnull }
          |     | | {select_core}: select: { x: integer notnull }
          |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |     |     | {select_expr_list}: select: { x: integer notnull }
          |     |     | | {select_expr}: x: integer notnull
          |     |     |   | {int 1}: integer notnull
          |     |     |   | {opt_as_alias}
          |     |     |     | {name x}
          |     |     | {select_from_etc}: ok
          |     |       | {select_where}
          |     |         | {select_groupby}
          |     |           | {select_having}
          |     | {select_orderby}
          |       | {select_limit}
          |         | {select_offset}
          | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC not_valid_proc_for_select_nothing ()
BEGIN
  SELECT NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in select_nothing_stmt : CQL0496: SELECT NOTHING may only appear in the ELSE clause of a shared fragment

  {create_proc_stmt}: err
  | {name not_valid_proc_for_select_nothing}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_nothing_stmt}: err

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC conditional_else_nothing ()
BEGIN
  IF 1 THEN
    SELECT 1 AS x;
  ELSE
    SELECT NOTHING;
  END IF;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: conditional_else_nothing: { x: integer notnull } dml_proc
    | {name conditional_else_nothing}: conditional_else_nothing: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {select_stmt}: select: { x: integer notnull }
          |     | {select_core_list}: select: { x: integer notnull }
          |     | | {select_core}: select: { x: integer notnull }
          |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |     |     | {select_expr_list}: select: { x: integer notnull }
          |     |     | | {select_expr}: x: integer notnull
          |     |     |   | {int 1}: integer notnull
          |     |     |   | {opt_as_alias}
          |     |     |     | {name x}
          |     |     | {select_from_etc}: ok
          |     |       | {select_where}
          |     |         | {select_groupby}
          |     |           | {select_having}
          |     | {select_orderby}
          |       | {select_limit}
          |         | {select_offset}
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {select_nothing_stmt}: select: { x: integer notnull }

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC ok_conditional_duplicate_cte_names ()
BEGIN
  IF 1 THEN
    WITH
    X (x, y, z) LIKE a_shared_frag
    SELECT *
      FROM X;
  ELSE
    WITH
    X (x, y, z) LIKE a_shared_frag
    SELECT *
      FROM X;
  END IF;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: ok_conditional_duplicate_cte_names: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {name ok_conditional_duplicate_cte_names}: ok_conditional_duplicate_cte_names: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |     | {with}
          |     | | {cte_tables}: ok
          |     |   | {cte_table}: X: { x: integer notnull, y: integer notnull, z: real notnull }
          |     |     | {cte_decl}: X: { x: integer notnull, y: integer notnull, z: real notnull }
          |     |     | | {name X}
          |     |     | | {name_list}
          |     |     |   | {name x}
          |     |     |   | {name_list}
          |     |     |     | {name y}
          |     |     |     | {name_list}
          |     |     |       | {name z}
          |     |     | {like}: ok
          |     |       | {name a_shared_frag}
          |     | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       |     | | {star}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          |       |     | {select_from_etc}: TABLE { X: X }
          |       |       | {table_or_subquery_list}: TABLE { X: X }
          |       |       | | {table_or_subquery}: TABLE { X: X }
          |       |       |   | {name X}: TABLE { X: X }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                  | {with}
                  | | {cte_tables}: ok
                  |   | {cte_table}: X: { x: integer notnull, y: integer notnull, z: real notnull }
                  |     | {cte_decl}: X: { x: integer notnull, y: integer notnull, z: real notnull }
                  |     | | {name X}
                  |     | | {name_list}
                  |     |   | {name x}
                  |     |   | {name_list}
                  |     |     | {name y}
                  |     |     | {name_list}
                  |     |       | {name z}
                  |     | {like}: ok
                  |       | {name a_shared_frag}
                  | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    |     | | {star}: select: { x: integer notnull, y: integer notnull, z: real notnull }
                    |     | {select_from_etc}: TABLE { X: X }
                    |       | {table_or_subquery_list}: TABLE { X: X }
                    |       | | {table_or_subquery}: TABLE { X: X }
                    |       |   | {name X}: TABLE { X: X }
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_duplicate_cte_names ()
BEGIN
  IF 1 THEN
    WITH
    bogus_cte (x, y, z) LIKE a_shared_frag
    SELECT 1 AS x;
  ELSE
    WITH
    bogus_cte (id) LIKE foo
    SELECT 1 AS x;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0057: bogus_cte, all must have the same column count
test/sem_test.sql:XXXX:1: error: in cte_decl : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 3 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 1 columns

only in 1st: x integer notnull
only in 1st: y integer notnull
only in 1st: z real notnull
only in 2nd: id integer notnull


  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_duplicate_cte_names}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {with_select_stmt}: select: { x: integer notnull }
          |     | {with}
          |     | | {cte_tables}: ok
          |     |   | {cte_table}: bogus_cte: { x: integer notnull, y: integer notnull, z: real notnull }
          |     |     | {cte_decl}: bogus_cte: { x: integer notnull, y: integer notnull, z: real notnull }
          |     |     | | {name bogus_cte}
          |     |     | | {name_list}
          |     |     |   | {name x}
          |     |     |   | {name_list}
          |     |     |     | {name y}
          |     |     |     | {name_list}
          |     |     |       | {name z}
          |     |     | {like}: ok
          |     |       | {name a_shared_frag}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {with_select_stmt}: select: { x: integer notnull }
                  | {with}
                  | | {cte_tables}: ok
                  |   | {cte_table}: bogus_cte: { id: integer notnull }
                  |     | {cte_decl}: err
                  |     | | {name bogus_cte}
                  |     | | {name_list}
                  |     |   | {name id}
                  |     | {like}: ok
                  |       | {name foo}
                  | {select_stmt}: select: { x: integer notnull }
                    | {select_core_list}: select: { x: integer notnull }
                    | | {select_core}: select: { x: integer notnull }
                    |   | {select_expr_list_con}: select: { x: integer notnull }
                    |     | {select_expr_list}: select: { x: integer notnull }
                    |     | | {select_expr}: x: integer notnull
                    |     |   | {int 1}: integer notnull
                    |     |   | {opt_as_alias}
                    |     |     | {name x}
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_two_selects ()
BEGIN
  IF 1 THEN
    SELECT 1 AS x;
    SELECT 1 AS x;
  ELSE
    SELECT 1 AS x;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0443: shared fragments with conditionals must have exactly one SELECT, or WITH...SELECT in each statement list 'bogus_conditional_two_selects'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_two_selects}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {select_stmt}: select: { x: integer notnull }
          |   | | {select_core_list}: select: { x: integer notnull }
          |   | | | {select_core}: select: { x: integer notnull }
          |   | |   | {select_expr_list_con}: select: { x: integer notnull }
          |   | |     | {select_expr_list}: select: { x: integer notnull }
          |   | |     | | {select_expr}: x: integer notnull
          |   | |     |   | {int 1}: integer notnull
          |   | |     |   | {opt_as_alias}
          |   | |     |     | {name x}
          |   | |     | {select_from_etc}: ok
          |   | |       | {select_where}
          |   | |         | {select_groupby}
          |   | |           | {select_having}
          |   | | {select_orderby}
          |   |   | {select_limit}
          |   |     | {select_offset}
          |   | {select_stmt}: select: { x: integer notnull }
          |     | {select_core_list}: select: { x: integer notnull }
          |     | | {select_core}: select: { x: integer notnull }
          |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |     |     | {select_expr_list}: select: { x: integer notnull }
          |     |     | | {select_expr}: x: integer notnull
          |     |     |   | {int 1}: integer notnull
          |     |     |   | {opt_as_alias}
          |     |     |     | {name x}
          |     |     | {select_from_etc}: ok
          |     |       | {select_where}
          |     |         | {select_groupby}
          |     |           | {select_having}
          |     | {select_orderby}
          |       | {select_limit}
          |         | {select_offset}
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {select_stmt}: select: { x: integer notnull }
                  | {select_core_list}: select: { x: integer notnull }
                  | | {select_core}: select: { x: integer notnull }
                  |   | {select_expr_list_con}: select: { x: integer notnull }
                  |     | {select_expr_list}: select: { x: integer notnull }
                  |     | | {select_expr}: x: integer notnull
                  |     |   | {int 1}: integer notnull
                  |     |   | {opt_as_alias}
                  |     |     | {name x}
                  |     | {select_from_etc}: ok
                  |       | {select_where}
                  |         | {select_groupby}
                  |           | {select_having}
                  | {select_orderby}
                    | {select_limit}
                      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_non_select ()
BEGIN
  IF 1 THEN
    DECLARE x INTEGER;
  ELSE
    SELECT 1 AS x;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in declare_vars_type : CQL0443: shared fragments with conditionals must have exactly SELECT, or WITH...SELECT in each statement list 'bogus_conditional_non_select'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_non_select}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {declare_vars_type}: integer
          |     | {name_list}: x: integer variable
          |     | | {name x}: x: integer variable
          |     | {type_int}: integer
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {select_stmt}: select: { x: integer notnull }
                  | {select_core_list}: select: { x: integer notnull }
                  | | {select_core}: select: { x: integer notnull }
                  |   | {select_expr_list_con}: select: { x: integer notnull }
                  |     | {select_expr_list}: select: { x: integer notnull }
                  |     | | {select_expr}: x: integer notnull
                  |     |   | {int 1}: integer notnull
                  |     |   | {opt_as_alias}
                  |     |     | {name x}
                  |     | {select_from_etc}: ok
                  |       | {select_where}
                  |         | {select_groupby}
                  |           | {select_having}
                  | {select_orderby}
                    | {select_limit}
                      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_empty_clause ()
BEGIN
  IF 1 THEN
  ELSE
    SELECT 1 AS x;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in cond_action : CQL0443: shared fragments with conditionals must have exactly one SELECT, or WITH...SELECT in each statement list 'bogus_conditional_empty_clause'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_empty_clause}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | {if_alt}: ok
            | {else}: ok
              | {stmt_list}: ok
                | {select_stmt}: select: { x: integer notnull }
                  | {select_core_list}: select: { x: integer notnull }
                  | | {select_core}: select: { x: integer notnull }
                  |   | {select_expr_list_con}: select: { x: integer notnull }
                  |     | {select_expr_list}: select: { x: integer notnull }
                  |     | | {select_expr}: x: integer notnull
                  |     |   | {int 1}: integer notnull
                  |     |   | {opt_as_alias}
                  |     |     | {name x}
                  |     | {select_from_etc}: ok
                  |       | {select_where}
                  |         | {select_groupby}
                  |           | {select_having}
                  | {select_orderby}
                    | {select_limit}
                      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_conditional_empty_else_clause ()
BEGIN
  IF 1 THEN
    SELECT 1 AS x;
  ELSE
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in if_stmt : CQL0443: shared fragments with conditionals must have exactly one SELECT, or WITH...SELECT in each statement list 'bogus_conditional_empty_else_clause'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_conditional_empty_else_clause}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {if_stmt}: integer notnull
          | {cond_action}: integer notnull
          | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {select_stmt}: select: { x: integer notnull }
          |     | {select_core_list}: select: { x: integer notnull }
          |     | | {select_core}: select: { x: integer notnull }
          |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |     |     | {select_expr_list}: select: { x: integer notnull }
          |     |     | | {select_expr}: x: integer notnull
          |     |     |   | {int 1}: integer notnull
          |     |     |   | {opt_as_alias}
          |     |     |     | {name x}
          |     |     | {select_from_etc}: ok
          |     |       | {select_where}
          |     |         | {select_groupby}
          |     |           | {select_having}
          |     | {select_orderby}
          |       | {select_limit}
          |         | {select_offset}
          | {if_alt}: ok
            | {else}: ok

The statement ending at line XXXX

CALL a_shared_frag();

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0434: shared fragments may not be called outside of a SQL statement 'a_shared_frag'

  {call_stmt}: err
  | {name a_shared_frag}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag2 (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  WITH
  source (x, y, z) LIKE a_shared_frag
  SELECT *
    FROM source;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x: integer notnull variable in
      | | | {param_detail}: x: integer notnull variable in
      | |   | {name x}: x: integer notnull variable in
      | |   | {notnull}: integer notnull
      | |     | {type_int}: integer
      | | {params}
      |   | {param}: y: integer notnull variable in
      |     | {param_detail}: y: integer notnull variable in
      |       | {name y}: y: integer notnull variable in
      |       | {notnull}: integer notnull
      |         | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull, y: integer notnull, z: real notnull }
          |     | {cte_decl}: source: { x: integer notnull, y: integer notnull, z: real notnull }
          |     | | {name source}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {like}: ok
          |       | {name a_shared_frag}
          | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            |     | | {star}: select: { x: integer notnull, y: integer notnull, z: real notnull }
            |     | {select_from_etc}: TABLE { source: source }
            |       | {table_or_subquery_list}: TABLE { source: source }
            |       | | {table_or_subquery}: TABLE { source: source }
            |       |   | {name source}: TABLE { source: source }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

WITH
shared_frag2 (*) AS (CALL shared_frag2(1, 2))
SELECT *
  FROM a_shared_frag;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0430: no actual table was provided for the table parameter 'source'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |     | | {star}
  |     | {shared_cte}: err
  |       | {call_stmt}: err
  |         | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | {expr_list}: ok
  |           | {int 1}: integer notnull
  |           | {expr_list}
  |             | {int 2}: integer notnull
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name a_shared_frag}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE PROC frag_type () (id INTEGER<job>, name TEXT);

  {declare_proc_stmt}: frag_type: { id: integer<job>, name: text } dml_proc
  | {proc_name_type}
  | | {name frag_type}: frag_type: { id: integer<job>, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: frag_type: { id: integer<job>, name: text }
      | {typed_name}: id: integer<job>
      | | {name id}
      | | {type_int}: id: integer<job>
      |   | {name job}
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag3 ()
BEGIN
  WITH
  source (id, name) LIKE frag_type
  SELECT *
    FROM source;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: shared_frag3: { id: integer<job>, name: text } dml_proc
    | {name shared_frag3}: shared_frag3: { id: integer<job>, name: text } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer<job>, name: text }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { id: integer<job>, name: text }
          |     | {cte_decl}: source: { id: integer<job>, name: text }
          |     | | {name source}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name name}
          |     | {like}: ok
          |       | {name frag_type}
          | {select_stmt}: select: { id: integer<job>, name: text }
            | {select_core_list}: select: { id: integer<job>, name: text }
            | | {select_core}: select: { id: integer<job>, name: text }
            |   | {select_expr_list_con}: select: { id: integer<job>, name: text }
            |     | {select_expr_list}: select: { id: integer<job>, name: text }
            |     | | {star}: select: { id: integer<job>, name: text }
            |     | {select_from_etc}: TABLE { source: source }
            |       | {table_or_subquery_list}: TABLE { source: source }
            |       | | {table_or_subquery}: TABLE { source: source }
            |       |   | {name source}: TABLE { source: source }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE jobstuff(
  id INTEGER<job>,
  name TEXT
);

  {create_table_stmt}: jobstuff: { id: integer<job>, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name jobstuff}
  | {col_key_list}
    | {col_def}: id: integer<job>
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer<job>
    |       | {name job}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE bad_jobstuff(
  id INTEGER<meters>,
  name TEXT
);

  {create_table_stmt}: bad_jobstuff: { id: integer<meters>, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_jobstuff}
  | {col_key_list}
    | {col_def}: id: integer<meters>
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer<meters>
    |       | {name meters}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

WITH
data (id, name) AS (CALL shared_frag3() USING jobstuff AS source)
SELECT *
  FROM data;

  {with_select_stmt}: select: { id: integer<job>, name: text }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: data: { id: integer<job>, name: text }
  |     | {cte_decl}: data: { id: integer<job>, name: text }
  |     | | {name data}
  |     | | {name_list}
  |     |   | {name id}
  |     |   | {name_list}
  |     |     | {name name}
  |     | {shared_cte}: shared_frag3: { id: integer<job>, name: text } dml_proc
  |       | {call_stmt}: shared_frag3: { id: integer<job>, name: text } dml_proc
  |       | | {name shared_frag3}: shared_frag3: { id: integer<job>, name: text } dml_proc
  |       | {cte_binding_list}
  |         | {cte_binding}
  |           | {name jobstuff}: jobstuff: { id: integer<job>, name: text }
  |           | {name source}: source: { id: integer<job>, name: text }
  | {select_stmt}: select: { id: integer<job>, name: text }
    | {select_core_list}: select: { id: integer<job>, name: text }
    | | {select_core}: select: { id: integer<job>, name: text }
    |   | {select_expr_list_con}: select: { id: integer<job>, name: text }
    |     | {select_expr_list}: select: { id: integer<job>, name: text }
    |     | | {star}: select: { id: integer<job>, name: text }
    |     | {select_from_etc}: TABLE { data: data }
    |       | {table_or_subquery_list}: TABLE { data: data }
    |       | | {table_or_subquery}: TABLE { data: data }
    |       |   | {name data}: TABLE { data: data }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
data (*) AS (CALL shared_frag3() USING bad_jobstuff AS source)
SELECT *
  FROM data;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'meters' vs. 'job'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name data}
  |     | | {star}
  |     | {shared_cte}: err
  |       | {call_stmt}: err
  |       | | {name shared_frag3}: shared_frag3: { id: integer<job>, name: text } dml_proc
  |       | {cte_binding_list}
  |         | {cte_binding}
  |           | {name bad_jobstuff}: err
  |           | {name source}: source: { id: integer<job>, name: text }
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name data}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag_bad_like ()
BEGIN
  WITH
  source (*) LIKE there_is_no_such_source
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'there_is_no_such_source'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name shared_frag_bad_like}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: err
          |     | {cte_decl}
          |     | | {name source}
          |     | | {star}
          |     | {like}: err
          |       | {name there_is_no_such_source}: err
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     | | | {int 1}
            |     | | | {opt_as_alias}
            |     | |   | {name x}
            |     | | {select_expr_list}
            |     |   | {select_expr}
            |     |   | | {int 2}
            |     |   | | {opt_as_alias}
            |     |   |   | {name y}
            |     |   | {select_expr_list}
            |     |     | {select_expr}
            |     |       | {dbl 3.0}
            |     |       | {opt_as_alias}
            |     |         | {name z}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

WITH
source (*) LIKE there_is_no_such_source
SELECT 1 AS x, 2 AS y, 3.0 AS z;

test/sem_test.sql:XXXX:1: error: in like : CQL0427: LIKE CTE form may only be used inside a shared fragment at the top level i.e. @attribute(cql:shared_fragment)

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name source}
  |     | | {star}
  |     | {like}
  |       | {name there_is_no_such_source}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     | | | {int 1}
    |     | | | {opt_as_alias}
    |     | |   | {name x}
    |     | | {select_expr_list}
    |     |   | {select_expr}
    |     |   | | {int 2}
    |     |   | | {opt_as_alias}
    |     |   |   | {name y}
    |     |   | {select_expr_list}
    |     |     | {select_expr}
    |     |       | {dbl 3.0}
    |     |       | {opt_as_alias}
    |     |         | {name z}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC not_a_shared_fragment ()
BEGIN
  WITH
  source (*) LIKE there_is_no_such_source
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0427: LIKE CTE form may only be used inside a shared fragment at the top level i.e. @attribute(cql:shared_fragment) 'not_a_shared_fragment'

  {create_proc_stmt}: err
  | {name not_a_shared_fragment}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_select_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name source}
        |     | | {star}
        |     | {like}
        |       | {name there_is_no_such_source}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {select_expr}
          |     | | | {int 1}
          |     | | | {opt_as_alias}
          |     | |   | {name x}
          |     | | {select_expr_list}
          |     |   | {select_expr}
          |     |   | | {int 2}
          |     |   | | {opt_as_alias}
          |     |   |   | {name y}
          |     |   | {select_expr_list}
          |     |     | {select_expr}
          |     |       | {dbl 3.0}
          |     |       | {opt_as_alias}
          |     |         | {name z}
          |     | {select_from_etc}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z),
x (*) AS (CALL a_shared_frag(1, 2) USING some_cte AS foo)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in cte_binding_list : CQL0429: called procedure has no table arguments but a USING clause is present 'a_shared_frag'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name some_cte}
  |             | {name foo}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z),
x (*) AS (CALL shared_frag2(1, 2) USING some_cte AS foo)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in cte_binding_list : CQL0430: no actual table was provided for the table parameter 'source'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name some_cte}
  |             | {name foo}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z),
x (*) AS (CALL shared_frag2(1, 2) USING source AS bar, source AS bar)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0428: duplicate binding of table in CALL/USING clause 'bar'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |           | | {name source}
  |           | | {name bar}
  |           | {cte_binding_list}
  |             | {cte_binding}
  |               | {name source}
  |               | {name bar}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z),
x (*) AS (CALL shared_frag2(1, 2) USING some_cte AS source, some_cte AS bogus)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0431: an actual table was provided for a table parameter that does not exist 'bogus'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |           | | {name some_cte}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |           | | {name source}: source: { x: integer notnull, y: integer notnull, z: real notnull }
  |           | {cte_binding_list}
  |             | {cte_binding}
  |               | {name some_cte}
  |               | {name bogus}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z),
x (*) AS (CALL shared_frag2(1, 2) USING bogus AS source)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'bogus'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name bogus}: err
  |             | {name source}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z, u) AS (SELECT 1 AS x, 2 AS y, 3.0 AS z, 4 AS u),
x (*) AS (CALL shared_frag2(1, 2) USING some_cte AS source)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0432: table provided must have the same number of columns as the table parameter 'some_cte'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | |       | {name_list}
  |   | |         | {name u}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: real notnull
  |   |   |     |     | | {dbl 3.0}: real notnull
  |   |   |     |     | | {opt_as_alias}
  |   |   |     |     |   | {name z}
  |   |   |     |     | {select_expr_list}
  |   |   |     |       | {select_expr}: u: integer notnull
  |   |   |     |         | {int 4}: integer notnull
  |   |   |     |         | {opt_as_alias}
  |   |   |     |           | {name u}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name some_cte}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull, u: integer notnull }
  |             | {name source}: source: { x: integer notnull, y: integer notnull, z: real notnull }
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, w) AS (SELECT 1 AS x, 2 AS y, 3.0 AS w),
x (*) AS (CALL shared_frag2(1, 2) USING some_cte AS source)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0433: table argument 'source' requires column 'z' but it is missing in provided table 'some_cte'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, w: real notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, w: real notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name w}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, w: real notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, w: real notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, w: real notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, w: real notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, w: real notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: w: real notnull
  |   |   |     |       | {dbl 3.0}: real notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name w}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name some_cte}: some_cte: { x: integer notnull, y: integer notnull, w: real notnull }
  |             | {name source}: source: { x: integer notnull, y: integer notnull, z: real notnull }
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (SELECT 1 AS x, 2 AS y, '3.0' AS z),
x (*) AS (CALL shared_frag2(1, 2) USING some_cte AS source)
SELECT *
  FROM x;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'z'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: text notnull }
  |   | | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: text notnull }
  |   | | | {name some_cte}
  |   | | | {name_list}
  |   | |   | {name x}
  |   | |   | {name_list}
  |   | |     | {name y}
  |   | |     | {name_list}
  |   | |       | {name z}
  |   | | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: text notnull }
  |   |   | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: text notnull }
  |   |   | | {select_core}: select: { x: integer notnull, y: integer notnull, z: text notnull }
  |   |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: text notnull }
  |   |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: text notnull }
  |   |   |     | | {select_expr}: x: integer notnull
  |   |   |     | | | {int 1}: integer notnull
  |   |   |     | | | {opt_as_alias}
  |   |   |     | |   | {name x}
  |   |   |     | | {select_expr_list}
  |   |   |     |   | {select_expr}: y: integer notnull
  |   |   |     |   | | {int 2}: integer notnull
  |   |   |     |   | | {opt_as_alias}
  |   |   |     |   |   | {name y}
  |   |   |     |   | {select_expr_list}
  |   |   |     |     | {select_expr}: z: text notnull
  |   |   |     |       | {strlit '3.0'}: text notnull
  |   |   |     |       | {opt_as_alias}
  |   |   |     |         | {name z}
  |   |   |     | {select_from_etc}: ok
  |   |   |       | {select_where}
  |   |   |         | {select_groupby}
  |   |   |           | {select_having}
  |   |   | {select_orderby}
  |   |     | {select_limit}
  |   |       | {select_offset}
  |   | {cte_tables}: err
  |     | {cte_table}: err
  |       | {cte_decl}
  |       | | {name x}
  |       | | {star}
  |       | {shared_cte}: err
  |         | {call_stmt}: err
  |         | | {name shared_frag2}: shared_frag2: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | | {expr_list}: ok
  |         |   | {int 1}: integer notnull
  |         |   | {expr_list}
  |         |     | {int 2}: integer notnull
  |         | {cte_binding_list}
  |           | {cte_binding}
  |             | {name some_cte}: err
  |             | {name source}: source: { x: integer notnull, y: integer notnull, z: real notnull }
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name x}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC bogus_like_in_shared ()
BEGIN
  WITH
  data (*) AS (WITH
  source (*) LIKE there_is_no_such_source
  SELECT *
    FROM source)
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0427: LIKE CTE form may only be used inside a shared fragment at the top level i.e. @attribute(cql:shared_fragment) 'bogus_like_in_shared'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name bogus_like_in_shared}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: err
          |     | {cte_decl}
          |     | | {name data}
          |     | | {star}
          |     | {with_select_stmt}: err
          |       | {with}
          |       | | {cte_tables}: err
          |       |   | {cte_table}: err
          |       |     | {cte_decl}
          |       |     | | {name source}
          |       |     | | {star}
          |       |     | {like}
          |       |       | {name there_is_no_such_source}
          |       | {select_stmt}
          |         | {select_core_list}
          |         | | {select_core}
          |         |   | {select_expr_list_con}
          |         |     | {select_expr_list}
          |         |     | | {star}
          |         |     | {select_from_etc}
          |         |       | {table_or_subquery_list}
          |         |       | | {table_or_subquery}
          |         |       |   | {name source}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     | | | {int 1}
            |     | | | {opt_as_alias}
            |     | |   | {name x}
            |     | | {select_expr_list}
            |     |   | {select_expr}
            |     |   | | {int 2}
            |     |   | | {opt_as_alias}
            |     |   |   | {name y}
            |     |   | {select_expr_list}
            |     |     | {select_expr}
            |     |       | {dbl 3.0}
            |     |       | {opt_as_alias}
            |     |         | {name z}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag_bad_like_decl ()
BEGIN
  WITH
  source (u) LIKE a_shared_frag
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0101: too few column names specified in common table expression 'source'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name shared_frag_bad_like_decl}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: err
          |     | {cte_decl}: err
          |     | | {name source}
          |     | | {name_list}
          |     |   | {name u}
          |     | {like}: ok
          |       | {name a_shared_frag}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     | | | {int 1}
            |     | | | {opt_as_alias}
            |     | |   | {name x}
            |     | | {select_expr_list}
            |     |   | {select_expr}
            |     |   | | {int 2}
            |     |   | | {opt_as_alias}
            |     |   |   | {name y}
            |     |   | {select_expr_list}
            |     |     | {select_expr}
            |     |       | {dbl 3.0}
            |     |       | {opt_as_alias}
            |     |         | {name z}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC shared_frag_bogus_cte_columns ()
BEGIN
  WITH
  source (id, id) LIKE (SELECT 1 AS x, 2 AS y)
  SELECT 1 AS x, 2 AS y, 3.0 AS z;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name shared_frag_bogus_cte_columns}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: err
          |     | {cte_decl}: err
          |     | | {name source}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name id}
          |     | {like}
          |       | {select_stmt}
          |         | {select_core_list}
          |         | | {select_core}: select: { x: integer notnull, y: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
          |         |     | | {select_expr}: x: integer notnull
          |         |     | | | {int 1}: integer notnull
          |         |     | | | {opt_as_alias}
          |         |     | |   | {name x}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: y: integer notnull
          |         |     |     | {int 2}: integer notnull
          |         |     |     | {opt_as_alias}
          |         |     |       | {name y}
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     | | | {int 1}
            |     | | | {opt_as_alias}
            |     | |   | {name x}
            |     | | {select_expr_list}
            |     |   | {select_expr}
            |     |   | | {int 2}
            |     |   | | {opt_as_alias}
            |     |   |   | {name y}
            |     |   | {select_expr_list}
            |     |     | {select_expr}
            |     |       | {dbl 3.0}
            |     |       | {opt_as_alias}
            |     |         | {name z}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

WITH
some_cte (id, id) AS (CALL a_shared_frag(1, 2))
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'id'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name id}
  |     |   | {name_list}
  |     |     | {name id}
  |     | {shared_cte}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       | {call_stmt}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | {expr_list}: ok
  |           | {int 1}: integer notnull
  |           | {expr_list}
  |             | {int 2}: integer notnull
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (*) AS (WITH
garbonzo (goo, goo) AS (SELECT 1 AS x, 2 AS y)
SELECT *
  FROM garbonzo)
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'goo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name some_cte}
  |     | | {star}
  |     | {with_select_stmt}: err
  |       | {with}
  |       | | {cte_tables}: err
  |       |   | {cte_table}: err
  |       |     | {cte_decl}: err
  |       |     | | {name garbonzo}
  |       |     | | {name_list}
  |       |     |   | {name goo}
  |       |     |   | {name_list}
  |       |     |     | {name goo}
  |       |     | {select_stmt}
  |       |       | {select_core_list}
  |       |       | | {select_core}: select: { x: integer notnull, y: integer notnull }
  |       |       |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
  |       |       |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
  |       |       |     | | {select_expr}: x: integer notnull
  |       |       |     | | | {int 1}: integer notnull
  |       |       |     | | | {opt_as_alias}
  |       |       |     | |   | {name x}
  |       |       |     | | {select_expr_list}
  |       |       |     |   | {select_expr}: y: integer notnull
  |       |       |     |     | {int 2}: integer notnull
  |       |       |     |     | {opt_as_alias}
  |       |       |     |       | {name y}
  |       |       |     | {select_from_etc}: ok
  |       |       |       | {select_where}
  |       |       |         | {select_groupby}
  |       |       |           | {select_having}
  |       |       | {select_orderby}
  |       |         | {select_limit}
  |       |           | {select_offset}
  |       | {select_stmt}
  |         | {select_core_list}
  |         | | {select_core}
  |         |   | {select_expr_list_con}
  |         |     | {select_expr_list}
  |         |     | | {star}
  |         |     | {select_from_etc}
  |         |       | {table_or_subquery_list}
  |         |       | | {table_or_subquery}
  |         |       |   | {name garbonzo}
  |         |       | {select_where}
  |         |         | {select_groupby}
  |         |           | {select_having}
  |         | {select_orderby}
  |           | {select_limit}
  |             | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (goo, goo) AS (WITH
garbonzo (x, y) AS (SELECT 1 AS x, 2 AS y)
SELECT *
  FROM garbonzo)
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'goo'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name goo}
  |     |   | {name_list}
  |     |     | {name goo}
  |     | {with_select_stmt}: select: { x: integer notnull, y: integer notnull }
  |       | {with}
  |       | | {cte_tables}: ok
  |       |   | {cte_table}: garbonzo: { x: integer notnull, y: integer notnull }
  |       |     | {cte_decl}: garbonzo: { x: integer notnull, y: integer notnull }
  |       |     | | {name garbonzo}
  |       |     | | {name_list}
  |       |     |   | {name x}
  |       |     |   | {name_list}
  |       |     |     | {name y}
  |       |     | {select_stmt}: select: { x: integer notnull, y: integer notnull }
  |       |       | {select_core_list}: select: { x: integer notnull, y: integer notnull }
  |       |       | | {select_core}: select: { x: integer notnull, y: integer notnull }
  |       |       |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
  |       |       |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
  |       |       |     | | {select_expr}: x: integer notnull
  |       |       |     | | | {int 1}: integer notnull
  |       |       |     | | | {opt_as_alias}
  |       |       |     | |   | {name x}
  |       |       |     | | {select_expr_list}
  |       |       |     |   | {select_expr}: y: integer notnull
  |       |       |     |     | {int 2}: integer notnull
  |       |       |     |     | {opt_as_alias}
  |       |       |     |       | {name y}
  |       |       |     | {select_from_etc}: ok
  |       |       |       | {select_where}
  |       |       |         | {select_groupby}
  |       |       |           | {select_having}
  |       |       | {select_orderby}
  |       |         | {select_limit}
  |       |           | {select_offset}
  |       | {select_stmt}: select: { x: integer notnull, y: integer notnull }
  |         | {select_core_list}: select: { x: integer notnull, y: integer notnull }
  |         | | {select_core}: select: { x: integer notnull, y: integer notnull }
  |         |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
  |         |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
  |         |     | | {star}: select: { x: integer notnull, y: integer notnull }
  |         |     | {select_from_etc}: TABLE { garbonzo: garbonzo }
  |         |       | {table_or_subquery_list}: TABLE { garbonzo: garbonzo }
  |         |       | | {table_or_subquery}: TABLE { garbonzo: garbonzo }
  |         |       |   | {name garbonzo}: TABLE { garbonzo: garbonzo }
  |         |       | {select_where}
  |         |         | {select_groupby}
  |         |           | {select_having}
  |         | {select_orderby}
  |           | {select_limit}
  |             | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (x, y, z) AS (CALL a_shared_frag(1, 2))
SELECT *
  FROM some_cte;

  {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |     | {cte_decl}: some_cte: { x: integer notnull, y: integer notnull, z: real notnull }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name x}
  |     |   | {name_list}
  |     |     | {name y}
  |     |     | {name_list}
  |     |       | {name z}
  |     | {shared_cte}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |       | {call_stmt}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | {name a_shared_frag}: a_shared_frag: { x: integer notnull, y: integer notnull, z: real notnull } dml_proc
  |         | {expr_list}: ok
  |           | {int 1}: integer notnull
  |           | {expr_list}
  |             | {int 2}: integer notnull
  | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    | | {select_core}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    |     | | {star}: select: { x: integer notnull, y: integer notnull, z: real notnull }
    |     | {select_from_etc}: TABLE { some_cte: some_cte }
    |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |   | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (*) AS (CALL return_with_attr())
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in str : CQL0224: a CALL statement inside SQL may call only a shared fragment i.e. @attribute(cql:shared_fragment) 'return_with_attr'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name some_cte}
  |     | | {star}
  |     | {shared_cte}: err
  |       | {call_stmt}: ok
  |         | {name return_with_attr}: ok
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (*) AS (CALL this_is_not_even_a_proc())
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0323: calls to undeclared procedures are forbidden; declaration missing or typo 'this_is_not_even_a_proc'

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name some_cte}
  |     | | {star}
  |     | {shared_cte}: err
  |       | {call_stmt}: err
  |         | {name this_is_not_even_a_proc}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC test_shared_fragment_with_CTEs (id_ INTEGER NOT NULL)
BEGIN
  WITH
  t1 (id) AS (SELECT id
    FROM foo
    WHERE id = id_
  LIMIT 20),
  t2 (x, y, z) AS (SELECT t1.id, name, rate
    FROM bar
    INNER JOIN t1 ON t1.id = bar.id)
  SELECT *
    FROM t2;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: test_shared_fragment_with_CTEs: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_shared_fragment_with_CTEs}: test_shared_fragment_with_CTEs: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: t1: { id: integer notnull }
          |   | | {cte_decl}: t1: { id: integer notnull }
          |   | | | {name t1}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | | {select_stmt}: select: { id: integer notnull }
          |   |   | {select_core_list}: select: { id: integer notnull }
          |   |   | | {select_core}: select: { id: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     |   | {name id}: id: integer notnull
          |   |   |     | {select_from_etc}: TABLE { foo: foo }
          |   |   |       | {table_or_subquery_list}: TABLE { foo: foo }
          |   |   |       | | {table_or_subquery}: TABLE { foo: foo }
          |   |   |       |   | {name foo}: TABLE { foo: foo }
          |   |   |       | {select_where}
          |   |   |         | {opt_where}: bool notnull
          |   |   |         | | {eq}: bool notnull
          |   |   |         |   | {name id}: id: integer notnull
          |   |   |         |   | {name id_}: id_: integer notnull variable in
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {opt_limit}: integer notnull
          |   |       | | {int 20}: integer notnull
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: t2: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: t2: { x: integer notnull, y: text, z: longint }
          |       | | {name t2}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |         | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |         | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |         |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |         |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |         |     | | {select_expr}: id: integer notnull
          |         |     | | | {dot}: id: integer notnull
          |         |     | |   | {name t1}
          |         |     | |   | {name id}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: name: text
          |         |     |   | | {name name}: name: text
          |         |     |   | {select_expr_list}
          |         |     |     | {select_expr}: rate: longint
          |         |     |       | {name rate}: rate: longint
          |         |     | {select_from_etc}: JOIN { bar: bar, t1: t1 }
          |         |       | {join_clause}: JOIN { bar: bar, t1: t1 }
          |         |       | | {table_or_subquery}: TABLE { bar: bar }
          |         |       | | | {name bar}: TABLE { bar: bar }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { bar: bar, t1: t1 }
          |         |       |     | {int 1} {join_inner}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { t1: t1 }
          |         |       |       | | {name t1}: TABLE { t1: t1 }
          |         |       |       | {join_cond}: JOIN { bar: bar, t1: t1 }
          |         |       |         | {on}: bool notnull
          |         |       |         | {eq}: bool notnull
          |         |       |           | {dot}: id: integer notnull
          |         |       |           | | {name t1}
          |         |       |           | | {name id}
          |         |       |           | {dot}: id: integer notnull
          |         |       |             | {name bar}
          |         |       |             | {name id}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { t2: t2 }
            |       | {table_or_subquery_list}: TABLE { t2: t2 }
            |       | | {table_or_subquery}: TABLE { t2: t2 }
            |       |   | {name t2}: TABLE { t2: t2 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC test_shared_fragment_without_CTEs (id_ INTEGER NOT NULL)
BEGIN
  SELECT id, name, rate
    FROM bar
    WHERE id = id_;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: test_shared_fragment_without_CTEs: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name test_shared_fragment_without_CTEs}: test_shared_fragment_without_CTEs: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {select_expr}: id: integer notnull
          |     | | | {name id}: id: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text
          |     |   | | {name name}: name: text
          |     |   | {select_expr_list}
          |     |     | {select_expr}: rate: longint
          |     |       | {name rate}: rate: longint
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {opt_where}: bool notnull
          |         | | {eq}: bool notnull
          |         |   | {name id}: id: integer notnull
          |         |   | {name id_}: id_: integer notnull variable in
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC test_shared_fragment_wrong_form ()
BEGIN
  SELECT *
    FROM bar;
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0179: shared fragments must consist of exactly one top level statement 'test_shared_fragment_wrong_form'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name test_shared_fragment_wrong_form}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        | | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        | | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        | |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        | |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        | |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        | |     | {select_from_etc}: TABLE { bar: bar }
        | |       | {table_or_subquery_list}: TABLE { bar: bar }
        | |       | | {table_or_subquery}: TABLE { bar: bar }
        | |       |   | {name bar}: TABLE { bar: bar }
        | |       | {select_where}
        | |         | {select_groupby}
        | |           | {select_having}
        | | {select_orderby}
        |   | {select_limit}
        |     | {select_offset}
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC test_shared_fragment_bad_args (OUT x INTEGER)
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0208: shared fragments cannot have any out or in/out parameters 'x'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name test_shared_fragment_bad_args}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x: integer variable out
      |   | {out}
      |   | {param_detail}: x: integer variable out
      |     | {name x}: x: integer variable out
      |     | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC test_shared_fragment_wrong_form_not_select ()
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in declare_vars_type : CQL0441: shared fragments may only have IF, SELECT, or WITH...SELECT at the top level 'test_shared_fragment_wrong_form_not_select'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name test_shared_fragment_wrong_form_not_select}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

WITH RECURSIVE
cnt (current, current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

test/sem_test.sql:XXXX:1: error: in str : CQL0206: duplicate name in list 'current'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     |   | {name_list}
  |     |     | {name current}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}
  |       |     | {select_core}
  |       |       | {select_expr_list_con}
  |       |         | {select_expr_list}
  |       |         | | {select_expr}
  |       |         |   | {add}
  |       |         |     | {name current}
  |       |         |     | {int 1}
  |       |         | {select_from_etc}
  |       |           | {table_or_subquery_list}
  |       |           | | {table_or_subquery}
  |       |           |   | {name cnt}
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}
  |           | | {int 10}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT NOT 'x'
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT current
  FROM cnt;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       | | | {select_expr_list_con}: err
  |       | |   | {select_expr_list}: err
  |       | |   | | {select_expr}: err
  |       | |   |   | {not}: err
  |       | |   |     | {strlit 'x'}: text notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}
  |       |     | {select_core}
  |       |       | {select_expr_list_con}
  |       |         | {select_expr_list}
  |       |         | | {select_expr}
  |       |         |   | {add}
  |       |         |     | {name current}
  |       |         |     | {int 1}
  |       |         | {select_from_etc}
  |       |           | {table_or_subquery_list}
  |       |           | | {table_or_subquery}
  |       |           |   | {name cnt}
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}
  |           | | {int 10}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT NOT 'x')
SELECT current
  FROM cnt;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: err
  |       | {select_core_list}: err
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: err
  |       |     | {select_core}: err
  |       |       | {select_expr_list_con}: err
  |       |         | {select_expr_list}: err
  |       |         | | {select_expr}: err
  |       |         |   | {not}: err
  |       |         |     | {strlit 'x'}: text notnull
  |       |         | {select_from_etc}: ok
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {name current}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name cnt}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH RECURSIVE
cnt (current) AS (SELECT 1
UNION ALL
SELECT current + 1
  FROM cnt
LIMIT 10)
SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {with_select_stmt}: err
  | {with_recursive}
  | | {cte_tables}: ok
  |   | {cte_table}: cnt: { current: integer notnull }
  |     | {cte_decl}: cnt: { current: integer notnull }
  |     | | {name cnt}
  |     | | {name_list}
  |     |   | {name current}
  |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
  |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |       | | {select_core}: select: { _anon: integer notnull }
  |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |       | |   | {select_expr_list}: select: { _anon: integer notnull }
  |       | |   | | {select_expr}: integer notnull
  |       | |   |   | {int 1}: integer notnull
  |       | |   | {select_from_etc}: ok
  |       | |     | {select_where}
  |       | |       | {select_groupby}
  |       | |         | {select_having}
  |       | | {select_core_compound}
  |       |   | {int 2}
  |       |   | {select_core_list}: select: { _anon: integer notnull }
  |       |     | {select_core}: select: { _anon: integer notnull }
  |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |         | {select_expr_list}: select: { _anon: integer notnull }
  |       |         | | {select_expr}: integer notnull
  |       |         |   | {add}: integer notnull
  |       |         |     | {name current}: current: integer notnull
  |       |         |     | {int 1}: integer notnull
  |       |         | {select_from_etc}: TABLE { cnt: cnt }
  |       |           | {table_or_subquery_list}: TABLE { cnt: cnt }
  |       |           | | {table_or_subquery}: TABLE { cnt: cnt }
  |       |           |   | {name cnt}: TABLE { cnt: cnt }
  |       |           | {select_where}
  |       |             | {select_groupby}
  |       |               | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {opt_limit}: integer notnull
  |           | | {int 10}: integer notnull
  |           | {select_offset}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {not}: err
    |     |     | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT X AS A
UNION ALL
SELECT X AS A
UNION ALL
SELECT Y AS A;

  {select_stmt}: UNION ALL: { A: integer }
  | {select_core_list}: UNION ALL: { A: integer }
  | | {select_core}: select: { A: integer variable was_set }
  | | | {select_expr_list_con}: select: { A: integer variable was_set }
  | |   | {select_expr_list}: select: { A: integer variable was_set }
  | |   | | {select_expr}: A: integer variable was_set
  | |   |   | {name X}: X: integer variable was_set
  | |   |   | {opt_as_alias}
  | |   |     | {name A}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: UNION ALL: { A: integer }
  |     | {select_core}: select: { A: integer variable was_set }
  |     | | {select_expr_list_con}: select: { A: integer variable was_set }
  |     |   | {select_expr_list}: select: { A: integer variable was_set }
  |     |   | | {select_expr}: A: integer variable was_set
  |     |   |   | {name X}: X: integer variable was_set
  |     |   |   | {opt_as_alias}
  |     |   |     | {name A}
  |     |   | {select_from_etc}: ok
  |     |     | {select_where}
  |     |       | {select_groupby}
  |     |         | {select_having}
  |     | {select_core_compound}
  |       | {int 2}
  |       | {select_core_list}: select: { A: integer variable was_set }
  |         | {select_core}: select: { A: integer variable was_set }
  |           | {select_expr_list_con}: select: { A: integer variable was_set }
  |             | {select_expr_list}: select: { A: integer variable was_set }
  |             | | {select_expr}: A: integer variable was_set
  |             |   | {name Y}: Y: integer variable was_set
  |             |   | {opt_as_alias}
  |             |     | {name A}
  |             | {select_from_etc}: ok
  |               | {select_where}
  |                 | {select_groupby}
  |                   | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW view_with_cte AS
WITH
goo (x) AS (SELECT 1)
SELECT *
  FROM goo;

  {create_view_stmt}: view_with_cte: { x: integer notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name view_with_cte}
      | {with_select_stmt}: view_with_cte: { x: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: goo: { x: integer notnull }
        |     | {cte_decl}: goo: { x: integer notnull }
        |     | | {name goo}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: view_with_cte: { x: integer notnull }
          | {select_core_list}: view_with_cte: { x: integer notnull }
          | | {select_core}: view_with_cte: { x: integer notnull }
          |   | {select_expr_list_con}: view_with_cte: { x: integer notnull }
          |     | {select_expr_list}: view_with_cte: { x: integer notnull }
          |     | | {star}: view_with_cte: { x: integer notnull }
          |     | {select_from_etc}: TABLE { goo: goo }
          |       | {table_or_subquery_list}: TABLE { goo: goo }
          |       | | {table_or_subquery}: TABLE { goo: goo }
          |       |   | {name goo}: TABLE { goo: goo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT 1 IN (SELECT 1
UNION ALL
SELECT 2
UNION ALL
SELECT 3) AS A;

  {select_stmt}: select: { A: bool notnull }
  | {select_core_list}: select: { A: bool notnull }
  | | {select_core}: select: { A: bool notnull }
  |   | {select_expr_list_con}: select: { A: bool notnull }
  |     | {select_expr_list}: select: { A: bool notnull }
  |     | | {select_expr}: A: bool notnull
  |     |   | {in_pred}: bool notnull
  |     |   | | {int 1}: integer notnull
  |     |   | | {select_stmt}: _anon: integer
  |     |   |   | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |     |   |   | | {select_core}: select: { _anon: integer notnull }
  |     |   |   | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   | |   | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   | |   | | {select_expr}: integer notnull
  |     |   |   | |   |   | {int 1}: integer notnull
  |     |   |   | |   | {select_from_etc}: ok
  |     |   |   | |     | {select_where}
  |     |   |   | |       | {select_groupby}
  |     |   |   | |         | {select_having}
  |     |   |   | | {select_core_compound}
  |     |   |   |   | {int 2}
  |     |   |   |   | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |     |   |   |     | {select_core}: select: { _anon: integer notnull }
  |     |   |   |     | | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   |     |   | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   |     |   | | {select_expr}: integer notnull
  |     |   |   |     |   |   | {int 2}: integer notnull
  |     |   |   |     |   | {select_from_etc}: ok
  |     |   |   |     |     | {select_where}
  |     |   |   |     |       | {select_groupby}
  |     |   |   |     |         | {select_having}
  |     |   |   |     | {select_core_compound}
  |     |   |   |       | {int 2}
  |     |   |   |       | {select_core_list}: select: { _anon: integer notnull }
  |     |   |   |         | {select_core}: select: { _anon: integer notnull }
  |     |   |   |           | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   |   |             | {select_expr_list}: select: { _anon: integer notnull }
  |     |   |   |             | | {select_expr}: integer notnull
  |     |   |   |             |   | {int 3}: integer notnull
  |     |   |   |             | {select_from_etc}: ok
  |     |   |   |               | {select_where}
  |     |   |   |                 | {select_groupby}
  |     |   |   |                   | {select_having}
  |     |   |   | {select_orderby}
  |     |   |     | {select_limit}
  |     |   |       | {select_offset}
  |     |   | {opt_as_alias}
  |     |     | {name A}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 AS _first, T.*, 3 AS _last
  FROM (SELECT 1 AS A, 2 AS B) AS T;

  {select_stmt}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  | {select_core_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  | | {select_core}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |   | {select_expr_list_con}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |     | {select_expr_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, _last: integer notnull }
  |     | | {select_expr}: _first: integer notnull
  |     | | | {int 0}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name _first}
  |     | | {select_expr_list}
  |     |   | {table_star}: T: select: { A: integer notnull, B: integer notnull }
  |     |   | | {name T}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: _last: integer notnull
  |     |       | {int 3}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name _last}
  |     | {select_from_etc}: TABLE { T: select }
  |       | {table_or_subquery_list}: TABLE { T: select }
  |       | | {table_or_subquery}: TABLE { T: select }
  |       |   | {select_stmt}: select: { A: integer notnull, B: integer notnull }
  |       |   | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |       |   | | | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       |   | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |       |   | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |       |   | |     | | {select_expr}: A: integer notnull
  |       |   | |     | | | {int 1}: integer notnull
  |       |   | |     | | | {opt_as_alias}
  |       |   | |     | |   | {name A}
  |       |   | |     | | {select_expr_list}
  |       |   | |     |   | {select_expr}: B: integer notnull
  |       |   | |     |     | {int 2}: integer notnull
  |       |   | |     |     | {opt_as_alias}
  |       |   | |     |       | {name B}
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 AS _first, T.*, S.*, 3 AS _last
  FROM (SELECT 1 AS A, 2 AS B) AS T,
(SELECT 1 AS C) AS S;

  {select_stmt}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  | {select_core_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  | | {select_core}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |   | {select_expr_list_con}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |     | {select_expr_list}: select: { _first: integer notnull, A: integer notnull, B: integer notnull, C: integer notnull, _last: integer notnull }
  |     | | {select_expr}: _first: integer notnull
  |     | | | {int 0}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name _first}
  |     | | {select_expr_list}
  |     |   | {table_star}: T: select: { A: integer notnull, B: integer notnull }
  |     |   | | {name T}
  |     |   | {select_expr_list}
  |     |     | {table_star}: S: select: { C: integer notnull }
  |     |     | | {name S}
  |     |     | {select_expr_list}
  |     |       | {select_expr}: _last: integer notnull
  |     |         | {int 3}: integer notnull
  |     |         | {opt_as_alias}
  |     |           | {name _last}
  |     | {select_from_etc}: JOIN { T: select, S: select }
  |       | {table_or_subquery_list}: JOIN { T: select, S: select }
  |       | | {table_or_subquery}: TABLE { T: select }
  |       | | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
  |       | | | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |       | | | | | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | | | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |       | | | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |       | | | |     | | {select_expr}: A: integer notnull
  |       | | | |     | | | {int 1}: integer notnull
  |       | | | |     | | | {opt_as_alias}
  |       | | | |     | |   | {name A}
  |       | | | |     | | {select_expr_list}
  |       | | | |     |   | {select_expr}: B: integer notnull
  |       | | | |     |     | {int 2}: integer notnull
  |       | | | |     |     | {opt_as_alias}
  |       | | | |     |       | {name B}
  |       | | | |     | {select_from_etc}: ok
  |       | | | |       | {select_where}
  |       | | | |         | {select_groupby}
  |       | | | |           | {select_having}
  |       | | | | {select_orderby}
  |       | | |   | {select_limit}
  |       | | |     | {select_offset}
  |       | | | {opt_as_alias}
  |       | |   | {name T}
  |       | | {table_or_subquery_list}: TABLE { S: select }
  |       |   | {table_or_subquery}: TABLE { S: select }
  |       |     | {select_stmt}: select: { C: integer notnull }
  |       |     | | {select_core_list}: select: { C: integer notnull }
  |       |     | | | {select_core}: select: { C: integer notnull }
  |       |     | |   | {select_expr_list_con}: select: { C: integer notnull }
  |       |     | |     | {select_expr_list}: select: { C: integer notnull }
  |       |     | |     | | {select_expr}: C: integer notnull
  |       |     | |     |   | {int 1}: integer notnull
  |       |     | |     |   | {opt_as_alias}
  |       |     | |     |     | {name C}
  |       |     | |     | {select_from_etc}: ok
  |       |     | |       | {select_where}
  |       |     | |         | {select_groupby}
  |       |     | |           | {select_having}
  |       |     | | {select_orderby}
  |       |     |   | {select_limit}
  |       |     |     | {select_offset}
  |       |     | {opt_as_alias}
  |       |       | {name S}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T.*;

test/sem_test.sql:XXXX:1: error: in table_star : CQL0053: select [table].* cannot be used with no FROM clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {table_star}: err
  |     |   | {name T}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T.*
  FROM (SELECT 1) AS U;

test/sem_test.sql:XXXX:1: error: in table_star : CQL0054: table not found 'T'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {table_star}: err
  |     |   | {name T}
  |     | {select_from_etc}: TABLE { U: select }
  |       | {table_or_subquery_list}: TABLE { U: select }
  |       | | {table_or_subquery}: TABLE { U: select }
  |       |   | {select_stmt}: select: { _anon: integer notnull }
  |       |   | | {select_core_list}: select: { _anon: integer notnull }
  |       |   | | | {select_core}: select: { _anon: integer notnull }
  |       |   | |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |   | |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |   | |     | | {select_expr}: integer notnull
  |       |   | |     |   | {int 1}: integer notnull
  |       |   | |     | {select_from_etc}: ok
  |       |   | |       | {select_where}
  |       |   | |         | {select_groupby}
  |       |   | |           | {select_having}
  |       |   | | {select_orderby}
  |       |   |   | {select_limit}
  |       |   |     | {select_offset}
  |       |   | {opt_as_alias}
  |       |     | {name U}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE FUNC simple_func (arg1 INTEGER NOT NULL) REAL NOT NULL;

  {declare_func_stmt}: real notnull
  | {name simple_func}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer notnull variable in
    |   | {param_detail}: arg1: integer notnull variable in
    |     | {name arg1}: arg1: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

DECLARE FUNC simple_func (arg1 INTEGER) REAL NOT NULL;

test/sem_test.sql:XXXX:1: error: in str : CQL0193: duplicate function name 'simple_func'

  {declare_func_stmt}: err
  | {name simple_func}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer variable in
    |   | {param_detail}: arg1: integer variable in
    |     | {name arg1}: arg1: integer variable in
    |     | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

DECLARE PROC simple_func (arg1 INTEGER NOT NULL);

test/sem_test.sql:XXXX:1: error: in str : CQL0195: proc name conflicts with func name 'simple_func'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name simple_func}
  | | {int 0}
  | {proc_params_stmts}
    | {params}
      | {param}
        | {param_detail}
          | {name arg1}
          | {notnull}
            | {type_int}

The statement ending at line XXXX

CREATE PROC simple_func (arg1 INTEGER NOT NULL)
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0185: proc name conflicts with func name 'simple_func'

  {create_proc_stmt}: err
  | {name simple_func}: err
  | {proc_params_stmts}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name arg1}
    |     | {notnull}
    |       | {type_int}
    | {stmt_list}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE FUNC proc1 (i INTEGER) INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0192: func name conflicts with proc name 'proc1'

  {declare_func_stmt}: err
  | {name proc1}
  | {func_params_return}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name i}
    |     | {type_int}
    | {type_int}

The statement ending at line XXXX

CREATE PROC nested_func_wrapper ()
BEGIN
  DECLARE FUNC foo () INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0191: declared functions must be top level 'foo'

  {create_proc_stmt}: err
  | {name nested_func_wrapper}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_func_stmt}: err
        | {name foo}
        | {func_params_return}
          | {type_int}

The statement ending at line XXXX

DECLARE FUNC dup_formal (a INTEGER, a INTEGER) INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0175: duplicate parameter name 'a'

  {declare_func_stmt}: err
  | {name dup_formal}
  | {func_params_return}
    | {params}: err
    | | {param}: a: integer variable in
    | | | {param_detail}: a: integer variable in
    | |   | {name a}: a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: err
    |     | {param_detail}
    |       | {name a}
    |       | {type_int}
    | {type_int}

The statement ending at line XXXX

DECLARE real_result REAL;

  {declare_vars_type}: real
  | {name_list}: real_result: real variable was_set
  | | {name real_result}: real_result: real variable was_set
  | {type_real}: real

The statement ending at line XXXX

SET real_result := simple_func(1);

  {assign}: real_result: real variable was_set
  | {name real_result}: real_result: real variable was_set
  | {call}: real notnull
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET real_result := simple_func('xx');

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'arg1'

  {assign}: err
  | {name real_result}: real_result: real variable was_set
  | {call}: err
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'xx'}: err

The statement ending at line XXXX

SET real_result := simple_func(NOT 'xx');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name real_result}: real_result: real variable was_set
  | {call}: err
    | {name simple_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {not}: err
          | {strlit 'xx'}: text notnull

The statement ending at line XXXX

SELECT simple_func(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0088: user function may not appear in the context of a SQL statement 'simple_func'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name simple_func}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE obj_var OBJECT;

  {declare_vars_type}: object
  | {name_list}: obj_var: object variable was_set
  | | {name obj_var}: obj_var: object variable was_set
  | {type_object}: object

The statement ending at line XXXX

SET X := obj_var < 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0002: left operand cannot be an object in '<'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {lt}: err
    | {name obj_var}: obj_var: object variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 < obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0003: right operand cannot be an object in '<'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {lt}: err
    | {int 1}: integer notnull
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var = obj_var;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {eq}: bool
    | {name obj_var}: obj_var: object variable
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var <> obj_var;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {ne}: bool
    | {name obj_var}: obj_var: object variable
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := obj_var + 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0002: left operand cannot be an object in '+'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {add}: err
    | {name obj_var}: obj_var: object variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 + obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0003: right operand cannot be an object in '+'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {add}: err
    | {int 1}: integer notnull
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := NOT obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0046: object operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not}: err
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET X := -obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0046: object operand not allowed in '-'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {uminus}: err
    | {name obj_var}: obj_var: object variable

The statement ending at line XXXX

SET a_string := obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'a_string'

  {assign}: err
  | {name a_string}: err
  | {name obj_var}: err

The statement ending at line XXXX

SET obj_var := a_string;

test/sem_test.sql:XXXX:1: error: in str : CQL0010: incompatible types in expression 'obj_var'

  {assign}: err
  | {name obj_var}: err
  | {name a_string}: err

The statement ending at line XXXX

CREATE PROC obj_proc (OUT an_obj OBJECT)
BEGIN
  SET an_obj := NULL;
END;

  {create_proc_stmt}: ok
  | {name obj_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: an_obj: object variable out was_set
    |   | {out}
    |   | {param_detail}: an_obj: object variable out was_set
    |     | {name an_obj}: an_obj: object variable out was_set
    |     | {type_object}: object
    | {stmt_list}: ok
      | {assign}: an_obj: object variable out was_set
        | {name an_obj}: an_obj: object variable out was_set
        | {null}: null

The statement ending at line XXXX

CREATE TABLE object_table_test(
  obj OBJECT
);

test/sem_test.sql:XXXX:1: error: in str : CQL0041: tables cannot have object columns 'obj'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name object_table_test}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name obj}
          | {type_object}: object

The statement ending at line XXXX

SELECT obj_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0064: object variables may not appear in the context of a SQL statement (except table-valued functions) 'obj_var'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name obj_var}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := obj_var IN (obj_var, NULL);

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {in_pred}: bool
    | {name obj_var}: obj_var: object variable was_set
    | {expr_list}: obj_var: object variable was_set
      | {name obj_var}: obj_var: object variable was_set
      | {expr_list}: null
        | {null}: null

The statement ending at line XXXX

SET X := obj_var IN (obj_var, 1);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0010: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {name obj_var}: obj_var: object variable was_set
    | {expr_list}: obj_var: object variable was_set
      | {name obj_var}: obj_var: object variable was_set
      | {expr_list}: integer notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

SET X := obj_var IN ('foo', obj_var);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0010: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {name obj_var}: obj_var: object variable was_set
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {name obj_var}

The statement ending at line XXXX

SET X := 'foo' IN ('foo', obj_var);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0009: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {strlit 'foo'}: text notnull
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}: obj_var: object variable was_set
        | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET X := CASE obj_var WHEN obj_var THEN 2
ELSE 3
END;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {case_expr}: integer notnull
    | {name obj_var}: obj_var: object variable was_set
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {name obj_var}: obj_var: object variable was_set
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET obj_var := CASE 1 WHEN 1 THEN obj_var
ELSE NULL
END;

  {assign}: obj_var: object variable was_set
  | {name obj_var}: obj_var: object variable was_set
  | {case_expr}: object
    | {int 1}: integer notnull
    | {connector}: object
      | {case_list}: object variable was_set
      | | {when}: obj_var: object variable was_set
      |   | {int 1}: integer notnull
      |   | {name obj_var}: obj_var: object variable was_set
      | {null}: null

The statement ending at line XXXX

SET X := obj_var BETWEEN 1 AND 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0072: first operand cannot be an object in 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {name obj_var}: obj_var: object variable was_set
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN obj_var AND 3;

test/sem_test.sql:XXXX:1: error: in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {name obj_var}: obj_var: object variable was_set
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN 1 AND obj_var;

test/sem_test.sql:XXXX:1: error: in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET X := obj_var NOT BETWEEN 1 AND 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0072: first operand cannot be an object in 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {name obj_var}: obj_var: object variable was_set
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN obj_var AND 3;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {name obj_var}: obj_var: object variable was_set
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN 1 AND obj_var;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

DECLARE FUNC creater_func () CREATE OBJECT NOT NULL;

  {declare_func_stmt}: object notnull create_func
  | {name creater_func}: object notnull create_func
  | {func_params_return}
    | {create_data_type}: object notnull create_func
      | {notnull}: object notnull
        | {type_object}: object

The statement ending at line XXXX

DECLARE FUNC maybe_create_func () CREATE OBJECT;

  {declare_func_stmt}: object create_func
  | {name maybe_create_func}: object create_func
  | {func_params_return}
    | {create_data_type}: object create_func
      | {type_object}: object

The statement ending at line XXXX

DECLARE not_null_object OBJECT NOT NULL;

  {declare_vars_type}: object notnull
  | {name_list}: not_null_object: object notnull variable init_required was_set
  | | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {notnull}: object notnull
    | {type_object}: object

The statement ending at line XXXX

SET not_null_object := ifnull_crash(obj_var);

  {assign}: not_null_object: object notnull variable init_required was_set
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: obj_var: object notnull variable was_set
    | {name ifnull_crash}: obj_var: object notnull variable was_set
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET not_null_object := ifnull_crash(obj_var);

  {assign}: not_null_object: object notnull variable init_required was_set
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: obj_var: object notnull variable was_set
    | {name ifnull_crash}: obj_var: object notnull variable was_set
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET not_null_object := ifnull_throw(obj_var);

  {assign}: not_null_object: object notnull variable init_required was_set
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: obj_var: object notnull variable was_set
    | {name ifnull_throw}: obj_var: object notnull variable was_set
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET price_d := ifnull_crash(price_d);

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {call}: price_d: real<dollars> notnull variable was_set
    | {name ifnull_crash}: price_d: real<dollars> notnull variable was_set
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name price_d}: price_d: real<dollars> variable was_set

The statement ending at line XXXX

SET price_d := ifnull_crash(price_e);

test/sem_test.sql:XXXX:1: error: in call : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {call}: err
    | {name ifnull_crash}: price_e: real<euros> notnull variable
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name price_e}: price_e: real<euros> variable

The statement ending at line XXXX

SET not_null_object := ifnull_crash(not_null_object);

test/sem_test.sql:XXXX:1: error: in str : CQL0344: argument must be a nullable type (but not constant NULL) in 'ifnull_crash'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: err
    | {name ifnull_crash}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name not_null_object}: not_null_object: object notnull variable was_set

The statement ending at line XXXX

SET not_null_object := ifnull_crash(NULL);

test/sem_test.sql:XXXX:1: error: in null : CQL0344: argument must be a nullable type (but not constant NULL) in 'ifnull_crash'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: err
    | {name ifnull_crash}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {null}: null

The statement ending at line XXXX

SET not_null_object := ifnull_crash(1, 7);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'ifnull_crash'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {call}: err
    | {name ifnull_crash}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 7}: integer notnull

The statement ending at line XXXX

SET not_null_object := ( SELECT ifnull_crash(1) );

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'ifnull_crash'

  {assign}: err
  | {name not_null_object}: not_null_object: object notnull variable init_required was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name ifnull_crash}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ECHO c, 'foo\n';

  {echo_stmt}: ok
  | {name c}
  | {strlit 'foo\n'}

The statement ending at line XXXX

DECLARE foo_obj OBJECT<Foo>;

  {declare_vars_type}: object<Foo>
  | {name_list}: foo_obj: object<Foo> variable was_set
  | | {name foo_obj}: foo_obj: object<Foo> variable was_set
  | {type_object}: object<Foo>
    | {name Foo}

The statement ending at line XXXX

SET foo_obj := foo_obj;

  {assign}: foo_obj: object<Foo> variable was_set
  | {name foo_obj}: foo_obj: object<Foo> variable was_set
  | {name foo_obj}: foo_obj: object<Foo> variable

The statement ending at line XXXX

DECLARE FUNC foo_func () OBJECT<Foo>;

  {declare_func_stmt}: object<Foo>
  | {name foo_func}: object<Foo>
  | {func_params_return}
    | {type_object}: object<Foo>
      | {name Foo}

The statement ending at line XXXX

SET foo_obj := foo_func();

  {assign}: foo_obj: object<Foo> variable was_set
  | {name foo_obj}: foo_obj: object<Foo> variable was_set
  | {call}: object<Foo>
    | {name foo_func}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

DECLARE bar_obj OBJECT<Bar>;

  {declare_vars_type}: object<Bar>
  | {name_list}: bar_obj: object<Bar> variable was_set
  | | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {type_object}: object<Bar>
    | {name Bar}

The statement ending at line XXXX

SET bar_obj := foo_obj;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'Bar' vs. 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
WHEN 2 THEN foo_obj
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'Bar' vs. 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: err
        | {when}: bar_obj: object<Bar> variable was_set
        | | {int 1}: integer notnull
        | | {name bar_obj}: bar_obj: object<Bar> variable was_set
        | {case_list}: err
          | {when}
            | {int 2}: integer notnull
            | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_object
WHEN 2 THEN foo_obj
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bar_object'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: err
        | {when}
        | | {int 1}: integer notnull
        | | {name bar_object}: err
        | {case_list}
          | {when}
            | {int 2}
            | {name foo_obj}

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
ELSE foo_obj
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'Bar' vs. 'Foo'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: object<Bar> variable was_set
      | | {when}: bar_obj: object<Bar> variable was_set
      |   | {int 1}: integer notnull
      |   | {name bar_obj}: bar_obj: object<Bar> variable was_set
      | {name foo_obj}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
ELSE foo_object
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'foo_object'

  {assign}: err
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {case_expr}: err
    | {int 1}: integer notnull
    | {connector}
      | {case_list}: object<Bar> variable was_set
      | | {when}: bar_obj: object<Bar> variable was_set
      |   | {int 1}: integer notnull
      |   | {name bar_obj}: bar_obj: object<Bar> variable was_set
      | {name foo_object}: err

The statement ending at line XXXX

SET bar_obj := CASE 1 WHEN 1 THEN bar_obj
WHEN 2 THEN bar_obj
ELSE bar_obj
END;

  {assign}: bar_obj: object<Bar> variable was_set
  | {name bar_obj}: bar_obj: object<Bar> variable was_set
  | {case_expr}: object<Bar>
    | {int 1}: integer notnull
    | {connector}: object<Bar>
      | {case_list}: object<Bar>
      | | {when}: bar_obj: object<Bar> variable was_set
      | | | {int 1}: integer notnull
      | | | {name bar_obj}: bar_obj: object<Bar> variable was_set
      | | {case_list}: bar_obj: object<Bar> variable was_set
      |   | {when}: bar_obj: object<Bar> variable was_set
      |     | {int 2}: integer notnull
      |     | {name bar_obj}: bar_obj: object<Bar> variable was_set
      | {name bar_obj}: bar_obj: object<Bar> variable was_set

The statement ending at line XXXX

CALL printf('%d', simple_func(NOT 'x'));

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {call_stmt}: err
  | {name printf}: ok
  | {expr_list}: err
    | {strlit '%d'}: text notnull
    | {expr_list}
      | {call}: err
        | {name simple_func}
        | {call_arg_list}
          | {call_filter_clause}
          | {arg_list}: ok
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, '2', 3);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit '2'}: text notnull
        |         | {insert_list}
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null }
        | {select_core_list}: values: { column1: null }
        | | {select_core}: values: { column1: null }
        |   | {select_values}
        |   | {values}: values: { column1: null }
        |     | {insert_list}: ok
        |       | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(name) VALUES('x');

test/sem_test.sql:XXXX:1: error: in insert_stmt : CQL0158: required column missing in INSERT statement 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: ok
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(garbonzo) VALUES('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'garbonzo'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}: err
      |   | {name garbonzo}: err
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: ok
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, id) VALUES('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}: err
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name id}: err
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: ok
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO booly(id) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name booly}: booly: { id: integer has_default, flag: bool }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO MyView(id) VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0161: cannot insert into a view 'MyView'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO garbonzo(id) VALUES('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0160: table in insert statement does not exist 'garbonzo'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name garbonzo}
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {strlit 'x'}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE FUNC goo_func (goo OBJECT<Goo>) TEXT;

  {declare_func_stmt}: text
  | {name goo_func}: text
  | {func_params_return}
    | {params}: ok
    | | {param}: goo: object<Goo> variable in
    |   | {param_detail}: goo: object<Goo> variable in
    |     | {name goo}: goo: object<Goo> variable in
    |     | {type_object}: object<Goo>
    |       | {name Goo}
    | {type_text}: text

The statement ending at line XXXX

SET a_string := goo_func(bar_obj);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'Goo' vs. 'Bar'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name goo_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name bar_obj}: err

The statement ending at line XXXX

SET a_string := goo_func(NOT 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name goo_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {not}: err
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL, NULL);

test/sem_test.sql:XXXX:1: error: in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: null, column2: null }
        | {select_core_list}: values: { column1: null, column2: null }
        | | {select_core}: values: { column1: null, column2: null }
        |   | {select_values}
        |   | {values}: values: { column1: null, column2: null }
        |     | {insert_list}: ok
        |       | {null}: null
        |       | {insert_list}
        |         | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NOT 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_values}
        |   | {values}: err
        |     | {insert_list}: ok
        |       | {not}: err
        |         | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: ok
        |       | {strlit 'x'}: err
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TEMP VIEW temp_view AS
SELECT 1 AS A, 2 AS B;

  {create_view_stmt}: temp_view: { A: integer notnull, B: integer notnull }
  | {int 1}
  | {view_and_attrs}
    | {name_and_select}
      | {name temp_view}
      | {select_stmt}: temp_view: { A: integer notnull, B: integer notnull }
        | {select_core_list}: temp_view: { A: integer notnull, B: integer notnull }
        | | {select_core}: temp_view: { A: integer notnull, B: integer notnull }
        |   | {select_expr_list_con}: temp_view: { A: integer notnull, B: integer notnull }
        |     | {select_expr_list}: temp_view: { A: integer notnull, B: integer notnull }
        |     | | {select_expr}: A: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name A}
        |     | | {select_expr_list}
        |     |   | {select_expr}: B: integer notnull
        |     |     | {int 2}: integer notnull
        |     |     | {opt_as_alias}
        |     |       | {name B}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT;

  {alter_table_add_column_stmt}: ok
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name name}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT NOT NULL;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0147: adding a not nullable column with no default value is not allowed 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text notnull
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {col_attrs_not_null}: ok

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name INTEGER;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0149: added column must be an exact match for the column type declared in the table 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: integer
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name name}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN goo INTEGER;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'goo'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: goo: integer
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name goo}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN NAME TEXT;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'NAME'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: NAME: text
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name NAME}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN foo OBJECT;

test/sem_test.sql:XXXX:1: error: in str : CQL0041: tables cannot have object columns 'foo'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name foo}
        | {type_object}: object

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0146: adding an auto increment column is not allowed 'id'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: id: integer notnull primary_key autoinc
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name id}
      | | {type_int}: integer
      | {col_attrs_pk}: ok
        | {autoinc_and_conflict_clause}
          | {col_attrs_autoinc}

The statement ending at line XXXX

ALTER TABLE garbonzo ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

test/sem_test.sql:XXXX:1: error: in str : CQL0144: table in alter statement does not exist 'garbonzo'

  {alter_table_add_column_stmt}: err
  | {name garbonzo}
  | {col_def}
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}
      | {col_attrs_pk}
        | {autoinc_and_conflict_clause}
          | {col_attrs_autoinc}

The statement ending at line XXXX

ALTER TABLE MyView ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;

test/sem_test.sql:XXXX:1: error: in str : CQL0144: cannot alter a view 'MyView'

  {alter_table_add_column_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {col_def}
    | {col_def_type_attrs}
      | {col_def_name_type}
      | | {name id}
      | | {type_int}
      | {col_attrs_pk}
        | {autoinc_and_conflict_clause}
          | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE PROC bogus_version ()
BEGIN
  @SCHEMA_UPGRADE (11);
END;

test/sem_test.sql:XXXX:1: error: in schema_upgrade_version_stmt : CQL0230: schema upgrade version declaration must be outside of any proc

  {create_proc_stmt}: err
  | {name bogus_version}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {schema_upgrade_version_stmt}: err
        | {int 11}

The statement ending at line XXXX

@SCHEMA_UPGRADE (11);

test/sem_test.sql:XXXX:1: error: in schema_upgrade_version_stmt : CQL0231: schema upgrade version declaration must come before any tables are declared

  {schema_upgrade_version_stmt}: err
  | {int 11}

The statement ending at line XXXX

@SCHEMA_UPGRADE (0);

test/sem_test.sql:XXXX:1: error: in schema_upgrade_version_stmt : CQL0228: schema upgrade version must be a positive integer

  {schema_upgrade_version_stmt}: err
  | {int 0}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(1, bar_upgrader);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0145: version annotations not valid in alter statement 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text @create(1)
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: ok
        | {version_annotation}
          | {int 1}
          | {name bar_upgrader}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @DELETE(1);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0145: version annotations not valid in alter statement 'name'

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: name: text deleted @delete(1)
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {delete_attr}: ok
        | {version_annotation}
          | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @DELETE(1) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in delete_attr : CQL0026: duplicate version annotation

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {delete_attr}: err
        | {version_annotation}
        | | {int 1}
        | {delete_attr}: err
          | {version_annotation}
            | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(1) @CREATE(1);

test/sem_test.sql:XXXX:1: error: in create_attr : CQL0026: duplicate version annotation

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: err
        | {version_annotation}
        | | {int 1}
        | {create_attr}: err
          | {version_annotation}
            | {int 1}

The statement ending at line XXXX

ALTER TABLE bar ADD COLUMN name TEXT @CREATE(0);

test/sem_test.sql:XXXX:1: error: in create_attr : CQL0025: version number in annotation must be positive

  {alter_table_add_column_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {col_def}: err
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name name}
      | | {type_text}: text
      | {create_attr}: err
        | {version_annotation}
          | {int 0}

The statement ending at line XXXX

CREATE TABLE hides_id_not_name(
  id INTEGER @DELETE(2),
  name TEXT @CREATE(3)
);

  {create_table_stmt}: hides_id_not_name: { name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name hides_id_not_name}
  | {col_key_list}
    | {col_def}: id: integer deleted @delete(2)
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {delete_attr}: ok
    |     | {version_annotation}
    |       | {int 2}
    | {col_key_list}
      | {col_def}: name: text @create(3)
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name name}
          | | {type_text}: text
          | {create_attr}: ok
            | {version_annotation}
              | {int 3}

The statement ending at line XXXX

SELECT id
  FROM hides_id_not_name;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'id'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name id}: err
  |     | {select_from_etc}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {table_or_subquery_list}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | | {table_or_subquery}: TABLE { hides_id_not_name: hides_id_not_name }
  |       |   | {name hides_id_not_name}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT name
  FROM hides_id_not_name;

  {select_stmt}: select: { name: text }
  | {select_core_list}: select: { name: text }
  | | {select_core}: select: { name: text }
  |   | {select_expr_list_con}: select: { name: text }
  |     | {select_expr_list}: select: { name: text }
  |     | | {select_expr}: name: text
  |     |   | {name name}: name: text
  |     | {select_from_etc}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {table_or_subquery_list}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | | {table_or_subquery}: TABLE { hides_id_not_name: hides_id_not_name }
  |       |   | {name hides_id_not_name}: TABLE { hides_id_not_name: hides_id_not_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE migrate_test(
  id INTEGER NOT NULL,
  id2 INTEGER @CREATE(4, creator),
  id3 INTEGER @CREATE(4, creator)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0027: a procedure can appear in only one annotation 'creator'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_test}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: id2: integer @create(4)
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id2}
      |   | | {type_int}: integer
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 4}
      |       | {name creator}
      | {col_key_list}
        | {col_def}: err
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name id3}
            | | {type_int}: integer
            | {create_attr}: err
              | {version_annotation}
                | {int 4}
                | {name creator}

The statement ending at line XXXX

CREATE PROC creator ()
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0187: @schema_upgrade_version not declared or doesn't match upgrade version 4 for proc 'creator'

  {create_proc_stmt}: err
  | {name creator}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken(
  col1 INTEGER,
  col2 INTEGER @CREATE(3),
  col3 INTEGER
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0032: created columns must be at the end and must be in version order 'col3'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: col2: integer @create(3)
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name col2}
      |   | | {type_int}: integer
      |   | {create_attr}: ok
      |     | {version_annotation}
      |       | {int 3}
      | {col_key_list}
        | {col_def}: err
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name col3}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken_not_null_create(
  col1 INTEGER,
  col2 INTEGER NOT NULL @CREATE(3)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0034: create/delete version numbers can only be applied to columns that are nullable or have a default value 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken_not_null_create}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok
            | {create_attr}
              | {version_annotation}
                | {int 3}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_broken_not_null_delete(
  col1 INTEGER,
  col2 INTEGER NOT NULL @DELETE(3)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0034: create/delete version numbers can only be applied to columns that are nullable or have a default value 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_broken_not_null_delete}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok
            | {delete_attr}
              | {version_annotation}
                | {int 3}

The statement ending at line XXXX

CREATE TABLE migrate_annotions_delete_out_of_order(
  col1 INTEGER,
  col2 INTEGER @DELETE(3) @CREATE(4)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0035: column delete version can't be <= column create version 'col2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name migrate_annotions_delete_out_of_order}
  | {col_key_list}
    | {col_def}: col1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name col2}
          | | {type_int}: integer
          | {delete_attr}: ok
            | {version_annotation}
            | | {int 3}
            | {create_attr}
              | {version_annotation}
                | {int 4}

The statement ending at line XXXX

CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc);

  {create_table_stmt}: versioned_table: { id: integer } deleted @create(1) @delete(3)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | | {name table_create_proc}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 3}
  | |       | {name table_delete_proc}
  | | {name versioned_table}
  | {col_key_list}
    | {col_def}: id: integer @create(2)
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE bogus_migration_proc(
  id INTEGER
) @CREATE(1, x_crc);

test/sem_test.sql:XXXX:1: error: in create_attr : CQL0338: the name of a migration procedure may not end in '_crc' 'x_crc'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}: err
  | |   | {version_annotation}
  | |     | {int 1}
  | |     | {name x_crc}
  | | {name bogus_migration_proc}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TABLE versioned_table_double_create(
  id INTEGER
) @CREATE(1) @CREATE(1);

test/sem_test.sql:XXXX:1: error: in create_attr : CQL0026: duplicate version annotation

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | {create_attr}: err
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name versioned_table_double_create}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TABLE versioned_table_double_delete(
  id INTEGER
) @DELETE(1) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in delete_attr : CQL0026: duplicate version annotation

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |   | | {int 1}
  | |   | {delete_attr}: err
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name versioned_table_double_delete}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE INDEX index_broken ON versioned_table (id);

test/sem_test.sql:XXXX:1: error: in str : CQL0019: create index table name not found (hidden by @delete) 'versioned_table'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name index_broken}
  | | {name versioned_table}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES versioned_table (id)
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0021: foreign key refers to non-existent table (hidden by @delete) 'versioned_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name versioned_table}
            | | {name_list}
            |   | {name id}
            | {int 0}

The statement ending at line XXXX

SELECT *
  FROM versioned_table;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined (hidden by @delete) 'versioned_table'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name versioned_table}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

ALTER TABLE versioned_table ADD COLUMN id INTEGER;

  {alter_table_add_column_stmt}: ok
  | {name versioned_table}: versioned_table: { id: integer } deleted @create(1) @delete(3)
  | {col_def}: id: integer
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name id}
        | {type_int}: integer

The statement ending at line XXXX

DELETE FROM versioned_table;

test/sem_test.sql:XXXX:1: error: in str : CQL0151: table in delete statement does not exist (hidden by @delete) 'versioned_table'

  {delete_stmt}: err
  | {name versioned_table}

The statement ending at line XXXX

INSERT INTO versioned_table VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0160: table in insert statement does not exist (hidden by @delete) 'versioned_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name versioned_table}
    | {columns_values}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO versioned_table(id) VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0160: table in insert statement does not exist (hidden by @delete) 'versioned_table'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name versioned_table}
    | {columns_values}
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW versioned_table AS
SELECT 1 AS x;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc)
test/sem_test.sql:XXXX:1: error: in create_view_stmt : CREATE VIEW versioned_table AS
SELECT 1 AS x
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'versioned_table'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name versioned_table}: err
      | {select_stmt}: versioned_table: { x: integer notnull }
        | {select_core_list}: versioned_table: { x: integer notnull }
        | | {select_core}: versioned_table: { x: integer notnull }
        |   | {select_expr_list_con}: versioned_table: { x: integer notnull }
        |     | {select_expr_list}: versioned_table: { x: integer notnull }
        |     | | {select_expr}: x: integer notnull
        |     |   | {int 1}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE versioned_table INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0198: global variable hides table/view name 'versioned_table'

  {declare_vars_type}: err
  | {name_list}: err
  | | {name versioned_table}: err
  | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE versioned_table(
  id2 INTEGER
);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE versioned_table(
  id INTEGER @CREATE(2)
) @CREATE(1, table_create_proc) @DELETE(3, table_delete_proc)
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE versioned_table(
  id2 INTEGER
)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'versioned_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name versioned_table}: err
  | {col_key_list}
    | {col_def}: id2: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id2}
          | {type_int}: integer

The statement ending at line XXXX

DROP TABLE IF EXISTS versioned_table;

  {drop_table_stmt}: ok
  | {int 1}
  | {name versioned_table}: versioned_table: { id: integer } deleted @create(1) @delete(3)

The statement ending at line XXXX

DROP TABLE garbonzo;

test/sem_test.sql:XXXX:1: error: in str : CQL0108: table in drop statement does not exist 'garbonzo'

  {drop_table_stmt}: err
  | {name garbonzo}

The statement ending at line XXXX

DROP TABLE MyView;

test/sem_test.sql:XXXX:1: error: in str : CQL0109: cannot drop a view with drop table 'MyView'

  {drop_table_stmt}: err
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

CREATE PROC uses_proc_for_result ()
BEGIN
  CALL with_result_set();
END;

  {create_proc_stmt}: uses_proc_for_result: { id: integer notnull, name: text, rate: longint } dml_proc
  | {name uses_proc_for_result}: uses_proc_for_result: { id: integer notnull, name: text, rate: longint } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc
        | {name with_result_set}: with_result_set: { id: integer notnull, name: text, rate: longint } dml_proc

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @DELETE(2)
) @CREATE(3);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0036: column delete version can't be <= the table create version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 3}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {delete_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @CREATE(2)
) @CREATE(3);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0038: column create version can't be <= the table create version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 3}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @DELETE(2)
) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0037: column delete version can't be >= the table delete version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {delete_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_early_delete(
  id INTEGER @CREATE(2)
) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0039: column create version can't be >= the table delete version 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name t_col_early_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

CREATE TABLE t_col_delete_notnull(
  id INTEGER NOT NULL DEFAULT 8675309 @DELETE(2)
);

  {create_table_stmt}: t_col_delete_notnull: {  }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name t_col_delete_notnull}
  | {col_key_list}
    | {col_def}: id: integer notnull has_default deleted @delete(2)
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {int 8675309}: integer notnull
            | {delete_attr}
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

CREATE TABLE neg_default(
  id INTEGER NOT NULL DEFAULT -1 @CREATE(2)
);

  {create_table_stmt}: neg_default: { id: integer notnull has_default }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name neg_default}
  | {col_key_list}
    | {col_def}: id: integer notnull has_default @create(2)
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_default}
            | {uminus}: integer notnull
            | | {int 1}: integer notnull
            | {create_attr}
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

ALTER TABLE neg_default ADD COLUMN id INTEGER NOT NULL DEFAULT -1;

  {alter_table_add_column_stmt}: ok
  | {name neg_default}: neg_default: { id: integer notnull has_default }
  | {col_def}: id: integer notnull has_default
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
      | | {name id}
      | | {type_int}: integer
      | {col_attrs_not_null}: ok
        | {col_attrs_default}
          | {uminus}: integer notnull
            | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC bogus_validate ()
BEGIN
  @PREVIOUS_SCHEMA;
END;

test/sem_test.sql:XXXX:1: error: in previous_schema_stmt : CQL0225: switching to previous schema validation mode must be outside of any proc

  {create_proc_stmt}: err
  | {name bogus_validate}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {previous_schema_stmt}: err

The statement ending at line XXXX

CREATE PROC bogus_fetch ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM foo AS T1
    INNER JOIN foo AS T2 ON T1.id = T2.id;
  FETCH C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0180: duplicate column name in result not allowed 'id'

  {create_proc_stmt}: err
  | {name bogus_fetch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, id: integer notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, id: integer notnull } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, id: integer notnull }
      |   | {select_core_list}: select: { id: integer notnull, id: integer notnull }
      |   | | {select_core}: select: { id: integer notnull, id: integer notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
      |   |     | | {star}: select: { id: integer notnull, id: integer notnull }
      |   |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
      |   |       | {join_clause}: JOIN { T1: foo, T2: foo }
      |   |       | | {table_or_subquery}: TABLE { T1: foo }
      |   |       | | | {name foo}: TABLE { T1: foo }
      |   |       | | | {opt_as_alias}
      |   |       | |   | {name T1}
      |   |       | | {join_target_list}
      |   |       |   | {join_target}: JOIN { T1: foo, T2: foo }
      |   |       |     | {int 1} {join_inner}
      |   |       |     | {table_join}
      |   |       |       | {table_or_subquery}: TABLE { T2: foo }
      |   |       |       | | {name foo}: TABLE { T2: foo }
      |   |       |       | | {opt_as_alias}
      |   |       |       |   | {name T2}
      |   |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
      |   |       |         | {on}: bool notnull
      |   |       |         | {eq}: bool notnull
      |   |       |           | {dot}: id: integer notnull
      |   |       |           | | {name T1}
      |   |       |           | | {name id}
      |   |       |           | {dot}: id: integer notnull
      |   |       |             | {name T2}
      |   |       |             | {name id}
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE PROC bogus_result_duplicate_names ()
BEGIN
  SELECT *
    FROM foo AS T1
    INNER JOIN foo AS T2 ON T1.id = T2.id;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0180: duplicate column name in result not allowed 'id'

  {create_proc_stmt}: err
  | {name bogus_result_duplicate_names}: err
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer notnull, id: integer notnull }
        | {select_core_list}: select: { id: integer notnull, id: integer notnull }
        | | {select_core}: select: { id: integer notnull, id: integer notnull }
        |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
        |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
        |     | | {star}: select: { id: integer notnull, id: integer notnull }
        |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
        |       | {join_clause}: JOIN { T1: foo, T2: foo }
        |       | | {table_or_subquery}: TABLE { T1: foo }
        |       | | | {name foo}: TABLE { T1: foo }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { T1: foo, T2: foo }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { T2: foo }
        |       |       | | {name foo}: TABLE { T2: foo }
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}: JOIN { T1: foo, T2: foo }
        |       |         | {on}: bool notnull
        |       |         | {eq}: bool notnull
        |       |           | {dot}: id: integer notnull
        |       |           | | {name T1}
        |       |           | | {name id}
        |       |           | {dot}: id: integer notnull
        |       |             | {name T2}
        |       |             | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE table_with_text_as_name(
  text TEXT,
  text2 TEXT
);

  {create_table_stmt}: table_with_text_as_name: { text: text, text2: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name table_with_text_as_name}
  | {col_key_list}
    | {col_def}: text: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name text}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: text2: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name text2}
            | {type_text}: text

The statement ending at line XXXX

SELECT text, text2
  FROM table_with_text_as_name;

  {select_stmt}: select: { text: text, text2: text }
  | {select_core_list}: select: { text: text, text2: text }
  | | {select_core}: select: { text: text, text2: text }
  |   | {select_expr_list_con}: select: { text: text, text2: text }
  |     | {select_expr_list}: select: { text: text, text2: text }
  |     | | {select_expr}: text: text
  |     | | | {name text}: text: text
  |     | | {select_expr_list}
  |     |   | {select_expr}: text2: text
  |     |     | {name text2}: text2: text
  |     | {select_from_etc}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {table_or_subquery_list}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | | {table_or_subquery}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       |   | {name table_with_text_as_name}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT text2 AS text, text AS other_text
  FROM table_with_text_as_name;

  {select_stmt}: select: { text: text, other_text: text }
  | {select_core_list}: select: { text: text, other_text: text }
  | | {select_core}: select: { text: text, other_text: text }
  |   | {select_expr_list_con}: select: { text: text, other_text: text }
  |     | {select_expr_list}: select: { text: text, other_text: text }
  |     | | {select_expr}: text: text
  |     | | | {name text2}: text2: text
  |     | | | {opt_as_alias}
  |     | |   | {name text}
  |     | | {select_expr_list}
  |     |   | {select_expr}: other_text: text
  |     |     | {name text}: text: text
  |     |     | {opt_as_alias}
  |     |       | {name other_text}
  |     | {select_from_etc}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {table_or_subquery_list}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | | {table_or_subquery}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       |   | {name table_with_text_as_name}: TABLE { table_with_text_as_name: table_with_text_as_name }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@SCHEMA_UPGRADE_SCRIPT;

test/sem_test.sql:XXXX:1: error: in schema_upgrade_script_stmt : CQL0227: schema upgrade declaration must come before any tables are declared

  {schema_upgrade_script_stmt}: err

The statement ending at line XXXX

CREATE PROC schema_upgrade_you_wish ()
BEGIN
  @SCHEMA_UPGRADE_SCRIPT;
END;

test/sem_test.sql:XXXX:1: error: in schema_upgrade_script_stmt : CQL0226: schema upgrade declaration must be outside of any proc

  {create_proc_stmt}: err
  | {name schema_upgrade_you_wish}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {schema_upgrade_script_stmt}: err

The statement ending at line XXXX

INSERT INTO hides_id_not_name(name) VALUES('x');

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name hides_id_not_name}: hides_id_not_name: { name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: values: { column1: text notnull }
        | {select_core_list}: values: { column1: text notnull }
        | | {select_core}: values: { column1: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull }
        |     | {insert_list}: ok
        |       | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE trickier_alter_target(
  id INTEGER,
  something_deleted TEXT @CREATE(1) @DELETE(2),
  added TEXT @CREATE(2),
  PRIMARY KEY (id)
);

  {create_table_stmt}: trickier_alter_target: { id: integer notnull partial_pk, added: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name trickier_alter_target}
  | {col_key_list}
    | {col_def}: id: integer notnull partial_pk
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: something_deleted: text deleted @create(1) @delete(2)
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name something_deleted}
      |   | | {type_text}: text
      |   | {create_attr}: ok
      |     | {version_annotation}
      |     | | {int 1}
      |     | {delete_attr}
      |       | {version_annotation}
      |         | {int 2}
      | {col_key_list}
        | {col_def}: added: text @create(2)
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name added}
        |   | | {type_text}: text
        |   | {create_attr}: ok
        |     | {version_annotation}
        |       | {int 2}
        | {col_key_list}
          | {pk_def}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN id INTEGER;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'id'

  {alter_table_add_column_stmt}: err
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull partial_pk, added: text }
  | {col_def}: id: integer
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name id}
        | {type_int}: integer

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN something_deleted TEXT;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0148: added column must already be reflected in declared schema, with @create, exact name match required 'something_deleted'

  {alter_table_add_column_stmt}: err
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull partial_pk, added: text }
  | {col_def}: something_deleted: text
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name something_deleted}
        | {type_text}: text

The statement ending at line XXXX

ALTER TABLE trickier_alter_target ADD COLUMN added TEXT;

  {alter_table_add_column_stmt}: ok
  | {name trickier_alter_target}: trickier_alter_target: { id: integer notnull partial_pk, added: text }
  | {col_def}: added: text
    | {col_def_type_attrs}: ok
      | {col_def_name_type}
        | {name added}
        | {type_text}: text

The statement ending at line XXXX

SELECT *
  FROM (SELECT NOT 'x' AS X);

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {select_stmt}: err
  |       |     | {select_core_list}: err
  |       |     | | {select_core}: err
  |       |     |   | {select_expr_list_con}: err
  |       |     |     | {select_expr_list}: err
  |       |     |     | | {select_expr}: err
  |       |     |     |   | {not}: err
  |       |     |     |   | | {strlit 'x'}: text notnull
  |       |     |     |   | {opt_as_alias}
  |       |     |     |     | {name X}
  |       |     |     | {select_from_etc}: ok
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE VIEW view_with_version AS
SELECT *
  FROM bar @DELETE(2);

  {create_view_stmt}: view_with_version: { id: integer notnull, name: text, rate: longint } deleted @delete(2)
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
    | | {name view_with_version}
    | | {select_stmt}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   | {select_core_list}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   | | {select_core}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |   | {select_expr_list_con}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | {select_expr_list}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | | {star}: view_with_version: { id: integer notnull, name: text, rate: longint }
    |   |     | {select_from_etc}: TABLE { bar: bar }
    |   |       | {table_or_subquery_list}: TABLE { bar: bar }
    |   |       | | {table_or_subquery}: TABLE { bar: bar }
    |   |       |   | {name bar}: TABLE { bar: bar }
    |   |       | {select_where}
    |   |         | {select_groupby}
    |   |           | {select_having}
    |   | {select_orderby}
    |     | {select_limit}
    |       | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 2}

The statement ending at line XXXX

SET ll := 3147483647L;

  {assign}: ll: longint notnull variable was_set
  | {name ll}: ll: longint notnull variable was_set
  | {longint 3147483647}: longint notnull

The statement ending at line XXXX

DROP VIEW view_not_present;

test/sem_test.sql:XXXX:1: error: in str : CQL0110: view in drop statement does not exist 'view_not_present'

  {drop_view_stmt}: err
  | {name view_not_present}

The statement ending at line XXXX

DROP VIEW foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0111: cannot drop a table with drop view 'foo'

  {drop_view_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

DROP VIEW IF EXISTS MyView;

  {drop_view_stmt}: ok
  | {int 1}
  | {name MyView}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }

The statement ending at line XXXX

DROP INDEX index_1;

  {drop_index_stmt}: ok
  | {name index_1}

The statement ending at line XXXX

DROP INDEX IF EXISTS I_dont_see_no_steekin_index;

test/sem_test.sql:XXXX:1: error: in str : CQL0112: index in drop statement was not declared 'I_dont_see_no_steekin_index'

  {drop_index_stmt}: err
  | {int 1}
  | {name I_dont_see_no_steekin_index}

The statement ending at line XXXX

CREATE TABLE two_not_null(
  id INTEGER NOT NULL UNIQUE NOT NULL
);

test/sem_test.sql:XXXX:1: error: in col_attrs_not_null : CQL0030: a column attribute was specified twice on the same column 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_not_null}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: err
          | {col_attrs_unique}
            | {col_attrs_not_null}

The statement ending at line XXXX

CREATE TABLE mixed_pk_uk(
  id INTEGER PRIMARY KEY UNIQUE
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0031: column can't be primary key and also unique key 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name mixed_pk_uk}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
          | {col_attrs_unique}

The statement ending at line XXXX

CREATE TABLE table_with_uk(
  id INTEGER UNIQUE
);

  {create_table_stmt}: table_with_uk: { id: integer unique_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name table_with_uk}
  | {col_key_list}
    | {col_def}: id: integer unique_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_unique}: ok

The statement ending at line XXXX

CREATE TABLE baz(
  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  PRIMARY KEY (id)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0143: more than one primary key in table 'baz'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name baz}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | | {col_attrs_autoinc}
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {pk_def}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
            | {indexed_column}
              | {name id}: id: integer notnull

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3) @DUMMY_SEED('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0156: seed expression must be a non-nullable integer

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: err
  |   | {strlit 'x'}: text notnull
  |   | {int 0}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {strlit 'bazzle'}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(1, 'bazzle', 3) @DUMMY_SEED(NOT 'x');

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}: err
  |   | {not}: err
  |   | | {strlit 'x'}: text notnull
  |   | {int 0}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {strlit 'bazzle'}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) VALUES(_seed_, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(1 + 2) @DUMMY_DEFAULTS @DUMMY_NULLABLES;

  {insert_stmt}: ok
  | {insert_normal}
  | | {seed_stub}
  |   | {add}: integer notnull
  |   | | {int 1}: integer notnull
  |   | | {int 2}: integer notnull
  |   | {int 3}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {insert_list}
        | {name _seed_}: _seed_: integer notnull variable
        | {insert_list}
          | {call}: text notnull
          | | {name printf}: text notnull
          | | {call_arg_list}
          |   | {call_filter_clause}
          |   | {arg_list}: ok
          |     | {strlit 'name_%d'}: text notnull
          |     | {arg_list}
          |       | {name _seed_}: _seed_: integer notnull variable
          | {insert_list}
            | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

INSERT INTO booly(flag) VALUES(1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name booly}: booly: { id: integer has_default, flag: bool }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name flag}: flag: bool
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE blob_var BLOB;

  {declare_vars_type}: blob
  | {name_list}: blob_var: blob variable was_set
  | | {name blob_var}: blob_var: blob variable was_set
  | {type_blob}: blob

The statement ending at line XXXX

SET X := blob_var < 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0004: left operand cannot be a blob in '<'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {lt}: err
    | {name blob_var}: blob_var: blob variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 < blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0005: right operand cannot be a blob in '<'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {lt}: err
    | {int 1}: integer notnull
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var = blob_var;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {eq}: bool
    | {name blob_var}: blob_var: blob variable
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var <> blob_var;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {ne}: bool
    | {name blob_var}: blob_var: blob variable
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := blob_var + 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0004: left operand cannot be a blob in '+'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {add}: err
    | {name blob_var}: blob_var: blob variable
    | {int 1}: integer notnull

The statement ending at line XXXX

SET X := 1 + blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0005: right operand cannot be a blob in '+'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {add}: err
    | {int 1}: integer notnull
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := NOT blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0045: blob operand not allowed in 'NOT'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not}: err
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET X := -blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0045: blob operand not allowed in '-'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {uminus}: err
    | {name blob_var}: blob_var: blob variable

The statement ending at line XXXX

SET a_string := blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'a_string'

  {assign}: err
  | {name a_string}: err
  | {name blob_var}: err

The statement ending at line XXXX

SET blob_var := a_string;

test/sem_test.sql:XXXX:1: error: in str : CQL0011: incompatible types in expression 'blob_var'

  {assign}: err
  | {name blob_var}: err
  | {name a_string}: err

The statement ending at line XXXX

SET a_string := blob_var || 2.0;

test/sem_test.sql:XXXX:1: error: in concat : CQL0241: CONCAT may only appear in the context of a SQL statement

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {concat}: err
    | {name blob_var}: blob_var: blob variable was_set
    | {dbl 2.0}: real notnull

The statement ending at line XXXX

SELECT blob_var || 2.0;

test/sem_test.sql:XXXX:1: error: in str : CQL0243: blob operand must be converted to string first in '||'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {name blob_var}: blob_var: blob variable was_set
  |     |     | {dbl 2.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 || blob_var;

test/sem_test.sql:XXXX:1: error: in str : CQL0243: blob operand must be converted to string first in '||'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {int 1}: integer notnull
  |     |     | {name blob_var}: blob_var: blob variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_proc (OUT a_blob BLOB)
BEGIN
  SET a_blob := NULL;
END;

  {create_proc_stmt}: ok
  | {name blob_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_blob: blob variable out was_set
    |   | {out}
    |   | {param_detail}: a_blob: blob variable out was_set
    |     | {name a_blob}: a_blob: blob variable out was_set
    |     | {type_blob}: blob
    | {stmt_list}: ok
      | {assign}: a_blob: blob variable out was_set
        | {name a_blob}: a_blob: blob variable out was_set
        | {null}: null

The statement ending at line XXXX

CREATE TABLE blob_table_test(
  b BLOB
);

  {create_table_stmt}: blob_table_test: { b: blob }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name blob_table_test}
  | {col_key_list}
    | {col_def}: b: blob
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name b}
          | {type_blob}: blob

The statement ending at line XXXX

SELECT blob_var;

  {select_stmt}: select: { blob_var: blob variable was_set }
  | {select_core_list}: select: { blob_var: blob variable was_set }
  | | {select_core}: select: { blob_var: blob variable was_set }
  |   | {select_expr_list_con}: select: { blob_var: blob variable was_set }
  |     | {select_expr_list}: select: { blob_var: blob variable was_set }
  |     | | {select_expr}: blob_var: blob variable was_set
  |     |   | {name blob_var}: blob_var: blob variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := blob_var IN (blob_var, NULL);

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {in_pred}: bool
    | {name blob_var}: blob_var: blob variable was_set
    | {expr_list}: blob_var: blob variable was_set
      | {name blob_var}: blob_var: blob variable was_set
      | {expr_list}: null
        | {null}: null

The statement ending at line XXXX

SET X := blob_var IN (blob_var, 1);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0011: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {name blob_var}: blob_var: blob variable was_set
    | {expr_list}: blob_var: blob variable was_set
      | {name blob_var}: blob_var: blob variable was_set
      | {expr_list}: integer notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

SET X := blob_var IN ('foo', blob_var);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0011: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {name blob_var}: blob_var: blob variable was_set
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}
        | {name blob_var}

The statement ending at line XXXX

SET X := 'foo' IN ('foo', blob_var);

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0009: incompatible types in expression 'IN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {in_pred}: err
    | {strlit 'foo'}: text notnull
    | {expr_list}: text notnull
      | {strlit 'foo'}: text notnull
      | {expr_list}: blob_var: blob variable was_set
        | {name blob_var}: blob_var: blob variable was_set

The statement ending at line XXXX

SET X := CASE blob_var WHEN blob_var THEN 2
ELSE 3
END;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {case_expr}: integer notnull
    | {name blob_var}: blob_var: blob variable was_set
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {name blob_var}: blob_var: blob variable was_set
      |   | {int 2}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET blob_var := CASE 1 WHEN 1 THEN blob_var
ELSE NULL
END;

  {assign}: blob_var: blob variable was_set
  | {name blob_var}: blob_var: blob variable was_set
  | {case_expr}: blob
    | {int 1}: integer notnull
    | {connector}: blob
      | {case_list}: blob variable was_set
      | | {when}: blob_var: blob variable was_set
      |   | {int 1}: integer notnull
      |   | {name blob_var}: blob_var: blob variable was_set
      | {null}: null

The statement ending at line XXXX

SET X := blob_var BETWEEN 1 AND 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0071: first operand cannot be a blob in 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {name blob_var}: blob_var: blob variable was_set
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN blob_var AND 3;

test/sem_test.sql:XXXX:1: error: in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {name blob_var}: blob_var: blob variable was_set
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 BETWEEN 1 AND blob_var;

test/sem_test.sql:XXXX:1: error: in between : CQL0012: incompatible types in expression 'BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name blob_var}: blob_var: blob variable was_set

The statement ending at line XXXX

SET X := blob_var NOT BETWEEN 1 AND 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0071: first operand cannot be a blob in 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {name blob_var}: blob_var: blob variable was_set
    | {range}
      | {int 1}: integer notnull
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN blob_var AND 3;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {name blob_var}: blob_var: blob variable was_set
      | {int 3}: integer notnull

The statement ending at line XXXX

SET X := 2 NOT BETWEEN 1 AND blob_var;

test/sem_test.sql:XXXX:1: error: in not_between : CQL0012: incompatible types in expression 'NOT BETWEEN'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {not_between}: err
    | {int 2}: integer notnull
    | {range}
      | {int 1}: integer notnull
      | {name blob_var}: blob_var: blob variable was_set

The statement ending at line XXXX

CREATE PROC bogus_object_read ()
BEGIN
  DECLARE o1, o2, o3 OBJECT;
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  FETCH C INTO o1, o2, o3;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0010: incompatible types in expression 'o1'

  {create_proc_stmt}: err
  | {name bogus_object_read}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: object
      | | {name_list}: o1: object variable
      | | | {name o1}: o1: object variable
      | | | {name_list}: o2: object variable
      | |   | {name o2}: o2: object variable
      | |   | {name_list}: o3: object variable
      | |     | {name o3}: o3: object variable
      | | {type_object}: object
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
        | {name_list}
          | {name o1}: err
          | {name_list}
            | {name o2}
            | {name_list}
              | {name o3}

The statement ending at line XXXX

CREATE PROC fool (x INTEGER)
BEGIN
  SET x := x IN (SELECT 1);
END;

test/sem_test.sql:XXXX:1: error: in in_pred : CQL0078: [not] in (select ...) is only allowed inside of select lists, where, on, and having clauses

  {create_proc_stmt}: err
  | {name fool}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name x}: x: integer variable in
        | {in_pred}: err
          | {name x}: x: integer variable in
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     |   | {int 1}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE PROC notfool (x INTEGER)
BEGIN
  SET x := x NOT IN (SELECT 1);
END;

test/sem_test.sql:XXXX:1: error: in not_in : CQL0078: [not] in (select ...) is only allowed inside of select lists, where, on, and having clauses

  {create_proc_stmt}: err
  | {name notfool}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name x}: x: integer variable in
        | {not_in}: err
          | {name x}: x: integer variable in
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     |   | {int 1}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

INSERT INTO blob_table_test(b) VALUES(CAST(printf('b_%d', _seed_) AS BLOB)) @DUMMY_SEED(1) @DUMMY_NULLABLES;

  {insert_stmt}: ok
  | {insert_normal}
  | | {seed_stub}
  |   | {int 1}: integer notnull
  |   | {int 2}
  | {name_columns_values}
    | {name blob_table_test}: blob_table_test: { b: blob }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name b}: b: blob
      | {insert_list}
        | {cast_expr}: blob notnull
          | {call}: text notnull
          | | {name printf}: text notnull
          | | {call_arg_list}
          |   | {call_filter_clause}
          |   | {arg_list}: ok
          |     | {strlit 'b_%d'}: text notnull
          |     | {arg_list}
          |       | {name _seed_}: _seed_: integer notnull variable
          | {type_blob}: blob

The statement ending at line XXXX

CREATE PROC out_cursor_proc ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
  | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

DECLARE QQ CURSOR LIKE out_cursor_proc;

  {declare_cursor_like_name}: QQ: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
  | {name QQ}: QQ: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
  | {shape_def}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
    | {like}: ok
      | {name out_cursor_proc}

The statement ending at line XXXX

FETCH QQ FROM CALL out_cursor_proc(1);

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0235: too many arguments provided to procedure 'out_cursor_proc'

  {fetch_call_stmt}: err
  | {name QQ}
  | {call_stmt}: err
    | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
    | {expr_list}: ok
      | {int 1}

The statement ending at line XXXX

CREATE PROC not_out_cursor_proc ()
BEGIN
  SELECT 1 AS A, 2 AS B;
END;

  {create_proc_stmt}: not_out_cursor_proc: { A: integer notnull, B: integer notnull } dml_proc
  | {name not_out_cursor_proc}: not_out_cursor_proc: { A: integer notnull, B: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { A: integer notnull, B: integer notnull }
        | {select_core_list}: select: { A: integer notnull, B: integer notnull }
        | | {select_core}: select: { A: integer notnull, B: integer notnull }
        |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
        |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
        |     | | {select_expr}: A: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name A}
        |     | | {select_expr_list}
        |     |   | {select_expr}: B: integer notnull
        |     |     | {int 2}: integer notnull
        |     |     | {opt_as_alias}
        |     |       | {name B}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

FETCH QQ FROM CALL not_out_cursor_proc();

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0203: cursor requires a procedure that returns a cursor with OUT 'QQ'

  {fetch_call_stmt}: err
  | {name QQ}
  | {call_stmt}: err
    | {name not_out_cursor_proc}: not_out_cursor_proc: { A: integer notnull, B: integer notnull } dml_proc

The statement ending at line XXXX

CREATE PROC out_cursor_proc_not_shape_storage ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C INTO a, b;
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in out_stmt : CQL0223: cursor was not fetched with the auto-fetch syntax 'fetch [cursor]' 'C'

  {create_proc_stmt}: err
  | {name out_cursor_proc_not_shape_storage}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable was_set
      | | | {name a}: a: integer notnull variable was_set
      | | | {name_list}: b: integer notnull variable was_set
      | |   | {name b}: b: integer notnull variable was_set
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc fetch_into
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc fetch_into
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name_list}
      |   | {name a}: a: integer notnull variable was_set
      |   | {name_list}
      |     | {name b}: b: integer notnull variable was_set
      | {out_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc fetch_into

The statement ending at line XXXX

CREATE PROC out_cursor_proc_incompat_results ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  DECLARE D CURSOR FOR SELECT 1 AS A, 2 AS C;
  FETCH C;
  FETCH D;
  OUT C;
  OUT D;
END;

test/sem_test.sql:XXXX:1: error: in out_stmt : CQL0058: in multiple select/out statements, all column names must be identical so they have unambiguous names; error in column 2: 'B' vs. 'C'
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 2 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 2 columns

only in 1st: B integer notnull
only in 2nd: C integer notnull


  {create_proc_stmt}: err
  | {name out_cursor_proc_incompat_results}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: D: select: { A: integer notnull, C: integer notnull } variable dml_proc
      | | {name D}: D: select: { A: integer notnull, C: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: C: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {fetch_stmt}: D: select: { A: integer notnull, C: integer notnull } variable dml_proc shape_storage
      | | {name D}: D: select: { A: integer notnull, C: integer notnull } variable dml_proc shape_storage
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {out_stmt}: err
        | {name D}: D: select: { A: integer notnull, C: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT C;
  SELECT 1 AS A, 2 AS B;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {out_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {select_stmt}: err
        | {select_core_list}: select: { A: integer notnull, B: integer notnull }
        | | {select_core}: select: { A: integer notnull, B: integer notnull }
        |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
        |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
        |     | | {select_expr}: A: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name A}
        |     | | {select_expr_list}
        |     |   | {select_expr}: B: integer notnull
        |     |     | {int 2}: integer notnull
        |     |     | {opt_as_alias}
        |     |       | {name B}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select_select_first ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  SELECT 1 AS A, 2 AS B;
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in out_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select_select_first'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select_select_first}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      | | | {select_core}: select: { A: integer notnull, B: integer notnull }
      | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      | |     | | {select_expr}: A: integer notnull
      | |     | | | {int 1}: integer notnull
      | |     | | | {opt_as_alias}
      | |     | |   | {name A}
      | |     | | {select_expr_list}
      | |     |   | {select_expr}: B: integer notnull
      | |     |     | {int 2}: integer notnull
      | |     |     | {opt_as_alias}
      | |     |       | {name B}
      | |     | {select_from_etc}: ok
      | |       | {select_where}
      | |         | {select_groupby}
      | |           | {select_having}
      | | {select_orderby}
      |   | {select_limit}
      |     | {select_offset}
      | {out_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC out_cursor_proc_mixed_cursor_select_then_union ()
BEGIN
  DECLARE a, b INTEGER NOT NULL;
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  SELECT 1 AS A, 2 AS B;
  OUT UNION C;
END;

test/sem_test.sql:XXXX:1: error: in out_union_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_cursor_proc_mixed_cursor_select_then_union'

  {create_proc_stmt}: err
  | {name out_cursor_proc_mixed_cursor_select_then_union}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: a: integer notnull variable
      | | | {name a}: a: integer notnull variable
      | | | {name_list}: b: integer notnull variable
      | |   | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      | | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      | | | {select_core}: select: { A: integer notnull, B: integer notnull }
      | |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      | |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      | |     | | {select_expr}: A: integer notnull
      | |     | | | {int 1}: integer notnull
      | |     | | | {opt_as_alias}
      | |     | |   | {name A}
      | |     | | {select_expr_list}
      | |     |   | {select_expr}: B: integer notnull
      | |     |     | {int 2}: integer notnull
      | |     |     | {opt_as_alias}
      | |     |       | {name B}
      | |     | {select_from_etc}: ok
      | |       | {select_where}
      | |         | {select_groupby}
      | |           | {select_having}
      | | {select_orderby}
      |   | {select_limit}
      |     | {select_offset}
      | {out_union_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC out_union_dml ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT UNION C;
END;

  {create_proc_stmt}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union
  | {name out_union_dml}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {out_union_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC out_union ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2 AS B;
  FETCH C(A, B) FROM VALUES(1, 2);
  OUT UNION C;
END;

  {create_proc_stmt}: C: out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union value_cursor
  | {name out_union}: C: out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {out_union_stmt}: C: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC call_out_union_dml ()
BEGIN
  CALL out_union_dml();
END;

  {create_proc_stmt}: C: call_out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union calls_out_union
  | {name call_out_union_dml}: C: call_out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union calls_out_union
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union
        | {name out_union_dml}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union

The statement ending at line XXXX

CREATE PROC call_out_union ()
BEGIN
  CALL out_union();
END;

  {create_proc_stmt}: C: call_out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union calls_out_union value_cursor
  | {name call_out_union}: C: call_out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union calls_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {call_stmt}: C: out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union value_cursor
        | {name out_union}: C: out_union: { A: integer notnull, B: integer notnull } variable shape_storage uses_out_union value_cursor

The statement ending at line XXXX

CREATE PROC out_union_call_and_out_union ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  OUT UNION C;
  CALL out_union_dml();
END;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_union_call_and_out_union'

  {create_proc_stmt}: err
  | {name out_union_call_and_out_union}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {out_union_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {call_stmt}: err
        | {name out_union_dml}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union

The statement ending at line XXXX

CREATE PROC out_union_call_and_out_union_other_order ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C;
  CALL out_union_dml();
  OUT UNION C;
END;

test/sem_test.sql:XXXX:1: error: in out_union_stmt : CQL0063: can't mix and match out, out union, or select/call for return values 'out_union_call_and_out_union_other_order'

  {create_proc_stmt}: err
  | {name out_union_call_and_out_union_other_order}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage
      | {call_stmt}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union
      | | {name out_union_dml}: C: out_union_dml: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union
      | {out_union_stmt}: err
        | {name C}: C: select: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC out_not_cursor ()
BEGIN
  DECLARE C INTEGER;
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'C'

  {create_proc_stmt}: err
  | {name out_not_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C: integer variable
      | | | {name C}: C: integer variable
      | | {type_int}: integer
      | {out_stmt}: err
        | {name C}: err

The statement ending at line XXXX

OUT curs;

test/sem_test.sql:XXXX:1: error: in out_stmt : CQL0222: out cursor statement only makes sense inside of a procedure

  {out_stmt}: err
  | {name curs}

The statement ending at line XXXX

CREATE PROC result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;

  {create_proc_stmt}: ok dml_proc
  | {name result_reader}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
        | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
          | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out

The statement ending at line XXXX

CREATE PROC fails_result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0215: value cursors are not used with FETCH C, or FETCH C INTO 'C'

  {create_proc_stmt}: err
  | {name fails_result_reader}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_stmt}: err
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor

The statement ending at line XXXX

DECLARE PROC declared_proc (id INTEGER) OUT (t TEXT);

  {declare_proc_stmt}: declared_proc: { t: text } uses_out
  | {proc_name_type}
  | | {name declared_proc}: declared_proc: { t: text } uses_out
  | | {int 5}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: declared_proc: { t: text }
      | {typed_name}: t: text
        | {name t}
        | {type_text}: t: text

The statement ending at line XXXX

CREATE PROC invalid_proc_fetch_bogus_call ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL declared_proc(NOT 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name invalid_proc_fetch_bogus_call}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: err
        | {name C}
        | {call_stmt}: err
          | {name declared_proc}: declared_proc: { t: text } uses_out
          | {expr_list}: ok
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE PROC xyzzy ()
BEGIN
END;

  {create_proc_stmt}: ok
  | {name xyzzy}: ok
  | {proc_params_stmts}

The statement ending at line XXXX

CREATE PROC invalid_proc_fetch ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL xyzzy();
END;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0203: cursor requires a procedure that returns a cursor with OUT 'C'

  {create_proc_stmt}: err
  | {name invalid_proc_fetch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: err
        | {name C}
        | {call_stmt}: err
          | {name xyzzy}: ok

The statement ending at line XXXX

CREATE PROC fails_result_reader_double_decl ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
END;

test/sem_test.sql:XXXX:1: error: in declare_value_cursor : CQL0197: duplicate variable name in the same scope 'C'

  {create_proc_stmt}: err
  | {name fails_result_reader_double_decl}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {declare_value_cursor}: err
        | {name C}: err
        | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
          | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out

The statement ending at line XXXX

CREATE PROC proc_with_single_output (a INTEGER, b INTEGER, OUT c INTEGER)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name proc_with_single_output}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer variable in
      | | {param_detail}: a: integer variable in
      |   | {name a}: a: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: b: integer variable in
        | | {param_detail}: b: integer variable in
        |   | {name b}: b: integer variable in
        |   | {type_int}: integer
        | {params}
          | {param}: c: integer variable out
            | {out}
            | {param_detail}: c: integer variable out
              | {name c}: c: integer variable out
              | {type_int}: integer

The statement ending at line XXXX

SET an_int := proc_with_single_output(1, an_int);

  {assign}: an_int: integer variable was_set
  | {name an_int}: an_int: integer variable was_set
  | {call}: integer
    | {name proc_with_single_output}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name an_int}: an_int: integer variable was_set

The statement ending at line XXXX

CREATE PROC proc_func (IN arg1 INTEGER, OUT arg2 INTEGER)
BEGIN
  DROP TABLE foo;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc_func}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: integer variable in
    | | | {in}
    | | | {param_detail}: arg1: integer variable in
    | |   | {name arg1}: arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: arg2: integer variable out
    |     | {out}
    |     | {param_detail}: arg2: integer variable out
    |       | {name arg2}: arg2: integer variable out
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {drop_table_stmt}: ok
        | {name foo}: foo: { id: integer notnull primary_key autoinc }

The statement ending at line XXXX

SET an_int := proc_func(DISTINCT 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0451: procedure as function call is not compatible with DISTINCT or filter clauses 'proc_func'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {call}: err
    | {name proc_func}
    | {call_arg_list}
      | {call_filter_clause}
      | | {distinct}
      | {arg_list}: ok
        | {int 1}

The statement ending at line XXXX

SET an_int := proc_with_single_output(1, an_int, an_int2);

test/sem_test.sql:XXXX:1: error: in call : CQL0235: too many arguments provided to procedure 'proc_with_single_output'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {call}: err
    | {name proc_with_single_output}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name an_int}: an_int: integer variable was_set
          | {arg_list}
            | {name an_int2}: an_int2: integer variable

The statement ending at line XXXX

LET out_result_set := out_cursor_proc();

  {let_stmt}: out_result_set: object<out_cursor_proc SET> notnull variable
  | {name out_result_set}: out_result_set: object<out_cursor_proc SET> notnull variable
  | {call}: object<out_cursor_proc SET> notnull
    | {name out_cursor_proc}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

SET an_int := proc2(1);

test/sem_test.sql:XXXX:1: error: in param : CQL0211: procedure without trailing OUT parameter used as function 'proc2'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {call}: err
    | {name proc2}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SET an_int := ( SELECT proc_with_single_output(1, an_int, an_int) );

test/sem_test.sql:XXXX:1: error: in call : CQL0224: a function call to a procedure inside SQL may call only a shared fragment i.e. @attribute(cql:shared_fragment) 'proc_with_single_output'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name proc_with_single_output}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}
    |     |         | {arg_list}
    |     |           | {name an_int}
    |     |           | {arg_list}
    |     |             | {name an_int}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC dml_func (OUT a INTEGER NOT NULL)
BEGIN
  SET a := ( SELECT 1 );
END;

  {create_proc_stmt}: ok dml_proc
  | {name dml_func}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer notnull variable out was_set
    |   | {out}
    |   | {param_detail}: a: integer notnull variable out was_set
    |     | {name a}: a: integer notnull variable out was_set
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: a: integer notnull variable out was_set
        | {name a}: a: integer notnull variable out was_set
        | {select_stmt}: _anon: integer notnull
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 1}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC should_be_dml (OUT a INTEGER NOT NULL)
BEGIN
  SET a := dml_func();
END;

  {create_proc_stmt}: ok dml_proc
  | {name should_be_dml}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer notnull variable out was_set
    |   | {out}
    |   | {param_detail}: a: integer notnull variable out was_set
    |     | {name a}: a: integer notnull variable out was_set
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: a: integer notnull variable out was_set
        | {name a}: a: integer notnull variable out was_set
        | {call}: integer notnull
          | {name dml_func}
          | {call_arg_list}
            | {call_filter_clause}

The statement ending at line XXXX

CREATE PROC fetch_values ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, 2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}: ok
              | {int 1}: integer notnull
              | {insert_list}
                | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC fetch_values_dummy ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(_seed_, _seed_) @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values_dummy}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}
              | {name _seed_}: _seed_: integer notnull variable
              | {insert_list}
                | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_from_call ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

  {create_proc_stmt}: C: fetch_from_call: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out value_cursor
  | {name fetch_from_call}: C: fetch_from_call: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {shape_def}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {like}: ok
      |     | {name out_cursor_proc}
      | {fetch_call_stmt}: ok
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {out_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_invalid_arguments ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc(42);
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0235: too many arguments provided to procedure 'out_cursor_proc'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_invalid_arguments}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {shape_def}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {like}: ok
      |     | {name out_cursor_proc}
      | {fetch_call_stmt}: err
      | | {name C}
      | | {call_stmt}: err
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {expr_list}: ok
      |     | {int 42}
      | {out_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_invalid_cursor ()
BEGIN
  DECLARE C TEXT;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'C'
test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'C'

  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_invalid_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: text
      | | {name_list}: C: text variable
      | | | {name C}: C: text variable
      | | {type_text}: text
      | {fetch_call_stmt}: err
      | | {name C}: err
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {out_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE PROC fetch_from_call_to_proc_with_different_column_names ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2 AS C;
  FETCH C FROM CALL out_cursor_proc();
  OUT C;
END;

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0058: receiving cursor from call, all column names must be identical so they have unambiguous names; error in column 2: 'C' vs. 'B'
test/sem_test.sql:XXXX:1: error: in str : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 2 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 2 columns

only in 1st: C integer notnull
only in 2nd: B integer notnull


  {create_proc_stmt}: err
  | {name fetch_from_call_to_proc_with_different_column_names}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C: select: { A: integer notnull, C: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: select: { A: integer notnull, C: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: C: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_call_stmt}: err
      | | {name C}: C: select: { A: integer notnull, C: integer notnull } variable shape_storage value_cursor
      | | {call_stmt}: err
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {out_stmt}: C: select: { A: integer notnull, C: integer notnull } variable shape_storage value_cursor
        | {name C}: C: select: { A: integer notnull, C: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

FETCH not_a_cursor FROM VALUES(1, 2, 3);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name not_a_cursor}: err
    | {columns_values}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

FETCH my_cursor FROM VALUES(1, 2, 3);

test/sem_test.sql:XXXX:1: error: in str : CQL0165: fetch values is only for value cursors, not for sqlite cursors 'my_cursor'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
    | {columns_values}
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}
          | {insert_list}
            | {int 3}

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_seed_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C() FROM VALUES() @DUMMY_SEED(NOT 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_seed_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {insert_dummy_spec}: err
        | | {not}: err
        | | | {strlit 'x'}: text notnull
        | | {int 0}
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}

The statement ending at line XXXX

CREATE PROC fetch_values_missing_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES();
END;

test/sem_test.sql:XXXX:1: error: in fetch_values_stmt : CQL0166: count of columns differs from count of values

  {create_proc_stmt}: err
  | {name fetch_values_missing_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
              | {name_list}
                | {name A}: A: integer notnull
                | {name_list}
                  | {name B}: B: integer notnull

The statement ending at line XXXX

CREATE PROC blob_out ()
BEGIN
  DECLARE C CURSOR FOR SELECT CASE WHEN 1 THEN CAST('x' AS BLOB)
  ELSE NULL
  END AS B;
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
  | {name blob_out}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { B: blob } variable dml_proc
      | | {name C}: C: select: { B: blob } variable dml_proc shape_storage
      | | {select_stmt}: select: { B: blob }
      |   | {select_core_list}: select: { B: blob }
      |   | | {select_core}: select: { B: blob }
      |   |   | {select_expr_list_con}: select: { B: blob }
      |   |     | {select_expr_list}: select: { B: blob }
      |   |     | | {select_expr}: B: blob
      |   |     |   | {case_expr}: blob
      |   |     |   | | {connector}: blob
      |   |     |   |   | {case_list}: blob notnull
      |   |     |   |   | | {when}: blob notnull
      |   |     |   |   |   | {int 1}: integer notnull
      |   |     |   |   |   | {cast_expr}: blob notnull
      |   |     |   |   |     | {strlit 'x'}: text notnull
      |   |     |   |   |     | {type_blob}: blob
      |   |     |   |   | {null}: null
      |   |     |   | {opt_as_alias}
      |   |     |     | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { B: blob } variable dml_proc shape_storage
      | | {name C}: C: select: { B: blob } variable dml_proc shape_storage
      | {out_stmt}: C: select: { B: blob } variable dml_proc shape_storage
        | {name C}: C: select: { B: blob } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC fetch_values_blob_dummy ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL blob_out();
  FETCH C() FROM VALUES() @DUMMY_SEED(123) @DUMMY_NULLABLES;
END;

test/sem_test.sql:XXXX:1: error: in fetch_values_stmt : CQL0168: CQL has no good way to generate dummy blobs; not supported for now

  {create_proc_stmt}: err
  | {name fetch_values_blob_dummy}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
      | | {name C}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
      |   | {name blob_out}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}

The statement ending at line XXXX

CREATE PROC fetch_values_missing_columns ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A) FROM VALUES(1);
END;

test/sem_test.sql:XXXX:1: error: in fetch_values_stmt : CQL0167: required column missing in FETCH statement 'B'

  {create_proc_stmt}: err
  | {name fetch_values_missing_columns}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            | {insert_list}: ok
              | {int 1}

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_value ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, NOT 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_value}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}: ok
              | {int 1}: integer notnull
              | {insert_list}
                | {not}: err
                  | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE PROC fetch_values_bogus_type ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL out_cursor_proc();
  FETCH C(A, B) FROM VALUES(1, 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'B'

  {create_proc_stmt}: err
  | {name fetch_values_bogus_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: integer notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            | {insert_list}: ok
              | {int 1}: integer notnull
              | {insert_list}
                | {strlit 'x'}: err

The statement ending at line XXXX

CREATE PROC fetch_values_blob_dummy_with_null ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL blob_out();
  FETCH C(B) FROM VALUES(NULL) @DUMMY_SEED(123);
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_values_blob_dummy_with_null}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
      | | {name C}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
      |   | {name blob_out}: C: blob_out: { B: blob } variable dml_proc shape_storage uses_out
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 123}: integer notnull
        | | {int 0}
        | {name_columns_values}
          | {name C}: C: blob_out: { B: blob } variable dml_proc shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name B}: B: blob
            | {insert_list}
              | {null}: null

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1(A, B) FROM VALUES(C0.A, C0.B);
  OUT C1;
END;

  {create_proc_stmt}: C1: fetch_to_cursor_from_cursor: { A: integer notnull, B: integer notnull } variable shape_storage uses_out value_cursor
  | {name fetch_to_cursor_from_cursor}: C1: fetch_to_cursor_from_cursor: { A: integer notnull, B: integer notnull } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_name}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {shape_def}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {like}: ok
      |     | {name C0}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {dot}: C0.A: integer notnull variable
      |       | | {name C0}
      |       | | {name A}
      |       | {insert_list}
      |         | {dot}: C0.B: integer notnull variable
      |           | {name C0}
      |           | {name B}
      | {out_stmt}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_invalid_cursor ()
BEGIN
  DECLARE C0 INTEGER;
  DECLARE C1 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  FETCH C1(A, B) FROM C0;
  OUT C1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'C0'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_invalid_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C0: integer variable
      | | | {name C0}: C0: integer variable
      | | {type_int}: integer
      | {declare_cursor_like_select}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: err
      | | {name_columns_values}
      |   | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}
      |     |   | {name_list}
      |     |     | {name B}
      |     | {from_shape}
      |       | {name C0}: err
      | {out_stmt}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_invalid_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 INTEGER;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'C1'

  {create_proc_stmt}: err
  | {name fetch_to_invalid_cursor_from_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_vars_type}: integer
      | | {name_list}: C1: integer variable
      | | | {name C1}: C1: integer variable
      | | {type_int}: integer
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C1}: err
          | {columns_values}
            | {from_shape}
              | {name C0}

The statement ending at line XXXX

CREATE PROC fetch_to_statement_cursor_from_cursor ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR FOR SELECT 1 AS A, 2 AS B;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1 FROM C0;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0165: fetch values is only for value cursors, not for sqlite cursors 'C1'

  {create_proc_stmt}: err
  | {name fetch_to_statement_cursor_from_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: C1: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable dml_proc
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C1}: C1: select: { A: integer notnull, B: integer notnull } variable dml_proc
          | {columns_values}
            | {from_shape}
              | {name C0}

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor_with_different_columns ()
BEGIN
  DECLARE C0 CURSOR LIKE SELECT 1 AS A, 2 AS B;
  DECLARE C1 CURSOR LIKE SELECT 1 AS A, 2 AS B, 3 AS C;
  FETCH C0(A, B) FROM VALUES(1, 2);
  FETCH C1(A, B, C) FROM C0(A, B);
END;

test/sem_test.sql:XXXX:1: error: in columns_values : CQL0299: [shape] has too few fields 'C0'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_cursor_with_different_columns}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name B}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_select}: C1: select: { A: integer notnull, B: integer notnull, C: integer notnull } variable shape_storage value_cursor
      | | {name C1}: C1: select: { A: integer notnull, B: integer notnull, C: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
      |   | | {select_core}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |   | | {int 2}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: integer notnull
      |   |     |       | {int 3}: integer notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C1}: C1: select: { A: integer notnull, B: integer notnull, C: integer notnull } variable shape_storage value_cursor
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name A}
            |   | {name_list}
            |     | {name B}
            |     | {name_list}
            |       | {name C}
            | {from_shape}: ok
              | {column_spec}
              | | {name_list}
              |   | {name A}
              |   | {name_list}
              |     | {name B}
              | {name C0}: C0: select: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC fetch_to_cursor_from_cursor_without_fields ()
BEGIN
  DECLARE X INTEGER;
  DECLARE Y REAL;
  DECLARE C0 CURSOR FOR SELECT 1 AS A, 2.5;
  DECLARE C1 CURSOR LIKE C0;
  FETCH C0 INTO X, Y;
  FETCH C1(A, _anon) FROM C0(A, _anon);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0298: cannot read from a cursor without fields 'C0'

  {create_proc_stmt}: err
  | {name fetch_to_cursor_from_cursor_without_fields}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: X: integer variable was_set
      | | | {name X}: X: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: real
      | | {name_list}: Y: real variable was_set
      | | | {name Y}: Y: real variable was_set
      | | {type_real}: real
      | {declare_cursor}: C0: select: { A: integer notnull, _anon: real notnull } variable dml_proc
      | | {name C0}: C0: select: { A: integer notnull, _anon: real notnull } variable dml_proc fetch_into
      | | {select_stmt}: select: { A: integer notnull, _anon: real notnull }
      |   | {select_core_list}: select: { A: integer notnull, _anon: real notnull }
      |   | | {select_core}: select: { A: integer notnull, _anon: real notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, _anon: real notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, _anon: real notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: real notnull
      |   |     |     | {dbl 2.5}: real notnull
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor_like_name}: C1: select: { A: integer notnull, _anon: real notnull } variable shape_storage value_cursor
      | | {name C1}: C1: select: { A: integer notnull, _anon: real notnull } variable shape_storage value_cursor
      | | {shape_def}: C0: select: { A: integer notnull, _anon: real notnull } variable dml_proc
      |   | {like}: ok
      |     | {name C0}
      | {fetch_stmt}: C0: select: { A: integer notnull, _anon: real notnull } variable dml_proc fetch_into
      | | {name C0}: C0: select: { A: integer notnull, _anon: real notnull } variable dml_proc
      | | {name_list}
      |   | {name X}: X: integer variable was_set
      |   | {name_list}
      |     | {name Y}: Y: real variable was_set
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C1}: C1: select: { A: integer notnull, _anon: real notnull } variable shape_storage value_cursor
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name A}
            |   | {name_list}
            |     | {name _anon}
            | {from_shape}: ok
              | {column_spec}
              | | {name_list}
              |   | {name A}
              |   | {name_list}
              |     | {name _anon}
              | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_cursor ()
BEGIN
  DECLARE C0 CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C1 CURSOR LIKE C0;
END;

  {create_proc_stmt}: ok dml_proc
  | {name declare_cursor_like_cursor}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C0: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C0}: C0: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {declare_cursor_like_name}: C1: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C1}: C1: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {shape_def}: C0: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
          | {like}: ok
            | {name C0}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_non_cursor_variable ()
BEGIN
  DECLARE C0 INTEGER;
  DECLARE C1 CURSOR LIKE C0;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0200: variable is not a cursor 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_non_cursor_variable}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: C0: integer variable
      | | | {name C0}: C0: integer variable
      | | {type_int}: integer
      | {declare_cursor_like_name}: err
        | {name C1}
        | {shape_def}: err
          | {like}: err
            | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_cursor_with_same_name ()
BEGIN
  DECLARE C0 CURSOR FETCH FROM CALL out_cursor_proc();
  DECLARE C0 CURSOR LIKE C0;
END;

test/sem_test.sql:XXXX:1: error: in declare_cursor_like_name : CQL0197: duplicate variable name in the same scope 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_cursor_with_same_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_value_cursor}: C0: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {name C0}: C0: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {declare_cursor_like_name}: err
        | {name C0}: err
        | {shape_def}
          | {like}
            | {name C0}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_undefined_variable ()
BEGIN
  DECLARE C1 CURSOR LIKE C0;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'C0'

  {create_proc_stmt}: err
  | {name declare_cursor_like_undefined_variable}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: err
        | {name C1}
        | {shape_def}: err
          | {like}: err
            | {name C0}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_proc ()
BEGIN
  DECLARE C CURSOR LIKE decl3;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_proc}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: decl3: { A: integer notnull, B: bool } variable shape_storage value_cursor
        | {name C}: C: decl3: { A: integer notnull, B: bool } variable shape_storage value_cursor
        | {shape_def}: decl3: { A: integer notnull, B: bool } dml_proc
          | {like}: ok
            | {name decl3}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_proc_with_no_result ()
BEGIN
  DECLARE C CURSOR LIKE decl1;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0178: proc has no result 'decl1'

  {create_proc_stmt}: err
  | {name declare_cursor_like_proc_with_no_result}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: err
        | {name C}
        | {shape_def}: err
          | {like}: err
            | {name decl1}: err

The statement ending at line XXXX

CREATE PROC declare_cursor_like_table ()
BEGIN
  DECLARE C CURSOR LIKE bar;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_table}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
        | {shape_def}: bar: { id: integer notnull, name: text, rate: longint }
          | {like}: ok
            | {name bar}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_view ()
BEGIN
  DECLARE C CURSOR LIKE MyView;
END;

  {create_proc_stmt}: ok
  | {name declare_cursor_like_view}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull } variable shape_storage value_cursor
        | {name C}: C: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull } variable shape_storage value_cursor
        | {shape_def}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
          | {like}: ok
            | {name MyView}

The statement ending at line XXXX

CREATE PROC declare_cursor_like_select ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS A, 2.5 AS B, 'x' AS C;
  FETCH C(A, B, C) FROM VALUES(_seed_, _seed_, printf('C_%d', _seed_)) @DUMMY_SEED(123);
  OUT C;
END;

  {create_proc_stmt}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage uses_out value_cursor
  | {name declare_cursor_like_select}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
      | | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   | {select_core_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   | | {select_core}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |     | {select_expr_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
      |   |     | | {select_expr}: A: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: real notnull
      |   |     |   | | {dbl 2.5}: real notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: text notnull
      |   |     |       | {strlit 'x'}: text notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {insert_dummy_spec}: integer notnull
      | | | {int 123}: integer notnull
      | | | {int 0}
      | | {name_columns_values}
      |   | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: real notnull
      |     |     | {name_list}
      |     |       | {name C}: C: text notnull
      |     | {insert_list}
      |       | {name _seed_}: _seed_: integer notnull variable
      |       | {insert_list}
      |         | {name _seed_}: _seed_: integer notnull variable
      |         | {insert_list}
      |           | {call}: text notnull
      |             | {name printf}: text notnull
      |             | {call_arg_list}
      |               | {call_filter_clause}
      |               | {arg_list}: ok
      |                 | {strlit 'C_%d'}: text notnull
      |                 | {arg_list}
      |                   | {name _seed_}: _seed_: integer notnull variable
      | {out_stmt}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
        | {name C}: C: select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor

The statement ending at line XXXX

DECLARE some_cursor CURSOR LIKE SELECT 1 AS A, 2.5 AS B, NOT 'x' AS C;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {declare_cursor_like_select}: err
  | {name some_cursor}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: A: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name A}
    |     | | {select_expr_list}
    |     |   | {select_expr}: B: real notnull
    |     |   | | {dbl 2.5}: real notnull
    |     |   | | {opt_as_alias}
    |     |   |   | {name B}
    |     |   | {select_expr_list}
    |     |     | {select_expr}: err
    |     |       | {not}: err
    |     |       | | {strlit 'x'}: text notnull
    |     |       | {opt_as_alias}
    |     |         | {name C}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE X CURSOR LIKE SELECT 1 AS A, 2.5 AS B, 'x' AS C;

test/sem_test.sql:XXXX:1: error: in declare_cursor_like_select : CQL0197: duplicate variable name in the same scope 'X'

  {declare_cursor_like_select}: err
  | {name X}: err
  | {select_stmt}: select: { A: integer notnull, B: real notnull, C: text notnull }
    | {select_core_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
    | | {select_core}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |   | {select_expr_list_con}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |     | {select_expr_list}: select: { A: integer notnull, B: real notnull, C: text notnull }
    |     | | {select_expr}: A: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name A}
    |     | | {select_expr_list}
    |     |   | {select_expr}: B: real notnull
    |     |   | | {dbl 2.5}: real notnull
    |     |   | | {opt_as_alias}
    |     |   |   | {name B}
    |     |   | {select_expr_list}
    |     |     | {select_expr}: C: text notnull
    |     |       | {strlit 'x'}: text notnull
    |     |       | {opt_as_alias}
    |     |         | {name C}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT rowid
  FROM foo;

  {select_stmt}: select: { rowid: longint notnull }
  | {select_core_list}: select: { rowid: longint notnull }
  | | {select_core}: select: { rowid: longint notnull }
  |   | {select_expr_list_con}: select: { rowid: longint notnull }
  |     | {select_expr_list}: select: { rowid: longint notnull }
  |     | | {select_expr}: rowid: longint notnull
  |     |   | {name rowid}: rowid: longint notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.rowid
  FROM foo AS T1,
bar AS T2;

  {select_stmt}: select: { rowid: longint notnull }
  | {select_core_list}: select: { rowid: longint notnull }
  | | {select_core}: select: { rowid: longint notnull }
  |   | {select_expr_list_con}: select: { rowid: longint notnull }
  |     | {select_expr_list}: select: { rowid: longint notnull }
  |     | | {select_expr}: rowid: longint notnull
  |     |   | {dot}: rowid: longint notnull
  |     |     | {name T1}
  |     |     | {name rowid}
  |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
  |       | {table_or_subquery_list}: JOIN { T1: foo, T2: bar }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: TABLE { T2: bar }
  |       |   | {table_or_subquery}: TABLE { T2: bar }
  |       |     | {name bar}: TABLE { T2: bar }
  |       |     | {opt_as_alias}
  |       |       | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.rowid
  FROM foo AS T2,
foo AS T3;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'T1.rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name T1}
  |     |     | {name rowid}
  |     | {select_from_etc}: JOIN { T2: foo, T3: foo }
  |       | {table_or_subquery_list}: JOIN { T2: foo, T3: foo }
  |       | | {table_or_subquery}: TABLE { T2: foo }
  |       | | | {name foo}: TABLE { T2: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T2}
  |       | | {table_or_subquery_list}: TABLE { T3: foo }
  |       |   | {table_or_subquery}: TABLE { T3: foo }
  |       |     | {name foo}: TABLE { T3: foo }
  |       |     | {opt_as_alias}
  |       |       | {name T3}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT rowid
  FROM foo AS T1,
foo AS T2;

test/sem_test.sql:XXXX:1: error: in str : CQL0066: identifier is ambiguous 'rowid'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {name rowid}: err
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {table_or_subquery_list}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {table_or_subquery_list}: TABLE { T2: foo }
  |       |   | {table_or_subquery}: TABLE { T2: foo }
  |       |     | {name foo}: TABLE { T2: foo }
  |       |     | {opt_as_alias}
  |       |       | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC value_result_reader ()
BEGIN
  DECLARE C CURSOR FETCH FROM CALL declare_cursor_like_select();
END;

  {create_proc_stmt}: ok
  | {name value_result_reader}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_value_cursor}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
        | {name C}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage value_cursor
        | {call_stmt}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage uses_out value_cursor
          | {name declare_cursor_like_select}: C: declare_cursor_like_select: { A: integer notnull, B: real notnull, C: text notnull } variable shape_storage uses_out value_cursor

The statement ending at line XXXX

@ATTRIBUTE(foo)
@ATTRIBUTE(goo)
@ATTRIBUTE(num=-9)
CREATE TABLE misc_attr_table(
  @ATTRIBUTE(bar=baz)
  id INTEGER NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {name foo}
  | | {misc_attrs}
  |   | {misc_attr}
  |   | | {name goo}
  |   | {misc_attrs}
  |     | {misc_attr}
  |       | {name num}
  |       | {uminus}: ok
  |         | {int 9}
  | {create_table_stmt}: misc_attr_table: { id: integer notnull }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name misc_attr_table}
    | {col_key_list}
      | {col_def}: id: integer notnull
        | {col_def_type_attrs}: ok
        | | {col_def_name_type}
        | | | {name id}
        | | | {type_int}: integer
        | | {col_attrs_not_null}: ok
        | {misc_attrs}
          | {misc_attr}
            | {name bar}
            | {name baz}

The statement ending at line XXXX

CREATE UNIQUE INDEX IF NOT EXISTS my_unique_index ON bar (id / 2 ASC, name DESC, rate);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name my_unique_index}
  | | {name bar}
  | {flags_names_attrs}
    | {int 3}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
          | | {div}: integer notnull
          | | | {name id}: id: integer notnull
          | | | {int 2}: integer notnull
          | | {asc}
          | {indexed_columns}
            | {indexed_column}
            | | {name name}: name: text
            | | {desc}
            | {indexed_columns}
              | {indexed_column}
                | {name rate}: rate: longint

The statement ending at line XXXX

CREATE TABLE ref_bar(
  id INTEGER NOT NULL REFERENCES bar (id)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'bar'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name ref_bar}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {col_attrs_fk}: err
            | {fk_target_options}
              | {fk_target}
              | | {name bar}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

UPDATE This_Table_Does_Not_Exist
SET x = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0154: table in update statement does not exist 'This_Table_Does_Not_Exist'

  {update_stmt}: err
  | {name This_Table_Does_Not_Exist}
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name x}
    |   | {int 1}
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

CREATE TABLE fk_on_col(
  fk_src INTEGER REFERENCES foo (id) ON UPDATE CASCADE ON DELETE SET NULL
);

  {create_table_stmt}: fk_on_col: { fk_src: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_on_col}
  | {col_key_list}
    | {col_def}: fk_src: integer foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 49}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (id, name) ON UPDATE CASCADE ON DELETE SET NULL
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0028: FK reference must be exactly one column with the correct type 'fk_src'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            | {int 49}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (name)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0028: FK reference must be exactly one column with the correct type 'fk_src'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}
            |   | {name name}: name: text
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES no_such_table (name)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0021: foreign key refers to non-existent table 'no_such_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name no_such_table}
            | | {name_list}
            |   | {name name}
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_fk_on_col_1(
  fk_src INTEGER REFERENCES bar (no_such_column)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'no_such_column'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_fk_on_col_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name fk_src}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name bar}
            | | {name_list}: err
            |   | {name no_such_column}: err
            | {int 0}

The statement ending at line XXXX

CREATE TABLE bogus_autoinc_type(
  id BOOL PRIMARY KEY AUTOINCREMENT
);

test/sem_test.sql:XXXX:1: error: in autoinc_and_conflict_clause : CQL0029: autoincrement column must be [LONG_]INTEGER PRIMARY KEY 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bogus_autoinc_type}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_bool}: bool
        | {col_attrs_pk}: err
          | {autoinc_and_conflict_clause}
            | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE bogus_without_rowid(
  id INTEGER PRIMARY KEY AUTOINCREMENT
) WITHOUT ROWID;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0141: table has an AUTOINCREMENT column; it cannot also be WITHOUT ROWID 'bogus_without_rowid'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name bogus_without_rowid}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
            | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE TABLE recreatable(
  id INTEGER PRIMARY KEY,
  name TEXT
) @RECREATE;

  {create_table_stmt}: recreatable: { id: integer notnull primary_key, name: text } @recreate
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE column_marked_delete_on_recreate_table(
  id INTEGER PRIMARY KEY @CREATE(2),
  name TEXT
) @RECREATE;

test/sem_test.sql:XXXX:1: error: in col_def : CQL0033: columns in a table marked @recreate cannot have @create or @delete 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name column_marked_delete_on_recreate_table}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | {create_attr}
    |       | {version_annotation}
    |         | {int 2}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE PROC cte_test ()
BEGIN
  WITH
  should_not_conflict (a, b) AS (SELECT 111, 222)
  SELECT *
    FROM should_not_conflict;
  WITH
  should_not_conflict (a, b) AS (SELECT 111, 222)
  SELECT *
    FROM should_not_conflict;
END;

  {create_proc_stmt}: cte_test: { a: integer notnull, b: integer notnull } dml_proc
  | {name cte_test}: cte_test: { a: integer notnull, b: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
      | | {with}
      | | | {cte_tables}: ok
      | |   | {cte_table}: should_not_conflict: { a: integer notnull, b: integer notnull }
      | |     | {cte_decl}: should_not_conflict: { a: integer notnull, b: integer notnull }
      | |     | | {name should_not_conflict}
      | |     | | {name_list}
      | |     |   | {name a}
      | |     |   | {name_list}
      | |     |     | {name b}
      | |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
      | |       |     | | {select_expr}: integer notnull
      | |       |     | | | {int 111}: integer notnull
      | |       |     | | {select_expr_list}
      | |       |     |   | {select_expr}: integer notnull
      | |       |     |     | {int 222}: integer notnull
      | |       |     | {select_from_etc}: ok
      | |       |       | {select_where}
      | |       |         | {select_groupby}
      | |       |           | {select_having}
      | |       | {select_orderby}
      | |         | {select_limit}
      | |           | {select_offset}
      | | {select_stmt}: select: { a: integer notnull, b: integer notnull }
      |   | {select_core_list}: select: { a: integer notnull, b: integer notnull }
      |   | | {select_core}: select: { a: integer notnull, b: integer notnull }
      |   |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
      |   |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
      |   |     | | {star}: select: { a: integer notnull, b: integer notnull }
      |   |     | {select_from_etc}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | {table_or_subquery_list}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | | {table_or_subquery}: TABLE { should_not_conflict: should_not_conflict }
      |   |       |   | {name should_not_conflict}: TABLE { should_not_conflict: should_not_conflict }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {with_select_stmt}: select: { a: integer notnull, b: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: should_not_conflict: { a: integer notnull, b: integer notnull }
        |     | {cte_decl}: should_not_conflict: { a: integer notnull, b: integer notnull }
        |     | | {name should_not_conflict}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 111}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: integer notnull
        |       |     |     | {int 222}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { a: integer notnull, b: integer notnull }
          | {select_core_list}: select: { a: integer notnull, b: integer notnull }
          | | {select_core}: select: { a: integer notnull, b: integer notnull }
          |   | {select_expr_list_con}: select: { a: integer notnull, b: integer notnull }
          |     | {select_expr_list}: select: { a: integer notnull, b: integer notnull }
          |     | | {star}: select: { a: integer notnull, b: integer notnull }
          |     | {select_from_etc}: TABLE { should_not_conflict: should_not_conflict }
          |       | {table_or_subquery_list}: TABLE { should_not_conflict: should_not_conflict }
          |       | | {table_or_subquery}: TABLE { should_not_conflict: should_not_conflict }
          |       |   | {name should_not_conflict}: TABLE { should_not_conflict: should_not_conflict }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_form ()
BEGIN
  WITH
  x (a, b, c) AS (SELECT 12, 'foo', 35L)
  INSERT INTO bar(id, name, rate) VALUES(ifnull(( SELECT a
    FROM x ), 0), ifnull(( SELECT b
    FROM x ), 'foo'), ifnull(( SELECT 1L AS c
    WHERE 0 ), 0));
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_insert_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_insert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | {cte_decl}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     |     | {name_list}
        |     |       | {name c}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 12}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: text notnull
        |       |     |   | | {strlit 'foo'}: text notnull
        |       |     |   | {select_expr_list}
        |       |     |     | {select_expr}: longint notnull
        |       |     |       | {longint 35}: longint notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: ok
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}: id: integer notnull
              |   | {name_list}
              |     | {name name}: name: text
              |     | {name_list}
              |       | {name rate}: rate: longint
              | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |   | {select_values}
                |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |     | {insert_list}: ok
                |       | {call}: integer notnull
                |       | | {name ifnull}
                |       | | {call_arg_list}
                |       |   | {call_filter_clause}
                |       |   | {arg_list}: ok
                |       |     | {select_stmt}: a: integer
                |       |     | | {select_core_list}: select: { a: integer notnull }
                |       |     | | | {select_core}: select: { a: integer notnull }
                |       |     | |   | {select_expr_list_con}: select: { a: integer notnull }
                |       |     | |     | {select_expr_list}: select: { a: integer notnull }
                |       |     | |     | | {select_expr}: a: integer notnull
                |       |     | |     |   | {name a}: a: integer notnull
                |       |     | |     | {select_from_etc}: TABLE { x: x }
                |       |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |       |     | |       | | {table_or_subquery}: TABLE { x: x }
                |       |     | |       |   | {name x}: TABLE { x: x }
                |       |     | |       | {select_where}
                |       |     | |         | {select_groupby}
                |       |     | |           | {select_having}
                |       |     | | {select_orderby}
                |       |     |   | {select_limit}
                |       |     |     | {select_offset}
                |       |     | {arg_list}
                |       |       | {int 0}: integer notnull
                |       | {insert_list}
                |         | {call}: text notnull
                |         | | {name ifnull}
                |         | | {call_arg_list}
                |         |   | {call_filter_clause}
                |         |   | {arg_list}: ok
                |         |     | {select_stmt}: b: text
                |         |     | | {select_core_list}: select: { b: text notnull }
                |         |     | | | {select_core}: select: { b: text notnull }
                |         |     | |   | {select_expr_list_con}: select: { b: text notnull }
                |         |     | |     | {select_expr_list}: select: { b: text notnull }
                |         |     | |     | | {select_expr}: b: text notnull
                |         |     | |     |   | {name b}: b: text notnull
                |         |     | |     | {select_from_etc}: TABLE { x: x }
                |         |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |         |     | |       | | {table_or_subquery}: TABLE { x: x }
                |         |     | |       |   | {name x}: TABLE { x: x }
                |         |     | |       | {select_where}
                |         |     | |         | {select_groupby}
                |         |     | |           | {select_having}
                |         |     | | {select_orderby}
                |         |     |   | {select_limit}
                |         |     |     | {select_offset}
                |         |     | {arg_list}
                |         |       | {strlit 'foo'}: text notnull
                |         | {insert_list}
                |           | {call}: longint notnull
                |             | {name ifnull}
                |             | {call_arg_list}
                |               | {call_filter_clause}
                |               | {arg_list}: ok
                |                 | {select_stmt}: c: longint
                |                 | | {select_core_list}: select: { c: longint notnull }
                |                 | | | {select_core}: select: { c: longint notnull }
                |                 | |   | {select_expr_list_con}: select: { c: longint notnull }
                |                 | |     | {select_expr_list}: select: { c: longint notnull }
                |                 | |     | | {select_expr}: c: longint notnull
                |                 | |     |   | {longint 1}: longint notnull
                |                 | |     |   | {opt_as_alias}
                |                 | |     |     | {name c}
                |                 | |     | {select_from_etc}: ok
                |                 | |       | {select_where}
                |                 | |         | {opt_where}: integer notnull
                |                 | |         | | {int 0}: integer notnull
                |                 | |         | {select_groupby}
                |                 | |           | {select_having}
                |                 | | {select_orderby}
                |                 |   | {select_limit}
                |                 |     | {select_offset}
                |                 | {arg_list}
                |                   | {int 0}: integer notnull
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_column_spec_form ()
BEGIN
  WITH
  x (a, b, c) AS (SELECT 12, 'foo', 35L)
  INSERT INTO bar(id, name, rate) VALUES(ifnull(( SELECT a
    FROM x ), 0), ifnull(( SELECT b
    FROM x ), 'foo'), ifnull(( SELECT 1L AS c
    WHERE 0 ), 0));
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_column_spec_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_insert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | {cte_decl}: x: { a: integer notnull, b: text notnull, c: longint notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     |   | {name_list}
        |     |     | {name b}
        |     |     | {name_list}
        |     |       | {name c}
        |     | {select_stmt}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | {select_core_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       | | {select_core}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text notnull, _anon: longint notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     | | | {int 12}: integer notnull
        |       |     | | {select_expr_list}
        |       |     |   | {select_expr}: text notnull
        |       |     |   | | {strlit 'foo'}: text notnull
        |       |     |   | {select_expr_list}
        |       |     |     | {select_expr}: longint notnull
        |       |     |       | {longint 35}: longint notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: ok
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}: id: integer notnull
              |   | {name_list}
              |     | {name name}: name: text
              |     | {name_list}
              |       | {name rate}: rate: longint
              | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |   | {select_values}
                |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                |     | {insert_list}: ok
                |       | {call}: integer notnull
                |       | | {name ifnull}
                |       | | {call_arg_list}
                |       |   | {call_filter_clause}
                |       |   | {arg_list}: ok
                |       |     | {select_stmt}: a: integer
                |       |     | | {select_core_list}: select: { a: integer notnull }
                |       |     | | | {select_core}: select: { a: integer notnull }
                |       |     | |   | {select_expr_list_con}: select: { a: integer notnull }
                |       |     | |     | {select_expr_list}: select: { a: integer notnull }
                |       |     | |     | | {select_expr}: a: integer notnull
                |       |     | |     |   | {name a}: a: integer notnull
                |       |     | |     | {select_from_etc}: TABLE { x: x }
                |       |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |       |     | |       | | {table_or_subquery}: TABLE { x: x }
                |       |     | |       |   | {name x}: TABLE { x: x }
                |       |     | |       | {select_where}
                |       |     | |         | {select_groupby}
                |       |     | |           | {select_having}
                |       |     | | {select_orderby}
                |       |     |   | {select_limit}
                |       |     |     | {select_offset}
                |       |     | {arg_list}
                |       |       | {int 0}: integer notnull
                |       | {insert_list}
                |         | {call}: text notnull
                |         | | {name ifnull}
                |         | | {call_arg_list}
                |         |   | {call_filter_clause}
                |         |   | {arg_list}: ok
                |         |     | {select_stmt}: b: text
                |         |     | | {select_core_list}: select: { b: text notnull }
                |         |     | | | {select_core}: select: { b: text notnull }
                |         |     | |   | {select_expr_list_con}: select: { b: text notnull }
                |         |     | |     | {select_expr_list}: select: { b: text notnull }
                |         |     | |     | | {select_expr}: b: text notnull
                |         |     | |     |   | {name b}: b: text notnull
                |         |     | |     | {select_from_etc}: TABLE { x: x }
                |         |     | |       | {table_or_subquery_list}: TABLE { x: x }
                |         |     | |       | | {table_or_subquery}: TABLE { x: x }
                |         |     | |       |   | {name x}: TABLE { x: x }
                |         |     | |       | {select_where}
                |         |     | |         | {select_groupby}
                |         |     | |           | {select_having}
                |         |     | | {select_orderby}
                |         |     |   | {select_limit}
                |         |     |     | {select_offset}
                |         |     | {arg_list}
                |         |       | {strlit 'foo'}: text notnull
                |         | {insert_list}
                |           | {call}: longint notnull
                |             | {name ifnull}
                |             | {call_arg_list}
                |               | {call_filter_clause}
                |               | {arg_list}: ok
                |                 | {select_stmt}: c: longint
                |                 | | {select_core_list}: select: { c: longint notnull }
                |                 | | | {select_core}: select: { c: longint notnull }
                |                 | |   | {select_expr_list_con}: select: { c: longint notnull }
                |                 | |     | {select_expr_list}: select: { c: longint notnull }
                |                 | |     | | {select_expr}: c: longint notnull
                |                 | |     |   | {longint 1}: longint notnull
                |                 | |     |   | {opt_as_alias}
                |                 | |     |     | {name c}
                |                 | |     | {select_from_etc}: ok
                |                 | |       | {select_where}
                |                 | |         | {opt_where}: integer notnull
                |                 | |         | | {int 0}: integer notnull
                |                 | |         | {select_groupby}
                |                 | |           | {select_having}
                |                 | | {select_orderby}
                |                 |   | {select_limit}
                |                 |     | {select_offset}
                |                 | {arg_list}
                |                   | {int 0}: integer notnull
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_bogus_cte ()
BEGIN
  WITH
  x (a) AS (SELECT NOT 'x')
  INSERT INTO bar(id, name, rate) VALUES(1, 'x', 2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_insert_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_insert_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}: err
        |       |   | {select_expr_list_con}: err
        |       |     | {select_expr_list}: err
        |       |     | | {select_expr}: err
        |       |     |   | {not}: err
        |       |     |     | {strlit 'x'}: text notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}
          | {insert_normal}
          | {name_columns_values}
            | {name bar}
            | {columns_values}
              | {column_spec}
              | | {name_list}
              |   | {name id}
              |   | {name_list}
              |     | {name name}
              |     | {name_list}
              |       | {name rate}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_values}
                |   | {values}
                |     | {insert_list}
                |       | {int 1}
                |       | {insert_list}
                |         | {strlit 'x'}
                |         | {insert_list}
                |           | {int 2}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_insert_bogus_insert ()
BEGIN
  WITH
  x (a) AS (SELECT 1)
  INSERT INTO bar(id, name, rate) VALUES(1, NOT 'x', 1);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_insert_bogus_insert}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_insert_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { a: integer notnull }
        |     | {cte_decl}: x: { a: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name a}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {insert_stmt}: err
          | {insert_normal}
          | {name_columns_values}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {columns_values}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}
              |   | {name_list}
              |     | {name name}
              |     | {name_list}
              |       | {name rate}
              | {select_stmt}: err
                | {select_core_list}: err
                | | {select_core}: err
                |   | {select_values}
                |   | {values}: err
                |     | {insert_list}: ok
                |       | {int 1}: integer notnull
                |       | {insert_list}
                |         | {not}: err
                |         | | {strlit 'x'}: text notnull
                |         | {insert_list}
                |           | {int 1}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT *
  FROM bar
  WHERE id > 5;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {gt}: bool notnull
        |         |   | {name id}: id: integer notnull
        |         |   | {int 5}: integer notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT id
  FROM bar;

test/sem_test.sql:XXXX:1: error: in insert_stmt : CQL0157: count of columns differs from count of values

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { id: integer notnull }
        | {select_core_list}: select: { id: integer notnull }
        | | {select_core}: select: { id: integer notnull }
        |   | {select_expr_list_con}: select: { id: integer notnull }
        |     | {select_expr_list}: select: { id: integer notnull }
        |     | | {select_expr}: id: integer notnull
        |     |   | {name id}: id: integer notnull
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT name, id, rate
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: err
      |   | {name_list}
      |     | {name name}: name: text
      |     | {name_list}
      |       | {name rate}: rate: longint
      | {select_stmt}: select: { name: text, id: integer notnull, rate: longint }
        | {select_core_list}: select: { name: text, id: integer notnull, rate: longint }
        | | {select_core}: select: { name: text, id: integer notnull, rate: longint }
        |   | {select_expr_list_con}: select: { name: text, id: integer notnull, rate: longint }
        |     | {select_expr_list}: select: { name: text, id: integer notnull, rate: longint }
        |     | | {select_expr}: name: text
        |     | | | {name name}: name: text
        |     | | {select_expr_list}
        |     |   | {select_expr}: id: integer notnull
        |     |   | | {name id}: id: integer notnull
        |     |   | {select_expr_list}
        |     |     | {select_expr}: rate: longint
        |     |       | {name rate}: rate: longint
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name, rate) SELECT NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      |   | {name_list}
      |     | {name name}
      |     | {name_list}
      |       | {name rate}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {not}: err
        |     |     | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC SqlUserFunc (id INTEGER) REAL NOT NULL;

  {declare_select_func_stmt}: real notnull select_func
  | {name SqlUserFunc}: real notnull
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {notnull}: real notnull
      | {type_real}: real

The statement ending at line XXXX

SELECT SqlUserFunc(1);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SqlUserFunc(DISTINCT id)
  FROM foo;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SqlUserFunc(DISTINCT id) FILTER (WHERE 1)
  FROM foo;

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name SqlUserFunc}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | | {distinct}
  |     |       | | {opt_filter_clause}: integer notnull
  |     |       |   | {opt_where}: integer notnull
  |     |       |     | {int 1}: integer notnull
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET my_real := SqlUserFunc(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0089: user function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable was_set
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}

The statement ending at line XXXX

SET my_real := SqlUserFunc(DISTINCT 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0089: user function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable was_set
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | | {distinct}
      | {arg_list}: ok
        | {int 1}

The statement ending at line XXXX

SET my_real := SqlUserFunc(1) FILTER (WHERE 0);

test/sem_test.sql:XXXX:1: error: in call : CQL0089: user function may only appear in the context of a SQL statement 'SqlUserFunc'

  {assign}: err
  | {name my_real}: my_real: real variable was_set
  | {call}: err
    | {name SqlUserFunc}
    | {call_arg_list}
      | {call_filter_clause}
      | | {opt_filter_clause}: integer notnull
      |   | {opt_where}: integer notnull
      |     | {int 0}: integer notnull
      | {arg_list}: ok
        | {int 1}

The statement ending at line XXXX

DECLARE SELECT FUNC foo (x INTEGER, x INTEGER) INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0192: func name conflicts with proc name 'foo'

  {declare_select_func_stmt}: err
  | {name foo}
  | {func_params_return}
    | {params}
    | | {param}
    | | | {param_detail}
    | |   | {name x}
    | |   | {type_int}
    | | {params}
    |   | {param}
    |     | {param_detail}
    |       | {name x}
    |       | {type_int}
    | {type_int}

The statement ending at line XXXX

CREATE PROC arg_fetcher (arg1 TEXT NOT NULL, arg2 INTEGER NOT NULL, arg3 REAL NOT NULL)
BEGIN
  DECLARE curs CURSOR LIKE SELECT 'x' AS A, 1 AS B, 3.5 AS C;
  FETCH curs(A, B, C) FROM VALUES(arg1, arg2, arg3);
END;

  {create_proc_stmt}: ok
  | {name arg_fetcher}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: text notnull variable in
    | | | {param_detail}: arg1: text notnull variable in
    | |   | {name arg1}: arg1: text notnull variable in
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: arg2: integer notnull variable in
    |   | | {param_detail}: arg2: integer notnull variable in
    |   |   | {name arg2}: arg2: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: arg3: real notnull variable in
    |       | {param_detail}: arg3: real notnull variable in
    |         | {name arg3}: arg3: real notnull variable in
    |         | {notnull}: real notnull
    |           | {type_real}: real
    | {stmt_list}: ok
      | {declare_cursor_like_select}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
      | | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | {select_core_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | | {select_core}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |   | {select_expr_list_con}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | {select_expr_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | | {select_expr}: A: text notnull
      |   |     | | | {strlit 'x'}: text notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: real notnull
      |   |     |       | {dbl 3.5}: real notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name A}: A: text notnull
            |   | {name_list}
            |     | {name B}: B: integer notnull
            |     | {name_list}
            |       | {name C}: C: real notnull
            | {insert_list}: ok
              | {dot}: arg1: text notnull variable in
              | | {name ARGUMENTS}
              | | {name arg1}
              | {insert_list}
                | {dot}: arg2: integer notnull variable in
                | | {name ARGUMENTS}
                | | {name arg2}
                | {insert_list}
                  | {dot}: arg3: real notnull variable in
                    | {name ARGUMENTS}
                    | {name arg3}

The statement ending at line XXXX

CREATE PROC fetch_bar (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  DECLARE curs CURSOR LIKE bar;
  FETCH curs(id, name, rate) FROM VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok
  | {name fetch_bar}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {declare_cursor_like_name}: curs: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {name curs}: curs: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {shape_def}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {like}: ok
      |     | {name bar}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name curs}: curs: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}: ok
              | {dot}: id_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: name_: text variable in
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate_: longint variable in
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC qualified_like (x_id INTEGER NOT NULL, x_name TEXT, x_rate LONG_INT, y_id INTEGER NOT NULL, y_name TEXT, y_rate LONG_INT)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name qualified_like}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_id: integer notnull variable in
      | | {param_detail}: x_id: integer notnull variable in
      |   | {name x_id}: x_id: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: x_name: text variable in
        | | {param_detail}: x_name: text variable in
        |   | {name x_name}: x_name: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: x_rate: longint variable in
          | | {param_detail}: x_rate: longint variable in
          |   | {name x_rate}: x_rate: longint variable in
          |   | {type_long}: longint
          | {params}
            | {param}: y_id: integer notnull variable in
            | | {param_detail}: y_id: integer notnull variable in
            |   | {name y_id}: y_id: integer notnull variable in
            |   | {notnull}: integer notnull
            |     | {type_int}: integer
            | {params}
              | {param}: y_name: text variable in
              | | {param_detail}: y_name: text variable in
              |   | {name y_name}: y_name: text variable in
              |   | {type_text}: text
              | {params}
                | {param}: y_rate: longint variable in
                  | {param_detail}: y_rate: longint variable in
                    | {name y_rate}: y_rate: longint variable in
                    | {type_long}: longint

The statement ending at line XXXX

CREATE PROC insert_bar (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_bar}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: name_: text variable in
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate_: longint variable in
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC insert_bar_explicit (extra INTEGER, id INTEGER NOT NULL, name_ TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id, name_, rate);
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_bar_explicit}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id: integer notnull variable in
    |   | | {param_detail}: id: integer notnull variable in
    |   |   | {name id}: id: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate: longint variable in
    |         | {param_detail}: rate: longint variable in
    |           | {name rate}: rate: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: name_: text variable in
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate: longint variable in
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC insert_bar_locals (extra INTEGER, id INTEGER NOT NULL, name_ TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(LOCALS.id, LOCALS.name, LOCALS.rate);
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_bar_locals}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id: integer notnull variable in
    |   | | {param_detail}: id: integer notnull variable in
    |   |   | {name id}: id: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate: longint variable in
    |         | {param_detail}: rate: longint variable in
    |           | {name rate}: rate: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id: integer notnull variable in
              | | {name LOCALS}
              | | {name id}
              | {insert_list}
                | {dot}: name_: text variable in
                | | {name LOCALS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate: longint variable in
                    | {name LOCALS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC insert_bar_missing (extra INTEGER, id INTEGER NOT NULL)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id, ARGUMENTS.name, ARGUMENTS.rate);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0201: expanding FROM ARGUMENTS, there is no argument matching 'name'

  {create_proc_stmt}: err
  | {name insert_bar_missing}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id: integer notnull variable in
    |     | {param_detail}: id: integer notnull variable in
    |       | {name id}: id: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: err
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC insert_bar_from_bogus (extra INTEGER, id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) FROM ARGUMENTS(LIKE bogus_name_here);
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'bogus_name_here'

  {create_proc_stmt}: err
  | {name insert_bar_from_bogus}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: extra: integer variable in
    | | | {param_detail}: extra: integer variable in
    | |   | {name extra}: extra: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: id_: integer notnull variable in
    |   | | {param_detail}: id_: integer notnull variable in
    |   |   | {name id_}: id_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: name_: text variable in
    |     | | {param_detail}: name_: text variable in
    |     |   | {name name_}: name_: text variable in
    |     |   | {type_text}: text
    |     | {params}
    |       | {param}: rate_: longint variable in
    |         | {param_detail}: rate_: longint variable in
    |           | {name rate_}: rate_: longint variable in
    |           | {type_long}: longint
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}
            |   | {name_list}
            |     | {name name}
            |     | {name_list}
            |       | {name rate}
            | {from_shape}: err
              | {column_spec}
              | | {shape_def}: err
              |   | {like}: err
              |     | {name bogus_name_here}: err
              | {name ARGUMENTS}: ARGUMENTS: ARGUMENTS: { extra: integer variable in, id: integer notnull variable in, name: text variable in, rate: longint variable in } shape_storage

The statement ending at line XXXX

DECLARE val_cursor CURSOR LIKE my_cursor;

  {declare_cursor_like_name}: val_cursor: select: { one: integer notnull, two: integer notnull } variable shape_storage value_cursor
  | {name val_cursor}: val_cursor: select: { one: integer notnull, two: integer notnull } variable shape_storage value_cursor
  | {shape_def}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
    | {like}: ok
      | {name my_cursor}

The statement ending at line XXXX

FETCH val_cursor(one, two) FROM ARGUMENTS;

test/sem_test.sql:XXXX:1: error: in str : CQL0163: FROM ARGUMENTS construct is only valid inside a procedure

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name val_cursor}: val_cursor: select: { one: integer notnull, two: integer notnull } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name one}
      |   | {name_list}
      |     | {name two}
      | {from_shape}
        | {name ARGUMENTS}: err

The statement ending at line XXXX

CREATE PROC arg_fetcher_not_enough_args (arg1 TEXT NOT NULL)
BEGIN
  DECLARE curs CURSOR LIKE SELECT 'x' AS A, 1 AS B, 3.5 AS C;
  FETCH curs(A, B, C) FROM ARGUMENTS(arg1);
END;

test/sem_test.sql:XXXX:1: error: in columns_values : CQL0299: [shape] has too few fields 'ARGUMENTS'

  {create_proc_stmt}: err
  | {name arg_fetcher_not_enough_args}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: arg1: text notnull variable in
    |   | {param_detail}: arg1: text notnull variable in
    |     | {name arg1}: arg1: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: err
      | {declare_cursor_like_select}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
      | | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | {select_core_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   | | {select_core}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |   | {select_expr_list_con}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | {select_expr_list}: select: { A: text notnull, B: integer notnull, C: real notnull }
      |   |     | | {select_expr}: A: text notnull
      |   |     | | | {strlit 'x'}: text notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name A}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: B: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name B}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: C: real notnull
      |   |     |       | {dbl 3.5}: real notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name C}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name curs}: curs: select: { A: text notnull, B: integer notnull, C: real notnull } variable shape_storage value_cursor
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name A}
            |   | {name_list}
            |     | {name B}
            |     | {name_list}
            |       | {name C}
            | {from_shape}: ok
              | {column_spec}
              | | {name_list}
              |   | {name arg1}
              | {name ARGUMENTS}: ARGUMENTS: ARGUMENTS: { arg1: text notnull variable in } shape_storage

The statement ending at line XXXX

CREATE PROC bar_auto_inserter (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id, name, rate);
END;

  {create_proc_stmt}: ok dml_proc
  | {name bar_auto_inserter}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: name: text variable in
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate: longint variable in
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_mininal (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar(id) VALUES(id);
END;

  {create_proc_stmt}: ok dml_proc
  | {name bar_auto_inserter_mininal}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {insert_list}
              | {dot}: id: integer notnull variable in
                | {name ARGUMENTS}
                | {name id}

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_no_columns (id INTEGER NOT NULL, name TEXT, rate LONG_INT)
BEGIN
  INSERT INTO bar() FROM ARGUMENTS @DUMMY_SEED(1);
END;

test/sem_test.sql:XXXX:1: error: in from_shape : CQL0297: FROM [shape] is redundant if column list is empty

  {create_proc_stmt}: err
  | {name bar_auto_inserter_no_columns}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer notnull variable in
    | | | {param_detail}: id: integer notnull variable in
    | |   | {name id}: id: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name: text variable in
    |   | | {param_detail}: name: text variable in
    |   |   | {name name}: name: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate: longint variable in
    |       | {param_detail}: rate: longint variable in
    |         | {name rate}: rate: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | | {insert_dummy_spec}
        |   | {int 1}
        |   | {int 0}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | {from_shape}
              | {name ARGUMENTS}

The statement ending at line XXXX

CREATE PROC bar_auto_inserter_missing_columns (id INTEGER)
BEGIN
  INSERT INTO bar(id, name, rate) FROM ARGUMENTS(id);
END;

test/sem_test.sql:XXXX:1: error: in columns_values : CQL0299: [shape] has too few fields 'ARGUMENTS'

  {create_proc_stmt}: err
  | {name bar_auto_inserter_missing_columns}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: err
            | {column_spec}
            | | {name_list}
            |   | {name id}
            |   | {name_list}
            |     | {name name}
            |     | {name_list}
            |       | {name rate}
            | {from_shape}: ok
              | {column_spec}
              | | {name_list}
              |   | {name id}
              | {name ARGUMENTS}: ARGUMENTS: ARGUMENTS: { id: integer variable in } shape_storage

The statement ending at line XXXX

CREATE PROC rewritten_like_args (id_ INTEGER NOT NULL, name_ TEXT, rate_ LONG_INT)
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(id_, name_, rate_);
END;

  {create_proc_stmt}: ok dml_proc
  | {name rewritten_like_args}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id_: integer notnull variable in
    | | | {param_detail}: id_: integer notnull variable in
    | |   | {name id_}: id_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: name_: text variable in
    |   | | {param_detail}: name_: text variable in
    |   |   | {name name_}: name_: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: rate_: longint variable in
    |       | {param_detail}: rate_: longint variable in
    |         | {name rate_}: rate_: longint variable in
    |         | {type_long}: longint
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {dot}: id_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name id}
              | {insert_list}
                | {dot}: name_: text variable in
                | | {name ARGUMENTS}
                | | {name name}
                | {insert_list}
                  | {dot}: rate_: longint variable in
                    | {name ARGUMENTS}
                    | {name rate}

The statement ending at line XXXX

CREATE PROC rewrite_args_fails (LIKE garbonzo)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'garbonzo'

  {create_proc_stmt}: err
  | {name rewrite_args_fails}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {shape_def}: err
    |       | {like}: err
    |         | {name garbonzo}: err
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name x}
        | {type_int}

The statement ending at line XXXX

CREATE TABLE args1(
  id INTEGER PRIMARY KEY,
  name TEXT,
  data BLOB
);

  {create_table_stmt}: args1: { id: integer notnull primary_key, name: text, data: blob }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name args1}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: data: blob
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name data}
              | {type_blob}: blob

The statement ending at line XXXX

CREATE TABLE args2(
  id INTEGER REFERENCES args1 (id),
  name2 TEXT,
  rate REAL
);

  {create_table_stmt}: args2: { id: integer foreign_key, name2: text, rate: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name args2}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_fk}: ok
    |     | {fk_target_options}
    |       | {fk_target}
    |       | | {name args1}
    |       | | {name_list}
    |       |   | {name id}: id: integer notnull
    |       | {int 0}
    | {col_key_list}
      | {col_def}: name2: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: real
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name rate}
              | {type_real}: real

The statement ending at line XXXX

CREATE PROC two_arg_sources (id_ INTEGER NOT NULL, name_ TEXT, data_ BLOB, name2_ TEXT, rate_ REAL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name two_arg_sources}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id_: integer notnull variable in
      | | {param_detail}: id_: integer notnull variable in
      |   | {name id_}: id_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: name_: text variable in
        | | {param_detail}: name_: text variable in
        |   | {name name_}: name_: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: data_: blob variable in
          | | {param_detail}: data_: blob variable in
          |   | {name data_}: data_: blob variable in
          |   | {type_blob}: blob
          | {params}
            | {param}: name2_: text variable in
            | | {param_detail}: name2_: text variable in
            |   | {name name2_}: name2_: text variable in
            |   | {type_text}: text
            | {params}
              | {param}: rate_: real variable in
                | {param_detail}: rate_: real variable in
                  | {name rate_}: rate_: real variable in
                  | {type_real}: real

The statement ending at line XXXX

CREATE PROC two_arg_sources_fully_redundant (id_ INTEGER NOT NULL, name_ TEXT, data_ BLOB)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name two_arg_sources_fully_redundant}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id_: integer notnull variable in
      | | {param_detail}: id_: integer notnull variable in
      |   | {name id_}: id_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: name_: text variable in
        | | {param_detail}: name_: text variable in
        |   | {name name_}: name_: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: data_: blob variable in
            | {param_detail}: data_: blob variable in
              | {name data_}: data_: blob variable in
              | {type_blob}: blob

The statement ending at line XXXX

CREATE VIEW ViewShape AS
SELECT TRUE AS a, 2.5 AS b, 'xyz' AS c;

  {create_view_stmt}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name ViewShape}
      | {select_stmt}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        | {select_core_list}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        | | {select_core}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |   | {select_expr_list_con}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_expr_list}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
        |     | | {select_expr}: a: bool notnull
        |     | | | {bool 1}: bool notnull
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: real notnull
        |     |   | | {dbl 2.5}: real notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: text notnull
        |     |       | {strlit 'xyz'}: text notnull
        |     |       | {opt_as_alias}
        |     |         | {name c}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC like_a_view (a_ BOOL NOT NULL, b_ REAL NOT NULL, c_ TEXT NOT NULL)
BEGIN
  SELECT *
    FROM ViewShape AS v
    WHERE v.a = a_ AND v.b = b_ AND v.c > c_;
END;

  {create_proc_stmt}: like_a_view: { a: bool notnull, b: real notnull, c: text notnull } dml_proc
  | {name like_a_view}: like_a_view: { a: bool notnull, b: real notnull, c: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_: bool notnull variable in
    | | | {param_detail}: a_: bool notnull variable in
    | |   | {name a_}: a_: bool notnull variable in
    | |   | {notnull}: bool notnull
    | |     | {type_bool}: bool
    | | {params}
    |   | {param}: b_: real notnull variable in
    |   | | {param_detail}: b_: real notnull variable in
    |   |   | {name b_}: b_: real notnull variable in
    |   |   | {notnull}: real notnull
    |   |     | {type_real}: real
    |   | {params}
    |     | {param}: c_: text notnull variable in
    |       | {param_detail}: c_: text notnull variable in
    |         | {name c_}: c_: text notnull variable in
    |         | {notnull}: text notnull
    |           | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { a: bool notnull, b: real notnull, c: text notnull }
        | {select_core_list}: select: { a: bool notnull, b: real notnull, c: text notnull }
        | | {select_core}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |   | {select_expr_list_con}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_expr_list}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | | {star}: select: { a: bool notnull, b: real notnull, c: text notnull }
        |     | {select_from_etc}: TABLE { v: ViewShape }
        |       | {table_or_subquery_list}: TABLE { v: ViewShape }
        |       | | {table_or_subquery}: TABLE { v: ViewShape }
        |       |   | {name ViewShape}: TABLE { v: ViewShape }
        |       |   | {opt_as_alias}
        |       |     | {name v}
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {and}: bool notnull
        |         |   | {and}: bool notnull
        |         |   | | {eq}: bool notnull
        |         |   | | | {dot}: a: bool notnull
        |         |   | | | | {name v}
        |         |   | | | | {name a}
        |         |   | | | {name a_}: a_: bool notnull variable in
        |         |   | | {eq}: bool notnull
        |         |   |   | {dot}: b: real notnull
        |         |   |   | | {name v}
        |         |   |   | | {name b}
        |         |   |   | {name b_}: b_: real notnull variable in
        |         |   | {gt}: bool notnull
        |         |     | {dot}: c: text notnull
        |         |     | | {name v}
        |         |     | | {name c}
        |         |     | {name c_}: c_: text notnull variable in
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC bogus_cursor_shape ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1, 2;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0055: all columns in the select must have a name

  {create_proc_stmt}: err
  | {name bogus_cursor_shape}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_select}: err
        | {name C}
        | {select_stmt}: err
          | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: integer notnull
          |     |     | {int 2}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE VIEW MyBogusView AS
SELECT 1, 2;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0055: all columns in the select must have a name

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyBogusView}
      | {select_stmt}: err
        | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | {select_expr_list}
        |     |   | {select_expr}: integer notnull
        |     |     | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC like_other_proc (A_ INTEGER NOT NULL, B_ INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C(A, B) FROM VALUES(A_, B_);
  OUT C;
END;

  {create_proc_stmt}: C: like_other_proc: { A: integer notnull, B: integer notnull } variable shape_storage uses_out value_cursor
  | {name like_other_proc}: C: like_other_proc: { A: integer notnull, B: integer notnull } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: A_: integer notnull variable in
    | | | {param_detail}: A_: integer notnull variable in
    | |   | {name A_}: A_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: B_: integer notnull variable in
    |     | {param_detail}: B_: integer notnull variable in
    |       | {name B_}: B_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {shape_def}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {like}: ok
      |     | {name out_cursor_proc}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name A}: A: integer notnull
      |     |   | {name_list}
      |     |     | {name B}: B: integer notnull
      |     | {insert_list}: ok
      |       | {dot}: A_: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name A}
      |       | {insert_list}
      |         | {dot}: B_: integer notnull variable in
      |           | {name ARGUMENTS}
      |           | {name B}
      | {out_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC bogus_like_proc (LIKE proc1)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0178: proc has no result 'proc1'

  {create_proc_stmt}: err
  | {name bogus_like_proc}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {shape_def}: err
    |       | {like}: err
    |         | {name proc1}: err
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name x}
        | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE nontemp_table_like_table(
  id INTEGER NOT NULL
);

  {create_table_stmt}: nontemp_table_like_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name nontemp_table_like_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_table(
  id INTEGER NOT NULL
);

  {create_table_stmt}: table_like_table: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_table}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_view(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

  {create_table_stmt}: table_like_view: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_view}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name f3}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP TABLE table_like_proc(
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: table_like_proc: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_proc}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: longint
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name rate}
              | {type_long}: longint

The statement ending at line XXXX

CREATE TEMP TABLE table_like_proc_with_no_result(
  LIKE proc1
);

test/sem_test.sql:XXXX:1: error: in like : CQL0178: proc has no result 'proc1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_proc_with_no_result}
  | {col_key_list}: err
    | {shape_def}: err
      | {like}: err
        | {name proc1}: err

The statement ending at line XXXX

CREATE TEMP TABLE table_like_nonexistent_view(
  LIKE this_thing_doesnt_exist
);

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'this_thing_doesnt_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_nonexistent_view}
  | {col_key_list}: err
    | {shape_def}: err
      | {like}: err
        | {name this_thing_doesnt_exist}: err

The statement ending at line XXXX

CREATE TEMP TABLE table_multiple_like(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL,
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: table_multiple_like: { f1: integer notnull, f2: integer notnull, f3: integer notnull, id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_multiple_like}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name f3}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: id: integer notnull
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |   | | {name id}
          |   | | {type_int}: integer
          |   | {col_attrs_not_null}: ok
          | {col_key_list}
            | {col_def}: name: text
            | | {col_def_type_attrs}: ok
            |   | {col_def_name_type}
            |     | {name name}
            |     | {type_text}: text
            | {col_key_list}
              | {col_def}: rate: longint
                | {col_def_type_attrs}: ok
                  | {col_def_name_type}
                    | {name rate}
                    | {type_long}: longint

The statement ending at line XXXX

CREATE TEMP TABLE table_like_mixed(
  garbage TEXT,
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL,
  happy INTEGER
);

  {create_table_stmt}: table_like_mixed: { garbage: text, f1: integer notnull, f2: integer notnull, f3: integer notnull, happy: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_like_mixed}
  | {col_key_list}
    | {col_def}: garbage: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name garbage}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: f1: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f1}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f2: integer notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name f2}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: f3: integer notnull
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |   | | {name f3}
          |   | | {type_int}: integer
          |   | {col_attrs_not_null}: ok
          | {col_key_list}
            | {col_def}: happy: integer
              | {col_def_type_attrs}: ok
                | {col_def_name_type}
                  | {name happy}
                  | {type_int}: integer

The statement ending at line XXXX

CREATE TEMP TABLE table_with_dup_col(
  f1 TEXT,
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

test/sem_test.sql:XXXX:1: error: in str : CQL0142: duplicate column name 'f1'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table_with_dup_col}
  | {col_key_list}
    | {col_def}: f1: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name f1}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: f1: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f1}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f2: integer notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name f2}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {col_def}: f3: integer notnull
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
              | | {name f3}
              | | {type_int}: integer
              | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TEMP VIEW bogus_temp_view_with_versioning AS
SELECT 1 AS x @DELETE(1);

test/sem_test.sql:XXXX:1: error: in create_view_stmt : CQL0139: temp objects may not have versioning annotations 'bogus_temp_view_with_versioning'

  {create_view_stmt}: err
  | {int 1}
  | {view_and_attrs}
    | {name_and_select}
    | | {name bogus_temp_view_with_versioning}
    | | {select_stmt}: select: { x: integer notnull }
    |   | {select_core_list}: select: { x: integer notnull }
    |   | | {select_core}: select: { x: integer notnull }
    |   |   | {select_expr_list_con}: select: { x: integer notnull }
    |   |     | {select_expr_list}: select: { x: integer notnull }
    |   |     | | {select_expr}: x: integer notnull
    |   |     |   | {int 1}: integer notnull
    |   |     |   | {opt_as_alias}
    |   |     |     | {name x}
    |   |     | {select_from_etc}: ok
    |   |       | {select_where}
    |   |         | {select_groupby}
    |   |           | {select_having}
    |   | {select_orderby}
    |     | {select_limit}
    |       | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 1}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS bogus_temp_trigger
  BEFORE DELETE ON bar
BEGIN
  DELETE FROM bar WHERE rate > id;
END @DELETE(2);

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0139: temp objects may not have versioning annotations 'bogus_temp_trigger'

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
    | | {name bogus_temp_trigger}
    | | {trigger_condition}
    |   | {int 4}
    |   | {trigger_op_target}
    |     | {trigger_operation}
    |     | | {int 64}
    |     | {trigger_target_action}
    |       | {name bar}
    |       | {trigger_action}
    |         | {int 0}
    |         | {trigger_when_stmts}
    |           | {stmt_list}
    |             | {delete_stmt}
    |               | {name bar}
    |               | {opt_where}
    |                 | {gt}
    |                   | {name rate}
    |                   | {name id}
    | {delete_attr}
      | {version_annotation}
        | {int 2}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_create_versioning(
  id INTEGER
) @CREATE(1);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0139: temp objects may not have versioning annotations 'bogus_temp_with_create_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_temp_with_create_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_delete_versioning(
  id INTEGER
) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0139: temp objects may not have versioning annotations 'bogus_temp_with_delete_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_temp_with_delete_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_recreate_versioning(
  id INTEGER
) @RECREATE;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0139: temp objects may not have versioning annotations 'bogus_temp_with_recreate_versioning'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | | {recreate_attr}
  | | {name bogus_temp_with_recreate_versioning}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TABLE bogus_temp_with_versioning_in_column(
  id INTEGER @CREATE(2)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0140: columns in a temp table may not have versioning attributes 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name bogus_temp_with_versioning_in_column}
  | {col_key_list}
    | {col_def}: id: integer @create(2)
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {create_attr}: ok
          | {version_annotation}
            | {int 2}

The statement ending at line XXXX

SELECT 'x' MATCH 'y';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {match}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := 'x' MATCH 'y';

test/sem_test.sql:XXXX:1: error: in match : CQL0044: operator may only appear in the context of a SQL statement 'MATCH'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {match}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SELECT 'x' GLOB 'y';

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {glob}: bool notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := 'x' GLOB 'y';

test/sem_test.sql:XXXX:1: error: in glob : CQL0044: operator may only appear in the context of a SQL statement 'GLOB'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {glob}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := 'x' MATCH 'y';

test/sem_test.sql:XXXX:1: error: in match : CQL0044: operator may only appear in the context of a SQL statement 'MATCH'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {match}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := 'x' REGEXP 'y';

test/sem_test.sql:XXXX:1: error: in regexp : CQL0044: operator may only appear in the context of a SQL statement 'REGEXP'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {regexp}: err
    | {strlit 'x'}
    | {strlit 'y'}

The statement ending at line XXXX

SET X := ( SELECT 'x' REGEXP 'y' );

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {select_stmt}: _anon: bool notnull
    | {select_core_list}: select: { _anon: bool notnull }
    | | {select_core}: select: { _anon: bool notnull }
    |   | {select_expr_list_con}: select: { _anon: bool notnull }
    |     | {select_expr_list}: select: { _anon: bool notnull }
    |     | | {select_expr}: bool notnull
    |     |   | {regexp}: bool notnull
    |     |     | {strlit 'x'}: text notnull
    |     |     | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET X := 1 << 2 | 1 << 4 & 1 >> 8;

  {assign}: X: integer variable was_set
  | {name X}: X: integer variable was_set
  | {rshift}: integer notnull
    | {bin_and}: integer notnull
    | | {lshift}: integer notnull
    | | | {bin_or}: integer notnull
    | | | | {lshift}: integer notnull
    | | | | | {int 1}: integer notnull
    | | | | | {int 2}: integer notnull
    | | | | {int 1}: integer notnull
    | | | {int 4}: integer notnull
    | | {int 1}: integer notnull
    | {int 8}: integer notnull

The statement ending at line XXXX

SET X := 3.0 & 2;

test/sem_test.sql:XXXX:1: error: in bin_and : CQL0001: operands must be an integer type, not real '&'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {bin_and}: err
    | {dbl 3.0}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SET X := ~3.0;

test/sem_test.sql:XXXX:1: error: in tilde : CQL0001: operands must be an integer type, not real '~'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {tilde}: err
    | {dbl 3.0}: real notnull

The statement ending at line XXXX

CREATE PROC simple_alias_order_by ()
BEGIN
  SELECT id AS bar_id
    FROM bar
  ORDER BY bar_id;
END;

  {create_proc_stmt}: simple_alias_order_by: { bar_id: integer notnull } dml_proc
  | {name simple_alias_order_by}: simple_alias_order_by: { bar_id: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { bar_id: integer notnull }
        | {select_core_list}: select: { bar_id: integer notnull }
        | | {select_core}: select: { bar_id: integer notnull }
        |   | {select_expr_list_con}: select: { bar_id: integer notnull }
        |     | {select_expr_list}: select: { bar_id: integer notnull }
        |     | | {select_expr}: bar_id: integer notnull
        |     |   | {name id}: id: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name bar_id}
        |     | {select_from_etc}: TABLE { bar: bar }
        |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |   | {name bar}: TABLE { bar: bar }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {opt_orderby}: ok
          | | {orderby_list}: ok
          |   | {orderby_item}
          |     | {name bar_id}: bar_id: integer notnull
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC complex_alias_order_by ()
BEGIN
  SELECT 1 AS sort_order_value, id
    FROM bar
  UNION ALL
  SELECT 2 AS sort_order_value, id
    FROM bar
  ORDER BY sort_order_value, id;
END;

  {create_proc_stmt}: complex_alias_order_by: { sort_order_value: integer notnull, id: integer notnull } dml_proc
  | {name complex_alias_order_by}: complex_alias_order_by: { sort_order_value: integer notnull, id: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull }
        | {select_core_list}: UNION ALL: { sort_order_value: integer notnull, id: integer notnull }
        | | {select_core}: select: { sort_order_value: integer notnull, id: integer notnull }
        | | | {select_expr_list_con}: select: { sort_order_value: integer notnull, id: integer notnull }
        | |   | {select_expr_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        | |   | | {select_expr}: sort_order_value: integer notnull
        | |   | | | {int 1}: integer notnull
        | |   | | | {opt_as_alias}
        | |   | |   | {name sort_order_value}
        | |   | | {select_expr_list}
        | |   |   | {select_expr}: id: integer notnull
        | |   |     | {name id}: id: integer notnull
        | |   | {select_from_etc}: TABLE { bar: bar }
        | |     | {table_or_subquery_list}: TABLE { bar: bar }
        | |     | | {table_or_subquery}: TABLE { bar: bar }
        | |     |   | {name bar}: TABLE { bar: bar }
        | |     | {select_where}
        | |       | {select_groupby}
        | |         | {select_having}
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        |     | {select_core}: select: { sort_order_value: integer notnull, id: integer notnull }
        |       | {select_expr_list_con}: select: { sort_order_value: integer notnull, id: integer notnull }
        |         | {select_expr_list}: select: { sort_order_value: integer notnull, id: integer notnull }
        |         | | {select_expr}: sort_order_value: integer notnull
        |         | | | {int 2}: integer notnull
        |         | | | {opt_as_alias}
        |         | |   | {name sort_order_value}
        |         | | {select_expr_list}
        |         |   | {select_expr}: id: integer notnull
        |         |     | {name id}: id: integer notnull
        |         | {select_from_etc}: TABLE { bar: bar }
        |           | {table_or_subquery_list}: TABLE { bar: bar }
        |           | | {table_or_subquery}: TABLE { bar: bar }
        |           |   | {name bar}: TABLE { bar: bar }
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {opt_orderby}: ok
          | | {orderby_list}: ok
          |   | {orderby_item}
          |   | | {name sort_order_value}: sort_order_value: integer notnull
          |   | {orderby_list}
          |     | {orderby_item}
          |       | {name id}: id: integer notnull
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE stories(
  media_id LONG_INT
);

  {create_table_stmt}: stories: { media_id: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name stories}
  | {col_key_list}
    | {col_def}: media_id: longint
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name media_id}
          | {type_long}: longint

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger1
  BEFORE DELETE ON bar
  FOR EACH ROW
  WHEN old.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
  DELETE FROM bar WHERE rate = old.id;
END;

  {create_trigger_stmt}: ok
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger1}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 256}
              | {trigger_when_stmts}
                | {eq}: bool notnull
                | | {dot}: id: integer notnull
                | | | {name old}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {opt_where}: bool
                  |   | {gt}: bool
                  |     | {name rate}: rate: longint
                  |     | {name id}: id: integer notnull
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {eq}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name old}
                          | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger1a
  BEFORE DELETE ON bar
  WHEN new.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'new.id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger1a}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {eq}: err
                | | {dot}: err
                | | | {name new}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger2
  AFTER INSERT ON bar
BEGIN
  DELETE FROM bar WHERE rate > new.id;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name new}
                          | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger2a
  AFTER INSERT ON bar
  WHEN old.id = 3
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'old.id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2a}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {eq}: err
                | | {dot}: err
                | | | {name old}
                | | | {name id}
                | | {int 3}: integer notnull
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
  UPDATE bar
  SET id = 7
    WHERE rate > old.b AND rate < new.b;
  INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {and}: bool notnull
                | | {gt}: bool notnull
                | | | {dot}: b: real notnull
                | | | | {name old}
                | | | | {name b}
                | | | {int 1}: integer notnull
                | | {lt}: bool notnull
                |   | {dot}: b: real notnull
                |   | | {name new}
                |   | | {name b}
                |   | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {update_set}
                  |   | {update_list}: ok
                  |   | | {update_entry}: id: integer notnull
                  |   |   | {name id}: id: integer notnull
                  |   |   | {int 7}: integer notnull
                  |   | {update_from}
                  |     | {update_where}
                  |       | {opt_where}: bool
                  |       | | {and}: bool
                  |       |   | {gt}: bool
                  |       |   | | {name rate}: rate: longint
                  |       |   | | {dot}: b: real notnull
                  |       |   |   | {name old}
                  |       |   |   | {name b}
                  |       |   | {lt}: bool
                  |       |     | {name rate}: rate: longint
                  |       |     | {dot}: b: real notnull
                  |       |       | {name new}
                  |       |       | {name b}
                  |       | {update_orderby}
                  | {insert_stmt}: ok
                    | {insert_normal}
                    | {name_columns_values}
                      | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                      | {columns_values}: ok
                        | {column_spec}
                        | | {name_list}
                        |   | {name id}: id: integer notnull
                        |   | {name_list}
                        |     | {name name}: name: text
                        |     | {name_list}
                        |       | {name rate}: rate: longint
                        | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |   | {select_values}
                          |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |     | {insert_list}: ok
                          |       | {int 7}: integer notnull
                          |       | {insert_list}
                          |         | {strlit 'goo'}: text notnull
                          |         | {insert_list}
                          |           | {longint 17}: longint notnull
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
  UPDATE bar
  SET id = 7
    WHERE rate > old.b AND rate < new.b;
  INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {and}: bool notnull
                | | {gt}: bool notnull
                | | | {dot}: b: real notnull
                | | | | {name old}
                | | | | {name b}
                | | | {int 1}: integer notnull
                | | {lt}: bool notnull
                |   | {dot}: b: real notnull
                |   | | {name new}
                |   | | {name b}
                |   | {int 3}: integer notnull
                | {stmt_list}: ok
                  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | | {update_set}
                  |   | {update_list}: ok
                  |   | | {update_entry}: id: integer notnull
                  |   |   | {name id}: id: integer notnull
                  |   |   | {int 7}: integer notnull
                  |   | {update_from}
                  |     | {update_where}
                  |       | {opt_where}: bool
                  |       | | {and}: bool
                  |       |   | {gt}: bool
                  |       |   | | {name rate}: rate: longint
                  |       |   | | {dot}: b: real notnull
                  |       |   |   | {name old}
                  |       |   |   | {name b}
                  |       |   | {lt}: bool
                  |       |     | {name rate}: rate: longint
                  |       |     | {dot}: b: real notnull
                  |       |       | {name new}
                  |       |       | {name b}
                  |       | {update_orderby}
                  | {insert_stmt}: ok
                    | {insert_normal}
                    | {name_columns_values}
                      | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                      | {columns_values}: ok
                        | {column_spec}
                        | | {name_list}
                        |   | {name id}: id: integer notnull
                        |   | {name_list}
                        |     | {name name}: name: text
                        |     | {name_list}
                        |       | {name rate}: rate: longint
                        | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |   | {select_values}
                          |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: longint notnull }
                          |     | {insert_list}: ok
                          |       | {int 7}: integer notnull
                          |       | {insert_list}
                          |         | {strlit 'goo'}: text notnull
                          |         | {insert_list}
                          |           | {longint 17}: longint notnull
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
BEGIN
  SELECT 1;
END;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
  WHEN old.b > 1 AND new.b < 3
BEGIN
UPDATE bar
SET id = 7
  WHERE rate > old.b AND rate < new.b;

INSERT INTO bar(id, name, rate) VALUES(7, 'goo', 17L);
END
test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CREATE TRIGGER trigger3
  INSTEAD OF UPDATE ON ViewShape
BEGIN
SELECT 1;
END
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0136: trigger already exists 'trigger3'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger3}: err
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: integer notnull }
                    | {select_core_list}: select: { _anon: integer notnull }
                    | | {select_core}: select: { _anon: integer notnull }
                    |   | {select_expr_list_con}: select: { _anon: integer notnull }
                    |     | {select_expr_list}: select: { _anon: integer notnull }
                    |     | | {select_expr}: integer notnull
                    |     |   | {int 1}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4
  INSTEAD OF UPDATE OF a, b, c ON ViewShape
BEGIN
  SELECT 1;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | | {name_list}
          |   | {name a}: a: bool notnull
          |   | {name_list}
          |     | {name b}: b: real notnull
          |     | {name_list}
          |       | {name c}: c: text notnull
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: integer notnull }
                    | {select_core_list}: select: { _anon: integer notnull }
                    | | {select_core}: select: { _anon: integer notnull }
                    |   | {select_expr_list_con}: select: { _anon: integer notnull }
                    |     | {select_expr_list}: select: { _anon: integer notnull }
                    |     | | {select_expr}: integer notnull
                    |     |   | {int 1}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4a
  INSTEAD OF UPDATE OF a, a, c ON ViewShape
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0172: name list has duplicate name 'a'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4a}
      | {trigger_condition}
        | {int 16}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | | {name_list}: err
          |   | {name a}: a: bool notnull
          |   | {name_list}
          |     | {name a}: err
          |     | {name_list}
          |       | {name c}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4b
  BEFORE UPDATE ON ViewShape
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0138: a trigger on a view must be the INSTEAD OF form 'ViewShape'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4b}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name ViewShape}: ViewShape: { a: bool notnull, b: real notnull, c: text notnull }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4c
  BEFORE UPDATE ON no_such_table_dude
BEGIN
  SELECT 1;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0137: table/view not found 'no_such_table_dude'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4c}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 32}
          | {trigger_target_action}
            | {name no_such_table_dude}
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {select_stmt}
                    | {select_core_list}
                    | | {select_core}
                    |   | {select_expr_list_con}
                    |     | {select_expr_list}
                    |     | | {select_expr}
                    |     |   | {int 1}
                    |     | {select_from_etc}
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER trigger4d
  BEFORE INSERT ON bar
BEGIN
  SELECT old.id;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'old.id'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger4d}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {dot}: err
                    |     |     | {name old}
                    |     |     | {name id}
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE PROC make_trigger ()
BEGIN
  CREATE TRIGGER selecting_trigger
    BEFORE DELETE ON bar
    FOR EACH ROW
    WHEN old.id > 7
  BEGIN
    SELECT old.id;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name make_trigger}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {create_trigger_stmt}: ok
        | {int 0}
        | {trigger_body_vers}
          | {trigger_def}
            | {name selecting_trigger}
            | {trigger_condition}
              | {int 4}
              | {trigger_op_target}
                | {trigger_operation}
                | | {int 64}
                | {trigger_target_action}
                  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | {trigger_action}
                    | {int 256}
                    | {trigger_when_stmts}
                      | {gt}: bool notnull
                      | | {dot}: id: integer notnull
                      | | | {name old}
                      | | | {name id}
                      | | {int 7}: integer notnull
                      | {stmt_list}: ok
                        | {select_stmt}: select: { id: integer notnull }
                          | {select_core_list}: select: { id: integer notnull }
                          | | {select_core}: select: { id: integer notnull }
                          |   | {select_expr_list_con}: select: { id: integer notnull }
                          |     | {select_expr_list}: select: { id: integer notnull }
                          |     | | {select_expr}: id: integer notnull
                          |     |   | {dot}: id: integer notnull
                          |     |     | {name old}
                          |     |     | {name id}
                          |     | {select_from_etc}: ok
                          |       | {select_where}
                          |         | {select_groupby}
                          |           | {select_having}
                          | {select_orderby}
                            | {select_limit}
                              | {select_offset}

The statement ending at line XXXX

DROP TRIGGER this_trigger_does_not_exist;

test/sem_test.sql:XXXX:1: error: in str : CQL0113: trigger in drop statement was not declared 'this_trigger_does_not_exist'

  {drop_trigger_stmt}: err
  | {name this_trigger_does_not_exist}

The statement ending at line XXXX

DROP TRIGGER IF EXISTS trigger1;

  {drop_trigger_stmt}: ok
  | {int 1}
  | {name trigger1}

The statement ending at line XXXX

CREATE TABLE retro_deleted_table(
  id INTEGER
) @CREATE(3) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0107: delete version can't be <= create version 'retro_deleted_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 3}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 1}
  | | {name retro_deleted_table}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger5
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, "omg roll it back!");
END;

  {create_trigger_stmt}: ok
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger5}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {select_stmt}: select: { _anon: null }
                    | {select_core_list}: select: { _anon: null }
                    | | {select_core}: select: { _anon: null }
                    |   | {select_expr_list_con}: select: { _anon: null }
                    |     | {select_expr_list}: select: { _anon: null }
                    |     | | {select_expr}: null
                    |     |   | {raise}: null
                    |     |     | {int 1}
                    |     |     | {strlit 'omg roll it back!'}: text notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

SELECT RAISE(IGNORE);

test/sem_test.sql:XXXX:1: error: in raise : CQL0092: RAISE may only be used in a trigger statement

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {raise}: err
  |     |     | {int 0}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger6
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, 0);
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0093: RAISE 2nd argument must be a string

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger6}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {raise}: err
                    |     |     | {int 1}
                    |     |     | {int 0}: integer notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TEMP TRIGGER IF NOT EXISTS trigger7
  BEFORE DELETE ON bar
BEGIN
  SELECT RAISE(ROLLBACK, NOT 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_trigger_stmt}: err
  | {int 3}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger7}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: err
                  | {select_stmt}: err
                    | {select_core_list}: err
                    | | {select_core}: err
                    |   | {select_expr_list_con}: err
                    |     | {select_expr_list}: err
                    |     | | {select_expr}: err
                    |     |   | {raise}: err
                    |     |     | {int 1}
                    |     |     | {not}: err
                    |     |       | {strlit 'x'}: text notnull
                    |     | {select_from_etc}: ok
                    |       | {select_where}
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER IF NOT EXISTS trigger8
  BEFORE DELETE ON bar
BEGIN
  SELECT 1 AS x;
END @DELETE(1, MigrateProcFoo);

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0321: migration proc not allowed on object 'trigger8'

  {create_trigger_stmt}: err
  | {int 2}
  | {trigger_body_vers}
    | {trigger_def}
    | | {name trigger8}
    | | {trigger_condition}
    |   | {int 4}
    |   | {trigger_op_target}
    |     | {trigger_operation}
    |     | | {int 64}
    |     | {trigger_target_action}
    |       | {name bar}
    |       | {trigger_action}
    |         | {int 0}
    |         | {trigger_when_stmts}
    |           | {stmt_list}
    |             | {select_stmt}
    |               | {select_core_list}
    |               | | {select_core}
    |               |   | {select_expr_list_con}
    |               |     | {select_expr_list}
    |               |     | | {select_expr}
    |               |     |   | {int 1}
    |               |     |   | {opt_as_alias}
    |               |     |     | {name x}
    |               |     | {select_from_etc}
    |               |       | {select_where}
    |               |         | {select_groupby}
    |               |           | {select_having}
    |               | {select_orderby}
    |                 | {select_limit}
    |                   | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 1}
        | {name MigrateProcFoo}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B, 3 AS C
UNION ALL
SELECT 3 AS A, 4 AS B;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0057: if multiple selects, all must have the same column count
test/sem_test.sql:XXXX:1: error: in select_core : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 3 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 2 columns

only in 1st: C integer notnull


  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull, C: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |   | | {int 2}: integer notnull
  | |   |   | | {opt_as_alias}
  | |   |   |   | {name B}
  | |   |   | {select_expr_list}
  | |   |     | {select_expr}: C: integer notnull
  | |   |       | {int 3}: integer notnull
  | |   |       | {opt_as_alias}
  | |   |         | {name C}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr}: A: integer notnull
  |         | | | {int 3}: integer notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 'x' AS A, 4 AS B;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0012: incompatible types in expression 'A'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { A: text notnull, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: text notnull, B: integer notnull }
  |         | {select_expr_list}: select: { A: text notnull, B: integer notnull }
  |         | | {select_expr}: A: text notnull
  |         | | | {strlit 'x'}: text notnull
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, nullable(2) AS B
UNION ALL
SELECT NULL AS A, 4 AS B;

  {select_stmt}: UNION ALL: { A: integer, B: integer }
  | {select_core_list}: UNION ALL: { A: integer, B: integer }
  | | {select_core}: select: { A: integer notnull, B: integer }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer
  | |   |     | {call}: integer
  | |   |     | | {name nullable}: integer
  | |   |     | | {call_arg_list}
  | |   |     |   | {call_filter_clause}
  | |   |     |   | {arg_list}: ok
  | |   |     |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { A: null, B: integer notnull }
  |     | {select_core}: select: { A: null, B: integer notnull }
  |       | {select_expr_list_con}: select: { A: null, B: integer notnull }
  |         | {select_expr_list}: select: { A: null, B: integer notnull }
  |         | | {select_expr}: A: null
  |         | | | {null}: null
  |         | | | {opt_as_alias}
  |         | |   | {name A}
  |         | | {select_expr_list}
  |         |   | {select_expr}: B: integer notnull
  |         |     | {int 4}: integer notnull
  |         |     | {opt_as_alias}
  |         |       | {name B}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B
UNION ALL
SELECT 1 AS A, 2 AS B;

  {select_stmt}: UNION ALL: { A: integer notnull, B: integer notnull }
  | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  | | {select_core}: select: { A: integer notnull, B: integer notnull }
  | | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  | |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  | |   | | {select_expr}: A: integer notnull
  | |   | | | {int 1}: integer notnull
  | |   | | | {opt_as_alias}
  | |   | |   | {name A}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: B: integer notnull
  | |   |     | {int 2}: integer notnull
  | |   |     | {opt_as_alias}
  | |   |       | {name B}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  |     | {select_core}: select: { A: integer notnull, B: integer notnull }
  |     | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |     |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |     |   | | {select_expr}: A: integer notnull
  |     |   | | | {int 1}: integer notnull
  |     |   | | | {opt_as_alias}
  |     |   | |   | {name A}
  |     |   | | {select_expr_list}
  |     |   |   | {select_expr}: B: integer notnull
  |     |   |     | {int 2}: integer notnull
  |     |   |     | {opt_as_alias}
  |     |   |       | {name B}
  |     |   | {select_from_etc}: ok
  |     |     | {select_where}
  |     |       | {select_groupby}
  |     |         | {select_having}
  |     | {select_core_compound}
  |       | {int 2}
  |       | {select_core_list}: UNION ALL: { A: integer notnull, B: integer notnull }
  |         | {select_core}: select: { A: integer notnull, B: integer notnull }
  |         | | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |         |   | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |         |   | | {select_expr}: A: integer notnull
  |         |   | | | {int 1}: integer notnull
  |         |   | | | {opt_as_alias}
  |         |   | |   | {name A}
  |         |   | | {select_expr_list}
  |         |   |   | {select_expr}: B: integer notnull
  |         |   |     | {int 2}: integer notnull
  |         |   |     | {opt_as_alias}
  |         |   |       | {name B}
  |         |   | {select_from_etc}: ok
  |         |     | {select_where}
  |         |       | {select_groupby}
  |         |         | {select_having}
  |         | {select_core_compound}
  |           | {int 2}
  |           | {select_core_list}: select: { A: integer notnull, B: integer notnull }
  |             | {select_core}: select: { A: integer notnull, B: integer notnull }
  |               | {select_expr_list_con}: select: { A: integer notnull, B: integer notnull }
  |                 | {select_expr_list}: select: { A: integer notnull, B: integer notnull }
  |                 | | {select_expr}: A: integer notnull
  |                 | | | {int 1}: integer notnull
  |                 | | | {opt_as_alias}
  |                 | |   | {name A}
  |                 | | {select_expr_list}
  |                 |   | {select_expr}: B: integer notnull
  |                 |     | {int 2}: integer notnull
  |                 |     | {opt_as_alias}
  |                 |       | {name B}
  |                 | {select_from_etc}: ok
  |                   | {select_where}
  |                     | {select_groupby}
  |                       | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC returns_bogus_null ()
BEGIN
  SELECT NULL AS n;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0056: NULL expression has no type to imply the type of the select result 'n'

  {create_proc_stmt}: err
  | {name returns_bogus_null}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: select: { n: null }
        | | {select_core}: select: { n: null }
        |   | {select_expr_list_con}: select: { n: null }
        |     | {select_expr_list}: select: { n: null }
        |     | | {select_expr}: n: null
        |     |   | {null}: null
        |     |   | {opt_as_alias}
        |     |     | {name n}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC fetch_null_column ()
BEGIN
  DECLARE C CURSOR FOR SELECT NULL AS n;
  FETCH C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0056: NULL expression has no type to imply the type of the select result 'n'

  {create_proc_stmt}: err
  | {name fetch_null_column}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { n: null } variable dml_proc
      | | {name C}: C: select: { n: null } variable dml_proc
      | | {select_stmt}: select: { n: null }
      |   | {select_core_list}: select: { n: null }
      |   | | {select_core}: select: { n: null }
      |   |   | {select_expr_list_con}: select: { n: null }
      |   |     | {select_expr_list}: select: { n: null }
      |   |     | | {select_expr}: n: null
      |   |     |   | {null}: null
      |   |     |   | {opt_as_alias}
      |   |     |     | {name n}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: err
        | {name C}: err

The statement ending at line XXXX

CREATE TABLE with_sensitive(
  id INTEGER,
  name TEXT @SENSITIVE,
  info INTEGER @SENSITIVE
);

  {create_table_stmt}: with_sensitive: { id: integer, name: text sensitive, info: integer sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_sensitive}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: name: text sensitive
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name name}
      |   | | {type_text}: text
      |   | {sensitive_attr}: ok
      | {col_key_list}
        | {col_def}: info: integer sensitive
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name info}
            | | {type_int}: integer
            | {sensitive_attr}: ok

The statement ending at line XXXX

CREATE TABLE without_sensitive(
  name TEXT
);

  {create_table_stmt}: without_sensitive: { name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name without_sensitive}
  | {col_key_list}
    | {col_def}: name: text
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name name}
          | {type_text}: text

The statement ending at line XXXX

CREATE PROC get_sensitive ()
BEGIN
  SELECT 1 AS safe, info + 1 AS sensitive_1, name AS sensitive_2, 'x' AS not_sensitive_1, -info AS sensitive_3, info BETWEEN 1 AND 3 AS sensitive_4
    FROM with_sensitive;
END;

  {create_proc_stmt}: get_sensitive: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive } dml_proc
  | {name get_sensitive}: get_sensitive: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        | {select_core_list}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        | | {select_core}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |   | {select_expr_list_con}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |     | {select_expr_list}: select: { safe: integer notnull, sensitive_1: integer sensitive, sensitive_2: text sensitive, not_sensitive_1: text notnull, sensitive_3: integer sensitive, sensitive_4: bool sensitive }
        |     | | {select_expr}: safe: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name safe}
        |     | | {select_expr_list}
        |     |   | {select_expr}: sensitive_1: integer sensitive
        |     |   | | {add}: integer sensitive
        |     |   | | | {name info}: info: integer sensitive
        |     |   | | | {int 1}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name sensitive_1}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: sensitive_2: text sensitive
        |     |     | | {name name}: name: text sensitive
        |     |     | | {opt_as_alias}
        |     |     |   | {name sensitive_2}
        |     |     | {select_expr_list}
        |     |       | {select_expr}: not_sensitive_1: text notnull
        |     |       | | {strlit 'x'}: text notnull
        |     |       | | {opt_as_alias}
        |     |       |   | {name not_sensitive_1}
        |     |       | {select_expr_list}
        |     |         | {select_expr}: sensitive_3: integer sensitive
        |     |         | | {uminus}: integer sensitive
        |     |         | | | {name info}: info: integer sensitive
        |     |         | | {opt_as_alias}
        |     |         |   | {name sensitive_3}
        |     |         | {select_expr_list}
        |     |           | {select_expr}: sensitive_4: bool sensitive
        |     |             | {between}: bool sensitive
        |     |             | | {name info}: info: integer sensitive
        |     |             | | {range}
        |     |             |   | {int 1}: integer notnull
        |     |             |   | {int 3}: integer notnull
        |     |             | {opt_as_alias}
        |     |               | {name sensitive_4}
        |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
        |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
        |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
        |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE _sens INTEGER @SENSITIVE;

  {declare_vars_type}: integer sensitive
  | {name_list}: _sens: integer variable sensitive was_set
  | | {name _sens}: _sens: integer variable sensitive was_set
  | {sensitive_attr}: integer sensitive
    | {type_int}: integer

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT _sens;

  {select_stmt}: select: { safe: integer notnull sensitive }
  | {select_core_list}: select: { safe: integer notnull sensitive }
  | | {select_core}: select: { safe: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { safe: integer notnull sensitive }
  |     | {select_expr_list}: select: { safe: integer notnull sensitive }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: _sens: integer variable sensitive
      | | {name _sens}: _sens: integer variable sensitive
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1;

  {select_stmt}: select: { safe: integer notnull }
  | {select_core_list}: select: { safe: integer notnull }
  | | {select_core}: select: { safe: integer notnull }
  |   | {select_expr_list_con}: select: { safe: integer notnull }
  |     | {select_expr_list}: select: { safe: integer notnull }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1
OFFSET _sens;

  {select_stmt}: select: { safe: integer notnull sensitive }
  | {select_core_list}: select: { safe: integer notnull sensitive }
  | | {select_core}: select: { safe: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { safe: integer notnull sensitive }
  |     | {select_expr_list}: select: { safe: integer notnull sensitive }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}
        | {opt_offset}: _sens: integer variable sensitive
          | {name _sens}: _sens: integer variable sensitive

The statement ending at line XXXX

SELECT 1 AS safe
LIMIT 1
OFFSET 1;

  {select_stmt}: select: { safe: integer notnull }
  | {select_core_list}: select: { safe: integer notnull }
  | | {select_core}: select: { safe: integer notnull }
  |   | {select_expr_list_con}: select: { safe: integer notnull }
  |     | {select_expr_list}: select: { safe: integer notnull }
  |     | | {select_expr}: safe: integer notnull
  |     |   | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name safe}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 1}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 1}: integer notnull

The statement ending at line XXXX

SET _sens := _sens + 1;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {add}: integer sensitive
    | {name _sens}: _sens: integer variable sensitive
    | {int 1}: integer notnull

The statement ending at line XXXX

SET _sens := _sens IN (1, 2);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {in_pred}: bool sensitive
    | {name _sens}: _sens: integer variable sensitive was_set
    | {expr_list}: integer notnull
      | {int 1}: integer notnull
      | {expr_list}: integer notnull
        | {int 2}: integer notnull

The statement ending at line XXXX

SET _sens := 1 IN (1, _sens);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {in_pred}: bool notnull sensitive
    | {int 1}: integer notnull
    | {expr_list}: integer notnull
      | {int 1}: integer notnull
      | {expr_list}: _sens: integer variable sensitive was_set
        | {name _sens}: _sens: integer variable sensitive was_set

The statement ending at line XXXX

SET _sens := ( SELECT 1 IN (SELECT info
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {in_pred}: bool notnull sensitive
    |     |     | {int 1}: integer notnull
    |     |     | {select_stmt}: info: integer sensitive
    |     |       | {select_core_list}: select: { info: integer sensitive }
    |     |       | | {select_core}: select: { info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { info: integer sensitive }
    |     |       |     | | {select_expr}: info: integer sensitive
    |     |       |     |   | {name info}: info: integer sensitive
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := nullable(CASE 0 WHEN 1 THEN 2
ELSE 3
END);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer
    | {name nullable}: integer
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {case_expr}: integer notnull
          | {int 0}: integer notnull
          | {connector}: integer notnull
            | {case_list}: integer notnull
            | | {when}: integer notnull
            |   | {int 1}: integer notnull
            |   | {int 2}: integer notnull
            | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := nullable(CASE _sens WHEN 1 THEN 2
ELSE 3
END);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer sensitive
    | {name nullable}: integer sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {case_expr}: integer notnull sensitive
          | {name _sens}: _sens: integer variable sensitive was_set
          | {connector}: integer notnull sensitive
            | {case_list}: integer notnull
            | | {when}: integer notnull
            |   | {int 1}: integer notnull
            |   | {int 2}: integer notnull
            | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := nullable(CASE 0 WHEN _sens THEN 2
ELSE 3
END);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer sensitive
    | {name nullable}: integer sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {case_expr}: integer notnull sensitive
          | {int 0}: integer notnull
          | {connector}: integer notnull sensitive
            | {case_list}: integer notnull sensitive
            | | {when}: integer notnull
            |   | {name _sens}: _sens: integer variable sensitive was_set
            |   | {int 2}: integer notnull
            | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := nullable(CASE 0 WHEN 1 THEN _sens
ELSE 3
END);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer sensitive
    | {name nullable}: integer sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {case_expr}: integer sensitive
          | {int 0}: integer notnull
          | {connector}: integer sensitive
            | {case_list}: integer variable sensitive was_set
            | | {when}: _sens: integer variable sensitive was_set
            |   | {int 1}: integer notnull
            |   | {name _sens}: _sens: integer variable sensitive was_set
            | {int 3}: integer notnull

The statement ending at line XXXX

SET _sens := nullable(CASE 0 WHEN 1 THEN 2
ELSE _sens
END);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer sensitive
    | {name nullable}: integer sensitive
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {case_expr}: integer sensitive
          | {int 0}: integer notnull
          | {connector}: integer sensitive
            | {case_list}: integer notnull
            | | {when}: integer notnull
            |   | {int 1}: integer notnull
            |   | {int 2}: integer notnull
            | {name _sens}: _sens: integer variable sensitive was_set

The statement ending at line XXXX

SET _sens := ( SELECT CAST(_sens AS INTEGER) );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: integer sensitive
    | {select_core_list}: select: { _anon: integer sensitive }
    | | {select_core}: select: { _anon: integer sensitive }
    |   | {select_expr_list_con}: select: { _anon: integer sensitive }
    |     | {select_expr_list}: select: { _anon: integer sensitive }
    |     | | {select_expr}: integer sensitive
    |     |   | {cast_expr}: integer sensitive
    |     |     | {name _sens}: _sens: integer variable sensitive was_set
    |     |     | {type_int}: integer
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT AVG(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: real sensitive }
  | {select_core_list}: select: { _anon: real sensitive }
  | | {select_core}: select: { _anon: real sensitive }
  |   | {select_expr_list_con}: select: { _anon: real sensitive }
  |     | {select_expr_list}: select: { _anon: real sensitive }
  |     | | {select_expr}: real sensitive
  |     |   | {call}: real sensitive
  |     |     | {name AVG}: real sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MIN(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: integer sensitive }
  | {select_core_list}: select: { _anon: integer sensitive }
  | | {select_core}: select: { _anon: integer sensitive }
  |   | {select_expr_list_con}: select: { _anon: integer sensitive }
  |     | {select_expr_list}: select: { _anon: integer sensitive }
  |     | | {select_expr}: integer sensitive
  |     |   | {call}: integer sensitive
  |     |     | {name MIN}: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MAX(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: integer sensitive }
  | {select_core_list}: select: { _anon: integer sensitive }
  | | {select_core}: select: { _anon: integer sensitive }
  |   | {select_expr_list_con}: select: { _anon: integer sensitive }
  |     | {select_expr_list}: select: { _anon: integer sensitive }
  |     | | {select_expr}: integer sensitive
  |     |   | {call}: integer sensitive
  |     |     | {name MAX}: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SUM(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: integer sensitive }
  | {select_core_list}: select: { _anon: integer sensitive }
  | | {select_core}: select: { _anon: integer sensitive }
  |   | {select_expr_list_con}: select: { _anon: integer sensitive }
  |     | {select_expr_list}: select: { _anon: integer sensitive }
  |     | | {select_expr}: integer sensitive
  |     |   | {call}: integer sensitive
  |     |     | {name SUM}: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COUNT(T1.info)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: integer notnull sensitive }
  | {select_core_list}: select: { _anon: integer notnull sensitive }
  | | {select_core}: select: { _anon: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { _anon: integer notnull sensitive }
  |     | {select_expr_list}: select: { _anon: integer notnull sensitive }
  |     | | {select_expr}: integer notnull sensitive
  |     |   | {call}: integer notnull sensitive
  |     |     | {name COUNT}: integer notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: info: integer sensitive
  |     |           | {name T1}
  |     |           | {name info}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT AVG(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name AVG}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT MAX(T1.id)
  FROM with_sensitive AS T1;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {call}: integer
  |     |     | {name MAX}: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dot}: id: integer
  |     |           | {name T1}
  |     |           | {name id}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT SUM(T1.id) AS s
  FROM with_sensitive AS T1;

  {select_stmt}: select: { s: integer }
  | {select_core_list}: select: { s: integer }
  | | {select_core}: select: { s: integer }
  |   | {select_expr_list_con}: select: { s: integer }
  |     | {select_expr_list}: select: { s: integer }
  |     | | {select_expr}: s: integer
  |     |   | {call}: integer
  |     |   | | {name SUM}: integer
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {dot}: id: integer
  |     |   |       | {name T1}
  |     |   |       | {name id}
  |     |   | {opt_as_alias}
  |     |     | {name s}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COUNT(T1.id) AS c
  FROM with_sensitive AS T1;

  {select_stmt}: select: { c: integer notnull }
  | {select_core_list}: select: { c: integer notnull }
  | | {select_core}: select: { c: integer notnull }
  |   | {select_expr_list_con}: select: { c: integer notnull }
  |     | {select_expr_list}: select: { c: integer notnull }
  |     | | {select_expr}: c: integer notnull
  |     |   | {call}: integer notnull
  |     |   | | {name COUNT}: integer notnull
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {dot}: id: integer
  |     |   |       | {name T1}
  |     |   |       | {name id}
  |     |   | {opt_as_alias}
  |     |     | {name c}
  |     | {select_from_etc}: TABLE { T1: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { T1: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       |   | {opt_as_alias}
  |       |     | {name T1}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET _sens := coalesce(_sens, 0);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer notnull sensitive
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name _sens}: _sens: integer variable sensitive was_set
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := coalesce(nullable(1), 0);

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: integer notnull
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {call}: integer
        | | {name nullable}: integer
        | | {call_arg_list}
        |   | {call_filter_clause}
        |   | {arg_list}: ok
        |     | {int 1}: integer notnull
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := coalesce(7, 0);

test/sem_test.sql:XXXX:1: error: in num : CQL0077: encountered arg known to be not null before the end of the list, rendering the rest useless. '7'

  {assign}: err
  | {name _sens}: _sens: integer variable sensitive was_set
  | {call}: err
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 7}: integer notnull
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS _sens;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is}: bool notnull sensitive
    | {int 0}: integer notnull
    | {call}: _sens: integer notnull variable sensitive was_set
      | {name cql_inferred_notnull}: _sens: integer notnull variable sensitive was_set
      | {call_arg_list}
        | {call_filter_clause}
        | {arg_list}: ok
          | {name _sens}: _sens: integer inferred_notnull variable sensitive was_set

The statement ending at line XXXX

SET _sens := _sens IS 0;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is}: bool notnull sensitive
    | {call}: _sens: integer notnull variable sensitive was_set
    | | {name cql_inferred_notnull}: _sens: integer notnull variable sensitive was_set
    | | {call_arg_list}
    |   | {call_filter_clause}
    |   | {arg_list}: ok
    |     | {name _sens}: _sens: integer inferred_notnull variable sensitive was_set
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS 0;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is}: bool notnull
    | {int 0}: integer notnull
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS NOT _sens;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is_not}: bool notnull sensitive
    | {int 0}: integer notnull
    | {call}: _sens: integer notnull variable sensitive was_set
      | {name cql_inferred_notnull}: _sens: integer notnull variable sensitive was_set
      | {call_arg_list}
        | {call_filter_clause}
        | {arg_list}: ok
          | {name _sens}: _sens: integer inferred_notnull variable sensitive was_set

The statement ending at line XXXX

SET _sens := _sens IS NOT 0;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is_not}: bool notnull sensitive
    | {call}: _sens: integer notnull variable sensitive was_set
    | | {name cql_inferred_notnull}: _sens: integer notnull variable sensitive was_set
    | | {call_arg_list}
    |   | {call_filter_clause}
    |   | {arg_list}: ok
    |     | {name _sens}: _sens: integer inferred_notnull variable sensitive was_set
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := 0 IS NOT 0;

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {is_not}: bool notnull
    | {int 0}: integer notnull
    | {int 0}: integer notnull

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT *
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {exists_expr}: bool notnull sensitive
    |     |     | {select_stmt}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       | {select_core_list}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       | | {select_core}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | | {star}: select: { id: integer, name: text sensitive, info: integer sensitive }
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT info
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: bool notnull sensitive
    | {select_core_list}: select: { _anon: bool notnull sensitive }
    | | {select_core}: select: { _anon: bool notnull sensitive }
    |   | {select_expr_list_con}: select: { _anon: bool notnull sensitive }
    |     | {select_expr_list}: select: { _anon: bool notnull sensitive }
    |     | | {select_expr}: bool notnull sensitive
    |     |   | {exists_expr}: bool notnull sensitive
    |     |     | {select_stmt}: select: { info: integer sensitive }
    |     |       | {select_core_list}: select: { info: integer sensitive }
    |     |       | | {select_core}: select: { info: integer sensitive }
    |     |       |   | {select_expr_list_con}: select: { info: integer sensitive }
    |     |       |     | {select_expr_list}: select: { info: integer sensitive }
    |     |       |     | | {select_expr}: info: integer sensitive
    |     |       |     |   | {name info}: info: integer sensitive
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT EXISTS (SELECT id
  FROM with_sensitive) );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: bool notnull
    | {select_core_list}: select: { _anon: bool notnull }
    | | {select_core}: select: { _anon: bool notnull }
    |   | {select_expr_list_con}: select: { _anon: bool notnull }
    |     | {select_expr_list}: select: { _anon: bool notnull }
    |     | | {select_expr}: bool notnull
    |     |   | {exists_expr}: bool notnull
    |     |     | {select_stmt}: select: { id: integer }
    |     |       | {select_core_list}: select: { id: integer }
    |     |       | | {select_core}: select: { id: integer }
    |     |       |   | {select_expr_list_con}: select: { id: integer }
    |     |       |     | {select_expr_list}: select: { id: integer }
    |     |       |     | | {select_expr}: id: integer
    |     |       |     |   | {name id}: id: integer
    |     |       |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |     |       |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  WHERE info = 1 );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: id: integer sensitive
    | {select_core_list}: select: { id: integer sensitive }
    | | {select_core}: select: { id: integer sensitive }
    |   | {select_expr_list_con}: select: { id: integer sensitive }
    |     | {select_expr_list}: select: { id: integer sensitive }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {opt_where}: bool sensitive
    |         | | {eq}: bool sensitive
    |         |   | {name info}: info: integer sensitive
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  WHERE id = 1 );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: id: integer
    | {select_core_list}: select: { id: integer }
    | | {select_core}: select: { id: integer }
    |   | {select_expr_list_con}: select: { id: integer }
    |     | {select_expr_list}: select: { id: integer }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {opt_where}: bool
    |         | | {eq}: bool
    |         |   | {name id}: id: integer
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET _sens := ( SELECT id
  FROM with_sensitive
  GROUP BY info
  HAVING info = 1 );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: id: integer sensitive
    | {select_core_list}: select: { id: integer sensitive }
    | | {select_core}: select: { id: integer sensitive }
    |   | {select_expr_list_con}: select: { id: integer sensitive }
    |     | {select_expr_list}: select: { id: integer sensitive }
    |     | | {select_expr}: id: integer
    |     |   | {name id}: id: integer
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {opt_groupby}: ok
    |           | | {groupby_list}: ok
    |           |   | {groupby_item}
    |           |     | {name info}: info: integer sensitive
    |           | {select_having}
    |             | {opt_having}: bool sensitive
    |               | {eq}: bool sensitive
    |                 | {name info}: info: integer sensitive
    |                 | {int 1}: integer notnull
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO without_sensitive(name) SELECT name
  FROM with_sensitive;

test/sem_test.sql:XXXX:1: error: in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'name'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name without_sensitive}: without_sensitive: { name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      | {select_stmt}: select: { name: text sensitive }
        | {select_core_list}: select: { name: text sensitive }
        | | {select_core}: select: { name: text sensitive }
        |   | {select_expr_list_con}: select: { name: text sensitive }
        |     | {select_expr_list}: select: { name: text sensitive }
        |     | | {select_expr}: name: text sensitive
        |     |   | {name name}: name: text sensitive
        |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
        |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
        |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
        |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE a(
  key_ INTEGER NOT NULL PRIMARY KEY,
  sort_key INTEGER NOT NULL
);

  {create_table_stmt}: a: { key_: integer notnull primary_key, sort_key: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a}
  | {col_key_list}
    | {col_def}: key_: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name key_}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    |     | {col_attrs_pk}
    |       | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: sort_key: integer notnull
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name sort_key}
          | | {type_int}: integer
          | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE b(
  key_ INTEGER NOT NULL PRIMARY KEY,
  a_key_ INTEGER NOT NULL,
  sort_key INTEGER NOT NULL
);

  {create_table_stmt}: b: { key_: integer notnull primary_key, a_key_: integer notnull, sort_key: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name b}
  | {col_key_list}
    | {col_def}: key_: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name key_}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    |     | {col_attrs_pk}
    |       | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: a_key_: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name a_key_}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: sort_key: integer notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name sort_key}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

SELECT key_, sort_key
  FROM a
UNION
SELECT key_, sort_key
  FROM b
ORDER BY sort_key, key_;

  {select_stmt}: UNION: { key_: integer notnull, sort_key: integer notnull }
  | {select_core_list}: UNION: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {name key_}: key_: integer notnull
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {name sort_key}: sort_key: integer notnull
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 1}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {name key_}: key_: integer notnull
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {name sort_key}: sort_key: integer notnull
  |         | {select_from_etc}: TABLE { b: b }
  |           | {table_or_subquery_list}: TABLE { b: b }
  |           | | {table_or_subquery}: TABLE { b: b }
  |           |   | {name b}: TABLE { b: b }
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |   | | {name sort_key}: sort_key: integer notnull
    |   | {orderby_list}
    |     | {orderby_item}
    |       | {name key_}: key_: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT key_, sort_key
  FROM a
UNION
SELECT key_, sort_key
  FROM b
ORDER BY 2, key_;

  {select_stmt}: UNION: { key_: integer notnull, sort_key: integer notnull }
  | {select_core_list}: UNION: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {name key_}: key_: integer notnull
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {name sort_key}: sort_key: integer notnull
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 1}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {name key_}: key_: integer notnull
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {name sort_key}: sort_key: integer notnull
  |         | {select_from_etc}: TABLE { b: b }
  |           | {table_or_subquery_list}: TABLE { b: b }
  |           | | {table_or_subquery}: TABLE { b: b }
  |           |   | {name b}: TABLE { b: b }
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |   | | {int 2}: integer notnull
    |   | {orderby_list}
    |     | {orderby_item}
    |       | {name key_}: key_: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT key_, sort_key
  FROM a
UNION
SELECT key_, sort_key
  FROM b
ORDER BY 1 + 1, key_;

test/sem_test.sql:XXXX:1: error: in add : CQL0398: compound select cannot be ordered by the result of an expression

  {select_stmt}: err
  | {select_core_list}: UNION: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {name key_}: key_: integer notnull
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {name sort_key}: sort_key: integer notnull
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 1}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {name key_}: key_: integer notnull
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {name sort_key}: sort_key: integer notnull
  |         | {select_from_etc}: TABLE { b: b }
  |           | {table_or_subquery_list}: TABLE { b: b }
  |           | | {table_or_subquery}: TABLE { b: b }
  |           |   | {name b}: TABLE { b: b }
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |   | | {add}: integer notnull
    |   |   | {int 1}: integer notnull
    |   |   | {int 1}: integer notnull
    |   | {orderby_list}
    |     | {orderby_item}
    |       | {name key_}: key_: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY sort_key, key_;

  {select_stmt}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1} {join_inner}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |   | | {name sort_key}: sort_key: integer notnull
    |   | {orderby_list}
    |     | {orderby_item}
    |       | {name key_}: key_: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY a_key_
LIMIT 2
OFFSET 3;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'a_key_'

  {select_stmt}: err
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1} {join_inner}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {orderby_list}: err
    |   | {orderby_item}
    |     | {name a_key_}: err
    | {select_limit}
      | {opt_limit}: integer notnull
      | | {int 2}: integer notnull
      | {select_offset}
        | {opt_offset}: integer notnull
          | {int 3}: integer notnull

The statement ending at line XXXX

SELECT a.key_, a.sort_key
  FROM a
UNION ALL
SELECT b.key_, b.sort_key
  FROM a
  INNER JOIN b ON b.a_key_ = a.key_
ORDER BY b.a_key_;

test/sem_test.sql:XXXX:1: error: in dot : CQL0069: name not found 'b.a_key_'

  {select_stmt}: err
  | {select_core_list}: UNION ALL: { key_: integer notnull, sort_key: integer notnull }
  | | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  | | | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  | |   | | {select_expr}: key_: integer notnull
  | |   | | | {dot}: key_: integer notnull
  | |   | |   | {name a}
  | |   | |   | {name key_}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: sort_key: integer notnull
  | |   |     | {dot}: sort_key: integer notnull
  | |   |       | {name a}
  | |   |       | {name sort_key}
  | |   | {select_from_etc}: TABLE { a: a }
  | |     | {table_or_subquery_list}: TABLE { a: a }
  | |     | | {table_or_subquery}: TABLE { a: a }
  | |     |   | {name a}: TABLE { a: a }
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |     | {select_core}: select: { key_: integer notnull, sort_key: integer notnull }
  |       | {select_expr_list_con}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | {select_expr_list}: select: { key_: integer notnull, sort_key: integer notnull }
  |         | | {select_expr}: key_: integer notnull
  |         | | | {dot}: key_: integer notnull
  |         | |   | {name b}
  |         | |   | {name key_}
  |         | | {select_expr_list}
  |         |   | {select_expr}: sort_key: integer notnull
  |         |     | {dot}: sort_key: integer notnull
  |         |       | {name b}
  |         |       | {name sort_key}
  |         | {select_from_etc}: JOIN { a: a, b: b }
  |           | {join_clause}: JOIN { a: a, b: b }
  |           | | {table_or_subquery}: TABLE { a: a }
  |           | | | {name a}: TABLE { a: a }
  |           | | {join_target_list}
  |           |   | {join_target}: JOIN { a: a, b: b }
  |           |     | {int 1} {join_inner}
  |           |     | {table_join}
  |           |       | {table_or_subquery}: TABLE { b: b }
  |           |       | | {name b}: TABLE { b: b }
  |           |       | {join_cond}: JOIN { a: a, b: b }
  |           |         | {on}: bool notnull
  |           |         | {eq}: bool notnull
  |           |           | {dot}: a_key_: integer notnull
  |           |           | | {name b}
  |           |           | | {name a_key_}
  |           |           | {dot}: key_: integer notnull
  |           |             | {name a}
  |           |             | {name key_}
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}: err
    | {opt_orderby}: err
    | | {orderby_list}: err
    |   | {orderby_item}
    |     | {dot}: err
    |       | {name b}
    |       | {name a_key_}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM bar AS T1
  INNER JOIN with_sensitive AS T2 ON T1.id = T2.id AND T2.info = 1;

  {select_stmt}: select: { id: integer notnull sensitive }
  | {select_core_list}: select: { id: integer notnull sensitive }
  | | {select_core}: select: { id: integer notnull sensitive }
  |   | {select_expr_list_con}: select: { id: integer notnull sensitive }
  |     | {select_expr_list}: select: { id: integer notnull sensitive }
  |     | | {select_expr}: id: integer notnull sensitive
  |     |   | {dot}: id: integer notnull sensitive
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: bar, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: bar, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: bar, T2: with_sensitive }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: bar, T2: with_sensitive }
  |       |         | {on}: bool sensitive
  |       |         | {and}: bool sensitive
  |       |           | {eq}: bool
  |       |           | | {dot}: id: integer notnull
  |       |           | | | {name T1}
  |       |           | | | {name id}
  |       |           | | {dot}: id: integer
  |       |           |   | {name T2}
  |       |           |   | {name id}
  |       |           | {eq}: bool sensitive
  |       |             | {dot}: info: integer sensitive
  |       |             | | {name T2}
  |       |             | | {name info}
  |       |             | {int 1}: integer notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM bar AS T1
  INNER JOIN with_sensitive AS T2 ON T1.id = T2.id;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     |   | {dot}: id: integer notnull
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: bar, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: bar, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: bar }
  |       | | | {name bar}: TABLE { T1: bar }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: bar, T2: with_sensitive }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: bar, T2: with_sensitive }
  |       |         | {on}: bool
  |       |         | {eq}: bool
  |       |           | {dot}: id: integer notnull
  |       |           | | {name T1}
  |       |           | | {name id}
  |       |           | {dot}: id: integer
  |       |             | {name T2}
  |       |             | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM with_sensitive AS T1
  INNER JOIN with_sensitive AS T2 USING (info);

  {select_stmt}: select: { id: integer sensitive }
  | {select_core_list}: select: { id: integer sensitive }
  | | {select_core}: select: { id: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer sensitive }
  |     | {select_expr_list}: select: { id: integer sensitive }
  |     | | {select_expr}: id: integer sensitive
  |     |   | {dot}: id: integer sensitive
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       | | | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |         | {using}
  |       |         | {name_list}: info: integer sensitive
  |       |           | {name info}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id
  FROM with_sensitive AS T1
  INNER JOIN with_sensitive AS T2 USING (id);

  {select_stmt}: select: { id: integer }
  | {select_core_list}: select: { id: integer }
  | | {select_core}: select: { id: integer }
  |   | {select_expr_list_con}: select: { id: integer }
  |     | {select_expr_list}: select: { id: integer }
  |     | | {select_expr}: id: integer
  |     |   | {dot}: id: integer
  |     |     | {name T1}
  |     |     | {name id}
  |     | {select_from_etc}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | {join_clause}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       | | {table_or_subquery}: TABLE { T1: with_sensitive }
  |       | | | {name with_sensitive}: TABLE { T1: with_sensitive }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: with_sensitive }
  |       |       | | {name with_sensitive}: TABLE { T2: with_sensitive }
  |       |       | | {opt_as_alias}
  |       |       |   | {name T2}
  |       |       | {join_cond}: JOIN { T1: with_sensitive, T2: with_sensitive }
  |       |         | {using}
  |       |         | {name_list}: id: integer
  |       |           | {name id}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := _sens;

test/sem_test.sql:XXXX:1: error: in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'X'

  {assign}: err
  | {name X}: err
  | {name _sens}: _sens: integer variable sensitive was_set

The statement ending at line XXXX

CALL decl1(_sens);

test/sem_test.sql:XXXX:1: error: in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {call_stmt}: err
  | {name decl1}: ok
  | {expr_list}: ok
    | {name _sens}: _sens: integer variable sensitive was_set

The statement ending at line XXXX

DECLARE PROC sens_proc (OUT foo INTEGER @SENSITIVE);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name sens_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer variable out sensitive
        | {out}
        | {param_detail}: foo: integer variable out sensitive
          | {name foo}: foo: integer variable out sensitive
          | {sensitive_attr}: integer sensitive
            | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC non_sens_proc (OUT foo INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name non_sens_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer variable out
        | {out}
        | {param_detail}: foo: integer variable out
          | {name foo}: foo: integer variable out
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC non_sens_proc_nonnull (OUT foo INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name non_sens_proc_nonnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: foo: integer notnull variable out
        | {out}
        | {param_detail}: foo: integer notnull variable out
          | {name foo}: foo: integer notnull variable out
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CALL sens_proc(X);

test/sem_test.sql:XXXX:1: error: in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'X'

  {call_stmt}: err
  | {name sens_proc}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable was_set

The statement ending at line XXXX

CALL non_sens_proc(_sens);

  {call_stmt}: ok
  | {name non_sens_proc}: ok
  | {expr_list}: ok
    | {name _sens}: _sens: integer variable sensitive was_set

The statement ending at line XXXX

CALL non_sens_proc(int_nn);

test/sem_test.sql:XXXX:1: error: in str : CQL0013: cannot assign/copy possibly null expression to not null target 'int_nn'

  {call_stmt}: err
  | {name non_sens_proc}: ok
  | {expr_list}: ok
    | {name int_nn}: int_nn: integer notnull variable was_set

The statement ending at line XXXX

CALL non_sens_proc_nonnull(X);

test/sem_test.sql:XXXX:1: error: in str : CQL0210: proc out parameter: arg must be an exact type match (even nullability) (expected integer notnull; found integer) 'X'

  {call_stmt}: err
  | {name non_sens_proc_nonnull}: ok
  | {expr_list}: ok
    | {name X}: X: integer variable was_set

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(coalesce(_sens, 0));

test/sem_test.sql:XXXX:1: error: in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: integer notnull sensitive }
        | {select_core_list}: values: { column1: integer notnull sensitive }
        | | {select_core}: values: { column1: integer notnull sensitive }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull sensitive }
        |     | {insert_list}: ok
        |       | {call}: integer notnull sensitive
        |         | {name coalesce}
        |         | {call_arg_list}
        |           | {call_filter_clause}
        |           | {arg_list}: ok
        |             | {name _sens}: _sens: integer variable sensitive was_set
        |             | {arg_list}
        |               | {int 0}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

UPDATE bar
SET id = coalesce(_sens, 0)
  WHERE name = 'x';

test/sem_test.sql:XXXX:1: error: in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'id'

  {update_stmt}: err
  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  | {update_set}
    | {update_list}: err
    | | {update_entry}: err
    |   | {name id}: id: integer notnull
    |   | {call}: integer notnull sensitive
    |     | {name coalesce}
    |     | {call_arg_list}
    |       | {call_filter_clause}
    |       | {arg_list}: ok
    |         | {name _sens}: _sens: integer variable sensitive was_set
    |         | {arg_list}
    |           | {int 0}: integer notnull
    | {update_from}
      | {update_where}
        | {opt_where}
        | | {eq}
        |   | {name name}
        |   | {strlit 'x'}
        | {update_orderby}

The statement ending at line XXXX

DECLARE FUNC sens_func (id INTEGER @SENSITIVE, t TEXT) TEXT @SENSITIVE;

  {declare_func_stmt}: text sensitive
  | {name sens_func}: text sensitive
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in sensitive
    | | | {param_detail}: id: integer variable in sensitive
    | |   | {name id}: id: integer variable in sensitive
    | |   | {sensitive_attr}: integer sensitive
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |     | {param_detail}: t: text variable in
    |       | {name t}: t: text variable in
    |       | {type_text}: text
    | {sensitive_attr}: text sensitive
      | {type_text}: text

The statement ending at line XXXX

DECLARE sens_text TEXT @SENSITIVE;

  {declare_vars_type}: text sensitive
  | {name_list}: sens_text: text variable sensitive was_set
  | | {name sens_text}: sens_text: text variable sensitive was_set
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE non_sens_text TEXT;

  {declare_vars_type}: text
  | {name_list}: non_sens_text: text variable was_set
  | | {name non_sens_text}: non_sens_text: text variable was_set
  | {type_text}: text

The statement ending at line XXXX

SET sens_text := sens_func(1, 'x');

  {assign}: sens_text: text variable sensitive was_set
  | {name sens_text}: sens_text: text variable sensitive was_set
  | {call}: text sensitive
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET non_sens_text := sens_func(1, 'x');

test/sem_test.sql:XXXX:1: error: in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'non_sens_text'

  {assign}: err
  | {name non_sens_text}: err
  | {call}: text sensitive
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET sens_text := sens_func(1, sens_text);

test/sem_test.sql:XXXX:1: error: in str : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 't'

  {assign}: err
  | {name sens_text}: sens_text: text variable sensitive was_set
  | {call}: err
    | {name sens_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {name sens_text}: sens_text: text variable sensitive was_set

The statement ending at line XXXX

UPDATE foo
SET id = CAST('1' AS INTEGER);

  {update_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {cast_expr}: integer notnull
    |     | {strlit '1'}: text notnull
    |     | {type_int}: integer
    | {update_from}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_delete_form ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  DELETE FROM bar WHERE id IN (SELECT *
    FROM x);
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_delete_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_delete_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}: ok
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {opt_where}: bool notnull
            | {in_pred}: bool notnull
              | {name id}: id: integer notnull
              | {select_stmt}: id: integer
                | {select_core_list}: select: { id: integer notnull }
                | | {select_core}: select: { id: integer notnull }
                |   | {select_expr_list_con}: select: { id: integer notnull }
                |     | {select_expr_list}: select: { id: integer notnull }
                |     | | {star}: select: { id: integer notnull }
                |     | {select_from_etc}: TABLE { x: x }
                |       | {table_or_subquery_list}: TABLE { x: x }
                |       | | {table_or_subquery}: TABLE { x: x }
                |       |   | {name x}: TABLE { x: x }
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_delete_form_bogus_cte ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 'x')
  DELETE FROM bar WHERE id IN (SELECT *
    FROM x);
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0012: incompatible types in expression '_anon'

  {create_proc_stmt}: err
  | {name with_delete_form_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_delete_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: err
        |       | {select_core_list}: err
        |       | | {select_core}: err
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: err
        |       |     | {select_core}: select: { _anon: text notnull }
        |       |       | {select_expr_list_con}: select: { _anon: text notnull }
        |       |         | {select_expr_list}: select: { _anon: text notnull }
        |       |         | | {select_expr}: text notnull
        |       |         |   | {strlit 'x'}: text notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}
          | {name bar}
          | {opt_where}
            | {in_pred}
              | {name id}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {star}
                |     | {select_from_etc}
                |       | {table_or_subquery_list}
                |       | | {table_or_subquery}
                |       |   | {name x}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_delete_form_bogus_delete ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  DELETE FROM not_valid_table WHERE id IN (SELECT *
    FROM x);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0151: table in delete statement does not exist 'not_valid_table'

  {create_proc_stmt}: err
  | {name with_delete_form_bogus_delete}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_delete_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {delete_stmt}: err
          | {name not_valid_table}
          | {opt_where}
            | {in_pred}
              | {name id}
              | {select_stmt}
                | {select_core_list}
                | | {select_core}
                |   | {select_expr_list_con}
                |     | {select_expr_list}
                |     | | {star}
                |     | {select_from_etc}
                |       | {table_or_subquery_list}
                |       | | {table_or_subquery}
                |       |   | {name x}
                |       | {select_where}
                |         | {select_groupby}
                |           | {select_having}
                | {select_orderby}
                  | {select_limit}
                    | {select_offset}

The statement ending at line XXXX

CREATE PROC with_update_form ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_update_form}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {update_set}
            | {update_list}: ok
            | | {update_entry}: name: text
            |   | {name name}: name: text
            |   | {strlit 'xyzzy'}: text notnull
            | {update_from}
              | {update_where}
                | {opt_where}: bool notnull
                | | {in_pred}: bool notnull
                |   | {name id}: id: integer notnull
                |   | {select_stmt}: id: integer
                |     | {select_core_list}: select: { id: integer notnull }
                |     | | {select_core}: select: { id: integer notnull }
                |     |   | {select_expr_list_con}: select: { id: integer notnull }
                |     |     | {select_expr_list}: select: { id: integer notnull }
                |     |     | | {star}: select: { id: integer notnull }
                |     |     | {select_from_etc}: TABLE { x: x }
                |     |       | {table_or_subquery_list}: TABLE { x: x }
                |     |       | | {table_or_subquery}: TABLE { x: x }
                |     |       |   | {name x}: TABLE { x: x }
                |     |       | {select_where}
                |     |         | {select_groupby}
                |     |           | {select_having}
                |     | {select_orderby}
                |       | {select_limit}
                |         | {select_offset}
                | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_update_form_bogus_cte ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 'x')
  UPDATE bar
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0012: incompatible types in expression '_anon'

  {create_proc_stmt}: err
  | {name with_update_form_bogus_cte}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_update_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: err
        |       | {select_core_list}: err
        |       | | {select_core}: err
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: err
        |       |     | {select_core}: select: { _anon: text notnull }
        |       |       | {select_expr_list_con}: select: { _anon: text notnull }
        |       |         | {select_expr_list}: select: { _anon: text notnull }
        |       |         | | {select_expr}: text notnull
        |       |         |   | {strlit 'x'}: text notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}
          | {name bar}
          | {update_set}
            | {update_list}
            | | {update_entry}
            |   | {name name}
            |   | {strlit 'xyzzy'}
            | {update_from}
              | {update_where}
                | {opt_where}
                | | {in_pred}
                |   | {name id}
                |   | {select_stmt}
                |     | {select_core_list}
                |     | | {select_core}
                |     |   | {select_expr_list_con}
                |     |     | {select_expr_list}
                |     |     | | {star}
                |     |     | {select_from_etc}
                |     |       | {table_or_subquery_list}
                |     |       | | {table_or_subquery}
                |     |       |   | {name x}
                |     |       | {select_where}
                |     |         | {select_groupby}
                |     |           | {select_having}
                |     | {select_orderby}
                |       | {select_limit}
                |         | {select_offset}
                | {update_orderby}

The statement ending at line XXXX

CREATE PROC with_update_form_bogus_delete ()
BEGIN
  WITH
  x (id) AS (SELECT 1
  UNION ALL
  SELECT 2)
  UPDATE not_valid_table
  SET name = 'xyzzy'
    WHERE id IN (SELECT *
    FROM x);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0154: table in update statement does not exist 'not_valid_table'

  {create_proc_stmt}: err
  | {name with_update_form_bogus_delete}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_update_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: x: { id: integer notnull }
        |     | {cte_decl}: x: { id: integer notnull }
        |     | | {name x}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: UNION ALL: { _anon: integer notnull }
        |       | {select_core_list}: UNION ALL: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       | | | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | |   | {select_expr_list}: select: { _anon: integer notnull }
        |       | |   | | {select_expr}: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { _anon: integer notnull }
        |       |     | {select_core}: select: { _anon: integer notnull }
        |       |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | | {select_expr}: integer notnull
        |       |         |   | {int 2}: integer notnull
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {update_stmt}: err
          | {name not_valid_table}
          | {update_set}
            | {update_list}
            | | {update_entry}
            |   | {name name}
            |   | {strlit 'xyzzy'}
            | {update_from}
              | {update_where}
                | {opt_where}
                | | {in_pred}
                |   | {name id}
                |   | {select_stmt}
                |     | {select_core_list}
                |     | | {select_core}
                |     |   | {select_expr_list_con}
                |     |     | {select_expr_list}
                |     |     | | {star}
                |     |     | {select_from_etc}
                |     |       | {table_or_subquery_list}
                |     |       | | {table_or_subquery}
                |     |       |   | {name x}
                |     |       | {select_where}
                |     |         | {select_groupby}
                |     |           | {select_having}
                |     | {select_orderby}
                |       | {select_limit}
                |         | {select_offset}
                | {update_orderby}

The statement ending at line XXXX

DECLARE PROC out_cursor_proc () OUT (A INTEGER NOT NULL, B INTEGER NOT NULL) USING TRANSACTION;

  {declare_proc_stmt}: out_cursor_proc: { A: integer notnull, B: integer notnull } dml_proc uses_out
  | {proc_name_type}
  | | {name out_cursor_proc}: out_cursor_proc: { A: integer notnull, B: integer notnull } dml_proc uses_out
  | | {int 7}
  | {proc_params_stmts}
    | {typed_names}: out_cursor_proc: { A: integer notnull, B: integer notnull }
      | {typed_name}: A: integer notnull
      | | {name A}
      | | {notnull}: A: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: B: integer notnull
          | {name B}
          | {notnull}: B: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC decl1 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

  {create_proc_stmt}: ok
  | {name decl1}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_vars_type}: integer
        | {name_list}: i: integer variable
        | | {name i}: i: integer variable
        | {type_int}: integer

The statement ending at line XXXX

CREATE PROC decl1 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0186: duplicate stored proc name 'decl1'

  {create_proc_stmt}: err
  | {name decl1}: err
  | {proc_params_stmts}
    | {params}
    | | {param}
    |   | {param_detail}
    |     | {name id}
    |     | {type_int}
    | {stmt_list}
      | {declare_vars_type}
        | {name_list}
        | | {name i}
        | {type_int}

The statement ending at line XXXX

CREATE PROC decl2 (id INTEGER)
BEGIN
  DECLARE i INTEGER;
END;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC decl2 (id INTEGER) USING TRANSACTION
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : DECLARE PROC decl2 (id INTEGER)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0189: procedure declarations/definitions do not match 'decl2'

  {create_proc_stmt}: err
  | {name decl2}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_vars_type}: integer
        | {name_list}: i: integer variable
        | | {name i}: i: integer variable
        | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test, dummy_table, dummy_insert, dummy_select, dummy_result_set))
CREATE PROC autotest_all_attribute ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_test}: ok
  |     | {misc_attr_value_list}
  |       | {name dummy_table}: ok
  |       | {misc_attr_value_list}
  |         | {name dummy_insert}: ok
  |         | {misc_attr_value_list}
  |           | {name dummy_select}: ok
  |           | {misc_attr_value_list}
  |             | {name dummy_result_set}: ok
  | {create_proc_stmt}: autotest_all_attribute: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_all_attribute}: autotest_all_attribute: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name), (1, 'Nelly'), (-2, 'Babeth')), (foo, (id), (777)))))
CREATE PROC autotest_dummy_test_with_others_attributes ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: ok
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |           | | {name bar}: ok
  |           | | {misc_attr_value_list}
  |           |   | {misc_attr_value_list}: ok
  |           |   | | {name id}: ok
  |           |   | | {misc_attr_value_list}
  |           |   |   | {name name}: ok
  |           |   | {misc_attr_value_list}
  |           |     | {misc_attr_value_list}: ok
  |           |     | | {int 1}: ok
  |           |     | | {misc_attr_value_list}
  |           |     |   | {strlit 'Nelly'}: ok
  |           |     | {misc_attr_value_list}
  |           |       | {misc_attr_value_list}: ok
  |           |         | {uminus}: ok
  |           |         | | {int 2}: ok
  |           |         | {misc_attr_value_list}
  |           |           | {strlit 'Babeth'}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |               | {name foo}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                 | | {name id}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}: ok
  |                     | {int 777}: ok
  | {create_proc_stmt}: autotest_dummy_test_with_others_attributes: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_with_others_attributes}: autotest_dummy_test_with_others_attributes: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (id), (1), (2)))))
CREATE PROC autotest_dummy_test_without_other_attributes ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |             | | {name id}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {int 1}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 2}: ok
  | {create_proc_stmt}: autotest_dummy_test_without_other_attributes: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_without_other_attributes}: autotest_dummy_test_without_other_attributes: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (one)))))
CREATE PROC autotest_dummy_test_invalid_col_str_value ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {name one}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_str_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (id), (0.1)))))
CREATE PROC autotest_dummy_test_invalid_col_dbl_value ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: err
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |             | | {name id}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |                 | {dbl 0.1}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_dbl_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (rate), (1)))))
CREATE PROC autotest_dummy_test_long_col_with_int_value ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |             | | {name rate}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |                 | {int 1}: ok
  | {create_proc_stmt}: autotest_dummy_test_long_col_with_int_value: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_long_col_with_int_value}: autotest_dummy_test_long_col_with_int_value: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (bar, (rate), (-1)))))
CREATE PROC autotest_dummy_test_neg_long_col_with_int_value ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {name bar}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |             | | {name rate}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |                 | {uminus}: ok
  |                   | {int 1}: ok
  | {create_proc_stmt}: autotest_dummy_test_neg_long_col_with_int_value: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name autotest_dummy_test_neg_long_col_with_int_value}: autotest_dummy_test_neg_long_col_with_int_value: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), ('bogus')))))
CREATE PROC autotest_dummy_test_invalid_col_strlit_value ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {strlit 'bogus'}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_strlit_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (1L)))))
CREATE PROC autotest_dummy_test_invalid_col_lng_value ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0276: autotest attribute 'dummy_test' has invalid value type in 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {longint 1}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_lng_value}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, id, (1), (2)))))
CREATE PROC autotest_dummy_test_invalid_col_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (column name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                 | | {int 1}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}: ok
  |                     | {int 2}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_invalid_col_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), (1, 2)))))
CREATE PROC autotest_dummy_test_too_many_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (too many column values) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 1}: ok
  |                   | {misc_attr_value_list}
  |                     | {int 2}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_too_many_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name), (1)))))
CREATE PROC autotest_dummy_test_missing_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (mismatch number of column and values) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | | {misc_attr_value_list}
  |               |   | {name name}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_missing_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id, name)))))
CREATE PROC autotest_dummy_test_no_value_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (column value should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |                 | {name id}: ok
  |                 | {misc_attr_value_list}
  |                   | {name name}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_no_value_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (1, (id), (1)))))
CREATE PROC autotest_bogus_table_name_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0273: autotest attribute has incorrect format (table name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: err
  |             | {int 1}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_bogus_table_name_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (1), (1)))))
CREATE PROC autotest_bogus_colum_name_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (column name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {int 1}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_bogus_colum_name_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (id), 1))))
CREATE PROC autotest_colum_value_incorrect_format ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0273: autotest attribute has incorrect format (column value should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_colum_value_incorrect_format}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bar, (bogus_col), (1), (2)))))
CREATE PROC autotest_dummy_test_bogus_col_name ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0275: autotest attribute 'dummy_test' has non existent column 'bogus_col'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name bogus_col}: err
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                 | | {int 1}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}: ok
  |                     | {int 2}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_bogus_col_name}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_test, (bogus_table, (id), (1), (2)))))
CREATE PROC autotest_dummy_test_bogus_table_name ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0274: autotest attribute 'dummy_test' has non existent table 'bogus_table'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_test}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |             | {name bogus_table}: err
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                 | | {int 1}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}: ok
  |                     | {int 2}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_bogus_table_name}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_bogus))
CREATE PROC autotest_dummy_bogus ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0278: autotest attribute name is not valid 'dummy_bogus'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_bogus}: err
  | {create_proc_stmt}: err
    | {name autotest_dummy_bogus}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_table, (dummy_bogus)))
CREATE PROC autotest_bogus_nested_attribute ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0277: autotest has incorrect format 'found nested attributes that don't start with dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_table}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name dummy_bogus}: err
  | {create_proc_stmt}: err
    | {name autotest_bogus_nested_attribute}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test, (bar, (id), (1))))
CREATE PROC autotest_dummy_test_not_nested ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0277: autotest has incorrect format 'found nested attributes that don't start with dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_test}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name bar}: err
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: ok
  |           | | {name id}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |               | {int 1}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_not_nested}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test, bar, ((id, name), (1, 'x'))))
CREATE PROC autotest_dummy_test_not_nested_2 ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0278: autotest attribute name is not valid 'bar'
test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0277: autotest has incorrect format 'found nested attributes that don't start with dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_test}: ok
  |     | {misc_attr_value_list}
  |       | {name bar}: err
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {misc_attr_value_list}: err
  |           | | {name id}: ok
  |           | | {misc_attr_value_list}
  |           |   | {name name}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |               | {int 1}: ok
  |               | {misc_attr_value_list}
  |                 | {strlit 'x'}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_not_nested_2}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, ((bar, (id), (1), (2))))))
CREATE PROC autotest_dummy_test_with_col_double_nested ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0273: autotest attribute has incorrect format (table name should be nested) in 'dummy_test'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: err
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: err
  |           | {misc_attr_value_list}: ok
  |             | {name bar}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {name id}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                 | | {int 1}: ok
  |                 | {misc_attr_value_list}
  |                   | {misc_attr_value_list}: ok
  |                     | {int 2}: ok
  | {create_proc_stmt}: err
    | {name autotest_dummy_test_with_col_double_nested}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=dummy_table)
CREATE PROC autotest_incorrect_formatting ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0277: autotest has incorrect format 'no test types specified'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {name dummy_table}: err
  | {create_proc_stmt}: err
    | {name autotest_incorrect_formatting}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TEMP TABLE table1(
  id INTEGER
);

  {create_table_stmt}: table1: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table1}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TEMP TABLE table2(
  id INTEGER
);

  {create_table_stmt}: table2: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name table2}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE not_a_temp_table(
  id INTEGER
);

  {create_table_stmt}: not_a_temp_table: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name not_a_temp_table}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodropper ()
BEGIN
  SELECT *
    FROM table1;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: autodropper: { id: integer } dml_proc
    | {name autodropper}: autodropper: { id: integer } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(not_an_object))
CREATE PROC autodropper_not_an_objecte ()
BEGIN
  SELECT *
    FROM table1;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0181: autodrop temp table does not exist 'not_an_object'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name not_an_object}: ok
  | {create_proc_stmt}: err
    | {name autodropper_not_an_objecte}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(ViewShape))
CREATE PROC autodropper_dropping_view ()
BEGIN
  SELECT *
    FROM table1;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0182: autodrop target is not a table 'ViewShape'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name ViewShape}: ok
  | {create_proc_stmt}: err
    | {name autodropper_dropping_view}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(not_a_temp_table))
CREATE PROC autodropper_not_temp_table ()
BEGIN
  SELECT *
    FROM table1;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0183: autodrop target must be a temporary table 'not_a_temp_table'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name not_a_temp_table}: ok
  | {create_proc_stmt}: err
    | {name autodropper_not_temp_table}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer }
          | {select_core_list}: select: { id: integer }
          | | {select_core}: select: { id: integer }
          |   | {select_expr_list_con}: select: { id: integer }
          |     | {select_expr_list}: select: { id: integer }
          |     | | {star}: select: { id: integer }
          |     | {select_from_etc}: TABLE { table1: table1 }
          |       | {table_or_subquery_list}: TABLE { table1: table1 }
          |       | | {table_or_subquery}: TABLE { table1: table1 }
          |       |   | {name table1}: TABLE { table1: table1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodrop_not_really_a_result_set_proc ()
BEGIN
  DECLARE i INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0234: autodrop annotation can only go on a procedure that returns a result set 'autodrop_not_really_a_result_set_proc'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: err
    | {name autodrop_not_really_a_result_set_proc}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: i: integer variable
          | | {name i}: i: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:autodrop=(table1, table2))
CREATE PROC autodrop_no_db ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS id;
  FETCH c(id) FROM VALUES(1);
  OUT c;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0236: autodrop annotation can only go on a procedure that uses the database 'autodrop_no_db'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autodrop}
  |   | {misc_attr_value_list}: ok
  |     | {name table1}: ok
  |     | {misc_attr_value_list}
  |       | {name table2}: ok
  | {create_proc_stmt}: err
    | {name autodrop_no_db}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_cursor_like_select}: C: select: { id: integer notnull } variable shape_storage value_cursor
        | | {name C}: C: select: { id: integer notnull } variable shape_storage value_cursor
        | | {select_stmt}: select: { id: integer notnull }
        |   | {select_core_list}: select: { id: integer notnull }
        |   | | {select_core}: select: { id: integer notnull }
        |   |   | {select_expr_list_con}: select: { id: integer notnull }
        |   |     | {select_expr_list}: select: { id: integer notnull }
        |   |     | | {select_expr}: id: integer notnull
        |   |     |   | {int 1}: integer notnull
        |   |     |   | {opt_as_alias}
        |   |     |     | {name id}
        |   |     | {select_from_etc}: ok
        |   |       | {select_where}
        |   |         | {select_groupby}
        |   |           | {select_having}
        |   | {select_orderby}
        |     | {select_limit}
        |       | {select_offset}
        | {fetch_values_stmt}: ok
        | | {name_columns_values}
        |   | {name c}: C: select: { id: integer notnull } variable shape_storage value_cursor
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        | {out_stmt}: C: select: { id: integer notnull } variable shape_storage value_cursor
          | {name c}: C: select: { id: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE TABLE referenceable(
  a INTEGER PRIMARY KEY,
  b REAL UNIQUE,
  c TEXT,
  d TEXT,
  e LONG_INT
);

  {create_table_stmt}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable}
  | {col_key_list}
    | {col_def}: a: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: b: real unique_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name b}
      |   | | {type_real}: real
      |   | {col_attrs_unique}: ok
      | {col_key_list}
        | {col_def}: c: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c}
        |     | {type_text}: text
        | {col_key_list}
          | {col_def}: d: text
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name d}
          |     | {type_text}: text
          | {col_key_list}
            | {col_def}: e: longint
              | {col_def_type_attrs}: ok
                | {col_def_name_type}
                  | {name e}
                  | {type_long}: longint

The statement ending at line XXXX

CREATE TABLE referenceable_2(
  a INTEGER,
  b REAL,
  PRIMARY KEY (a, b)
);

  {create_table_stmt}: referenceable_2: { a: integer notnull partial_pk, b: real notnull partial_pk }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable_2}
  | {col_key_list}
    | {col_def}: a: integer notnull partial_pk
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name a}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: b: real notnull partial_pk
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name b}
      |     | {type_real}: real
      | {col_key_list}
        | {pk_def}
          | {indexed_columns_conflict_clause}
            | {indexed_columns}
              | {indexed_column}
              | | {name a}: a: integer
              | {indexed_columns}
                | {indexed_column}
                  | {name b}: b: real

The statement ending at line XXXX

CREATE UNIQUE INDEX referenceable_index ON referenceable (c, d);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name referenceable_index}
  | | {name referenceable}
  | {flags_names_attrs}
    | {int 1}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
          | | {name c}: c: text
          | {indexed_columns}
            | {indexed_column}
              | {name d}: d: text

The statement ending at line XXXX

CREATE TABLE reference_pk(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES referenceable (a)
);

  {create_table_stmt}: reference_pk: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name a}: a: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_2_pk(
  id INTEGER,
  size REAL,
  FOREIGN KEY (id, size) REFERENCES referenceable_2 (a, b)
);

  {create_table_stmt}: reference_2_pk: { id: integer foreign_key, size: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_2_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: size: real
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name size}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: ok
          | {fk_info}
            | {name_list}
            | | {name id}: id: integer
            | | {name_list}
            |   | {name size}: size: real
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable_2}
              | | {name_list}
              |   | {name a}: a: integer notnull partial_pk
              |   | {name_list}
              |     | {name b}: b: real notnull partial_pk
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_2_wrong_order_pk(
  id INTEGER,
  size REAL,
  FOREIGN KEY (size, id) REFERENCES referenceable_2 (b, a)
);

  {create_table_stmt}: reference_2_wrong_order_pk: { id: integer foreign_key, size: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_2_wrong_order_pk}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: size: real
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name size}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: ok
          | {fk_info}
            | {name_list}
            | | {name size}: size: real
            | | {name_list}
            |   | {name id}: id: integer
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable_2}
              | | {name_list}
              |   | {name b}: b: real notnull partial_pk
              |   | {name_list}
              |     | {name a}: a: integer notnull partial_pk
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_uk(
  id REAL,
  FOREIGN KEY (id) REFERENCES referenceable (b)
);

  {create_table_stmt}: reference_uk: { id: real foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_uk}
  | {col_key_list}
    | {col_def}: id: real
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_real}: real
    | {col_key_list}
      | {fk_def}: ok
        | {fk_info}
          | {name_list}
          | | {name id}: id: real
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name b}: b: real
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_pk_and_uk(
  id1 INTEGER,
  id2 REAL,
  FOREIGN KEY (id1, id2) REFERENCES referenceable (a, b)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk_and_uk}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: real
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_real}: real
      | {col_key_list}
        | {fk_def}: err
          | {fk_info}
            | {name_list}
            | | {name id1}: id1: integer
            | | {name_list}
            |   | {name id2}: id2: real
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable}
              | | {name_list}
              |   | {name a}: a: integer notnull
              |   | {name_list}
              |     | {name b}: b: real
              | {int 0}

The statement ending at line XXXX

CREATE TABLE referenceable_unique_index(
  id TEXT,
  label TEXT,
  FOREIGN KEY (id, label) REFERENCES referenceable (c, d)
);

  {create_table_stmt}: referenceable_unique_index: { id: text foreign_key, label: text foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name referenceable_unique_index}
  | {col_key_list}
    | {col_def}: id: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: label: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name label}
      |     | {type_text}: text
      | {col_key_list}
        | {fk_def}: ok
          | {fk_info}
            | {name_list}
            | | {name id}: id: text
            | | {name_list}
            |   | {name label}: label: text
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable}
              | | {name_list}
              |   | {name c}: c: text
              |   | {name_list}
              |     | {name d}: d: text
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_pk_and_unique_index(
  id1 INTEGER,
  id2 TEXT,
  FOREIGN KEY (id1, id2) REFERENCES referenceable (a, c)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_pk_and_unique_index}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {fk_def}: err
          | {fk_info}
            | {name_list}
            | | {name id1}: id1: integer
            | | {name_list}
            |   | {name id2}: id2: text
            | {fk_target_options}
              | {fk_target}
              | | {name referenceable}
              | | {name_list}
              |   | {name a}: a: integer notnull
              |   | {name_list}
              |     | {name c}: c: text
              | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_uk_and_unique_index(
  id1 REAL,
  id2 TEXT,
  id3 TEXT,
  FOREIGN KEY (id1, id2, id3) REFERENCES referenceable (b, c, d)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_uk_and_unique_index}
  | {col_key_list}
    | {col_def}: id1: real
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_real}: real
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: id3: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name id3}
        |     | {type_text}: text
        | {col_key_list}
          | {fk_def}: err
            | {fk_info}
              | {name_list}
              | | {name id1}: id1: real
              | | {name_list}
              |   | {name id2}: id2: text
              |   | {name_list}
              |     | {name id3}: id3: text
              | {fk_target_options}
                | {fk_target}
                | | {name referenceable}
                | | {name_list}
                |   | {name b}: b: real
                |   | {name_list}
                |     | {name c}: c: text
                |     | {name_list}
                |       | {name d}: d: text
                | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_column(
  id LONG_INT PRIMARY KEY,
  FOREIGN KEY (id) REFERENCES referenceable (e)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_column}
  | {col_key_list}
    | {col_def}: id: longint notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_long}: longint
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name id}: id: longint notnull
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name e}: e: longint
            | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_columns(
  id1 TEXT PRIMARY KEY,
  id2 TEXT,
  id3 TEXT,
  FOREIGN KEY (id1, id2, id3) REFERENCES referenceable (c, d, e)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_columns}
  | {col_key_list}
    | {col_def}: id1: text notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id1}
    |   | | {type_text}: text
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: id3: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name id3}
        |     | {type_text}: text
        | {col_key_list}
          | {fk_def}: err
            | {fk_info}
              | {name_list}
              | | {name id1}: id1: text notnull
              | | {name_list}
              |   | {name id2}: id2: text
              |   | {name_list}
              |     | {name id3}: id3: text
              | {fk_target_options}
                | {fk_target}
                | | {name referenceable}
                | | {name_list}
                |   | {name c}: c: text
                |   | {name_list}
                |     | {name d}: d: text
                |     | {name_list}
                |       | {name e}: e: longint
                | {int 0}

The statement ending at line XXXX

CREATE TABLE reference_not_referenceable_column(
  id TEXT,
  FOREIGN KEY (id) REFERENCES referenceable (c)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'referenceable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name reference_not_referenceable_column}
  | {col_key_list}
    | {col_def}: id: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name id}: id: text
          | {fk_target_options}
            | {fk_target}
            | | {name referenceable}
            | | {name_list}
            |   | {name c}: c: text
            | {int 0}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON DELETE;

  {enforce_strict_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON UPDATE;

  {enforce_normal_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON DELETE;

  {enforce_normal_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON DELETE;

  {enforce_strict_stmt}: ok
  | {int 2}

The statement ending at line XXXX

CREATE TABLE fk_strict_ok(
  id INTEGER REFERENCES foo (id) ON UPDATE CASCADE ON DELETE CASCADE
);

  {create_table_stmt}: fk_strict_ok: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_ok}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 51}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_update(
  id INTEGER REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in col_attrs_fk : CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_update}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_delete(
  id INTEGER REFERENCES foo (id) ON UPDATE NO ACTION
);

test/sem_test.sql:XXXX:1: error: in col_attrs_fk : CQL0238: strict FK validation requires that some ON DELETE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_delete}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 80}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_delete_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id) ON UPDATE NO ACTION
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0238: strict FK validation requires that some ON DELETE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_delete_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 80}

The statement ending at line XXXX

CREATE TABLE fk_strict_failure_update_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_failure_update_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_strict_success_loose(
  id INTEGER,
  FOREIGN KEY (id) REFERENCES foo (id) ON UPDATE CASCADE ON DELETE NO ACTION
);

  {create_table_stmt}: fk_strict_success_loose: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_success_loose}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {fk_def}: ok
        | {fk_info}
          | {name_list}
          | | {name id}: id: integer
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 53}

The statement ending at line XXXX

@ATTRIBUTE(cql:identity=(col1, col3))
CREATE PROC invalid_identity ()
BEGIN
  SELECT 1 AS col1, 2 AS col2, 3 AS data;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: procedure identity column does not exist in result set 'col3'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name identity}
  |   | {misc_attr_value_list}: ok
  |     | {name col1}: ok
  |     | {misc_attr_value_list}
  |       | {name col3}: ok
  | {create_proc_stmt}: err
    | {name invalid_identity}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          | {select_core_list}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          | | {select_core}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |   | {select_expr_list_con}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |     | {select_expr_list}: select: { col1: integer notnull, col2: integer notnull, data: integer notnull }
          |     | | {select_expr}: col1: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name col1}
          |     | | {select_expr_list}
          |     |   | {select_expr}: col2: integer notnull
          |     |   | | {int 2}: integer notnull
          |     |   | | {opt_as_alias}
          |     |   |   | {name col2}
          |     |   | {select_expr_list}
          |     |     | {select_expr}: data: integer notnull
          |     |       | {int 3}: integer notnull
          |     |       | {opt_as_alias}
          |     |         | {name data}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:identity=(col1, col3))
CREATE PROC no_result_set_identity ()
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0240: identity annotation can only go on a procedure that returns a result set 'no_result_set_identity'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name identity}
  |   | {misc_attr_value_list}: ok
  |     | {name col1}: ok
  |     | {misc_attr_value_list}
  |       | {name col3}: ok
  | {create_proc_stmt}: err
    | {name no_result_set_identity}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC test_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: test_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_base_fragment}: test_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_two (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM plugin_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: test_extension_fragment_union: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_extension_fragment_union}: test_extension_fragment_union: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_two: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: plugin_two: { x: integer notnull, y: text, z: longint }
          |       | | {name plugin_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { plugin_two: plugin_two }
            |       | {table_or_subquery_list}: TABLE { plugin_two: plugin_two }
            |       | | {table_or_subquery}: TABLE { plugin_two: plugin_two }
            |       |   | {name plugin_two}: TABLE { plugin_two: plugin_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_two_a (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM plugin_two_a;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: test_extension_fragment_union_two: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_extension_fragment_union_two}: test_extension_fragment_union_two: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_two_a: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: plugin_two_a: { x: integer notnull, y: text, z: longint }
          |       | | {name plugin_two_a}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { plugin_two_a: plugin_two_a }
            |       | {table_or_subquery_list}: TABLE { plugin_two_a: plugin_two_a }
            |       | | {table_or_subquery}: TABLE { plugin_two_a: plugin_two_a }
            |       |   | {name plugin_two_a}: TABLE { plugin_two_a: plugin_two_a }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=another_core)
CREATE PROC test_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  another_core (x, y) AS (SELECT T1.id, name
    FROM foo AS T1
    INNER JOIN bar AS T2 ON T1.id = T2.id
    WHERE T1.id = id_)
  SELECT *
    FROM another_core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name another_core}: ok
  | {create_proc_stmt}: test_base_fragment_two: { x: integer notnull, y: text } dml_proc
    | {name test_base_fragment_two}: test_base_fragment_two: { x: integer notnull, y: text } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: another_core: { x: integer notnull, y: text }
          |     | {cte_decl}: another_core: { x: integer notnull, y: text }
          |     | | {name another_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     | {select_stmt}: select: { id: integer notnull, name: text }
          |       | {select_core_list}: select: { id: integer notnull, name: text }
          |       | | {select_core}: select: { id: integer notnull, name: text }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {dot}: id: integer notnull
          |       |     | |   | {name T1}
          |       |     | |   | {name id}
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |     | {name name}: name: text
          |       |     | {select_from_etc}: JOIN { T1: foo, T2: bar }
          |       |       | {join_clause}: JOIN { T1: foo, T2: bar }
          |       |       | | {table_or_subquery}: TABLE { T1: foo }
          |       |       | | | {name foo}: TABLE { T1: foo }
          |       |       | | | {opt_as_alias}
          |       |       | |   | {name T1}
          |       |       | | {join_target_list}
          |       |       |   | {join_target}: JOIN { T1: foo, T2: bar }
          |       |       |     | {int 1} {join_inner}
          |       |       |     | {table_join}
          |       |       |       | {table_or_subquery}: TABLE { T2: bar }
          |       |       |       | | {name bar}: TABLE { T2: bar }
          |       |       |       | | {opt_as_alias}
          |       |       |       |   | {name T2}
          |       |       |       | {join_cond}: JOIN { T1: foo, T2: bar }
          |       |       |         | {on}: bool notnull
          |       |       |         | {eq}: bool notnull
          |       |       |           | {dot}: id: integer notnull
          |       |       |           | | {name T1}
          |       |       |           | | {name id}
          |       |       |           | {dot}: id: integer notnull
          |       |       |             | {name T2}
          |       |       |             | {name id}
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {dot}: id: integer notnull
          |       |         |   | | {name T1}
          |       |         |   | | {name id}
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text }
            | {select_core_list}: select: { x: integer notnull, y: text }
            | | {select_core}: select: { x: integer notnull, y: text }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
            |     | {select_expr_list}: select: { x: integer notnull, y: text }
            |     | | {star}: select: { x: integer notnull, y: text }
            |     | {select_from_etc}: TABLE { another_core: another_core }
            |       | {table_or_subquery_list}: TABLE { another_core: another_core }
            |       | | {table_or_subquery}: TABLE { another_core: another_core }
            |       |   | {name another_core}: TABLE { another_core: another_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC test_duplicate_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0256: fragment name conflicts with existing base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_duplicate_base_fragment}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_one)
CREATE PROC bad_base_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_one (id, name, rate) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT id
    FROM core_one;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core_one'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_one}: ok
  | {create_proc_stmt}: err
    | {name bad_base_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_one: { id: integer notnull, name: text, rate: longint }
          |     | {cte_decl}: core_one: { id: integer notnull, name: text, rate: longint }
          |     | | {name core_one}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name name}
          |     |     | {name_list}
          |     |       | {name rate}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull }
            | | {select_core}: select: { id: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull }
            |     | | {select_expr}: id: integer notnull
            |     |   | {name id}: id: integer notnull
            |     | {select_from_etc}: TABLE { core_one: core_one }
            |       | {table_or_subquery_list}: TABLE { core_one: core_one }
            |       | | {table_or_subquery}: TABLE { core_one: core_one }
            |       |   | {name core_one}: TABLE { core_one: core_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_two)
CREATE PROC bad_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_two (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core_two'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_two}: ok
  | {create_proc_stmt}: err
    | {name bad_base_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_two: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core_two: { x: integer notnull, y: text, z: longint }
          |     | | {name core_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { bar: bar }
            |       | {table_or_subquery_list}: TABLE { bar: bar }
            |       | | {table_or_subquery}: TABLE { bar: bar }
            |       |   | {name bar}: TABLE { bar: bar }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=bar)
CREATE PROC bad_base_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_three (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0253: base fragment must have only a single CTE named the same as the fragment 'bar'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name bar}: ok
  | {create_proc_stmt}: err
    | {name bad_base_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_three: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core_three: { x: integer notnull, y: text, z: longint }
          |     | | {name core_three}: err
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { bar: bar }
            |       | {table_or_subquery_list}: TABLE { bar: bar }
            |       | | {table_or_subquery}: TABLE { bar: bar }
            |       |   | {name bar}: TABLE { bar: bar }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=err_assembly_name)
CREATE PROC ext1 ()
BEGIN
  WITH
  err_assembly_name (id) AS (SELECT *
    FROM foo),
  ext1 (id) AS (SELECT *
    FROM err_assembly_name
  UNION ALL
  SELECT 1 AS id)
  SELECT *
    FROM ext1;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0253: base fragment must have only a single CTE named the same as the fragment 'err_assembly_name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name err_assembly_name}: ok
  | {create_proc_stmt}: err
    | {name ext1}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: err_assembly_name: { id: integer notnull }
          |   | | {cte_decl}: err_assembly_name: { id: integer notnull }
          |   | | | {name err_assembly_name}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | | {select_stmt}: select: { id: integer notnull }
          |   |   | {select_core_list}: select: { id: integer notnull }
          |   |   | | {select_core}: select: { id: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull }
          |   |   |     | | {star}: select: { id: integer notnull }
          |   |   |     | {select_from_etc}: TABLE { foo: foo }
          |   |   |       | {table_or_subquery_list}: TABLE { foo: foo }
          |   |   |       | | {table_or_subquery}: TABLE { foo: foo }
          |   |   |       |   | {name foo}: TABLE { foo: foo }
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: ext1: { id: integer notnull }
          |       | {cte_decl}: ext1: { id: integer notnull }
          |       | | {name ext1}
          |       | | {name_list}
          |       |   | {name id}
          |       | {select_stmt}: UNION ALL: { id: integer notnull }
          |         | {select_core_list}: UNION ALL: { id: integer notnull }
          |         | | {select_core}: select: { id: integer notnull }
          |         | | | {select_expr_list_con}: select: { id: integer notnull }
          |         | |   | {select_expr_list}: select: { id: integer notnull }
          |         | |   | | {star}: select: { id: integer notnull }
          |         | |   | {select_from_etc}: TABLE { err_assembly_name: err_assembly_name }
          |         | |     | {table_or_subquery_list}: TABLE { err_assembly_name: err_assembly_name }
          |         | |     | | {table_or_subquery}: TABLE { err_assembly_name: err_assembly_name }
          |         | |     |   | {name err_assembly_name}: TABLE { err_assembly_name: err_assembly_name }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { id: integer notnull }
          |         |     | {select_core}: select: { id: integer notnull }
          |         |       | {select_expr_list_con}: select: { id: integer notnull }
          |         |         | {select_expr_list}: select: { id: integer notnull }
          |         |         | | {select_expr}: id: integer notnull
          |         |         |   | {int 1}: integer notnull
          |         |         |   | {opt_as_alias}
          |         |         |     | {name id}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull }
            | {select_core_list}: select: { id: integer notnull }
            | | {select_core}: select: { id: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull }
            |     | | {star}: select: { id: integer notnull }
            |     | {select_from_etc}: TABLE { ext1: ext1 }
            |       | {table_or_subquery_list}: TABLE { ext1: ext1 }
            |       | | {table_or_subquery}: TABLE { ext1: ext1 }
            |       |   | {name ext1}: TABLE { ext1: ext1 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core_four)
CREATE PROC bad_base_fragment_four (id_ INTEGER NOT NULL)
BEGIN
  SELECT id, name, rate
    FROM bar
    WHERE id = id_;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core_four}: ok
  | {create_proc_stmt}: err
    | {name bad_base_fragment_four}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {select_expr}: id: integer notnull
          |     | | | {name id}: id: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text
          |     |   | | {name name}: name: text
          |     |   | {select_expr_list}
          |     |     | {select_expr}: rate: longint
          |     |       | {name rate}: rate: longint
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {opt_where}: bool notnull
          |         | | {eq}: bool notnull
          |         |   | {name id}: id: integer notnull
          |         |   | {name id_}: id_: integer notnull variable in
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TABLE plugin_table(
  id INTEGER PRIMARY KEY,
  name TEXT,
  flag BOOL
);

  {create_table_stmt}: plugin_table: { id: integer notnull primary_key, name: text, flag: bool }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name plugin_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: flag: bool
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name flag}
              | {type_bool}: bool

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_not_union_all (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  not_union_all (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z
  EXCEPT
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM not_union_all;
END;

test/sem_test.sql:XXXX:1: error: in select_core_compound : CQL0333: all the compound operators in this CTE must be UNION ALL 'not_union_all'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_extension_fragment_not_union_all}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: not_union_all: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: not_union_all: { x: integer notnull, y: text, z: longint }
          |       | | {name not_union_all}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: EXCEPT: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     |   | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     |   | | {select_expr}: x: integer notnull
          |         |     |   | | | {int 3}: integer notnull
          |         |     |   | | | {opt_as_alias}
          |         |     |   | |   | {name x}
          |         |     |   | | {select_expr_list}
          |         |     |   |   | {select_expr}: y: text notnull
          |         |     |   |   | | {strlit 'y'}: text notnull
          |         |     |   |   | | {opt_as_alias}
          |         |     |   |   |   | {name y}
          |         |     |   |   | {select_expr_list}
          |         |     |   |     | {select_expr}: z: longint notnull
          |         |     |   |       | {longint 5}: longint notnull
          |         |     |   |       | {opt_as_alias}
          |         |     |   |         | {name z}
          |         |     |   | {select_from_etc}: ok
          |         |     |     | {select_where}
          |         |     |       | {select_groupby}
          |         |     |         | {select_having}
          |         |     | {select_core_compound}
          |         |       | {int 4}
          |         |       | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |           | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |             | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |             | | {select_expr}: x: integer notnull
          |         |             | | | {int 3}: integer notnull
          |         |             | | | {opt_as_alias}
          |         |             | |   | {name x}
          |         |             | | {select_expr_list}
          |         |             |   | {select_expr}: y: text notnull
          |         |             |   | | {strlit 'y'}: text notnull
          |         |             |   | | {opt_as_alias}
          |         |             |   |   | {name y}
          |         |             |   | {select_expr_list}
          |         |             |     | {select_expr}: z: longint notnull
          |         |             |       | {longint 5}: longint notnull
          |         |             |       | {opt_as_alias}
          |         |             |         | {name z}
          |         |             | {select_from_etc}: ok
          |         |               | {select_where}
          |         |                 | {select_groupby}
          |         |                   | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { not_union_all: not_union_all }
            |       | {table_or_subquery_list}: TABLE { not_union_all: not_union_all }
            |       | | {table_or_subquery}: TABLE { not_union_all: not_union_all }
            |       |   | {name not_union_all}: TABLE { not_union_all: not_union_all }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: test_extension_fragment: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_extension_fragment}: test_extension_fragment: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_out_of_order (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  out_of_order (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM out_of_order;
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0332: all extension fragments that use UNION ALL must come before those that use LEFT OUTER JOIN 'out_of_order'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_extension_fragment_union_out_of_order}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: out_of_order: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: out_of_order: { x: integer notnull, y: text, z: longint }
          |       | | {name out_of_order}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { out_of_order: out_of_order }
            |       | {table_or_subquery_list}: TABLE { out_of_order: out_of_order }
            |       | | {table_or_subquery}: TABLE { out_of_order: out_of_order }
            |       |   | {name out_of_order}: TABLE { out_of_order: out_of_order }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_bad_args (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_one;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0322: fragment parameters must be exactly '(id_ INTEGER NOT NULL)'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_extension_fragment_bad_args}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=wrong_core)
CREATE PROC test_bad_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_one (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_one;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0255: fragment name is not a previously declared base fragment 'wrong_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name wrong_core}: err
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       |   | {name plugin_wrong_one}: TABLE { plugin_wrong_one: plugin_wrong_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core_not_exist (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_two (x, y, z, a) AS (SELECT core_not_exist.*, plugin_table.flag
    FROM core_not_exist
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core_not_exist.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_two;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0268: extension/assembly fragment must have the CTE named same as the base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core_not_exist: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core_not_exist: { x: integer notnull, y: text, z: longint }
          |   | | | {name core_not_exist}: err
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core_not_exist: core_not_exist: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core_not_exist}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core_not_exist: core_not_exist }
          |         |       | | | {name core_not_exist}: TABLE { core_not_exist: core_not_exist }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core_not_exist: core_not_exist, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core_not_exist}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       |   | {name plugin_wrong_two}: TABLE { plugin_wrong_two: plugin_wrong_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_extra (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_),
  plugin_wrong_three (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_three;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0258: extension fragment must add exactly one CTE; found extra named 'plugin_wrong_three'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_extra: { x: integer notnull, y: text, z: longint, a: bool }
          |     | | {cte_decl}: plugin_wrong_extra: { x: integer notnull, y: text, z: longint, a: bool }
          |     | | | {name plugin_wrong_extra}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | |       | {name_list}
          |     | |         | {name a}
          |     | | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |     |   |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |     |   |     | | | {name core}
          |     |   |     | | {select_expr_list}
          |     |   |     |   | {select_expr}: flag: bool
          |     |   |     |     | {dot}: flag: bool
          |     |   |     |       | {name plugin_table}
          |     |   |     |       | {name flag}
          |     |   |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       | | {table_or_subquery}: TABLE { core: core }
          |     |   |       | | | {name core}: TABLE { core: core }
          |     |   |       | | {join_target_list}
          |     |   |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       |     | {int 3} {join_left_outer}
          |     |   |       |     | {table_join}
          |     |   |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |     |   |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |     |   |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |     |   |       |         | {on}: bool
          |     |   |       |         | {and}: bool
          |     |   |       |           | {eq}: bool
          |     |   |       |           | | {dot}: name: text
          |     |   |       |           | | | {name plugin_table}
          |     |   |       |           | | | {name name}
          |     |   |       |           | | {dot}: y: text
          |     |   |       |           |   | {name core}
          |     |   |       |           |   | {name y}
          |     |   |       |           | {eq}: bool
          |     |   |       |             | {dot}: id: integer
          |     |   |       |             | | {name plugin_table}
          |     |   |       |             | | {name id}
          |     |   |       |             | {name id_}: id_: integer notnull variable in
          |     |   |       | {select_where}
          |     |   |         | {select_groupby}
          |     |   |           | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}: plugin_wrong_three: { x: integer notnull, y: text, z: longint, a: bool }
          |         | {cte_decl}: plugin_wrong_three: { x: integer notnull, y: text, z: longint, a: bool }
          |         | | {name plugin_wrong_three}
          |         | | {name_list}
          |         |   | {name x}
          |         |   | {name_list}
          |         |     | {name y}
          |         |     | {name_list}
          |         |       | {name z}
          |         |       | {name_list}
          |         |         | {name a}
          |         | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |           |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |           |     | | | {name core}
          |           |     | | {select_expr_list}
          |           |     |   | {select_expr}: flag: bool
          |           |     |     | {dot}: flag: bool
          |           |     |       | {name plugin_table}
          |           |     |       | {name flag}
          |           |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |           |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |           |       | | {table_or_subquery}: TABLE { core: core }
          |           |       | | | {name core}: TABLE { core: core }
          |           |       | | {join_target_list}
          |           |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |           |       |     | {int 3} {join_left_outer}
          |           |       |     | {table_join}
          |           |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |           |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |           |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |           |       |         | {on}: bool
          |           |       |         | {and}: bool
          |           |       |           | {eq}: bool
          |           |       |           | | {dot}: name: text
          |           |       |           | | | {name plugin_table}
          |           |       |           | | | {name name}
          |           |       |           | | {dot}: y: text
          |           |       |           |   | {name core}
          |           |       |           |   | {name y}
          |           |       |           | {eq}: bool
          |           |       |             | {dot}: id: integer
          |           |       |             | | {name plugin_table}
          |           |       |             | | {name id}
          |           |       |             | {name id_}: id_: integer notnull variable in
          |           |       | {select_where}
          |           |         | {select_groupby}
          |           |           | {select_having}
          |           | {select_orderby}
          |             | {select_limit}
          |               | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       |   | {name plugin_wrong_three}: TABLE { plugin_wrong_three: plugin_wrong_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_shape (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_shape (x, y, z, a) AS (SELECT core.*, 1 AS a
    FROM core)
  SELECT *
    FROM bogus_shape;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bogus_extension_shape}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_shape: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_shape: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_shape}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer notnull
          |         |     |     | {int 1}: integer notnull
          |         |     |     | {opt_as_alias}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: TABLE { core: core }
          |         |       | {table_or_subquery_list}: TABLE { core: core }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       |   | {name core}: TABLE { core: core }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_shape: bogus_shape }
            |       | {table_or_subquery_list}: TABLE { bogus_shape: bogus_shape }
            |       | | {table_or_subquery}: TABLE { bogus_shape: bogus_shape }
            |       |   | {name bogus_shape}: TABLE { bogus_shape: bogus_shape }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_data_source (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_not_a_table (x, y, z, a) AS (SELECT core.*, junk.a
    FROM (SELECT *
    FROM core) AS core
    INNER JOIN (SELECT 1 AS a) AS junk)
  SELECT *
    FROM bogus_not_a_table;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bogus_extension_data_source}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_not_a_table: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_not_a_table: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_not_a_table}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | {table_star}: core: select: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer notnull
          |         |     |     | {dot}: a: integer notnull
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: select, junk: select }
          |         |       | {join_clause}: JOIN { core: select, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: select }
          |         |       | | | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         |       | | | |     | {select_from_etc}: TABLE { core: core }
          |         |       | | | |       | {table_or_subquery_list}: TABLE { core: core }
          |         |       | | | |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | |       |   | {name core}: TABLE { core: core }
          |         |       | | | |       | {select_where}
          |         |       | | | |         | {select_groupby}
          |         |       | | | |           | {select_having}
          |         |       | | | | {select_orderby}
          |         |       | | |   | {select_limit}
          |         |       | | |     | {select_offset}
          |         |       | | | {opt_as_alias}
          |         |       | |   | {name core}
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: select, junk: select }
          |         |       |     | {int 1} {join_inner}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | {table_or_subquery_list}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | | {table_or_subquery}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       |   | {name bogus_not_a_table}: TABLE { bogus_not_a_table: bogus_not_a_table }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE VIEW core2 AS
SELECT 1 AS x, nullable("a") AS y, nullable(3L) AS z;

  {create_view_stmt}: core2: { x: integer notnull, y: text, z: longint }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name core2}
      | {select_stmt}: core2: { x: integer notnull, y: text, z: longint }
        | {select_core_list}: core2: { x: integer notnull, y: text, z: longint }
        | | {select_core}: core2: { x: integer notnull, y: text, z: longint }
        |   | {select_expr_list_con}: core2: { x: integer notnull, y: text, z: longint }
        |     | {select_expr_list}: core2: { x: integer notnull, y: text, z: longint }
        |     | | {select_expr}: x: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name x}
        |     | | {select_expr_list}
        |     |   | {select_expr}: y: text
        |     |   | | {call}: text
        |     |   | | | {name nullable}: text
        |     |   | | | {call_arg_list}
        |     |   | |   | {call_filter_clause}
        |     |   | |   | {arg_list}: ok
        |     |   | |     | {strlit 'a'}: text notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name y}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: z: longint
        |     |       | {call}: longint
        |     |       | | {name nullable}: longint
        |     |       | | {call_arg_list}
        |     |       |   | {call_filter_clause}
        |     |       |   | {arg_list}: ok
        |     |       |     | {longint 3}: longint notnull
        |     |       | {opt_as_alias}
        |     |         | {name z}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bogus_extension_table_name (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_wrong_table (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core2 AS core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk)
  SELECT *
    FROM bogus_wrong_table;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bogus_extension_table_name}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_wrong_table: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_wrong_table: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_wrong_table}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core2: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core2, junk: select }
          |         |       | {join_clause}: JOIN { core: core2, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core2 }
          |         |       | | | {name core2}: TABLE { core: core2 }
          |         |       | | | {opt_as_alias}
          |         |       | |   | {name core}
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core2, junk: select }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | {table_or_subquery_list}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | | {table_or_subquery}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       |   | {name bogus_wrong_table}: TABLE { bogus_wrong_table: bogus_wrong_table }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_four (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z, a) AS (SELECT 1, nullable("a"), nullable(3L), 4),
  plugin_wrong_four (x, y, z, a, flag) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_four;
END;

test/sem_test.sql:XXXX:1: error: in cte_decl : CQL0268: extension/assembly fragment must use base CTE column list same as from the base fragment 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_four}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |   | | {cte_decl}: err
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | |       | {name_list}
          |   | |         | {name a}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, _anon: integer notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |     | | {call}: longint
          |   |   |     |     |   | {name nullable}: longint
          |   |   |     |     |   | {call_arg_list}
          |   |   |     |     |     | {call_filter_clause}
          |   |   |     |     |     | {arg_list}: ok
          |   |   |     |     |       | {longint 3}: longint notnull
          |   |   |     |     | {select_expr_list}
          |   |   |     |       | {select_expr}: integer notnull
          |   |   |     |         | {int 4}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_four: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |       | {cte_decl}: plugin_wrong_four: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |       | | {name plugin_wrong_four}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       |         | {name_list}
          |       |           | {name flag}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull, flag: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       |   | {name plugin_wrong_four}: TABLE { plugin_wrong_four: plugin_wrong_four }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_where_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk
    WHERE core.x = 1)
  SELECT *
    FROM bogus_extra_clauses;
END;

test/sem_test.sql:XXXX:1: error: in select_from_etc : CQL0320: extension fragment CTE must have a FROM clause and no other top level clauses 'bogus_extra_clauses'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_where_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_extra_clauses}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core, junk: select }
          |         |       | {join_clause}: JOIN { core: core, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, junk: select }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {opt_where}: bool notnull
          |         |         | | {eq}: bool notnull
          |         |         |   | {dot}: x: integer notnull
          |         |         |   | | {name core}
          |         |         |   | | {name x}
          |         |         |   | {int 1}: integer notnull
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       |   | {name bogus_extra_clauses}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_limit_in_union_all (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses2 (x, y, z) AS (SELECT *
    FROM core
  UNION ALL
  SELECT *
    FROM core
  LIMIT 1)
  SELECT *
    FROM bogus_extra_clauses2;
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0331: extension fragment CTE must have not have ORDER BY or LIMIT clauses 'bogus_extra_clauses2'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_limit_in_union_all}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses2: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: bogus_extra_clauses2: { x: integer notnull, y: text, z: longint }
          |       | | {name bogus_extra_clauses2}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |         | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_from_etc}: TABLE { core: core }
          |         |           | {table_or_subquery_list}: TABLE { core: core }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           |   | {name core}: TABLE { core: core }
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {opt_limit}: integer notnull
          |             | | {int 1}: integer notnull
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       |   | {name bogus_extra_clauses2}: TABLE { bogus_extra_clauses2: bogus_extra_clauses2 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_limit_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_extra_clauses (x, y, z, a) AS (SELECT core.*, junk.a
    FROM core
    LEFT OUTER JOIN (SELECT 1 AS a) AS junk
  LIMIT 3)
  SELECT *
    FROM bogus_extra_clauses;
END;

test/sem_test.sql:XXXX:1: error: in select_from_etc : CQL0320: extension fragment CTE must have a FROM clause and no other top level clauses 'bogus_extra_clauses'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_limit_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | {cte_decl}: bogus_extra_clauses: { x: integer notnull, y: text, z: longint, a: integer }
          |       | | {name bogus_extra_clauses}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: a: integer
          |         |     |     | {dot}: a: integer
          |         |     |       | {name junk}
          |         |     |       | {name a}
          |         |     | {select_from_etc}: JOIN { core: core, junk: select }
          |         |       | {join_clause}: JOIN { core: core, junk: select }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, junk: select }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { junk: select }
          |         |       |         | {select_stmt}: select: { a: integer notnull }
          |         |       |         | | {select_core_list}: select: { a: integer notnull }
          |         |       |         | | | {select_core}: select: { a: integer notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { a: integer notnull }
          |         |       |         | |     | {select_expr_list}: select: { a: integer notnull }
          |         |       |         | |     | | {select_expr}: a: integer notnull
          |         |       |         | |     |   | {int 1}: integer notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name a}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name junk}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {opt_limit}: integer notnull
          |             | | {int 3}: integer notnull
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer }
            |     | {select_from_etc}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {table_or_subquery_list}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | | {table_or_subquery}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       |   | {name bogus_extra_clauses}: TABLE { bogus_extra_clauses: bogus_extra_clauses }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_missing_from_in_cte (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  bogus_missing_from (x, y, z, a) AS (SELECT 1, nullable("a"), nullable(3L), 1 AS a)
  SELECT *
    FROM bogus_missing_from;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_missing_from_in_cte}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: bogus_missing_from: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | {cte_decl}: bogus_missing_from: { x: integer notnull, y: text, z: longint, a: integer notnull }
          |       | | {name bogus_missing_from}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint, a: integer notnull }
          |         |     | | {select_expr}: integer notnull
          |         |     | | | {int 1}: integer notnull
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: text
          |         |     |   | | {call}: text
          |         |     |   |   | {name nullable}: text
          |         |     |   |   | {call_arg_list}
          |         |     |   |     | {call_filter_clause}
          |         |     |   |     | {arg_list}: ok
          |         |     |   |       | {strlit 'a'}: text notnull
          |         |     |   | {select_expr_list}
          |         |     |     | {select_expr}: longint
          |         |     |     | | {call}: longint
          |         |     |     |   | {name nullable}: longint
          |         |     |     |   | {call_arg_list}
          |         |     |     |     | {call_filter_clause}
          |         |     |     |     | {arg_list}: ok
          |         |     |     |       | {longint 3}: longint notnull
          |         |     |     | {select_expr_list}
          |         |     |       | {select_expr}: a: integer notnull
          |         |     |         | {int 1}: integer notnull
          |         |     |         | {opt_as_alias}
          |         |     |           | {name a}
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: integer notnull }
            |     | {select_from_etc}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | {table_or_subquery_list}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | | {table_or_subquery}: TABLE { bogus_missing_from: bogus_missing_from }
            |       |   | {name bogus_missing_from}: TABLE { bogus_missing_from: bogus_missing_from }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_five (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_five (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_five;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0260: extension fragment CTE must be a simple left outer join from 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_five}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_five: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_five: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_five}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 1} {join_inner}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool notnull
          |         |       |             | {dot}: id: integer notnull
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       |   | {name plugin_wrong_five}: TABLE { plugin_wrong_five: plugin_wrong_five }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_six (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_six (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT plugin_wrong_six.x
    FROM plugin_wrong_six;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM plugin_wrong_six'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_six}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_six: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_six: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_six}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {select_expr}: x: integer notnull
            |     |   | {dot}: x: integer notnull
            |     |     | {name plugin_wrong_six}
            |     |     | {name x}
            |     | {select_from_etc}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       |   | {name plugin_wrong_six}: TABLE { plugin_wrong_six: plugin_wrong_six }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_seven (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_seven (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = core.y AND plugin_table.id = id_)
  SELECT *
    FROM core;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM plugin_wrong_seven'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_seven}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_seven: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_seven: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_seven}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_eight (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_eight (x, y, z, a) AS (SELECT bar.*, plugin_table.flag
    FROM bar
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_eight;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_eight}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: plugin_wrong_eight: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_eight: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_eight}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         | {select_core_list}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         | | {select_core}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint, flag: bool }
          |         |     | | {table_star}: bar: bar: { id: integer notnull, name: text, rate: longint }
          |         |     | | | {name bar}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { bar: bar }
          |         |       | | | {name bar}: TABLE { bar: bar }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { bar: bar, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       |   | {name plugin_wrong_eight}: TABLE { plugin_wrong_eight: plugin_wrong_eight }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_nine (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y) AS (SELECT core.y, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0259: extension fragment CTE must select T.* from base CTE 'core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_nine}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: text, y: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: plugin_wrong_nine: { x: text, y: bool }
          |       | {cte_decl}: plugin_wrong_nine: { x: text, y: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       | {select_stmt}: select: { y: text, flag: bool }
          |         | {select_core_list}: select: { y: text, flag: bool }
          |         | | {select_core}: select: { y: text, flag: bool }
          |         |   | {select_expr_list_con}: err
          |         |     | {select_expr_list}: select: { y: text, flag: bool }
          |         |     | | {select_expr}: y: text
          |         |     | | | {dot}: y: text
          |         |     | |   | {name core}
          |         |     | |   | {name y}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: text, y: bool }
            | {select_core_list}: select: { x: text, y: bool }
            | | {select_core}: select: { x: text, y: bool }
            |   | {select_expr_list_con}: select: { x: text, y: bool }
            |     | {select_expr_list}: select: { x: text, y: bool }
            |     | | {star}: select: { x: text, y: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_nine_ok (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: test_bad_extension_fragment_nine_ok: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_extension_fragment_nine_ok}: test_bad_extension_fragment_nine_ok: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_ten (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  plugin_wrong_nine (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_nine;
END;

test/sem_test.sql:XXXX:1: error: in cte_table : CQL0266: extension fragment name conflicts with existing fragment 'plugin_wrong_nine'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_ten}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: err
          |       | {cte_decl}: plugin_wrong_nine: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name plugin_wrong_nine}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       |   | {name plugin_wrong_nine}: TABLE { plugin_wrong_nine: plugin_wrong_nine }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_eleven (id_ INTEGER NOT NULL)
BEGIN
  SELECT *
    FROM plugin_table;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_eleven}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, flag: bool }
          | {select_core_list}: select: { id: integer notnull, name: text, flag: bool }
          | | {select_core}: select: { id: integer notnull, name: text, flag: bool }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, flag: bool }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, flag: bool }
          |     | | {star}: select: { id: integer notnull, name: text, flag: bool }
          |     | {select_from_etc}: TABLE { plugin_table: plugin_table }
          |       | {table_or_subquery_list}: TABLE { plugin_table: plugin_table }
          |       | | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |       |   | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_with_wrong_base_sem_type (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3)),
  plugin_wrong_eleven (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_eleven;
END;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0287: extension/assembly fragment must add stub for base CTE with same types from base fragment (expected longint; found integer) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_with_wrong_base_sem_type}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: integer, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: integer }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: integer }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   |   | {select_expr_list_con}: err
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: integer }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: integer
          |   |   |     |       | {call}: integer
          |   |   |     |         | {name nullable}: integer
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {int 3}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_eleven: { x: integer notnull, y: text, z: integer, a: bool }
          |       | {cte_decl}: plugin_wrong_eleven: { x: integer notnull, y: text, z: integer, a: bool }
          |       | | {name plugin_wrong_eleven}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: integer, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: integer }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: integer, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: integer, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: integer, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       |   | {name plugin_wrong_eleven}: TABLE { plugin_wrong_eleven: plugin_wrong_eleven }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_with_wrong_base_nullability (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), 3L),
  plugin_wrong_twelve (x, y, z, a) AS (SELECT core.*, plugin_table.flag
    FROM core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM plugin_wrong_twelve;
END;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0288: extension/assembly fragment stub for base CTE column must be exact type match (including nullability) (expected longint; found longint notnull) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_with_wrong_base_nullability}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint notnull }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint notnull }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   |   | {select_expr_list_con}: err
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint notnull
          |   |   |     |       | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_wrong_twelve: { x: integer notnull, y: text, z: longint notnull, a: bool }
          |       | {cte_decl}: plugin_wrong_twelve: { x: integer notnull, y: text, z: longint notnull, a: bool }
          |       | | {name plugin_wrong_twelve}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull, flag: bool }
          |         |     | | {table_star}: core: core: { x: integer notnull, y: text, z: longint notnull }
          |         |     | | | {name core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { core: core }
          |         |       | | | {name core}: TABLE { core: core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint notnull, a: bool }
            |     | {select_from_etc}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | {table_or_subquery_list}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | | {table_or_subquery}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       |   | {name plugin_wrong_twelve}: TABLE { plugin_wrong_twelve: plugin_wrong_twelve }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_union_one (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_one (x, y, z, name) AS (SELECT core.*, CAST(NULL AS TEXT) AS name2
    FROM core
  UNION ALL
  SELECT core.*, plugin_table.name
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = "test")
  SELECT *
    FROM test_bad_extension_fragment_union_one;
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0058: if multiple selects, all column names must be identical so they have unambiguous names; error in column 4: 'name2' vs. 'name'
test/sem_test.sql:XXXX:1: error: in select_core : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 4 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 4 columns

only in 1st: name2 text
only in 2nd: name text


  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_union_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: err
          |       | {cte_decl}: test_bad_extension_fragment_union_one: { x: integer notnull, y: text, z: longint, name: text }
          |       | | {name test_bad_extension_fragment_union_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name name}
          |       | {select_stmt}: err
          |         | {select_core_list}: err
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name2: text }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name2: text }
          |         | |   | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         | |   | | | {name core}
          |         | |   | | {select_expr_list}
          |         | |   |   | {select_expr}: name2: text
          |         | |   |     | {cast_expr}: text
          |         | |   |     | | {null}: null
          |         | |   |     | | {type_text}: text
          |         | |   |     | {opt_as_alias}
          |         | |   |       | {name name2}
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: err
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         |         | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |         | | | {name core}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: name: text
          |         |         |     | {dot}: name: text
          |         |         |       | {name plugin_table}
          |         |         |       | {name name}
          |         |         | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           | | | {name core}: TABLE { core: core }
          |         |           | | {join_target_list}
          |         |           |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |     | {int 1} {join_inner}
          |         |           |     | {table_join}
          |         |           |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |           |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |           |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |         | {on}: bool
          |         |           |         | {eq}: bool
          |         |           |           | {dot}: name: text
          |         |           |           | | {name plugin_table}
          |         |           |           | | {name name}
          |         |           |           | {strlit 'test'}: text notnull
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name test_bad_extension_fragment_union_one}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_bad_extension_fragment_union_two (id_ INTEGER)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_two (x, y, z, name) AS (SELECT core.*, CAST(NULL AS TEXT) AS name
    FROM core
  UNION ALL
  SELECT core.*
    FROM core
    INNER JOIN plugin_table ON plugin_table.name = "test")
  SELECT *
    FROM test_bad_extension_fragment_union_two;
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0057: if multiple selects, all must have the same column count
test/sem_test.sql:XXXX:1: error: in select_core : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 4 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 3 columns

only in 1st: name text


  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_bad_extension_fragment_union_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: err
          |       | {cte_decl}: test_bad_extension_fragment_union_two: { x: integer notnull, y: text, z: longint, name: text }
          |       | | {name test_bad_extension_fragment_union_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name name}
          |       | {select_stmt}: err
          |         | {select_core_list}: err
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, name: text }
          |         | |   | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         | |   | | | {name core}
          |         | |   | | {select_expr_list}
          |         | |   |   | {select_expr}: name: text
          |         | |   |     | {cast_expr}: text
          |         | |   |     | | {null}: null
          |         | |   |     | | {type_text}: text
          |         | |   |     | {opt_as_alias}
          |         | |   |       | {name name}
          |         | |   | {select_from_etc}: TABLE { core: core }
          |         | |     | {table_or_subquery_list}: TABLE { core: core }
          |         | |     | | {table_or_subquery}: TABLE { core: core }
          |         | |     |   | {name core}: TABLE { core: core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: err
          |         |     | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         |         | | {table_star}: core: core: { x: integer notnull, y: text, z: longint }
          |         |         |   | {name core}
          |         |         | {select_from_etc}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | {join_clause}: JOIN { core: core, plugin_table: plugin_table }
          |         |           | | {table_or_subquery}: TABLE { core: core }
          |         |           | | | {name core}: TABLE { core: core }
          |         |           | | {join_target_list}
          |         |           |   | {join_target}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |     | {int 1} {join_inner}
          |         |           |     | {table_join}
          |         |           |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |           |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |           |       | {join_cond}: JOIN { core: core, plugin_table: plugin_table }
          |         |           |         | {on}: bool
          |         |           |         | {eq}: bool
          |         |           |           | {dot}: name: text
          |         |           |           | | {name plugin_table}
          |         |           |           | | {name name}
          |         |           |           | {strlit 'test'}: text notnull
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name test_bad_extension_fragment_union_two}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=core)
CREATE PROC test_extension_fragment_union_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  test_bad_extension_fragment_union_three (id, name, rate) AS (SELECT *
    FROM bar
  UNION ALL
  SELECT *
    FROM bar)
  SELECT *
    FROM test_bad_extension_fragment_union_three;
END;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0330: fragment must start with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name test_extension_fragment_union_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |   | | | {name core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: test_bad_extension_fragment_union_three: { id: integer notnull, name: text, rate: longint }
          |       | {cte_decl}: test_bad_extension_fragment_union_three: { id: integer notnull, name: text, rate: longint }
          |       | | {name test_bad_extension_fragment_union_three}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name name}
          |       |     | {name_list}
          |       |       | {name rate}
          |       | {select_stmt}: UNION ALL: { id: integer notnull, name: text, rate: longint }
          |         | {select_core_list}: UNION ALL: { id: integer notnull, name: text, rate: longint }
          |         | | {select_core}: err
          |         | | | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |         | |   | {select_from_etc}: TABLE { bar: bar }
          |         | |     | {table_or_subquery_list}: TABLE { bar: bar }
          |         | |     | | {table_or_subquery}: TABLE { bar: bar }
          |         | |     |   | {name bar}: TABLE { bar: bar }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |         |     | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |         |       | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |         |         | {select_from_etc}: TABLE { bar: bar }
          |         |           | {table_or_subquery_list}: TABLE { bar: bar }
          |         |           | | {table_or_subquery}: TABLE { bar: bar }
          |         |           |   | {name bar}: TABLE { bar: bar }
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
            | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
            | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
            |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
            |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
            |     | {select_from_etc}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | {table_or_subquery_list}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | | {table_or_subquery}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       |   | {name test_bad_extension_fragment_union_three}: TABLE { test_bad_extension_fragment_union_three: test_bad_extension_fragment_union_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core)
CREATE PROC test_assembly_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: test_assembly_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_assembly_base_fragment}: test_assembly_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core: assembly_core }
            |       | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
            |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
            |       |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_one (x, y, z) AS (SELECT *
    FROM assembly_core
  UNION ALL
  SELECT 3 AS x, "y" AS y, 5L AS z)
  SELECT *
    FROM assembly_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: test_assembly_extension_fragment_one: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_assembly_extension_fragment_one}: test_assembly_extension_fragment_one: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_one: { x: integer notnull, y: text, z: longint }
          |       | {cte_decl}: assembly_one: { x: integer notnull, y: text, z: longint }
          |       | | {name assembly_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |         | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |         | |   | {select_from_etc}: TABLE { assembly_core: assembly_core }
          |         | |     | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
          |         | |     | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         | |     |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |         |         | | {select_expr}: x: integer notnull
          |         |         | | | {int 3}: integer notnull
          |         |         | | | {opt_as_alias}
          |         |         | |   | {name x}
          |         |         | | {select_expr_list}
          |         |         |   | {select_expr}: y: text notnull
          |         |         |   | | {strlit 'y'}: text notnull
          |         |         |   | | {opt_as_alias}
          |         |         |   |   | {name y}
          |         |         |   | {select_expr_list}
          |         |         |     | {select_expr}: z: longint notnull
          |         |         |       | {longint 5}: longint notnull
          |         |         |       | {opt_as_alias}
          |         |         |         | {name z}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_one: assembly_one }
            |       | {table_or_subquery_list}: TABLE { assembly_one: assembly_one }
            |       | | {table_or_subquery}: TABLE { assembly_one: assembly_one }
            |       |   | {name assembly_one}: TABLE { assembly_one: assembly_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_two (x, y, z, a, b, c) AS (SELECT assembly_core.*, plugin_table.flag, min(plugin_table.id, 10L), min(plugin_table.id, 10.05)
    FROM assembly_core
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: test_assembly_extension_fragment_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real } dml_proc
    | {name test_assembly_extension_fragment_two}: test_assembly_extension_fragment_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | {cte_decl}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | {name assembly_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       |         | {name_list}
          |       |           | {name b}
          |       |           | {name_list}
          |       |             | {name c}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |         |     | | {table_star}: assembly_core: assembly_core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |   | | {dot}: flag: bool
          |         |     |   |   | {name plugin_table}
          |         |     |   |   | {name flag}
          |         |     |   | {select_expr_list}
          |         |     |     | {select_expr}: longint
          |         |     |     | | {call}: longint
          |         |     |     |   | {name min}: longint
          |         |     |     |   | {call_arg_list}
          |         |     |     |     | {call_filter_clause}
          |         |     |     |     | {arg_list}: ok
          |         |     |     |       | {dot}: id: integer
          |         |     |     |       | | {name plugin_table}
          |         |     |     |       | | {name id}
          |         |     |     |       | {arg_list}
          |         |     |     |         | {longint 10}: longint notnull
          |         |     |     | {select_expr_list}
          |         |     |       | {select_expr}: real
          |         |     |         | {call}: real
          |         |     |           | {name min}: real
          |         |     |           | {call_arg_list}
          |         |     |             | {call_filter_clause}
          |         |     |             | {arg_list}: ok
          |         |     |               | {dot}: id: integer
          |         |     |               | | {name plugin_table}
          |         |     |               | | {name id}
          |         |     |               | {arg_list}
          |         |     |                 | {dbl 10.05}: real notnull
          |         |     | {select_from_etc}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         |       | | | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
            |     | {select_from_etc}: TABLE { assembly_two: assembly_two }
            |       | {table_or_subquery_list}: TABLE { assembly_two: assembly_two }
            |       | | {table_or_subquery}: TABLE { assembly_two: assembly_two }
            |       |   | {name assembly_two}: TABLE { assembly_two: assembly_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core)
CREATE PROC test_assembly_extension_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_three (x, y, z, d) AS (SELECT assembly_core.*, plugin_table.id AS d
    FROM assembly_core
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM assembly_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: test_assembly_extension_fragment_three: { x: integer notnull, y: text, z: longint, d: integer } dml_proc
    | {name test_assembly_extension_fragment_three}: test_assembly_extension_fragment_three: { x: integer notnull, y: text, z: longint, d: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_three: { x: integer notnull, y: text, z: longint, d: integer }
          |       | {cte_decl}: assembly_three: { x: integer notnull, y: text, z: longint, d: integer }
          |       | | {name assembly_three}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name d}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
          |         |     | | {table_star}: assembly_core: assembly_core: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: d: integer
          |         |     |     | {dot}: id: integer
          |         |     |     | | {name plugin_table}
          |         |     |     | | {name id}
          |         |     |     | {opt_as_alias}
          |         |     |       | {name d}
          |         |     | {select_from_etc}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |         |       | | | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core: assembly_core, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {eq}: bool
          |         |       |           | {dot}: id: integer
          |         |       |           | | {name plugin_table}
          |         |       |           | | {name id}
          |         |       |           | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, d: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, d: integer }
            |     | {select_from_etc}: TABLE { assembly_three: assembly_three }
            |       | {table_or_subquery_list}: TABLE { assembly_three: assembly_three }
            |       | | {table_or_subquery}: TABLE { assembly_three: assembly_three }
            |       |   | {name assembly_three}: TABLE { assembly_three: assembly_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core)
CREATE PROC assembly_core (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_),
  assembly_one (x, y, z) AS (SELECT *
    FROM assembly_core
  UNION ALL
  SELECT 3 AS x, 'y' AS y, 5L AS z),
  assembly_two (x, y, z, a, b, c) AS (SELECT assembly_one.*, plugin_table.flag, min(plugin_table.id, 10L), min(plugin_table.id, 10.05)
    FROM assembly_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_one.y AND plugin_table.id = id_),
  assembly_three (x, y, z, a, b, c, d) AS (SELECT assembly_two.*, plugin_table.id AS d
    FROM assembly_two
    LEFT OUTER JOIN plugin_table ON plugin_table.id = id_)
  SELECT *
    FROM assembly_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: assembly_core: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer } dml_proc
    | {name assembly_core}: assembly_core: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {name id}: id: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: name: text
          |   |   |     |   | | {name name}: name: text
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: rate: longint
          |   |   |     |       | {name rate}: rate: longint
          |   |   |     | {select_from_etc}: TABLE { bar: bar }
          |   |   |       | {table_or_subquery_list}: TABLE { bar: bar }
          |   |   |       | | {table_or_subquery}: TABLE { bar: bar }
          |   |   |       |   | {name bar}: TABLE { bar: bar }
          |   |   |       | {select_where}
          |   |   |         | {opt_where}: bool notnull
          |   |   |         | | {eq}: bool notnull
          |   |   |         |   | {name id}: id: integer notnull
          |   |   |         |   | {name id_}: id_: integer notnull variable in
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_one: { x: integer notnull, y: text, z: longint }
          |     | | {cte_decl}: assembly_one: { x: integer notnull, y: text, z: longint }
          |     | | | {name assembly_one}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | | {select_stmt}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |     |   | {select_core_list}: UNION ALL: { x: integer notnull, y: text, z: longint }
          |     |   | | {select_core}: select: { x: integer notnull, y: text, z: longint }
          |     |   | | | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | | {star}: select: { x: integer notnull, y: text, z: longint }
          |     |   | |   | {select_from_etc}: TABLE { assembly_core: assembly_core }
          |     |   | |     | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
          |     |   | |     | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
          |     |   | |     |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
          |     |   | |     | {select_where}
          |     |   | |       | {select_groupby}
          |     |   | |         | {select_having}
          |     |   | | {select_core_compound}
          |     |   |   | {int 2}
          |     |   |   | {select_core_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |     | {select_core}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |       | {select_expr_list_con}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |         | {select_expr_list}: select: { x: integer notnull, y: text notnull, z: longint notnull }
          |     |   |         | | {select_expr}: x: integer notnull
          |     |   |         | | | {int 3}: integer notnull
          |     |   |         | | | {opt_as_alias}
          |     |   |         | |   | {name x}
          |     |   |         | | {select_expr_list}
          |     |   |         |   | {select_expr}: y: text notnull
          |     |   |         |   | | {strlit 'y'}: text notnull
          |     |   |         |   | | {opt_as_alias}
          |     |   |         |   |   | {name y}
          |     |   |         |   | {select_expr_list}
          |     |   |         |     | {select_expr}: z: longint notnull
          |     |   |         |       | {longint 5}: longint notnull
          |     |   |         |       | {opt_as_alias}
          |     |   |         |         | {name z}
          |     |   |         | {select_from_etc}: ok
          |     |   |           | {select_where}
          |     |   |             | {select_groupby}
          |     |   |               | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | {cte_decl}: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |       | | | {name assembly_two}
          |       | | | {name_list}
          |       | |   | {name x}
          |       | |   | {name_list}
          |       | |     | {name y}
          |       | |     | {name_list}
          |       | |       | {name z}
          |       | |       | {name_list}
          |       | |         | {name a}
          |       | |         | {name_list}
          |       | |           | {name b}
          |       | |           | {name_list}
          |       | |             | {name c}
          |       | | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool, _anon: longint, _anon: real }
          |       |   |     | | {table_star}: assembly_one: assembly_one: { x: integer notnull, y: text, z: longint }
          |       |   |     | | | {name assembly_one}
          |       |   |     | | {select_expr_list}
          |       |   |     |   | {select_expr}: flag: bool
          |       |   |     |   | | {dot}: flag: bool
          |       |   |     |   |   | {name plugin_table}
          |       |   |     |   |   | {name flag}
          |       |   |     |   | {select_expr_list}
          |       |   |     |     | {select_expr}: longint
          |       |   |     |     | | {call}: longint
          |       |   |     |     |   | {name min}: longint
          |       |   |     |     |   | {call_arg_list}
          |       |   |     |     |     | {call_filter_clause}
          |       |   |     |     |     | {arg_list}: ok
          |       |   |     |     |       | {dot}: id: integer
          |       |   |     |     |       | | {name plugin_table}
          |       |   |     |     |       | | {name id}
          |       |   |     |     |       | {arg_list}
          |       |   |     |     |         | {longint 10}: longint notnull
          |       |   |     |     | {select_expr_list}
          |       |   |     |       | {select_expr}: real
          |       |   |     |         | {call}: real
          |       |   |     |           | {name min}: real
          |       |   |     |           | {call_arg_list}
          |       |   |     |             | {call_filter_clause}
          |       |   |     |             | {arg_list}: ok
          |       |   |     |               | {dot}: id: integer
          |       |   |     |               | | {name plugin_table}
          |       |   |     |               | | {name id}
          |       |   |     |               | {arg_list}
          |       |   |     |                 | {dbl 10.05}: real notnull
          |       |   |     | {select_from_etc}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       | {join_clause}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       | | {table_or_subquery}: TABLE { assembly_one: assembly_one }
          |       |   |       | | | {name assembly_one}: TABLE { assembly_one: assembly_one }
          |       |   |       | | {join_target_list}
          |       |   |       |   | {join_target}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       |     | {int 3} {join_left_outer}
          |       |   |       |     | {table_join}
          |       |   |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |       |   |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |       |   |       |       | {join_cond}: JOIN { assembly_one: assembly_one, plugin_table: plugin_table }
          |       |   |       |         | {on}: bool
          |       |   |       |         | {and}: bool
          |       |   |       |           | {eq}: bool
          |       |   |       |           | | {dot}: name: text
          |       |   |       |           | | | {name plugin_table}
          |       |   |       |           | | | {name name}
          |       |   |       |           | | {dot}: y: text
          |       |   |       |           |   | {name assembly_one}
          |       |   |       |           |   | {name y}
          |       |   |       |           | {eq}: bool
          |       |   |       |             | {dot}: id: integer
          |       |   |       |             | | {name plugin_table}
          |       |   |       |             | | {name id}
          |       |   |       |             | {name id_}: id_: integer notnull variable in
          |       |   |       | {select_where}
          |       |   |         | {select_groupby}
          |       |   |           | {select_having}
          |       |   | {select_orderby}
          |       |     | {select_limit}
          |       |       | {select_offset}
          |       | {cte_tables}
          |         | {cte_table}: assembly_three: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |           | {cte_decl}: assembly_three: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |           | | {name assembly_three}
          |           | | {name_list}
          |           |   | {name x}
          |           |   | {name_list}
          |           |     | {name y}
          |           |     | {name_list}
          |           |       | {name z}
          |           |       | {name_list}
          |           |         | {name a}
          |           |         | {name_list}
          |           |           | {name b}
          |           |           | {name_list}
          |           |             | {name c}
          |           |             | {name_list}
          |           |               | {name d}
          |           | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
          |             |     | | {table_star}: assembly_two: assembly_two: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real }
          |             |     | | | {name assembly_two}
          |             |     | | {select_expr_list}
          |             |     |   | {select_expr}: d: integer
          |             |     |     | {dot}: id: integer
          |             |     |     | | {name plugin_table}
          |             |     |     | | {name id}
          |             |     |     | {opt_as_alias}
          |             |     |       | {name d}
          |             |     | {select_from_etc}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       | {join_clause}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       | | {table_or_subquery}: TABLE { assembly_two: assembly_two }
          |             |       | | | {name assembly_two}: TABLE { assembly_two: assembly_two }
          |             |       | | {join_target_list}
          |             |       |   | {join_target}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       |     | {int 3} {join_left_outer}
          |             |       |     | {table_join}
          |             |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |             |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |             |       |       | {join_cond}: JOIN { assembly_two: assembly_two, plugin_table: plugin_table }
          |             |       |         | {on}: bool
          |             |       |         | {eq}: bool
          |             |       |           | {dot}: id: integer
          |             |       |           | | {name plugin_table}
          |             |       |           | | {name id}
          |             |       |           | {name id_}: id_: integer notnull variable in
          |             |       | {select_where}
          |             |         | {select_groupby}
          |             |           | {select_having}
          |             | {select_orderby}
          |               | {select_limit}
          |                 | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool, b: longint, c: real, d: integer }
            |     | {select_from_etc}: TABLE { assembly_three: assembly_three }
            |       | {table_or_subquery_list}: TABLE { assembly_three: assembly_three }
            |       | | {table_or_subquery}: TABLE { assembly_three: assembly_three }
            |       |   | {name assembly_three}: TABLE { assembly_three: assembly_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=for_bad2)
CREATE PROC test_assembly_base_for_bad2 (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name for_bad2}: ok
  | {create_proc_stmt}: err
    | {name test_assembly_base_for_bad2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=for_bad)
CREATE PROC test_assembly_base_for_bad (id_ INTEGER NOT NULL)
BEGIN
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name for_bad}: ok
  | {create_proc_stmt}: test_assembly_base_for_bad: { x: integer notnull } dml_proc
    | {name test_assembly_base_for_bad}: test_assembly_base_for_bad: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=for_bad)
CREATE PROC test_bad_ext (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1),
  plugin_one (x, a) AS (SELECT 1, 2)
  SELECT *
    FROM plugin_one;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name for_bad}: ok
  | {create_proc_stmt}: err
    | {name test_bad_ext}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull, a: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |   | | {cte_decl}: for_bad: { x: integer notnull }
          |   | | | {name for_bad}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {select_stmt}: select: { _anon: integer notnull }
          |   |   | {select_core_list}: select: { _anon: integer notnull }
          |   |   | | {select_core}: select: { _anon: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     |   | {int 1}: integer notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: plugin_one: { x: integer notnull, a: integer notnull }
          |       | {cte_decl}: plugin_one: { x: integer notnull, a: integer notnull }
          |       | | {name plugin_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name a}
          |       | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
          |         | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |         | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
          |         |     | | {select_expr}: integer notnull
          |         |     | | | {int 1}: integer notnull
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: integer notnull
          |         |     |     | {int 2}: integer notnull
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, a: integer notnull }
            | {select_core_list}: select: { x: integer notnull, a: integer notnull }
            | | {select_core}: select: { x: integer notnull, a: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, a: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull, a: integer notnull }
            |     | | {star}: select: { x: integer notnull, a: integer notnull }
            |     | {select_from_etc}: TABLE { plugin_one: plugin_one }
            |       | {table_or_subquery_list}: TABLE { plugin_one: plugin_one }
            |       | | {table_or_subquery}: TABLE { plugin_one: plugin_one }
            |       |   | {name plugin_one}: TABLE { plugin_one: plugin_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=for_bad)
CREATE PROC test_assembly_fragment2 (id_ INTEGER NOT NULL)
BEGIN
  DECLARE foo INTEGER;
  WITH
  for_bad (x) AS (SELECT 1)
  SELECT *
    FROM for_bad;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name for_bad}: ok
  | {create_proc_stmt}: err
    | {name test_assembly_fragment2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {declare_vars_type}: integer
        | | {name_list}: foo: integer variable
        | | | {name foo}: foo: integer variable
        | | {type_int}: integer
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: for_bad: { x: integer notnull }
          |     | {cte_decl}: for_bad: { x: integer notnull }
          |     | | {name for_bad}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { for_bad: for_bad }
            |       | {table_or_subquery_list}: TABLE { for_bad: for_bad }
            |       | | {table_or_subquery}: TABLE { for_bad: for_bad }
            |       |   | {name for_bad}: TABLE { for_bad: for_bad }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core)
CREATE PROC duplicate_assembly_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core (x, y, z) AS (SELECT 1, 2, nullable(3L))
  SELECT *
    FROM assembly_core;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0264: duplicate assembly fragments of base fragment 'assembly_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core}: ok
  | {create_proc_stmt}: err
    | {name duplicate_assembly_fragment}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: integer notnull, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core: { x: integer notnull, y: integer notnull, z: longint }
          |     | {cte_decl}: assembly_core: { x: integer notnull, y: integer notnull, z: longint }
          |     | | {name assembly_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: integer notnull
          |       |     |   | | {int 2}: integer notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: integer notnull, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: integer notnull, z: longint }
            | | {select_core}: select: { x: integer notnull, y: integer notnull, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | | {star}: select: { x: integer notnull, y: integer notnull, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core: assembly_core }
            |       | {table_or_subquery_list}: TABLE { assembly_core: assembly_core }
            |       | | {table_or_subquery}: TABLE { assembly_core: assembly_core }
            |       |   | {name assembly_core}: TABLE { assembly_core: assembly_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=another_core)
CREATE PROC bad_assembly_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  another_core (x, y) AS (SELECT 1, nullable("a")),
  another_cte (x, y) AS (SELECT another_core.*
    FROM another_core)
  SELECT *
    FROM another_cte;
END;

test/sem_test.sql:XXXX:1: error: in cte_tables : CQL0265: assembly fragment can only have one CTE 'another_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name another_core}: ok
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text }
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: another_core: { x: integer notnull, y: text }
          |   | | {cte_decl}: another_core: { x: integer notnull, y: text }
          |   | | | {name another_core}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |     | {call}: text
          |   |   |     |       | {name nullable}: text
          |   |   |     |       | {call_arg_list}
          |   |   |     |         | {call_filter_clause}
          |   |   |     |         | {arg_list}: ok
          |   |   |     |           | {strlit 'a'}: text notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: another_cte: { x: integer notnull, y: text }
          |       | {cte_decl}: another_cte: { x: integer notnull, y: text }
          |       | | {name another_cte}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       | {select_stmt}: select: { x: integer notnull, y: text }
          |         | {select_core_list}: select: { x: integer notnull, y: text }
          |         | | {select_core}: select: { x: integer notnull, y: text }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text }
          |         |     | | {table_star}: another_core: another_core: { x: integer notnull, y: text }
          |         |     |   | {name another_core}
          |         |     | {select_from_etc}: TABLE { another_core: another_core }
          |         |       | {table_or_subquery_list}: TABLE { another_core: another_core }
          |         |       | | {table_or_subquery}: TABLE { another_core: another_core }
          |         |       |   | {name another_core}: TABLE { another_core: another_core }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text }
            | {select_core_list}: select: { x: integer notnull, y: text }
            | | {select_core}: select: { x: integer notnull, y: text }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text }
            |     | {select_expr_list}: select: { x: integer notnull, y: text }
            |     | | {star}: select: { x: integer notnull, y: text }
            |     | {select_from_etc}: TABLE { another_cte: another_cte }
            |       | {table_or_subquery_list}: TABLE { another_cte: another_cte }
            |       | | {table_or_subquery}: TABLE { another_cte: another_cte }
            |       |   | {name another_cte}: TABLE { another_cte: another_cte }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=wrong_core)
CREATE PROC bad_assembly_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  wrong_core (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L))
  SELECT *
    FROM wrong_core;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0255: fragment name is not a previously declared base fragment 'wrong_core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name wrong_core}: err
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_two}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: wrong_core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: wrong_core: { x: integer notnull, y: text, z: longint }
          |     | | {name wrong_core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: text
          |       |     |   | | {call}: text
          |       |     |   |   | {name nullable}: text
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {strlit 'a'}: text notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { wrong_core: wrong_core }
            |       | {table_or_subquery_list}: TABLE { wrong_core: wrong_core }
            |       | | {table_or_subquery}: TABLE { wrong_core: wrong_core }
            |       |   | {name wrong_core}: TABLE { wrong_core: wrong_core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=test_bad_assembly_base_fragment)
CREATE PROC test_bad_assembly_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  test_bad_assembly_base_fragment (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM test_bad_assembly_base_fragment;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name test_bad_assembly_base_fragment}: ok
  | {create_proc_stmt}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_bad_assembly_base_fragment}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: test_bad_assembly_base_fragment: { x: integer notnull, y: text, z: longint }
          |     | | {name test_bad_assembly_base_fragment}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | {table_or_subquery_list}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | | {table_or_subquery}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       |   | {name test_bad_assembly_base_fragment}: TABLE { test_bad_assembly_base_fragment: test_bad_assembly_base_fragment }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=test_bad_assembly_base_fragment)
CREATE PROC bad_assembly_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  SELECT id, name, rate
    FROM bar
    WHERE id = id_;
END;

test/sem_test.sql:XXXX:1: error: in stmt_list : CQL0290: fragments can only have one statement in the statement list and it must be a WITH...SELECT

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name test_bad_assembly_base_fragment}: ok
  | {create_proc_stmt}: err
    | {name bad_assembly_fragment_three}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {select_expr}: id: integer notnull
          |     | | | {name id}: id: integer notnull
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text
          |     |   | | {name name}: name: text
          |     |   | {select_expr_list}
          |     |     | {select_expr}: rate: longint
          |     |       | {name rate}: rate: longint
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {opt_where}: bool notnull
          |         | | {eq}: bool notnull
          |         |   | {name id}: id: integer notnull
          |         |   | {name id_}: id_: integer notnull variable in
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_base_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_one}: ok
  | {create_proc_stmt}: test_bad_assembly_base_fragment_one: { x: integer notnull, y: text, z: longint } dml_proc
    | {name test_bad_assembly_base_fragment_one}: test_bad_assembly_base_fragment_one: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_one}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       |   | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_extension_fragment_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_bad_one (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_bad_one;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core_bad_one}: ok
  | {create_proc_stmt}: test_bad_assembly_extension_fragment_one: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_assembly_extension_fragment_one}: test_bad_assembly_extension_fragment_one: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_bad_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: assembly_bad_one: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name assembly_bad_one}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: assembly_core_bad_one: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core_bad_one}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core_bad_one}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_bad_one: assembly_bad_one }
            |       |   | {name assembly_bad_one}: TABLE { assembly_bad_one: assembly_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=assembly_core_bad_one)
CREATE PROC test_bad_assembly_extension_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT 1, nullable("a"), nullable(3L)),
  assembly_bad_two (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_bad_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name assembly_core_bad_one}: ok
  | {create_proc_stmt}: test_bad_assembly_extension_fragment_two: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {name test_bad_assembly_extension_fragment_two}: test_bad_assembly_extension_fragment_two: { x: integer notnull, y: text, z: longint, a: bool } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint }
          |   |   |     | | {select_expr}: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: text
          |   |   |     |   | | {call}: text
          |   |   |     |   |   | {name nullable}: text
          |   |   |     |   |   | {call_arg_list}
          |   |   |     |   |     | {call_filter_clause}
          |   |   |     |   |     | {arg_list}: ok
          |   |   |     |   |       | {strlit 'a'}: text notnull
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: longint
          |   |   |     |       | {call}: longint
          |   |   |     |         | {name nullable}: longint
          |   |   |     |         | {call_arg_list}
          |   |   |     |           | {call_filter_clause}
          |   |   |     |           | {arg_list}: ok
          |   |   |     |             | {longint 3}: longint notnull
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: assembly_bad_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | {cte_decl}: assembly_bad_two: { x: integer notnull, y: text, z: longint, a: bool }
          |       | | {name assembly_bad_two}
          |       | | {name_list}
          |       |   | {name x}
          |       |   | {name_list}
          |       |     | {name y}
          |       |     | {name_list}
          |       |       | {name z}
          |       |       | {name_list}
          |       |         | {name a}
          |       | {select_stmt}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | {select_core_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         | | {select_core}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, flag: bool }
          |         |     | | {table_star}: assembly_core_bad_one: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |         |     | | | {name assembly_core_bad_one}
          |         |     | | {select_expr_list}
          |         |     |   | {select_expr}: flag: bool
          |         |     |     | {dot}: flag: bool
          |         |     |       | {name plugin_table}
          |         |     |       | {name flag}
          |         |     | {select_from_etc}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | {join_clause}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { plugin_table: plugin_table }
          |         |       |       | | {name plugin_table}: TABLE { plugin_table: plugin_table }
          |         |       |       | {join_cond}: JOIN { assembly_core_bad_one: assembly_core_bad_one, plugin_table: plugin_table }
          |         |       |         | {on}: bool
          |         |       |         | {and}: bool
          |         |       |           | {eq}: bool
          |         |       |           | | {dot}: name: text
          |         |       |           | | | {name plugin_table}
          |         |       |           | | | {name name}
          |         |       |           | | {dot}: y: text
          |         |       |           |   | {name assembly_core_bad_one}
          |         |       |           |   | {name y}
          |         |       |           | {eq}: bool
          |         |       |             | {dot}: id: integer
          |         |       |             | | {name plugin_table}
          |         |       |             | | {name id}
          |         |       |             | {name id_}: id_: integer notnull variable in
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint, a: bool }
            |     | {select_from_etc}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_bad_two: assembly_bad_two }
            |       |   | {name assembly_bad_two}: TABLE { assembly_bad_two: assembly_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_one)
CREATE PROC assembly_core_bad_one (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_one (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_),
  assembly_bad_one (x, y, z, a) AS (SELECT assembly_core_bad_one.*, plugin_table.flag
    FROM assembly_core_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_core_bad_one.y AND plugin_table.id = id_),
  assembly_bad_two (x, y, z, a) AS (SELECT assembly_bad_one.*, plugin_table.flag
    FROM assembly_bad_one
    LEFT OUTER JOIN plugin_table ON plugin_table.name = assembly_bad_one.y AND plugin_table.id = id_)
  SELECT *
    FROM assembly_core_bad_one;
END;

test/sem_test.sql:XXXX:1: error: in name_list : CQL0267: extension fragments of same base fragment share the same cte column 'a'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_one}: ok
  | {create_proc_stmt}: err
    | {name assembly_core_bad_one}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | {cte_decl}: assembly_core_bad_one: { x: integer notnull, y: text, z: longint }
          |   | | | {name assembly_core_bad_one}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | |   | {name_list}
          |   | |     | {name y}
          |   | |     | {name_list}
          |   | |       | {name z}
          |   | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {name id}: id: integer notnull
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: name: text
          |   |   |     |   | | {name name}: name: text
          |   |   |     |   | {select_expr_list}
          |   |   |     |     | {select_expr}: rate: longint
          |   |   |     |       | {name rate}: rate: longint
          |   |   |     | {select_from_etc}: TABLE { bar: bar }
          |   |   |       | {table_or_subquery_list}: TABLE { bar: bar }
          |   |   |       | | {table_or_subquery}: TABLE { bar: bar }
          |   |   |       |   | {name bar}: TABLE { bar: bar }
          |   |   |       | {select_where}
          |   |   |         | {opt_where}: bool notnull
          |   |   |         | | {eq}: bool notnull
          |   |   |         |   | {name id}: id: integer notnull
          |   |   |         |   | {name id_}: id_: integer notnull variable in
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}
          |     | | {cte_decl}
          |     | | | {name assembly_bad_one}
          |     | | | {name_list}
          |     | |   | {name x}
          |     | |   | {name_list}
          |     | |     | {name y}
          |     | |     | {name_list}
          |     | |       | {name z}
          |     | |       | {name_list}
          |     | |         | {name a}
          |     | | {select_stmt}
          |     |   | {select_core_list}
          |     |   | | {select_core}
          |     |   |   | {select_expr_list_con}
          |     |   |     | {select_expr_list}
          |     |   |     | | {table_star}
          |     |   |     | | | {name assembly_core_bad_one}
          |     |   |     | | {select_expr_list}
          |     |   |     |   | {select_expr}
          |     |   |     |     | {dot}
          |     |   |     |       | {name plugin_table}
          |     |   |     |       | {name flag}
          |     |   |     | {select_from_etc}
          |     |   |       | {join_clause}
          |     |   |       | | {table_or_subquery}
          |     |   |       | | | {name assembly_core_bad_one}
          |     |   |       | | {join_target_list}
          |     |   |       |   | {join_target}
          |     |   |       |     | {int 3} {join_left_outer}
          |     |   |       |     | {table_join}
          |     |   |       |       | {table_or_subquery}
          |     |   |       |       | | {name plugin_table}
          |     |   |       |       | {join_cond}
          |     |   |       |         | {on}
          |     |   |       |         | {and}
          |     |   |       |           | {eq}
          |     |   |       |           | | {dot}
          |     |   |       |           | | | {name plugin_table}
          |     |   |       |           | | | {name name}
          |     |   |       |           | | {dot}
          |     |   |       |           |   | {name assembly_core_bad_one}
          |     |   |       |           |   | {name y}
          |     |   |       |           | {eq}
          |     |   |       |             | {dot}
          |     |   |       |             | | {name plugin_table}
          |     |   |       |             | | {name id}
          |     |   |       |             | {name id_}
          |     |   |       | {select_where}
          |     |   |         | {select_groupby}
          |     |   |           | {select_having}
          |     |   | {select_orderby}
          |     |     | {select_limit}
          |     |       | {select_offset}
          |     | {cte_tables}
          |       | {cte_table}
          |         | {cte_decl}
          |         | | {name assembly_bad_two}
          |         | | {name_list}
          |         |   | {name x}
          |         |   | {name_list}
          |         |     | {name y}
          |         |     | {name_list}
          |         |       | {name z}
          |         |       | {name_list}: err
          |         |         | {name a}
          |         | {select_stmt}
          |           | {select_core_list}
          |           | | {select_core}
          |           |   | {select_expr_list_con}
          |           |     | {select_expr_list}
          |           |     | | {table_star}
          |           |     | | | {name assembly_bad_one}
          |           |     | | {select_expr_list}
          |           |     |   | {select_expr}
          |           |     |     | {dot}
          |           |     |       | {name plugin_table}
          |           |     |       | {name flag}
          |           |     | {select_from_etc}
          |           |       | {join_clause}
          |           |       | | {table_or_subquery}
          |           |       | | | {name assembly_bad_one}
          |           |       | | {join_target_list}
          |           |       |   | {join_target}
          |           |       |     | {int 3} {join_left_outer}
          |           |       |     | {table_join}
          |           |       |       | {table_or_subquery}
          |           |       |       | | {name plugin_table}
          |           |       |       | {join_cond}
          |           |       |         | {on}
          |           |       |         | {and}
          |           |       |           | {eq}
          |           |       |           | | {dot}
          |           |       |           | | | {name plugin_table}
          |           |       |           | | | {name name}
          |           |       |           | | {dot}
          |           |       |           |   | {name assembly_bad_one}
          |           |       |           |   | {name y}
          |           |       |           | {eq}
          |           |       |             | {dot}
          |           |       |             | | {name plugin_table}
          |           |       |             | | {name id}
          |           |       |             | {name id_}
          |           |       | {select_where}
          |           |         | {select_groupby}
          |           |           | {select_having}
          |           | {select_orderby}
          |             | {select_limit}
          |               | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       |   | {name assembly_core_bad_one}: TABLE { assembly_core_bad_one: assembly_core_bad_one }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_two)
CREATE PROC create_bad_assembly_base_fragment_two (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_two (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_two;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_two}: ok
  | {create_proc_stmt}: create_bad_assembly_base_fragment_two: { x: integer notnull, y: text, z: longint } dml_proc
    | {name create_bad_assembly_base_fragment_two}: create_bad_assembly_base_fragment_two: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       |   | {name assembly_core_bad_two}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_two)
CREATE PROC test_bad_assembly_fragment_with_wrong_base_sem_type (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_two (x, y, z) AS (SELECT 1, nullable("a"), 3L)
  SELECT *
    FROM assembly_core_bad_two;
END;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0288: extension/assembly fragment stub for base CTE column must be exact type match (including nullability) (expected longint; found longint notnull) 'rate'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_two}: ok
  | {create_proc_stmt}: err
    | {name test_bad_assembly_fragment_with_wrong_base_sem_type}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint notnull }
          |     | {cte_decl}: assembly_core_bad_two: { x: integer notnull, y: text, z: longint notnull }
          |     | | {name assembly_core_bad_two}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: text, _anon: longint notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: text
          |       |     |   | | {call}: text
          |       |     |   |   | {name nullable}: text
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {strlit 'a'}: text notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint notnull
          |       |     |       | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint notnull }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint notnull }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint notnull }
            |     | {select_from_etc}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       |   | {name assembly_core_bad_two}: TABLE { assembly_core_bad_two: assembly_core_bad_two }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_bad_three)
CREATE PROC create_bad_assembly_base_fragment_three (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_three (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM assembly_core_bad_three;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_bad_three}: ok
  | {create_proc_stmt}: create_bad_assembly_base_fragment_three: { x: integer notnull, y: text, z: longint } dml_proc
    | {name create_bad_assembly_base_fragment_three}: create_bad_assembly_base_fragment_three: { x: integer notnull, y: text, z: longint } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_three: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: assembly_core_bad_three: { x: integer notnull, y: text, z: longint }
          |     | | {name assembly_core_bad_three}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       |   | {name assembly_core_bad_three}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_bad_three)
CREATE PROC test_bad_assembly_fragment_with_wrong_base_nullability (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_bad_three (x, y, z) AS (SELECT 1, nullable(2), nullable(3L))
  SELECT *
    FROM assembly_core_bad_three;
END;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0287: extension/assembly fragment must add stub for base CTE with same types from base fragment (expected text; found integer) 'name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_bad_three}: ok
  | {create_proc_stmt}: err
    | {name test_bad_assembly_fragment_with_wrong_base_nullability}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: integer, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_bad_three: { x: integer notnull, y: integer, z: longint }
          |     | {cte_decl}: assembly_core_bad_three: { x: integer notnull, y: integer, z: longint }
          |     | | {name assembly_core_bad_three}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       | {select_core_list}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       | | {select_core}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer, _anon: longint }
          |       |     | | {select_expr}: integer notnull
          |       |     | | | {int 1}: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: integer
          |       |     |   | | {call}: integer
          |       |     |   |   | {name nullable}: integer
          |       |     |   |   | {call_arg_list}
          |       |     |   |     | {call_filter_clause}
          |       |     |   |     | {arg_list}: ok
          |       |     |   |       | {int 2}: integer notnull
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: longint
          |       |     |       | {call}: longint
          |       |     |         | {name nullable}: longint
          |       |     |         | {call_arg_list}
          |       |     |           | {call_filter_clause}
          |       |     |           | {arg_list}: ok
          |       |     |             | {longint 3}: longint notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: integer, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: integer, z: longint }
            | | {select_core}: select: { x: integer notnull, y: integer, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: integer, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: integer, z: longint }
            |     | | {star}: select: { x: integer notnull, y: integer, z: longint }
            |     | {select_from_etc}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {table_or_subquery_list}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | | {table_or_subquery}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       |   | {name assembly_core_bad_three}: TABLE { assembly_core_bad_three: assembly_core_bad_three }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=assembly_core_simple)
CREATE PROC base_with_args (idx_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_simple (x) AS (SELECT 1 AS x)
  SELECT *
    FROM assembly_core_simple;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name assembly_core_simple}: ok
  | {create_proc_stmt}: base_with_args: { x: integer notnull } dml_proc
    | {name base_with_args}: base_with_args: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: idx_: integer notnull variable in
      |   | {param_detail}: idx_: integer notnull variable in
      |     | {name idx_}: idx_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_simple: { x: integer notnull }
          |     | {cte_decl}: assembly_core_simple: { x: integer notnull }
          |     | | {name assembly_core_simple}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {table_or_subquery_list}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | | {table_or_subquery}: TABLE { assembly_core_simple: assembly_core_simple }
            |       |   | {name assembly_core_simple}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=assembly_core_simple)
CREATE PROC assembly_core_simple (id_ INTEGER NOT NULL)
BEGIN
  WITH
  assembly_core_simple (x) AS (SELECT 1 AS x)
  SELECT *
    FROM assembly_core_simple;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0322: fragment parameters must be exactly '(idx_ INTEGER NOT NULL)'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name assembly_core_simple}: ok
  | {create_proc_stmt}: err
    | {name assembly_core_simple}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: assembly_core_simple: { x: integer notnull }
          |     | {cte_decl}: assembly_core_simple: { x: integer notnull }
          |     | | {name assembly_core_simple}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {table_or_subquery_list}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | | {table_or_subquery}: TABLE { assembly_core_simple: assembly_core_simple }
            |       |   | {name assembly_core_simple}: TABLE { assembly_core_simple: assembly_core_simple }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region;

  {declare_schema_region_stmt}: root_region: region
  | {name root_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION dep_region USING root_region;

  {declare_schema_region_stmt}: dep_region: region
  | {name dep_region}
  | {region_list}
    | {region_spec}
      | {name root_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region;

test/sem_test.sql:XXXX:1: error: in declare_schema_region_stmt : CQL0245: schema region already defined 'root_region'

  {declare_schema_region_stmt}: err
  | {name root_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region USING unknown_region;

test/sem_test.sql:XXXX:1: error: in region_list : CQL0244: unknown schema region 'unknown_region'

  {declare_schema_region_stmt}: err
  | {name root_region}
  | {region_list}
    | {region_spec}
      | {name unknown_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION root_region USING root_region, root_region;

test/sem_test.sql:XXXX:1: error: in region_spec : CQL0206: duplicate name in list 'root_region'

  {declare_schema_region_stmt}: err
  | {name root_region}
  | {region_list}
    | {region_spec}
    | | {name root_region}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name root_region}
        | {int 0}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

  {begin_schema_region_stmt}: ok
  | {name root_region}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

test/sem_test.sql:XXXX:1: error: in begin_schema_region_stmt : CQL0246: schema regions do not nest; end the current region before starting a new one

  {begin_schema_region_stmt}: err
  | {name root_region}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION dep2_region USING root_region;

  {declare_schema_region_stmt}: dep2_region: region
  | {name dep2_region}
  | {region_list}
    | {region_spec}
      | {name root_region}
      | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION diamond_region USING dep_region, dep2_region;

  {declare_schema_region_stmt}: diamond_region: region
  | {name diamond_region}
  | {region_list}
    | {region_spec}
    | | {name dep_region}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name dep2_region}
        | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

test/sem_test.sql:XXXX:1: error: in end_schema_region_stmt : CQL0247: you must begin a schema region before you can end one

  {end_schema_region_stmt}: err

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION what_is_this_region;

test/sem_test.sql:XXXX:1: error: in str : CQL0244: unknown schema region 'what_is_this_region'

  {begin_schema_region_stmt}: err
  | {name what_is_this_region}

The statement ending at line XXXX

CREATE PROC decl_region_in_proc ()
BEGIN
  @DECLARE_SCHEMA_REGION fooey;
END;

test/sem_test.sql:XXXX:1: error: in declare_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name decl_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_schema_region_stmt}: err
        | {name fooey}

The statement ending at line XXXX

CREATE PROC begin_region_in_proc ()
BEGIN
  @BEGIN_SCHEMA_REGION fooey;
END;

test/sem_test.sql:XXXX:1: error: in begin_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name begin_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {begin_schema_region_stmt}: err
        | {name fooey}

The statement ending at line XXXX

CREATE PROC end_region_in_proc ()
BEGIN
  @END_SCHEMA_REGION;
END;

test/sem_test.sql:XXXX:1: error: in end_schema_region_stmt : CQL0248: schema region directives may not appear inside of a procedure

  {create_proc_stmt}: err
  | {name end_region_in_proc}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {end_schema_region_stmt}: err

The statement ending at line XXXX

SET my_real := 1.3 / 2;

  {assign}: my_real: real variable was_set
  | {name my_real}: my_real: real variable was_set
  | {div}: real notnull
    | {dbl 1.3}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SET X := 1.3 % 2;

test/sem_test.sql:XXXX:1: error: in mod : CQL0001: operands must be an integer type, not real '%'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {mod}: err
    | {dbl 1.3}: real notnull
    | {int 2}: integer notnull

The statement ending at line XXXX

SELECT (NOT 'x') || 'plugh';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {concat}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {strlit 'plugh'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION root_region;

  {begin_schema_region_stmt}: ok
  | {name root_region}

The statement ending at line XXXX

CREATE TABLE a_table_in_root_region(
  id INTEGER
);

  {create_table_stmt}: a_table_in_root_region: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_in_root_region}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TRIGGER a_trigger_in_root_region
  BEFORE DELETE ON a_table_in_root_region
BEGIN
  DELETE FROM a_table_in_root_region WHERE id > 3;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name a_trigger_in_root_region}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name id}: id: integer
                        | {int 3}: integer notnull

The statement ending at line XXXX

CREATE INDEX a_index_in_root_region ON a_table_in_root_region (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name a_index_in_root_region}
  | | {name a_table_in_root_region}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}: id: integer

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION dep_region;

  {begin_schema_region_stmt}: ok
  | {name dep_region}

The statement ending at line XXXX

CREATE TABLE a_table_in_dep_region(
  id INTEGER
);

  {create_table_stmt}: a_table_in_dep_region: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE VIEW a_view_in_dep_region AS
SELECT T1.id AS id1, T2.id AS id2
  FROM a_table_in_root_region AS T1
  INNER JOIN a_table_in_dep_region AS T2 USING (id);

  {create_view_stmt}: a_view_in_dep_region: { id1: integer, id2: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name a_view_in_dep_region}
      | {select_stmt}: a_view_in_dep_region: { id1: integer, id2: integer }
        | {select_core_list}: a_view_in_dep_region: { id1: integer, id2: integer }
        | | {select_core}: a_view_in_dep_region: { id1: integer, id2: integer }
        |   | {select_expr_list_con}: a_view_in_dep_region: { id1: integer, id2: integer }
        |     | {select_expr_list}: a_view_in_dep_region: { id1: integer, id2: integer }
        |     | | {select_expr}: id1: integer
        |     | | | {dot}: id: integer
        |     | | | | {name T1}
        |     | | | | {name id}
        |     | | | {opt_as_alias}
        |     | |   | {name id1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: id2: integer
        |     |     | {dot}: id: integer
        |     |     | | {name T2}
        |     |     | | {name id}
        |     |     | {opt_as_alias}
        |     |       | {name id2}
        |     | {select_from_etc}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       | {join_clause}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       | | {table_or_subquery}: TABLE { T1: a_table_in_root_region }
        |       | | | {name a_table_in_root_region}: TABLE { T1: a_table_in_root_region }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { T2: a_table_in_dep_region }
        |       |       | | {name a_table_in_dep_region}: TABLE { T2: a_table_in_dep_region }
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}: JOIN { T1: a_table_in_root_region, T2: a_table_in_dep_region }
        |       |         | {using}
        |       |         | {name_list}: id: integer
        |       |           | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DROP TRIGGER trigger2;

test/sem_test.sql:XXXX:1: error: in str : CQL0113: trigger in drop statement was not declared (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'trigger2'

  {drop_trigger_stmt}: err
  | {name trigger2}

The statement ending at line XXXX

DROP VIEW MyView;

test/sem_test.sql:XXXX:1: error: in str : CQL0110: view in drop statement does not exist (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'MyView'

  {drop_view_stmt}: err
  | {name MyView}

The statement ending at line XXXX

DROP TABLE foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0108: table in drop statement does not exist (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'foo'

  {drop_table_stmt}: err
  | {name foo}

The statement ending at line XXXX

DROP INDEX index_1;

test/sem_test.sql:XXXX:1: error: in str : CQL0112: index in drop statement was not declared (while in schema region 'dep_region', accessing an object that isn't in a region is invalid) 'index_1'

  {drop_index_stmt}: err
  | {name index_1}

The statement ending at line XXXX

CREATE TABLE a_table_like_table_in_dep_region(
  id INTEGER NOT NULL
);

  {create_table_stmt}: a_table_like_table_in_dep_region: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_table_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE a_table_like_table_in_dep_region_2(
  id1 INTEGER,
  id2 INTEGER
);

  {create_table_stmt}: a_table_like_table_in_dep_region_2: { id1: integer, id2: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_table_in_dep_region_2}
  | {col_key_list}
    | {col_def}: id1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: id2: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name id2}
            | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE a_table_like_view_in_dep_region(
  f1 INTEGER NOT NULL,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL
);

  {create_table_stmt}: a_table_like_view_in_dep_region: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_view_in_dep_region}
  | {col_key_list}
    | {col_def}: f1: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name f1}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name f3}
            | | {type_int}: integer
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE TABLE a_table_like_proc_in_dep_region(
  id INTEGER NOT NULL,
  name TEXT,
  rate LONG_INT
);

  {create_table_stmt}: a_table_like_proc_in_dep_region: { id: integer notnull, name: text, rate: longint }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name a_table_like_proc_in_dep_region}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: longint
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name rate}
              | {type_long}: longint

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION dep2_region;

  {begin_schema_region_stmt}: ok
  | {name dep2_region}

The statement ending at line XXXX

CREATE VIEW ok_view_in_dep2_region AS
SELECT *
  FROM a_table_in_root_region;

  {create_view_stmt}: ok_view_in_dep2_region: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name ok_view_in_dep2_region}
      | {select_stmt}: ok_view_in_dep2_region: { id: integer }
        | {select_core_list}: ok_view_in_dep2_region: { id: integer }
        | | {select_core}: ok_view_in_dep2_region: { id: integer }
        |   | {select_expr_list_con}: ok_view_in_dep2_region: { id: integer }
        |     | {select_expr_list}: ok_view_in_dep2_region: { id: integer }
        |     | | {star}: ok_view_in_dep2_region: { id: integer }
        |     | {select_from_etc}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | {table_or_subquery_list}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | | {table_or_subquery}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       |   | {name a_table_in_root_region}: TABLE { a_table_in_root_region: a_table_in_root_region }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW bogus_view_in_dep2_region AS
SELECT T1.id AS id1, T2.id AS id2
  FROM a_table_in_root_region AS T1
  INNER JOIN a_table_in_dep_region AS T2 USING (id);

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined (object is in schema region 'dep_region' not accessible from region 'dep2_region') 'a_table_in_dep_region'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name bogus_view_in_dep2_region}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}
        |     | | | {dot}
        |     | | | | {name T1}
        |     | | | | {name id}
        |     | | | {opt_as_alias}
        |     | |   | {name id1}
        |     | | {select_expr_list}
        |     |   | {select_expr}
        |     |     | {dot}
        |     |     | | {name T2}
        |     |     | | {name id}
        |     |     | {opt_as_alias}
        |     |       | {name id2}
        |     | {select_from_etc}: err
        |       | {join_clause}: err
        |       | | {table_or_subquery}: TABLE { T1: a_table_in_root_region }
        |       | | | {name a_table_in_root_region}: TABLE { T1: a_table_in_root_region }
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: err
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: err
        |       |       | | {name a_table_in_dep_region}
        |       |       | | {opt_as_alias}
        |       |       |   | {name T2}
        |       |       | {join_cond}
        |       |         | {using}
        |       |         | {name_list}
        |       |           | {name id}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW bogus_due_to_non_region_object AS
SELECT *
  FROM bar;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined (while in schema region 'dep2_region', accessing an object that isn't in a region is invalid) 'bar'

  {create_view_stmt}: err
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name bogus_due_to_non_region_object}
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {name bar}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION diamond_region;

  {begin_schema_region_stmt}: ok
  | {name diamond_region}

The statement ending at line XXXX

DROP TABLE a_table_like_proc_in_dep_region;

  {drop_table_stmt}: ok
  | {name a_table_like_proc_in_dep_region}: a_table_like_proc_in_dep_region: { id: integer notnull, name: text, rate: longint }

The statement ending at line XXXX

DROP TABLE a_table_in_root_region;

  {drop_table_stmt}: ok
  | {name a_table_in_root_region}: a_table_in_root_region: { id: integer }

The statement ending at line XXXX

DROP VIEW a_view_in_dep_region;

  {drop_view_stmt}: ok
  | {name a_view_in_dep_region}: a_view_in_dep_region: { id1: integer, id2: integer }

The statement ending at line XXXX

DROP TRIGGER a_trigger_in_root_region;

  {drop_trigger_stmt}: ok
  | {name a_trigger_in_root_region}

The statement ending at line XXXX

DROP INDEX a_index_in_root_region;

  {drop_index_stmt}: ok
  | {name a_index_in_root_region}

The statement ending at line XXXX

CREATE TABLE diamond_region_table(
  id INTEGER
) @RECREATE(d_group);

  {create_table_stmt}: diamond_region_table: { id: integer } @recreate(d_group)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name d_group}
  | | {name diamond_region_table}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

CREATE INDEX invalid_wrong_group_index ON diamond_region_table (id);

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0066: if a table is marked @recreate, its indices must be in its schema region 'invalid_wrong_group_index'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name invalid_wrong_group_index}
  | | {name diamond_region_table}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

SET x := ( WITH
threads2 (count) AS (SELECT 1 AS foo)
SELECT COUNT(*)
  FROM threads2 );

  {assign}: X: integer variable was_set
  | {name x}: X: integer variable was_set
  | {with_select_stmt}: _anon: integer notnull
    | {with}
    | | {cte_tables}: ok
    |   | {cte_table}: threads2: { count: integer notnull }
    |     | {cte_decl}: threads2: { count: integer notnull }
    |     | | {name threads2}
    |     | | {name_list}
    |     |   | {name count}
    |     | {select_stmt}: select: { foo: integer notnull }
    |       | {select_core_list}: select: { foo: integer notnull }
    |       | | {select_core}: select: { foo: integer notnull }
    |       |   | {select_expr_list_con}: select: { foo: integer notnull }
    |       |     | {select_expr_list}: select: { foo: integer notnull }
    |       |     | | {select_expr}: foo: integer notnull
    |       |     |   | {int 1}: integer notnull
    |       |     |   | {opt_as_alias}
    |       |     |     | {name foo}
    |       |     | {select_from_etc}: ok
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {select_stmt}: select: { _anon: integer notnull }
      | {select_core_list}: select: { _anon: integer notnull }
      | | {select_core}: select: { _anon: integer notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull }
      |     | | {select_expr}: integer notnull
      |     |   | {call}: integer notnull
      |     |     | {name COUNT}: integer notnull
      |     |     | {call_arg_list}
      |     |       | {call_filter_clause}
      |     |       | {arg_list}: ok
      |     |         | {star}: integer
      |     | {select_from_etc}: TABLE { threads2: threads2 }
      |       | {table_or_subquery_list}: TABLE { threads2: threads2 }
      |       | | {table_or_subquery}: TABLE { threads2: threads2 }
      |       |   | {name threads2}: TABLE { threads2: threads2 }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC tvf (id INTEGER) (foo TEXT);

  {declare_select_func_stmt}: select: { foo: text } select_func
  | {name tvf}: select: { foo: text }
  | {func_params_return}
    | {params}: ok
    | | {param}: id: integer variable in
    |   | {param_detail}: id: integer variable in
    |     | {name id}: id: integer variable in
    |     | {type_int}: integer
    | {typed_names}: select: { foo: text }
      | {typed_name}: foo: text
        | {name foo}
        | {type_text}: foo: text

The statement ending at line XXXX

SELECT 1
  WHERE tvf(5) = 1;

test/sem_test.sql:XXXX:1: error: in call : CQL0395: table valued functions may not be used in an expression context 'tvf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {int 1}
  |     | {select_from_etc}: err
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {eq}: err
  |         |   | {call}: err
  |         |   | | {name tvf}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   |   | {arg_list}: ok
  |         |   |     | {int 5}
  |         |   | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf ()
BEGIN
  LET v := 1;
  SELECT *
    FROM tvf(LOCALS.v);
END;

  {create_proc_stmt}: using_tvf: { foo: text } dml_proc
  | {name using_tvf}: using_tvf: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {let_stmt}: v: integer notnull variable
      | | {name v}: v: integer notnull variable
      | | {int 1}: integer notnull
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { tvf: select } table_valued_function
        |       | {table_or_subquery_list}: TABLE { tvf: select } table_valued_function
        |       | | {table_or_subquery}: TABLE { tvf: select } table_valued_function
        |       |   | {table_function}: TABLE { tvf: select } table_valued_function
        |       |     | {name tvf}: TABLE { tvf: select } table_valued_function
        |       |     | {arg_list}: ok
        |       |       | {dot}: v: integer notnull variable
        |       |         | {name LOCALS}
        |       |         | {name v}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_error ()
BEGIN
  LET v := 1;
  SELECT *
    FROM tvf(FROM does_not_exist);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'does_not_exist'

  {create_proc_stmt}: err
  | {name using_tvf_error}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: v: integer notnull variable
      | | {name v}: v: integer notnull variable
      | | {int 1}: integer notnull
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name tvf}
        |       |     | {arg_list}: err
        |       |       | {from_shape}
        |       |         | {name does_not_exist}: err
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_invalid_arg ()
BEGIN
  SELECT *
    FROM tvf(NOT 'x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name using_tvf_invalid_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name tvf}
        |       |     | {arg_list}: ok
        |       |       | {not}: err
        |       |         | {strlit 'x'}: text notnull
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_arg_mismatch ()
BEGIN
  SELECT *
    FROM tvf('x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {create_proc_stmt}: err
  | {name using_tvf_arg_mismatch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name tvf}
        |       |     | {arg_list}: ok
        |       |       | {strlit 'x'}: err
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_unaliased ()
BEGIN
  SELECT *
    FROM tvf(1)
    WHERE tvf.foo = 'x';
END;

  {create_proc_stmt}: using_tvf_unaliased: { foo: text } dml_proc
  | {name using_tvf_unaliased}: using_tvf_unaliased: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { tvf: select } table_valued_function
        |       | {table_or_subquery_list}: TABLE { tvf: select } table_valued_function
        |       | | {table_or_subquery}: TABLE { tvf: select } table_valued_function
        |       |   | {table_function}: TABLE { tvf: select } table_valued_function
        |       |     | {name tvf}: TABLE { tvf: select } table_valued_function
        |       |     | {arg_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: foo: text
        |         |   | | {name tvf}
        |         |   | | {name foo}
        |         |   | {strlit 'x'}: text notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_tvf_aliased ()
BEGIN
  SELECT *
    FROM tvf(1) AS T1
    WHERE T1.foo = 'x';
END;

  {create_proc_stmt}: using_tvf_aliased: { foo: text } dml_proc
  | {name using_tvf_aliased}: using_tvf_aliased: { foo: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { foo: text }
        | {select_core_list}: select: { foo: text }
        | | {select_core}: select: { foo: text }
        |   | {select_expr_list_con}: select: { foo: text }
        |     | {select_expr_list}: select: { foo: text }
        |     | | {star}: select: { foo: text }
        |     | {select_from_etc}: TABLE { T1: select } table_valued_function
        |       | {table_or_subquery_list}: TABLE { T1: select } table_valued_function
        |       | | {table_or_subquery}: TABLE { T1: select } table_valued_function
        |       |   | {table_function}: TABLE { T1: select } table_valued_function
        |       |   | | {name tvf}: TABLE { T1: select } table_valued_function
        |       |   | | {arg_list}: ok
        |       |   |   | {int 1}: integer notnull
        |       |   | {opt_as_alias}
        |       |     | {name T1}
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: foo: text
        |         |   | | {name T1}
        |         |   | | {name foo}
        |         |   | {strlit 'x'}: text notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_not_a_tvf ()
BEGIN
  SELECT *
    FROM SqlUserFunc(1);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0249: function is not a table-valued-function 'SqlUserFunc'

  {create_proc_stmt}: err
  | {name using_not_a_tvf}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name SqlUserFunc}
        |       |     | {arg_list}
        |       |       | {int 1}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC using_not_a_func ()
BEGIN
  SELECT *
    FROM ThisDoesNotExist(1);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0250: table-valued function not declared 'ThisDoesNotExist'

  {create_proc_stmt}: err
  | {name using_not_a_func}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {star}
        |     | {select_from_etc}: err
        |       | {table_or_subquery_list}: err
        |       | | {table_or_subquery}: err
        |       |   | {table_function}: err
        |       |     | {name ThisDoesNotExist}
        |       |     | {arg_list}
        |       |       | {int 1}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC ReadFromRowset (rowset OBJECT<rowset>) (id INTEGER);

  {declare_select_func_stmt}: select: { id: integer } select_func
  | {name ReadFromRowset}: select: { id: integer }
  | {func_params_return}
    | {params}: ok
    | | {param}: rowset: object<rowset> variable in
    |   | {param_detail}: rowset: object<rowset> variable in
    |     | {name rowset}: rowset: object<rowset> variable in
    |     | {type_object}: object<rowset>
    |       | {name rowset}
    | {typed_names}: select: { id: integer }
      | {typed_name}: id: integer
        | {name id}
        | {type_int}: id: integer

The statement ending at line XXXX

CREATE PROC rowset_object_reader (rowset OBJECT<rowset>)
BEGIN
  SELECT *
    FROM ReadFromRowset(rowset);
END;

  {create_proc_stmt}: rowset_object_reader: { id: integer } dml_proc
  | {name rowset_object_reader}: rowset_object_reader: { id: integer } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: rowset: object<rowset> variable in
    |   | {param_detail}: rowset: object<rowset> variable in
    |     | {name rowset}: rowset: object<rowset> variable in
    |     | {type_object}: object<rowset>
    |       | {name rowset}
    | {stmt_list}: ok
      | {select_stmt}: select: { id: integer }
        | {select_core_list}: select: { id: integer }
        | | {select_core}: select: { id: integer }
        |   | {select_expr_list_con}: select: { id: integer }
        |     | {select_expr_list}: select: { id: integer }
        |     | | {star}: select: { id: integer }
        |     | {select_from_etc}: TABLE { ReadFromRowset: select } table_valued_function
        |       | {table_or_subquery_list}: TABLE { ReadFromRowset: select } table_valued_function
        |       | | {table_or_subquery}: TABLE { ReadFromRowset: select } table_valued_function
        |       |   | {table_function}: TABLE { ReadFromRowset: select } table_valued_function
        |       |     | {name ReadFromRowset}: TABLE { ReadFromRowset: select } table_valued_function
        |       |     | {arg_list}: ok
        |       |       | {name rowset}: rowset: object<rowset> variable in
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SET ll := ( SELECT ptr(obj_var) );

  {assign}: ll: longint notnull variable was_set
  | {name ll}: ll: longint notnull variable was_set
  | {select_stmt}: _anon: longint notnull
    | {select_core_list}: select: { _anon: longint notnull }
    | | {select_core}: select: { _anon: longint notnull }
    |   | {select_expr_list_con}: select: { _anon: longint notnull }
    |     | {select_expr_list}: select: { _anon: longint notnull }
    |     | | {select_expr}: longint notnull
    |     |   | {call}: longint notnull
    |     |     | {name ptr}: longint notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name obj_var}: obj_var: object variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET ll := ( SELECT ptr(NOT 'x') );

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name ll}: ll: longint notnull variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name ptr}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: err
    |     |         | {not}: err
    |     |           | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET ll := ptr(obj_var);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'ptr'

  {assign}: err
  | {name ll}: ll: longint notnull variable was_set
  | {call}: err
    | {name ptr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

SET ll := ptr(obj_var, 1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'ptr'

  {assign}: err
  | {name ll}: ll: longint notnull variable was_set
  | {call}: err
    | {name ptr}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name obj_var}: obj_var: object variable was_set
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC variable_conflict ()
BEGIN
  DECLARE id INTEGER;
  SET id := ( SELECT id
    FROM foo );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0059: a variable name might be ambiguous with a column name, this is an anti-pattern 'id'

  {create_proc_stmt}: err
  | {name variable_conflict}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: id: integer variable
      | | | {name id}: id: integer variable
      | | {type_int}: integer
      | {assign}: err
        | {name id}: id: integer variable
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {name id}: err
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC variable_conflict_rowid ()
BEGIN
  DECLARE rowid INTEGER;
  SET rowid := ( SELECT rowid
    FROM foo );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0059: a variable name might be ambiguous with a column name, this is an anti-pattern 'rowid'

  {create_proc_stmt}: err
  | {name variable_conflict_rowid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: rowid: integer variable
      | | | {name rowid}: rowid: integer variable
      | | {type_int}: integer
      | {assign}: err
        | {name rowid}: rowid: integer variable
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {name rowid}: err
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT group_concat(name) AS gc
  FROM with_sensitive;

  {select_stmt}: select: { gc: text sensitive }
  | {select_core_list}: select: { gc: text sensitive }
  | | {select_core}: select: { gc: text sensitive }
  |   | {select_expr_list_con}: select: { gc: text sensitive }
  |     | {select_expr_list}: select: { gc: text sensitive }
  |     | | {select_expr}: gc: text sensitive
  |     |   | {call}: text sensitive
  |     |   | | {name group_concat}: text sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name name}: name: text sensitive
  |     |   | {opt_as_alias}
  |     |     | {name gc}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT group_concat('not-null') AS gc
  FROM foo;

  {select_stmt}: select: { gc: text }
  | {select_core_list}: select: { gc: text }
  | | {select_core}: select: { gc: text }
  |   | {select_expr_list_con}: select: { gc: text }
  |     | {select_expr_list}: select: { gc: text }
  |     | | {select_expr}: gc: text
  |     |   | {call}: text
  |     |   | | {name group_concat}: text
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {strlit 'not-null'}: text notnull
  |     |   | {opt_as_alias}
  |     |     | {name gc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC min_gets_blob (a_blob BLOB)
BEGIN
  SELECT min(a_blob)
    FROM foo;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0257: argument must be a string or numeric in 'min'

  {create_proc_stmt}: err
  | {name min_gets_blob}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_blob: blob variable in
    |   | {param_detail}: a_blob: blob variable in
    |     | {name a_blob}: a_blob: blob variable in
    |     | {type_blob}: blob
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name min}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {name a_blob}: a_blob: blob variable in
        |     | {select_from_etc}: TABLE { foo: foo }
        |       | {table_or_subquery_list}: TABLE { foo: foo }
        |       | | {table_or_subquery}: TABLE { foo: foo }
        |       |   | {name foo}: TABLE { foo: foo }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SET my_real := ( SELECT min(1.2, 2, 3) AS min_stuff );

  {assign}: my_real: real variable was_set
  | {name my_real}: my_real: real variable was_set
  | {select_stmt}: min_stuff: real notnull
    | {select_core_list}: select: { min_stuff: real notnull }
    | | {select_core}: select: { min_stuff: real notnull }
    |   | {select_expr_list_con}: select: { min_stuff: real notnull }
    |     | {select_expr_list}: select: { min_stuff: real notnull }
    |     | | {select_expr}: min_stuff: real notnull
    |     |   | {call}: real notnull
    |     |   | | {name min}: real notnull
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {dbl 1.2}: real notnull
    |     |   |     | {arg_list}
    |     |   |       | {int 2}: integer notnull
    |     |   |       | {arg_list}
    |     |   |         | {int 3}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name min_stuff}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT sum(1 AND 1)
  FROM foo;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {call}: integer
  |     |     | {name sum}: integer
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {and}: bool notnull
  |     |           | {int 1}: integer notnull
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(1L)
  FROM foo;

  {select_stmt}: select: { _anon: longint }
  | {select_core_list}: select: { _anon: longint }
  | | {select_core}: select: { _anon: longint }
  |   | {select_expr_list_con}: select: { _anon: longint }
  |     | {select_expr_list}: select: { _anon: longint }
  |     | | {select_expr}: longint
  |     |   | {call}: longint
  |     |     | {name sum}: longint
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {longint 1}: longint notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT sum(1.2)
  FROM foo;

  {select_stmt}: select: { _anon: real }
  | {select_core_list}: select: { _anon: real }
  | | {select_core}: select: { _anon: real }
  |   | {select_expr_list_con}: select: { _anon: real }
  |     | {select_expr_list}: select: { _anon: real }
  |     | | {select_expr}: real
  |     |   | {call}: real
  |     |     | {name sum}: real
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {dbl 1.2}: real notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(1, 'x');

test/sem_test.sql:XXXX:1: error: in call : CQL0012: incompatible types in expression 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(NULL, 'x');

test/sem_test.sql:XXXX:1: error: in call : CQL0257: argument must be a string or numeric in 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {null}: null
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min('x', NULL, 'y');

test/sem_test.sql:XXXX:1: error: in call : CQL0257: argument must be a string or numeric in 'min'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name min}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {null}: null
  |     |           | {arg_list}
  |     |             | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min('x', 'y');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name min}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'x'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'y'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(1, 1.2);

  {select_stmt}: select: { _anon: real notnull }
  | {select_core_list}: select: { _anon: real notnull }
  | | {select_core}: select: { _anon: real notnull }
  |   | {select_expr_list_con}: select: { _anon: real notnull }
  |     | {select_expr_list}: select: { _anon: real notnull }
  |     | | {select_expr}: real notnull
  |     |   | {call}: real notnull
  |     |     | {name min}: real notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {dbl 1.2}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT min(_sens, 1L);

  {select_stmt}: select: { _anon: longint sensitive }
  | {select_core_list}: select: { _anon: longint sensitive }
  | | {select_core}: select: { _anon: longint sensitive }
  |   | {select_expr_list_con}: select: { _anon: longint sensitive }
  |     | {select_expr_list}: select: { _anon: longint sensitive }
  |     | | {select_expr}: longint sensitive
  |     |   | {call}: longint sensitive
  |     |     | {name min}: longint sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name _sens}: _sens: integer variable sensitive was_set
  |     |         | {arg_list}
  |     |           | {longint 1}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_1(
  id INTEGER PRIMARY KEY REFERENCES recreatable (id),
  name TEXT
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0060: referenced table can be independently recreated so it cannot be used in a foreign key 'recreatable'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name recreatable_reference_1}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name recreatable}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 0}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE recreatable_reference_2(
  id INTEGER PRIMARY KEY REFERENCES recreatable (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE;

  {create_table_stmt}: recreatable_reference_2: { id: integer notnull primary_key foreign_key, name: text } @recreate
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable_reference_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: ok
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name recreatable}
    |         | | {name_list}
    |         |   | {name id}: id: integer notnull
    |         | {int 51}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE in_group_test(
  id INTEGER PRIMARY KEY,
  name TEXT
) @RECREATE(rtest);

  {create_table_stmt}: in_group_test: { id: integer notnull primary_key, name: text } @recreate(rtest)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest}
  | | {name in_group_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE recreatable_reference_3(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE;

  {create_table_stmt}: recreatable_reference_3: { id: integer notnull primary_key foreign_key, name: text } @recreate
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name recreatable_reference_3}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: ok
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}: id: integer notnull
    |         | {int 51}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE recreatable_reference_4(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id) ON UPDATE CASCADE ON DELETE CASCADE,
  id2 INTEGER REFERENCES recreatable_reference_3 (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE(rtest_other_group);

  {create_table_stmt}: recreatable_reference_4: { id: integer notnull primary_key foreign_key, id2: integer foreign_key, name: text } @recreate(rtest_other_group)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest_other_group}
  | | {name recreatable_reference_4}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: ok
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}: id: integer notnull
    |         | {int 51}
    | {col_key_list}
      | {col_def}: id2: integer foreign_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id2}
      |   | | {type_int}: integer
      |   | {col_attrs_fk}: ok
      |     | {fk_target_options}
      |       | {fk_target}
      |       | | {name recreatable_reference_3}
      |       | | {name_list}
      |       |   | {name id}: id: integer notnull
      |       | {int 51}
      | {col_key_list}
        | {col_def}: name: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name name}
              | {type_text}: text

The statement ending at line XXXX

CREATE TABLE recreatable_reference_5(
  id INTEGER PRIMARY KEY REFERENCES in_group_test (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE(rtest);

  {create_table_stmt}: recreatable_reference_5: { id: integer notnull primary_key foreign_key, name: text } @recreate(rtest)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest}
  | | {name recreatable_reference_5}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: ok
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name in_group_test}
    |         | | {name_list}
    |         |   | {name id}: id: integer notnull
    |         | {int 51}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE recreatable_reference_6(
  id INTEGER PRIMARY KEY REFERENCES recreatable_reference_4 (id) ON UPDATE CASCADE ON DELETE CASCADE,
  name TEXT
) @RECREATE(rtest);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0060: referenced table can be independently recreated so it cannot be used in a foreign key 'recreatable_reference_4'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | |   | {name rtest}
  | | {name recreatable_reference_6}
  | {col_key_list}
    | {col_def}: err
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: err
    |     | {autoinc_and_conflict_clause}
    |     | {col_attrs_fk}: err
    |       | {fk_target_options}
    |         | {fk_target}
    |         | | {name recreatable_reference_4}
    |         | | {name_list}
    |         |   | {name id}
    |         | {int 51}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name name}
            | {type_text}

The statement ending at line XXXX

CREATE TABLE early_out_on_errs(
  result_index INTEGER NOT NULL,
  query TEXT NOT NULL,
  FOREIGN KEY (query) REFERENCES table_not_found (q),
  PRIMARY KEY (garbonzo)
) @RECREATE;

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0021: foreign key refers to non-existent table 'table_not_found'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {recreate_attr}
  | | {name early_out_on_errs}
  | {col_key_list}
    | {col_def}: result_index: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name result_index}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: query: text notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name query}
      |   | | {type_text}: text
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {fk_def}
        | | {fk_info}
        |   | {name_list}
        |   | | {name query}: query: text notnull
        |   | {fk_target_options}
        |     | {fk_target}
        |     | | {name table_not_found}
        |     | | {name_list}
        |     |   | {name q}
        |     | {int 0}
        | {col_key_list}
          | {pk_def}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name garbonzo}

The statement ending at line XXXX

CREATE PROC invalid_ddl_1 ()
BEGIN
  CREATE TABLE inv_1(
    id INTEGER
  ) @RECREATE(xyx);
END;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'inv_1'

  {create_proc_stmt}: err
  | {name invalid_ddl_1}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_table_stmt}: err
        | {create_table_name_flags}
        | | {table_flags_attrs}
        | | | {int 0}
        | | | {recreate_attr}
        | |   | {name xyx}
        | | {name inv_1}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name id}
                | {type_int}

The statement ending at line XXXX

CREATE PROC invalid_ddl_2 ()
BEGIN
  CREATE TABLE inv2(
    id INTEGER
  ) @CREATE(1);
END;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'inv2'

  {create_proc_stmt}: err
  | {name invalid_ddl_2}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_table_stmt}: err
        | {create_table_name_flags}
        | | {table_flags_attrs}
        | | | {int 0}
        | | | {create_attr}
        | |   | {version_annotation}
        | |     | {int 1}
        | | {name inv2}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name id}
                | {type_int}

The statement ending at line XXXX

CREATE PROC invalid_ddl_3 ()
BEGIN
  CREATE TABLE inv3(
    id INTEGER
  ) @DELETE(2);
END;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'inv3'

  {create_proc_stmt}: err
  | {name invalid_ddl_3}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_table_stmt}: err
        | {create_table_name_flags}
        | | {table_flags_attrs}
        | | | {int 0}
        | | | {delete_attr}
        | |   | {version_annotation}
        | |     | {int 2}
        | | {name inv3}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name id}
                | {type_int}

The statement ending at line XXXX

CREATE PROC invalid_ddl_4 ()
BEGIN
  CREATE INDEX inv_4 ON bar (x) @DELETE(2);
END;

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'inv_4'

  {create_proc_stmt}: err
  | {name invalid_ddl_4}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_index_stmt}: err
        | {create_index_on_list}
        | | {name inv_4}
        | | {name bar}
        | {flags_names_attrs}
          | {int 0}
          | {connector}
            | {index_names_and_attrs}
            | | {indexed_columns}
            |   | {indexed_column}
            |     | {name x}
            | {delete_attr}
              | {version_annotation}
                | {int 2}

The statement ending at line XXXX

CREATE PROC invalid_ddl_5 ()
BEGIN
  CREATE VIEW inv_5 AS
  SELECT 1 AS f1 @DELETE(2);
END;

test/sem_test.sql:XXXX:1: error: in create_view_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'inv_5'

  {create_proc_stmt}: err
  | {name invalid_ddl_5}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_view_stmt}: err
        | {int 0}
        | {view_and_attrs}
          | {name_and_select}
          | | {name inv_5}
          | | {select_stmt}: select: { f1: integer notnull }
          |   | {select_core_list}: select: { f1: integer notnull }
          |   | | {select_core}: select: { f1: integer notnull }
          |   |   | {select_expr_list_con}: select: { f1: integer notnull }
          |   |     | {select_expr_list}: select: { f1: integer notnull }
          |   |     | | {select_expr}: f1: integer notnull
          |   |     |   | {int 1}: integer notnull
          |   |     |   | {opt_as_alias}
          |   |     |     | {name f1}
          |   |     | {select_from_etc}: ok
          |   |       | {select_where}
          |   |         | {select_groupby}
          |   |           | {select_having}
          |   | {select_orderby}
          |     | {select_limit}
          |       | {select_offset}
          | {delete_attr}
            | {version_annotation}
              | {int 2}

The statement ending at line XXXX

CREATE PROC invalid_ddl_6 ()
BEGIN
  CREATE TRIGGER IF NOT EXISTS trigger2
    AFTER INSERT ON bar
  BEGIN
    DELETE FROM bar WHERE rate > new.id;
  END @DELETE(2);
END;

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0396: versioning attributes may not be used on DDL inside a procedure 'trigger2'

  {create_proc_stmt}: err
  | {name invalid_ddl_6}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_trigger_stmt}: err
        | {int 2}
        | {trigger_body_vers}
          | {trigger_def}
          | | {name trigger2}
          | | {trigger_condition}
          |   | {int 8}
          |   | {trigger_op_target}
          |     | {trigger_operation}
          |     | | {int 128}
          |     | {trigger_target_action}
          |       | {name bar}
          |       | {trigger_action}
          |         | {int 0}
          |         | {trigger_when_stmts}
          |           | {stmt_list}
          |             | {delete_stmt}
          |               | {name bar}
          |               | {opt_where}
          |                 | {gt}
          |                   | {name rate}
          |                   | {dot}
          |                     | {name new}
          |                     | {name id}
          | {delete_attr}
            | {version_annotation}
              | {int 2}

The statement ending at line XXXX

@ENFORCE_STRICT JOIN;

  {enforce_strict_stmt}: ok
  | {int 3}

The statement ending at line XXXX

SELECT *
  FROM foo,
bar;

test/sem_test.sql:XXXX:1: error: in table_or_subquery_list : CQL0263: non-ANSI joins are forbidden if strict join mode is enabled

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {table_or_subquery_list}
  |       |   | {table_or_subquery}
  |       |     | {name bar}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC bar ()
BEGIN
  DECLARE C CURSOR FOR CALL out_cursor_proc();
END;

test/sem_test.sql:XXXX:1: error: in declare_cursor : CQL0270: use FETCH FROM for procedures that returns a cursor with OUT 'C'

  {create_proc_stmt}: err
  | {name bar}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
          | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out

The statement ending at line XXXX

SELECT *
  FROM foo
OFFSET 1;

test/sem_test.sql:XXXX:1: error: in opt_offset : CQL0271: OFFSET clause may only be used if LIMIT is also present

  {select_stmt}: err
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}: err
    | {select_limit}
      | {select_offset}
        | {opt_offset}: err
          | {int 1}

The statement ending at line XXXX

CREATE PROC upsert_do_nothing ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_do_nothing}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: select: { id: integer notnull }
        |       | {select_core_list}: select: { id: integer notnull }
        |       | | {select_core}: select: { id: integer notnull }
        |       |   | {select_expr_list_con}: select: { id: integer notnull }
        |       |     | {select_expr_list}: select: { id: integer notnull }
        |       |     | | {select_expr}: id: integer notnull
        |       |     |   | {name id}: id: integer notnull
        |       |     | {select_from_etc}: TABLE { bar: bar }
        |       |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |       |   | {name bar}: TABLE { bar: bar }
        |       |       | {select_where}
        |       |         | {opt_where}: integer notnull
        |       |         | | {int 1}: integer notnull
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }
            | {indexed_columns}
              | {indexed_column}
                | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE PROC with_upsert_do_nothing ()
BEGIN
  WITH
  data (id) AS (VALUES(1), (2), (3))
  INSERT INTO foo(id) SELECT id
    FROM data
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name with_upsert_do_nothing}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_upsert_stmt}: ok
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: data: { id: integer notnull }
        |     | {cte_decl}: data: { id: integer notnull }
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |     | | {int 1}: integer notnull
        |       |     | {values}
        |       |       | {insert_list}: ok
        |       |       | | {int 2}: integer notnull
        |       |       | {values}
        |       |         | {insert_list}: ok
        |       |           | {int 3}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}: ok
          | {insert_stmt}: ok
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name id}: id: integer notnull
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {select_expr}: id: integer notnull
          |       |     |   | {name id}: id: integer notnull
          |       |     | {select_from_etc}: TABLE { data: data }
          |       |       | {table_or_subquery_list}: TABLE { data: data }
          |       |       | | {table_or_subquery}: TABLE { data: data }
          |       |       |   | {name data}: TABLE { data: data }
          |       |       | {select_where}
          |       |         | {opt_where}: integer notnull
          |       |         | | {int 1}: integer notnull
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}: ok
            | {conflict_target}: excluded: { id: integer notnull }
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer notnull

The statement ending at line XXXX

CREATE PROC with_upsert_cte_err ()
BEGIN
  WITH
  data (id) AS (VALUES(NOT 'x'))
  INSERT INTO foo SELECT id
    FROM data
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_upsert_cte_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_upsert_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}: err
        |       |   | {select_values}
        |       |   | {values}: err
        |       |     | {insert_list}: ok
        |       |       | {not}: err
        |       |         | {strlit 'x'}: text notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}
          | {insert_stmt}
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}
          |   | {columns_values}
          |     | {select_stmt}
          |       | {select_core_list}
          |       | | {select_core}
          |       |   | {select_expr_list_con}
          |       |     | {select_expr_list}
          |       |     | | {select_expr}
          |       |     |   | {name id}
          |       |     | {select_from_etc}
          |       |       | {table_or_subquery_list}
          |       |       | | {table_or_subquery}
          |       |       |   | {name data}
          |       |       | {select_where}
          |       |         | {opt_where}
          |       |         | | {int 1}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}
            | {conflict_target}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}

The statement ending at line XXXX

CREATE PROC with_upsert_insert_err ()
BEGIN
  WITH
  data (id) AS (VALUES(1))
  INSERT INTO foo(id) SELECT id
    FROM data
    WHERE NOT 'x'
  ON CONFLICT (id) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name with_upsert_insert_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_upsert_stmt}: err
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: data: { id: integer notnull }
        |     | {cte_decl}: data: { id: integer notnull }
        |     | | {name data}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_stmt}: err
          | {insert_stmt}: err
          | | {insert_normal}
          | | {name_columns_values}
          |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: err
          |       | {select_core_list}: err
          |       | | {select_core}: err
          |       |   | {select_expr_list_con}: err
          |       |     | {select_expr_list}: err
          |       |     | | {select_expr}
          |       |     |   | {name id}
          |       |     | {select_from_etc}: err
          |       |       | {table_or_subquery_list}: TABLE { data: data }
          |       |       | | {table_or_subquery}: TABLE { data: data }
          |       |       |   | {name data}: TABLE { data: data }
          |       |       | {select_where}
          |       |         | {opt_where}: err
          |       |         | | {not}: err
          |       |         |   | {strlit 'x'}: text notnull
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {upsert_update}
            | {conflict_target}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}

The statement ending at line XXXX

CREATE PROC upsert_without_conflict_target ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_without_conflict_target}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }

The statement ending at line XXXX

CREATE PROC upsert_update ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) 
    WHERE id = 10 DO UPDATE
  SET id = id + 1
    WHERE id = 20;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_update}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { id: integer notnull }
          | | {indexed_columns}
          | | | {indexed_column}
          | |   | {name id}: id: integer notnull
          | | {opt_where}: bool notnull
          |   | {eq}: bool notnull
          |     | {name id}: id: integer notnull
          |     | {int 10}: integer notnull
          | {update_stmt}: foo: { id: integer notnull primary_key autoinc }
            | {update_set}
              | {update_list}: ok
              | | {update_entry}: id: integer notnull
              |   | {name id}: id: integer notnull
              |   | {add}: integer notnull
              |     | {name id}: id: integer notnull
              |     | {int 1}: integer notnull
              | {update_from}
                | {update_where}
                  | {opt_where}: bool notnull
                  | | {eq}: bool notnull
                  |   | {name id}: id: integer notnull
                  |   | {int 20}: integer notnull
                  | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_conflict_on_unknown_column ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id, bogus) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {create_proc_stmt}: err
  | {name upsert_conflict_on_unknown_column}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}: err
              | {indexed_column}
              | | {name id}: id: integer notnull
              | {indexed_columns}
                | {indexed_column}
                  | {name bogus}: err

The statement ending at line XXXX

CREATE PROC upsert_invalid_update_stmt ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) DO UPDATE foo
  SET id = 0;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0281: upsert statement does not include table name in the update statement 'foo'

  {create_proc_stmt}: err
  | {name upsert_invalid_update_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: excluded: { id: integer notnull }
          | | {indexed_columns}
          |   | {indexed_column}
          |     | {name id}: id: integer notnull
          | {update_stmt}: err
            | {name foo}: foo: { id: integer notnull primary_key autoinc }
            | {update_set}
              | {update_list}
              | | {update_entry}
              |   | {name id}
              |   | {int 0}
              | {update_from}
                | {update_where}
                  | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_no_where_stmt ()
BEGIN
  INSERT INTO foo(id) SELECT id
    FROM (SELECT *
    FROM bar)
  ON CONFLICT (id) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in insert_stmt : CQL0280: upsert statement requires a where clause if the insert clause uses select

  {create_proc_stmt}: err
  | {name upsert_no_where_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: err
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: select: { id: integer notnull }
        |       | {select_core_list}: select: { id: integer notnull }
        |       | | {select_core}: select: { id: integer notnull }
        |       |   | {select_expr_list_con}: select: { id: integer notnull }
        |       |     | {select_expr_list}: select: { id: integer notnull }
        |       |     | | {select_expr}: id: integer notnull
        |       |     |   | {name id}: id: integer notnull
        |       |     | {select_from_etc}: TABLE { select: select }
        |       |       | {table_or_subquery_list}: TABLE { select: select }
        |       |       | | {table_or_subquery}: TABLE { select: select }
        |       |       |   | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
        |       |       |     |     | {select_from_etc}: TABLE { bar: bar }
        |       |       |     |       | {table_or_subquery_list}: TABLE { bar: bar }
        |       |       |     |       | | {table_or_subquery}: TABLE { bar: bar }
        |       |       |     |       |   | {name bar}: TABLE { bar: bar }
        |       |       |     |       | {select_where}
        |       |       |     |         | {select_groupby}
        |       |       |     |           | {select_having}
        |       |       |     | {select_orderby}
        |       |       |       | {select_limit}
        |       |       |         | {select_offset}
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}
          | {conflict_target}: excluded: { id: integer notnull }
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE PROC upsert_or_ignore ()
BEGIN
  INSERT OR IGNORE INTO foo SELECT id
    FROM bar
    WHERE 1
  ON CONFLICT (id) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in insert_or_ignore : CQL0283: upsert syntax only supports INSERT INTO 'foo'

  {create_proc_stmt}: err
  | {name upsert_or_ignore}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: err
        | | {insert_or_ignore}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}
        |       |   | {select_expr_list_con}
        |       |     | {select_expr_list}
        |       |     | | {select_expr}
        |       |     |   | {name id}
        |       |     | {select_from_etc}
        |       |       | {table_or_subquery_list}
        |       |       | | {table_or_subquery}
        |       |       |   | {name bar}
        |       |       | {select_where}
        |       |         | {opt_where}
        |       |         | | {int 1}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}
          | {conflict_target}
            | {indexed_columns}
              | {indexed_column}
                | {name id}

The statement ending at line XXXX

CREATE PROC upsert_with_bogus_where_stmt ()
BEGIN
  INSERT INTO foo(id) VALUES(1)
  ON CONFLICT (id) 
    WHERE bogus = 1 DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {create_proc_stmt}: err
  | {name upsert_with_bogus_where_stmt}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}
            | | {indexed_column}
            |   | {name id}: id: integer notnull
            | {opt_where}: err
              | {eq}: err
                | {name bogus}: err
                | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC update_without_table_name ()
BEGIN
  CREATE TEMP TRIGGER update_without_table_name_trigger
    BEFORE DELETE ON bar
  BEGIN
    UPDATE
    SET id = 1
      WHERE id = 9;
  END;
END;

test/sem_test.sql:XXXX:1: error: in update_stmt : CQL0282: update statement require table name

  {create_proc_stmt}: err
  | {name update_without_table_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {create_trigger_stmt}: err
        | {int 1}
        | {trigger_body_vers}
          | {trigger_def}
            | {name update_without_table_name_trigger}
            | {trigger_condition}
              | {int 4}
              | {trigger_op_target}
                | {trigger_operation}
                | | {int 64}
                | {trigger_target_action}
                  | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                  | {trigger_action}
                    | {int 0}
                    | {trigger_when_stmts}
                      | {stmt_list}: err
                        | {update_stmt}: err
                          | {update_set}
                            | {update_list}
                            | | {update_entry}
                            |   | {name id}
                            |   | {int 1}
                            | {update_from}
                              | {update_where}
                                | {opt_where}
                                | | {eq}
                                |   | {name id}
                                |   | {int 9}
                                | {update_orderby}

The statement ending at line XXXX

CREATE PROC upsert_conflict_target_column_not_unique_key ()
BEGIN
  INSERT INTO bar(id) VALUES(1)
  ON CONFLICT (name) DO NOTHING;
END;

test/sem_test.sql:XXXX:1: error: in indexed_columns : CQL0279: columns referenced in an UPSERT conflict target must exactly match a unique key the target table

  {create_proc_stmt}: err
  | {name upsert_conflict_target_column_not_unique_key}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {upsert_stmt}: err
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name id}: id: integer notnull
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: err
          | {conflict_target}: err
            | {indexed_columns}
              | {indexed_column}
                | {name name}: name: text

The statement ending at line XXXX

CREATE PROC upsert_conflict_target_columns_valid ()
BEGIN
  INSERT INTO simple_ak_table_2(a, b, c, d) VALUES(1, "t", 1.7, 1)
  ON CONFLICT (a, b) DO NOTHING;
END;

  {create_proc_stmt}: ok dml_proc
  | {name upsert_conflict_target_columns_valid}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {upsert_stmt}: ok
        | {insert_stmt}: ok
        | | {insert_normal}
        | | {name_columns_values}
        |   | {name simple_ak_table_2}: simple_ak_table_2: { a: integer notnull, b: text, c: real, d: longint }
        |   | {columns_values}: ok
        |     | {column_spec}
        |     | | {name_list}
        |     |   | {name a}: a: integer notnull
        |     |   | {name_list}
        |     |     | {name b}: b: text
        |     |     | {name_list}
        |     |       | {name c}: c: real
        |     |       | {name_list}
        |     |         | {name d}: d: longint
        |     | {select_stmt}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull, column2: text notnull, column3: real notnull, column4: integer notnull }
        |       |     | {insert_list}: ok
        |       |       | {int 1}: integer notnull
        |       |       | {insert_list}
        |       |         | {strlit 't'}: text notnull
        |       |         | {insert_list}
        |       |           | {dbl 1.7}: real notnull
        |       |           | {insert_list}
        |       |             | {int 1}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {upsert_update}: ok
          | {conflict_target}: excluded: { a: integer notnull, b: text, c: real, d: longint }
            | {indexed_columns}
              | {indexed_column}
              | | {name a}: a: integer notnull
              | {indexed_columns}
                | {indexed_column}
                  | {name b}: b: text

The statement ending at line XXXX

@ENFORCE_STRICT UPSERT STATEMENT;

  {enforce_strict_stmt}: ok
  | {int 4}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES(1)
ON CONFLICT DO NOTHING;

test/sem_test.sql:XXXX:1: error: in upsert_stmt : CQL0289: upsert statement are forbidden if strict upsert statement mode is enabled

  {upsert_stmt}: err
  | {insert_stmt}
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name bar}
  |   | {columns_values}
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}
  |       |   | {select_values}
  |       |   | {values}
  |       |     | {insert_list}
  |       |       | {int 1}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}
    | {conflict_target}

The statement ending at line XXXX

@ENFORCE_NORMAL UPSERT STATEMENT;

  {enforce_normal_stmt}: ok
  | {int 4}

The statement ending at line XXXX

INSERT INTO bar(id) VALUES(1)
ON CONFLICT DO NOTHING;

  {upsert_stmt}: ok
  | {insert_stmt}: ok
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
  |   | {columns_values}: ok
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}: id: integer notnull
  |     | {select_stmt}: values: { column1: integer notnull }
  |       | {select_core_list}: values: { column1: integer notnull }
  |       | | {select_core}: values: { column1: integer notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull }
  |       |     | {insert_list}: ok
  |       |       | {int 1}: integer notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}: ok
    | {conflict_target}: excluded: { id: integer notnull }

The statement ending at line XXXX

@ENFORCE_STRICT WINDOW FUNCTION;

  {enforce_strict_stmt}: ok
  | {int 5}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in window_func_inv : CQL0312: window function invocation are forbidden if strict window function mode is enabled

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}
  |     |       | | {name rank}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL WINDOW FUNCTION;

  {enforce_normal_stmt}: ok
  | {int 5}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET X := max(1, 2);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'max'

  {assign}: err
  | {name X}: X: integer variable was_set
  | {call}: err
    | {name max}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull
        | {arg_list}
          | {int 2}: integer notnull

The statement ending at line XXXX

SET a_string := substr('x', 1, 2);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'substr'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name substr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull
          | {arg_list}
            | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC substr_test_notnull (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, 1, 2) AS t;
END;

  {create_proc_stmt}: substr_test_notnull: { t: text notnull } dml_proc
  | {name substr_test_notnull}: substr_test_notnull: { t: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text notnull }
        | {select_core_list}: select: { t: text notnull }
        | | {select_core}: select: { t: text notnull }
        |   | {select_expr_list_con}: select: { t: text notnull }
        |     | {select_expr_list}: select: { t: text notnull }
        |     | | {select_expr}: t: text notnull
        |     |   | {call}: text notnull
        |     |   | | {name substr}: text notnull
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text notnull variable in
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_onearg (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, 1) AS t;
END;

  {create_proc_stmt}: substr_test_onearg: { t: text notnull } dml_proc
  | {name substr_test_onearg}: substr_test_onearg: { t: text notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text notnull }
        | {select_core_list}: select: { t: text notnull }
        | | {select_core}: select: { t: text notnull }
        |   | {select_expr_list_con}: select: { t: text notnull }
        |     | {select_expr_list}: select: { t: text notnull }
        |     | | {select_expr}: t: text notnull
        |     |   | {call}: text notnull
        |     |   | | {name substr}: text notnull
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text notnull variable in
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_nullable_string (t TEXT)
BEGIN
  SELECT substr(t, 1, 2) AS t;
END;

  {create_proc_stmt}: substr_test_nullable_string: { t: text } dml_proc
  | {name substr_test_nullable_string}: substr_test_nullable_string: { t: text } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in
    |   | {param_detail}: t: text variable in
    |     | {name t}: t: text variable in
    |     | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text }
        | {select_core_list}: select: { t: text }
        | | {select_core}: select: { t: text }
        |   | {select_expr_list_con}: select: { t: text }
        |     | {select_expr_list}: select: { t: text }
        |     | | {select_expr}: t: text
        |     |   | {call}: text
        |     |   | | {name substr}: text
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text variable in
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_nullable_start (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, nullable(1), 2) AS t;
END;

  {create_proc_stmt}: substr_test_nullable_start: { t: text } dml_proc
  | {name substr_test_nullable_start}: substr_test_nullable_start: { t: text } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text }
        | {select_core_list}: select: { t: text }
        | | {select_core}: select: { t: text }
        |   | {select_expr_list_con}: select: { t: text }
        |     | {select_expr_list}: select: { t: text }
        |     | | {select_expr}: t: text
        |     |   | {call}: text
        |     |   | | {name substr}: text
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text notnull variable in
        |     |   |     | {arg_list}
        |     |   |       | {call}: integer
        |     |   |       | | {name nullable}: integer
        |     |   |       | | {call_arg_list}
        |     |   |       |   | {call_filter_clause}
        |     |   |       |   | {arg_list}: ok
        |     |   |       |     | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_nullable_count (t TEXT NOT NULL)
BEGIN
  SELECT substr(t, 1, nullable(2)) AS t;
END;

  {create_proc_stmt}: substr_test_nullable_count: { t: text } dml_proc
  | {name substr_test_nullable_count}: substr_test_nullable_count: { t: text } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable in
    |   | {param_detail}: t: text notnull variable in
    |     | {name t}: t: text notnull variable in
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text }
        | {select_core_list}: select: { t: text }
        | | {select_core}: select: { t: text }
        |   | {select_expr_list_con}: select: { t: text }
        |     | {select_expr_list}: select: { t: text }
        |     | | {select_expr}: t: text
        |     |   | {call}: text
        |     |   | | {name substr}: text
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text notnull variable in
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {call}: integer
        |     |   |           | {name nullable}: integer
        |     |   |           | {call_arg_list}
        |     |   |             | {call_filter_clause}
        |     |   |             | {arg_list}: ok
        |     |   |               | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_sensitive_string (t TEXT @SENSITIVE)
BEGIN
  SELECT substr(t, 1, 2) AS t;
END;

  {create_proc_stmt}: substr_test_sensitive_string: { t: text sensitive } dml_proc
  | {name substr_test_sensitive_string}: substr_test_sensitive_string: { t: text sensitive } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in sensitive
    |   | {param_detail}: t: text variable in sensitive
    |     | {name t}: t: text variable in sensitive
    |     | {sensitive_attr}: text sensitive
    |       | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text sensitive }
        | {select_core_list}: select: { t: text sensitive }
        | | {select_core}: select: { t: text sensitive }
        |   | {select_expr_list_con}: select: { t: text sensitive }
        |     | {select_expr_list}: select: { t: text sensitive }
        |     | | {select_expr}: t: text sensitive
        |     |   | {call}: text sensitive
        |     |   | | {name substr}: text sensitive
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text variable in sensitive
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_sensitive_start (t TEXT)
BEGIN
  SELECT substr(t, sensitive(1), 2) AS t;
END;

  {create_proc_stmt}: substr_test_sensitive_start: { t: text sensitive } dml_proc
  | {name substr_test_sensitive_start}: substr_test_sensitive_start: { t: text sensitive } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in
    |   | {param_detail}: t: text variable in
    |     | {name t}: t: text variable in
    |     | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text sensitive }
        | {select_core_list}: select: { t: text sensitive }
        | | {select_core}: select: { t: text sensitive }
        |   | {select_expr_list_con}: select: { t: text sensitive }
        |     | {select_expr_list}: select: { t: text sensitive }
        |     | | {select_expr}: t: text sensitive
        |     |   | {call}: text sensitive
        |     |   | | {name substr}: text sensitive
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text variable in
        |     |   |     | {arg_list}
        |     |   |       | {call}: integer notnull sensitive
        |     |   |       | | {name sensitive}: integer notnull sensitive
        |     |   |       | | {call_arg_list}
        |     |   |       |   | {call_filter_clause}
        |     |   |       |   | {arg_list}: ok
        |     |   |       |     | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_sensitive_count (t TEXT)
BEGIN
  SELECT substr(t, 1, sensitive(2)) AS t;
END;

  {create_proc_stmt}: substr_test_sensitive_count: { t: text sensitive } dml_proc
  | {name substr_test_sensitive_count}: substr_test_sensitive_count: { t: text sensitive } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text variable in
    |   | {param_detail}: t: text variable in
    |     | {name t}: t: text variable in
    |     | {type_text}: text
    | {stmt_list}: ok
      | {select_stmt}: select: { t: text sensitive }
        | {select_core_list}: select: { t: text sensitive }
        | | {select_core}: select: { t: text sensitive }
        |   | {select_expr_list_con}: select: { t: text sensitive }
        |     | {select_expr_list}: select: { t: text sensitive }
        |     | | {select_expr}: t: text sensitive
        |     |   | {call}: text sensitive
        |     |   | | {name substr}: text sensitive
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name t}: t: text variable in
        |     |   |     | {arg_list}
        |     |   |       | {int 1}: integer notnull
        |     |   |       | {arg_list}
        |     |   |         | {call}: integer notnull sensitive
        |     |   |           | {name sensitive}: integer notnull sensitive
        |     |   |           | {call_arg_list}
        |     |   |             | {call_filter_clause}
        |     |   |             | {arg_list}: ok
        |     |   |               | {int 2}: integer notnull
        |     |   | {opt_as_alias}
        |     |     | {name t}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_notstring ()
BEGIN
  SELECT substr(3, 1, 2);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0086: first argument must be a string in function 'substr'

  {create_proc_stmt}: err
  | {name substr_test_notstring}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {int 3}: integer notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_arg2string ()
BEGIN
  SELECT substr('x', '1', 2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0083: argument must be numeric 'substr'

  {create_proc_stmt}: err
  | {name substr_test_arg2string}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {strlit '1'}: text notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_arg3string ()
BEGIN
  SELECT substr('x', 1, '2');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0083: argument must be numeric 'substr'

  {create_proc_stmt}: err
  | {name substr_test_arg3string}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {strlit '2'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_toofew ()
BEGIN
  SELECT substr('x');
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'substr'

  {create_proc_stmt}: err
  | {name substr_test_toofew}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}: err
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC substr_test_toomany ()
BEGIN
  SELECT substr('x', 1, 2, 4);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'substr'

  {create_proc_stmt}: err
  | {name substr_test_toomany}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |     | {name substr}: err
        |     |     | {call_arg_list}
        |     |       | {call_filter_clause}
        |     |       | {arg_list}: ok
        |     |         | {strlit 'x'}: text notnull
        |     |         | {arg_list}
        |     |           | {int 1}: integer notnull
        |     |           | {arg_list}
        |     |             | {int 2}: integer notnull
        |     |             | {arg_list}
        |     |               | {int 4}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b');

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', 'c', 'd');

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     |             | {arg_list}
  |     |               | {strlit 'd'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET dummy := replace('a', 'b', 'c');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'replace'

  {let_stmt}: err
  | {name dummy}
  | {call}: err
    | {name replace}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'a'}: text notnull
        | {arg_list}
          | {strlit 'b'}: text notnull
          | {arg_list}
            | {strlit 'c'}: text notnull

The statement ending at line XXXX

SELECT replace(0, 'b', 'c');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 0}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 0, 'c');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', 0);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', 'c');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name replace}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace(nullable('a'), 'b', 'c');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name replace}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {call}: text
  |     |         | | {name nullable}: text
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         |   | {arg_list}: ok
  |     |         |     | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', nullable('b'), 'c');

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name replace}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {call}: text
  |     |           | | {name nullable}: text
  |     |           | | {call_arg_list}
  |     |           |   | {call_filter_clause}
  |     |           |   | {arg_list}: ok
  |     |           |     | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', nullable('c'));

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name replace}: text
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {call}: text
  |     |               | {name nullable}: text
  |     |               | {call_arg_list}
  |     |                 | {call_filter_clause}
  |     |                 | {arg_list}: ok
  |     |                   | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace(NULL, 'b', 'c');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {null}: null
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', NULL, 'c');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {null}: null
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', NULL);

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'replace'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name replace}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace(sensitive('a'), 'b', 'c');

  {select_stmt}: select: { _anon: text notnull sensitive }
  | {select_core_list}: select: { _anon: text notnull sensitive }
  | | {select_core}: select: { _anon: text notnull sensitive }
  |   | {select_expr_list_con}: select: { _anon: text notnull sensitive }
  |     | {select_expr_list}: select: { _anon: text notnull sensitive }
  |     | | {select_expr}: text notnull sensitive
  |     |   | {call}: text notnull sensitive
  |     |     | {name replace}: text notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {call}: text notnull sensitive
  |     |         | | {name sensitive}: text notnull sensitive
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         |   | {arg_list}: ok
  |     |         |     | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', sensitive('b'), 'c');

  {select_stmt}: select: { _anon: text notnull sensitive }
  | {select_core_list}: select: { _anon: text notnull sensitive }
  | | {select_core}: select: { _anon: text notnull sensitive }
  |   | {select_expr_list_con}: select: { _anon: text notnull sensitive }
  |     | {select_expr_list}: select: { _anon: text notnull sensitive }
  |     | | {select_expr}: text notnull sensitive
  |     |   | {call}: text notnull sensitive
  |     |     | {name replace}: text notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {call}: text notnull sensitive
  |     |           | | {name sensitive}: text notnull sensitive
  |     |           | | {call_arg_list}
  |     |           |   | {call_filter_clause}
  |     |           |   | {arg_list}: ok
  |     |           |     | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT replace('a', 'b', sensitive('c'));

  {select_stmt}: select: { _anon: text notnull sensitive }
  | {select_core_list}: select: { _anon: text notnull sensitive }
  | | {select_core}: select: { _anon: text notnull sensitive }
  |   | {select_expr_list_con}: select: { _anon: text notnull sensitive }
  |     | {select_expr_list}: select: { _anon: text notnull sensitive }
  |     | | {select_expr}: text notnull sensitive
  |     |   | {call}: text notnull sensitive
  |     |     | {name replace}: text notnull sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'b'}: text notnull
  |     |           | {arg_list}
  |     |             | {call}: text notnull sensitive
  |     |               | {name sensitive}: text notnull sensitive
  |     |               | {call_arg_list}
  |     |                 | {call_filter_clause}
  |     |                 | {arg_list}: ok
  |     |                   | {strlit 'c'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, MyAdHocMigration);

  {schema_ad_hoc_migration_stmt}: ok @create(5)
  | {version_annotation}
    | {int 5}
    | {name MyAdHocMigration}

The statement ending at line XXXX

DECLARE PROC MyAdHocMigration (x INTEGER);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC MyAdHocMigration () USING TRANSACTION
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC MyAdHocMigration (x INTEGER)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0196: procedure declarations/definitions do not match 'MyAdHocMigration'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name MyAdHocMigration}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x: integer variable in
        | {param_detail}: x: integer variable in
          | {name x}: x: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC InvalidAdHocMigration (y INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name InvalidAdHocMigration}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: y: integer variable in
        | {param_detail}: y: integer variable in
          | {name y}: y: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, InvalidAdHocMigration);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC InvalidAdHocMigration (y INTEGER)
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC InvalidAdHocMigration () USING TRANSACTION
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0196: procedure declarations/definitions do not match 'InvalidAdHocMigration'

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name InvalidAdHocMigration}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION FOR @RECREATE(group_foo, proc_bar);

  {schema_ad_hoc_migration_stmt}: ok
  | {name group_foo}
  | {name proc_bar}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION FOR @RECREATE(group_something, foo);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : DECLARE PROC foo ()
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC foo () USING TRANSACTION
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0196: procedure declarations/definitions do not match 'foo'

  {schema_ad_hoc_migration_stmt}: err
  | {name group_something}
  | {name foo}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION FOR @RECREATE(group_foo, proc_bar);

test/sem_test.sql:XXXX:1: error: in schema_ad_hoc_migration_stmt : CQL0176: indicated procedure or group already has a recreate action 'group_foo'

  {schema_ad_hoc_migration_stmt}: err
  | {name group_foo}
  | {name proc_bar}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, not_allowed_crc);

test/sem_test.sql:XXXX:1: error: in schema_ad_hoc_migration_stmt : CQL0338: the name of a migration procedure may not end in '_crc' 'not_allowed_crc'

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name not_allowed_crc}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(5, MyAdHocMigration);

test/sem_test.sql:XXXX:1: error: in str : CQL0027: a procedure can appear in only one annotation 'MyAdHocMigration'

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name MyAdHocMigration}

The statement ending at line XXXX

@SCHEMA_AD_HOC_MIGRATION(2);

test/sem_test.sql:XXXX:1: error: in schema_ad_hoc_migration_stmt : CQL0284: ad hoc schema migration directive must provide a procedure to run

  {schema_ad_hoc_migration_stmt}: err
  | {version_annotation}
    | {int 2}

The statement ending at line XXXX

CREATE TABLE upsert_test(
  id INTEGER PRIMARY KEY,
  name TEXT,
  rate REAL
);

  {create_table_stmt}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name upsert_test}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name name}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: rate: real
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name rate}
              | {type_real}: real

The statement ending at line XXXX

INSERT INTO upsert_test(id, name) VALUES(1, 'name')
ON CONFLICT (id) DO UPDATE
SET name = excluded.name,
rate = id + 1;

  {upsert_stmt}: ok
  | {insert_stmt}: ok
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name upsert_test}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
  |   | {columns_values}: ok
  |     | {column_spec}
  |     | | {name_list}
  |     |   | {name id}: id: integer notnull
  |     |   | {name_list}
  |     |     | {name name}: name: text
  |     | {select_stmt}: values: { column1: integer notnull, column2: text notnull }
  |       | {select_core_list}: values: { column1: integer notnull, column2: text notnull }
  |       | | {select_core}: values: { column1: integer notnull, column2: text notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull, column2: text notnull }
  |       |     | {insert_list}: ok
  |       |       | {int 1}: integer notnull
  |       |       | {insert_list}
  |       |         | {strlit 'name'}: text notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}: ok
    | {conflict_target}: excluded: { id: integer notnull, name: text }
    | | {indexed_columns}
    |   | {indexed_column}
    |     | {name id}: id: integer notnull
    | {update_stmt}: upsert_test: { id: integer notnull primary_key, name: text, rate: real }
      | {update_set}
        | {update_list}: ok
        | | {update_entry}: name: text
        | | | {name name}: name: text
        | | | {dot}: name: text
        | |   | {name excluded}
        | |   | {name name}
        | | {update_list}
        |   | {update_entry}: rate: real
        |     | {name rate}: rate: real
        |     | {add}: integer notnull
        |       | {name id}: id: integer notnull
        |       | {int 1}: integer notnull
        | {update_from}
          | {update_where}
            | {update_orderby}

The statement ending at line XXXX

INSERT INTO foo DEFAULT VALUES
ON CONFLICT DO NOTHING;

test/sem_test.sql:XXXX:1: error: in insert_normal : CQL0316: upsert-clause is not compatible with DEFAULT VALUES 'foo'

  {upsert_stmt}: err
  | {insert_stmt}: err
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name foo}: foo: { id: integer notnull primary_key autoinc }
  |   | {default_columns_values}
  | {upsert_update}
    | {conflict_target}

The statement ending at line XXXX

DECLARE PROC val_fetch (seed INTEGER NOT NULL) OUT (id TEXT);

  {declare_proc_stmt}: val_fetch: { id: text } uses_out
  | {proc_name_type}
  | | {name val_fetch}: val_fetch: { id: text } uses_out
  | | {int 5}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: seed: integer notnull variable in
    |   | {param_detail}: seed: integer notnull variable in
    |     | {name seed}: seed: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {typed_names}: val_fetch: { id: text }
      | {typed_name}: id: text
        | {name id}
        | {type_text}: id: text

The statement ending at line XXXX

DECLARE PROC val_fetch_dml (seed INTEGER NOT NULL) OUT (id TEXT) USING TRANSACTION;

  {declare_proc_stmt}: val_fetch_dml: { id: text } dml_proc uses_out
  | {proc_name_type}
  | | {name val_fetch_dml}: val_fetch_dml: { id: text } dml_proc uses_out
  | | {int 7}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: seed: integer notnull variable in
    |   | {param_detail}: seed: integer notnull variable in
    |     | {name seed}: seed: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {typed_names}: val_fetch_dml: { id: text }
      | {typed_name}: id: text
        | {name id}
        | {type_text}: id: text

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION root_deployable_region;

  {declare_deployable_region_stmt}: root_deployable_region: region deployable
  | {name root_deployable_region}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION root_deployable_region;

test/sem_test.sql:XXXX:1: error: in declare_deployable_region_stmt : CQL0245: schema region already defined 'root_deployable_region'

  {declare_deployable_region_stmt}: err
  | {name root_deployable_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf1;

  {declare_schema_region_stmt}: leaf1: region
  | {name leaf1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf2;

  {declare_schema_region_stmt}: leaf2: region
  | {name leaf2}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION leaf3;

  {declare_schema_region_stmt}: leaf3: region
  | {name leaf3}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION pending_leaf_user USING leaf3;

  {declare_schema_region_stmt}: err
  | {name pending_leaf_user}
  | {region_list}
    | {region_spec}
      | {name leaf3}
      | {int 0}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION uses_leaf_3 USING leaf3;

test/sem_test.sql:XXXX:1: error: in declare_schema_region_stmt : CQL0291: region links into the middle of a deployable region; you must point to the root of 'uses_leaf_3' not into the middle: 'pending_leaf_user'

  {declare_deployable_region_stmt}: err
  | {name uses_leaf_3}
  | {region_list}
    | {region_spec}
      | {name leaf3}
      | {int 0}

The statement ending at line XXXX

@DECLARE_DEPLOYABLE_REGION depl1 USING leaf1, leaf2;

  {declare_deployable_region_stmt}: depl1: region deployable
  | {name depl1}
  | {region_list}
    | {region_spec}
    | | {name leaf1}
    | | {int 0}
    | {region_list}
      | {region_spec}
        | {name leaf2}
        | {int 0}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION error_region USING leaf1;

test/sem_test.sql:XXXX:1: error: in declare_schema_region_stmt : CQL0291: region links into the middle of a deployable region; you must point to the root of 'depl1' not into the middle: 'error_region'

  {declare_schema_region_stmt}: err
  | {name error_region}
  | {region_list}
    | {region_spec}
      | {name leaf1}
      | {int 0}

The statement ending at line XXXX

CREATE PROC many_row_emitter ()
BEGIN
  DECLARE C CURSOR LIKE out_cursor_proc;
  FETCH C FROM CALL out_cursor_proc();
  OUT UNION C;
  OUT UNION C;
END;

  {create_proc_stmt}: C: many_row_emitter: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {name many_row_emitter}: C: many_row_emitter: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {shape_def}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {like}: ok
      |     | {name out_cursor_proc}
      | {fetch_call_stmt}: ok
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | {out_union_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
      | {out_union_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor
        | {name C}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC compound_select_expr ()
BEGIN
  DECLARE x INTEGER;
  SET x := ( SELECT 1
    WHERE 0
  UNION
  SELECT 2
  LIMIT 1 );
END;

  {create_proc_stmt}: ok dml_proc
  | {name compound_select_expr}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: x: integer variable was_set
      | | | {name x}: x: integer variable was_set
      | | {type_int}: integer
      | {assign}: x: integer variable was_set
        | {name x}: x: integer variable was_set
        | {select_stmt}: _anon: integer notnull
          | {select_core_list}: UNION: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          | | | {select_expr_list_con}: select: { _anon: integer notnull }
          | |   | {select_expr_list}: select: { _anon: integer notnull }
          | |   | | {select_expr}: integer notnull
          | |   |   | {int 1}: integer notnull
          | |   | {select_from_etc}: ok
          | |     | {select_where}
          | |       | {opt_where}: integer notnull
          | |       | | {int 0}: integer notnull
          | |       | {select_groupby}
          | |         | {select_having}
          | | {select_core_compound}
          |   | {int 1}
          |   | {select_core_list}: select: { _anon: integer notnull }
          |     | {select_core}: select: { _anon: integer notnull }
          |       | {select_expr_list_con}: select: { _anon: integer notnull }
          |         | {select_expr_list}: select: { _anon: integer notnull }
          |         | | {select_expr}: integer notnull
          |         |   | {int 2}: integer notnull
          |         | {select_from_etc}: ok
          |           | {select_where}
          |             | {select_groupby}
          |               | {select_having}
          | {select_orderby}
            | {select_limit}
              | {opt_limit}: integer notnull
              | | {int 1}: integer notnull
              | {select_offset}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION region_hiding_something USING depl1 PRIVATE;

  {declare_schema_region_stmt}: region_hiding_something: region
  | {name region_hiding_something}
  | {region_list}
    | {region_spec}
      | {name depl1}
      | {int 1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION region_not_hiding_something USING depl1;

  {declare_schema_region_stmt}: region_not_hiding_something: region
  | {name region_not_hiding_something}
  | {region_list}
    | {region_spec}
      | {name depl1}
      | {int 0}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON UPDATE;

  {enforce_normal_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL FOREIGN KEY ON DELETE;

  {enforce_normal_stmt}: ok
  | {int 2}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION private_region;

  {declare_schema_region_stmt}: private_region: region
  | {name private_region}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION containing_region USING private_region PRIVATE;

  {declare_schema_region_stmt}: containing_region: region
  | {name containing_region}
  | {region_list}
    | {region_spec}
      | {name private_region}
      | {int 1}

The statement ending at line XXXX

@DECLARE_SCHEMA_REGION client_region USING containing_region;

  {declare_schema_region_stmt}: client_region: region
  | {name client_region}
  | {region_list}
    | {region_spec}
      | {name containing_region}
      | {int 0}

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION private_region;

  {begin_schema_region_stmt}: ok
  | {name private_region}

The statement ending at line XXXX

CREATE TABLE private_region_table(
  id INTEGER PRIMARY KEY
);

  {create_table_stmt}: private_region_table: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name private_region_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION containing_region;

  {begin_schema_region_stmt}: ok
  | {name containing_region}

The statement ending at line XXXX

CREATE TABLE containing_region_table(
  id INTEGER PRIMARY KEY REFERENCES private_region_table (id)
);

  {create_table_stmt}: containing_region_table: { id: integer notnull primary_key foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name containing_region_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name private_region_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

@BEGIN_SCHEMA_REGION client_region;

  {begin_schema_region_stmt}: ok
  | {name client_region}

The statement ending at line XXXX

CREATE TABLE client_region_table_1(
  id INTEGER PRIMARY KEY REFERENCES private_region_table (id)
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0021: foreign key refers to non-existent table (object is in schema region 'private_region' not accessible from region 'client_region') 'private_region_table'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name client_region_table_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: err
          | {autoinc_and_conflict_clause}
          | {col_attrs_fk}: err
            | {fk_target_options}
              | {fk_target}
              | | {name private_region_table}
              | | {name_list}
              |   | {name id}
              | {int 0}

The statement ending at line XXXX

CREATE TABLE client_region_table_2(
  id INTEGER PRIMARY KEY REFERENCES containing_region_table (id)
);

  {create_table_stmt}: client_region_table_2: { id: integer notnull primary_key foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name client_region_table_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name containing_region_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@END_SCHEMA_REGION;

  {end_schema_region_stmt}: ok

The statement ending at line XXXX

EXPLAIN
SELECT 1;

test/sem_test.sql:XXXX:1: error: in explain_stmt : CQL0293: only [EXPLAIN QUERY PLAN ...] statement is supported

  {explain_stmt}: err
  | {int 1}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {select_expr}
    |     |   | {int 1}
    |     | {select_from_etc}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
SELECT *
  FROM foo
  INNER JOIN bar
  WHERE foo.id = 1;

  {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
  | {int 2}
  | {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
    |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
    |       | {join_clause}: JOIN { foo: foo, bar: bar }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       | | | {name foo}: TABLE { foo: foo }
    |       | | {join_target_list}
    |       |   | {join_target}: JOIN { foo: foo, bar: bar }
    |       |     | {int 1} {join_inner}
    |       |     | {table_join}
    |       |       | {table_or_subquery}: TABLE { bar: bar }
    |       |         | {name bar}: TABLE { bar: bar }
    |       | {select_where}
    |         | {opt_where}: bool notnull
    |         | | {eq}: bool notnull
    |         |   | {dot}: id: integer notnull
    |         |   | | {name foo}
    |         |   | | {name id}
    |         |   | {int 1}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
UPDATE bar
SET id = 1
  WHERE name = 'Stella';

  {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
  | {int 2}
  | {update_stmt}: bar: { id: integer notnull, name: text, rate: longint }
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {update_set}
      | {update_list}: ok
      | | {update_entry}: id: integer notnull
      |   | {name id}: id: integer notnull
      |   | {int 1}: integer notnull
      | {update_from}
        | {update_where}
          | {opt_where}: bool
          | | {eq}: bool
          |   | {name name}: name: text
          |   | {strlit 'Stella'}: text notnull
          | {update_orderby}

The statement ending at line XXXX

EXPLAIN QUERY PLAN
SELECT bogus;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {explain_stmt}: err
  | {int 2}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {name bogus}: err
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC explain_query ()
BEGIN
  EXPLAIN QUERY PLAN
  SELECT 1;
END;

  {create_proc_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } dml_proc
  | {name explain_query}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
        | {int 2}
        | {select_stmt}: select: { _anon: integer notnull }
          | {select_core_list}: select: { _anon: integer notnull }
          | | {select_core}: select: { _anon: integer notnull }
          |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |     | {select_expr_list}: select: { _anon: integer notnull }
          |     | | {select_expr}: integer notnull
          |     |   | {int 1}: integer notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE c CURSOR FOR EXPLAIN QUERY PLAN
SELECT *
  FROM foo
  INNER JOIN bar;

  {declare_cursor}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc
  | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc
  | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
    | {int 2}
    | {select_stmt}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      | {select_core_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      | | {select_core}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | | {star}: select: { id: integer notnull, id: integer notnull, name: text, rate: longint }
      |     | {select_from_etc}: JOIN { foo: foo, bar: bar }
      |       | {join_clause}: JOIN { foo: foo, bar: bar }
      |       | | {table_or_subquery}: TABLE { foo: foo }
      |       | | | {name foo}: TABLE { foo: foo }
      |       | | {join_target_list}
      |       |   | {join_target}: JOIN { foo: foo, bar: bar }
      |       |     | {int 1} {join_inner}
      |       |     | {table_join}
      |       |       | {table_or_subquery}: TABLE { bar: bar }
      |       |         | {name bar}: TABLE { bar: bar }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

CREATE PROC explain_query_with_cursor ()
BEGIN
  DECLARE c CURSOR FOR EXPLAIN QUERY PLAN
  SELECT 1;
  FETCH c;
END;

  {create_proc_stmt}: ok dml_proc
  | {name explain_query_with_cursor}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc
      | | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc shape_storage
      | | {explain_stmt}: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull }
      |   | {int 2}
      |   | {select_stmt}: select: { _anon: integer notnull }
      |     | {select_core_list}: select: { _anon: integer notnull }
      |     | | {select_core}: select: { _anon: integer notnull }
      |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     |     | {select_expr_list}: select: { _anon: integer notnull }
      |     |     | | {select_expr}: integer notnull
      |     |     |   | {int 1}: integer notnull
      |     |     | {select_from_etc}: ok
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {fetch_stmt}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc shape_storage
        | {name c}: c: explain_query: { iselectid: integer notnull, iorder: integer notnull, ifrom: integer notnull, zdetail: text notnull } variable dml_proc shape_storage

The statement ending at line XXXX

SELECT "x" AS X
UNION ALL
SELECT NULL AS X;

  {select_stmt}: UNION ALL: { X: text }
  | {select_core_list}: UNION ALL: { X: text }
  | | {select_core}: select: { X: text notnull }
  | | | {select_expr_list_con}: select: { X: text notnull }
  | |   | {select_expr_list}: select: { X: text notnull }
  | |   | | {select_expr}: X: text notnull
  | |   |   | {strlit 'x'}: text notnull
  | |   |   | {opt_as_alias}
  | |   |     | {name X}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { X: null }
  |     | {select_core}: select: { X: null }
  |       | {select_expr_list_con}: select: { X: null }
  |         | {select_expr_list}: select: { X: null }
  |         | | {select_expr}: X: null
  |         |   | {null}: null
  |         |   | {opt_as_alias}
  |         |     | {name X}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC mixed_union ()
BEGIN
  SELECT "x" AS X
  UNION ALL
  SELECT NULL AS X;
END;

  {create_proc_stmt}: mixed_union: { X: text } dml_proc
  | {name mixed_union}: mixed_union: { X: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: UNION ALL: { X: text }
        | {select_core_list}: UNION ALL: { X: text }
        | | {select_core}: select: { X: text notnull }
        | | | {select_expr_list_con}: select: { X: text notnull }
        | |   | {select_expr_list}: select: { X: text notnull }
        | |   | | {select_expr}: X: text notnull
        | |   |   | {strlit 'x'}: text notnull
        | |   |   | {opt_as_alias}
        | |   |     | {name X}
        | |   | {select_from_etc}: ok
        | |     | {select_where}
        | |       | {select_groupby}
        | |         | {select_having}
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { X: null }
        |     | {select_core}: select: { X: null }
        |       | {select_expr_list_con}: select: { X: null }
        |         | {select_expr_list}: select: { X: null }
        |         | | {select_expr}: X: null
        |         |   | {null}: null
        |         |   | {opt_as_alias}
        |         |     | {name X}
        |         | {select_from_etc}: ok
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC mixed_union_cte ()
BEGIN
  WITH
  core (x) AS (SELECT "x" AS X
  UNION ALL
  SELECT NULL AS X)
  SELECT *
    FROM core;
END;

  {create_proc_stmt}: mixed_union_cte: { x: text } dml_proc
  | {name mixed_union_cte}: mixed_union_cte: { x: text } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { x: text }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: core: { x: text }
        |     | {cte_decl}: core: { x: text }
        |     | | {name core}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: UNION ALL: { X: text }
        |       | {select_core_list}: UNION ALL: { X: text }
        |       | | {select_core}: select: { X: text notnull }
        |       | | | {select_expr_list_con}: select: { X: text notnull }
        |       | |   | {select_expr_list}: select: { X: text notnull }
        |       | |   | | {select_expr}: X: text notnull
        |       | |   |   | {strlit 'x'}: text notnull
        |       | |   |   | {opt_as_alias}
        |       | |   |     | {name X}
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { X: null }
        |       |     | {select_core}: select: { X: null }
        |       |       | {select_expr_list_con}: select: { X: null }
        |       |         | {select_expr_list}: select: { X: null }
        |       |         | | {select_expr}: X: null
        |       |         |   | {null}: null
        |       |         |   | {opt_as_alias}
        |       |         |     | {name X}
        |       |         | {select_from_etc}: ok
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { x: text }
          | {select_core_list}: select: { x: text }
          | | {select_core}: select: { x: text }
          |   | {select_expr_list_con}: select: { x: text }
          |     | {select_expr_list}: select: { x: text }
          |     | | {star}: select: { x: text }
          |     | {select_from_etc}: TABLE { core: core }
          |       | {table_or_subquery_list}: TABLE { core: core }
          |       | | {table_or_subquery}: TABLE { core: core }
          |       |   | {name core}: TABLE { core: core }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER () AS row_num
  FROM foo;

  {select_stmt}: select: { id: integer notnull, row_num: integer notnull }
  | {select_core_list}: select: { id: integer notnull, row_num: integer notnull }
  | | {select_core}: select: { id: integer notnull, row_num: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, row_num: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, row_num: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: row_num: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |     | | {call}: integer notnull
  |     |     | | | {name row_number}: integer notnull
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, row_number() AS row_num
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |     | | {name row_number}
  |     |     | | {call_arg_list}
  |     |     |   | {call_filter_clause}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1
  WHERE 
  row_number() OVER ();

test/sem_test.sql:XXXX:1: error: in window_func_inv : CQL0294: window function invocations can only appear in the select list of a select statement

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {int 1}
  |     | {select_from_etc}: err
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {window_func_inv}: err
  |         |   | {call}
  |         |   | | {name row_number}
  |         |   | | {call_arg_list}
  |         |   |   | {call_filter_clause}
  |         |   | {window_defn}
  |         |     | {window_defn_orderby}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number(1) OVER () AS row_num
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |     | | {call}: err
  |     |     | | | {name row_number}: err
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {int 1}: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER win1, 
  row_number() OVER win2
  FROM foo
  WINDOW 
    win1 AS (), 
    win2 AS ()
ORDER BY id;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |   | | {window_func_inv}: integer notnull
  |     |   |   | {call}: integer notnull
  |     |   |   | | {name row_number}: integer notnull
  |     |   |   | | {call_arg_list}
  |     |   |   |   | {call_filter_clause}
  |     |   |   | {name win1}: ok
  |     |   | {select_expr_list}
  |     |     | {select_expr}: integer notnull
  |     |       | {window_func_inv}: integer notnull
  |     |         | {call}: integer notnull
  |     |         | | {name row_number}: integer notnull
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {name win2}: ok
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: ok
  |               | {window_clause}: ok
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: ok
  |                   | | {name win1}
  |                   | | {window_defn}: ok
  |                   |   | {window_defn_orderby}
  |                   | {window_name_defn_list}
  |                     | {window_name_defn}: ok
  |                       | {name win2}
  |                       | {window_defn}: ok
  |                         | {window_defn_orderby}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {name id}: id: integer notnull
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER bogus
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0295: window name is not defined 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {name bogus}: err
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER win
  FROM foo
  WINDOW 
    win AS (ORDER BY bogus);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {window_func_inv}
  |     |       | {call}
  |     |       | | {name row_number}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {name win}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: err
  |               | {window_clause}: err
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: err
  |                     | {name win}
  |                     | {window_defn}: err
  |                       | {window_defn_orderby}
  |                         | {opt_orderby}: err
  |                           | {orderby_list}: err
  |                             | {orderby_item}
  |                               | {name bogus}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WINDOW 
    win AS ();

test/sem_test.sql:XXXX:1: error: in str : CQL0296: window name definition is not used 'win'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  |             | {opt_select_window}: err
  |               | {window_clause}: err
  |                 | {window_name_defn_list}
  |                   | {window_name_defn}: err
  |                     | {name win}: err
  |                     | {window_defn}
  |                       | {window_defn_orderby}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  group_concat(id, '.') FILTER (WHERE id >= 99) OVER () AS row_num
  FROM foo;

  {select_stmt}: select: { id: integer notnull, row_num: text }
  | {select_core_list}: select: { id: integer notnull, row_num: text }
  | | {select_core}: select: { id: integer notnull, row_num: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, row_num: text }
  |     | {select_expr_list}: select: { id: integer notnull, row_num: text }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: row_num: text
  |     |     | {window_func_inv}: text
  |     |     | | {call}: text
  |     |     | | | {name group_concat}: text
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | | {opt_filter_clause}: bool notnull
  |     |     | |   |   | {opt_where}: bool notnull
  |     |     | |   |     | {ge}: bool notnull
  |     |     | |   |       | {name id}: id: integer notnull
  |     |     | |   |       | {int 99}: integer notnull
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {name id}: id: integer notnull
  |     |     | |     | {arg_list}
  |     |     | |       | {strlit '.'}: text notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name row_num}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id AS alias, 
  avg(id) FILTER (WHERE alias = 0) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'alias'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: alias: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name alias}
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name avg}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | | {opt_filter_clause}: err
  |     |       |   |   | {opt_where}: err
  |     |       |   |     | {eq}: err
  |     |       |   |       | {name alias}: err
  |     |       |   |       | {int 0}: integer notnull
  |     |       |   | {arg_list}
  |     |       |     | {name id}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1, 
  row_number() FILTER (WHERE 1) OVER ();

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'row_number'
test/sem_test.sql:XXXX:1: error: in call : CQL0306: FILTER clause may only be used in function that are aggregated or user defined 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name row_number}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |     | {opt_filter_clause}: integer notnull
  |     |       |       | {opt_where}: integer notnull
  |     |       |         | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1, row_number(DISTINCT 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'row_number'
test/sem_test.sql:XXXX:1: error: in call : CQL0305: DISTINCT may only be used in function that are aggregated or user defined 'row_number'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {call}: err
  |     |       | {name row_number}
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | | {distinct}
  |     |         | {arg_list}: ok
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (PARTITION BY id)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {opt_partition_by}: ok
  |     |         | | {expr_list}
  |     |         |   | {name id}: id: integer notnull
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ORDER BY id ASC)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_orderby}: ok
  |     |             | {orderby_list}: ok
  |     |               | {orderby_item}
  |     |                 | {name id}: id: integer notnull
  |     |                 | {asc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ORDER BY bogus ASC)
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: err
  |     |         | {window_defn_orderby}
  |     |           | {opt_orderby}: err
  |     |             | {orderby_list}: err
  |     |               | {orderby_item}
  |     |                 | {name bogus}: err
  |     |                 | {asc}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  avg(id) FILTER (WHERE id > 0) OVER (GROUPS UNBOUNDED PRECEDING EXCLUDE TIES) AS avg, 
  row_number() OVER (ROWS BETWEEN id = 1 PRECEDING AND id = 45 FOLLOWING EXCLUDE CURRENT ROW)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, avg: real, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: avg: real
  |     |   | | {window_func_inv}: real
  |     |   | | | {call}: real
  |     |   | | | | {name avg}: real
  |     |   | | | | {call_arg_list}
  |     |   | | |   | {call_filter_clause}
  |     |   | | |   | | {opt_filter_clause}: bool notnull
  |     |   | | |   |   | {opt_where}: bool notnull
  |     |   | | |   |     | {gt}: bool notnull
  |     |   | | |   |       | {name id}: id: integer notnull
  |     |   | | |   |       | {int 0}: integer notnull
  |     |   | | |   | {arg_list}: ok
  |     |   | | |     | {name id}: id: integer notnull
  |     |   | | | {window_defn}: ok
  |     |   | |   | {window_defn_orderby}
  |     |   | |     | {opt_frame_spec}: ok
  |     |   | |       | {int 131084}
  |     |   | |       | {expr_list}
  |     |   | | {opt_as_alias}
  |     |   |   | {name avg}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: integer notnull
  |     |       | {window_func_inv}: integer notnull
  |     |         | {call}: integer notnull
  |     |         | | {name row_number}: integer notnull
  |     |         | | {call_arg_list}
  |     |         |   | {call_filter_clause}
  |     |         | {window_defn}: ok
  |     |           | {window_defn_orderby}
  |     |             | {opt_frame_spec}: ok
  |     |               | {int 36994}
  |     |               | {expr_list}
  |     |                 | {eq}: bool notnull
  |     |                 | | {name id}: id: integer notnull
  |     |                 | | {int 1}: integer notnull
  |     |                 | {eq}: bool notnull
  |     |                   | {name id}: id: integer notnull
  |     |                   | {int 45}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING EXCLUDE GROUP)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: ok
  |     |             | {int 73986}
  |     |             | {expr_list}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS id > 0 PRECEDING EXCLUDE TIES)
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: ok
  |     |             | {int 131090}
  |     |             | {expr_list}
  |     |               | {gt}: bool notnull
  |     |                 | {name id}: id: integer notnull
  |     |                 | {int 0}: integer notnull
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  row_number() OVER (ROWS bogus = NULL PRECEDING EXCLUDE TIES)
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: integer notnull
  |     |       | | {name row_number}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: err
  |     |         | {window_defn_orderby}
  |     |           | {opt_frame_spec}: err
  |     |             | {int 131090}
  |     |             | {expr_list}
  |     |               | {eq}: err
  |     |                 | {name bogus}: err
  |     |                 | {null}: null
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  dense_rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name dense_rank}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  percent_rank() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: real notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: real notnull }
  | | {select_core}: select: { id: integer notnull, _anon: real notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: real notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: real notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: real notnull
  |     |     | {window_func_inv}: real notnull
  |     |       | {call}: real notnull
  |     |       | | {name percent_rank}: real notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  cume_dist() OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: real notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: real notnull }
  | | {select_core}: select: { id: integer notnull, _anon: real notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: real notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: real notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: real notnull
  |     |     | {window_func_inv}: real notnull
  |     |       | {call}: real notnull
  |     |       | | {name cume_dist}: real notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(7) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, _anon: integer notnull }
  | {select_core_list}: select: { id: integer notnull, _anon: integer notnull }
  | | {select_core}: select: { id: integer notnull, _anon: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, _anon: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, _anon: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |       | {call}: integer notnull
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {int 7}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(9898989889989L) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0300: argument must be an integer (between 1 and max integer) in function 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {longint 9898989889989}: longint notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(0) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0300: argument must be an integer (between 1 and max integer) in function 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  ntile(1, 2) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name ntile}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {int 1}: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 2}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE ntile(7);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'ntile'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name ntile}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 1, 0) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name lag}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 
  lag(cost, 1, id) OVER ()
  FROM with_kind;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'some_key'
test/sem_test.sql:XXXX:1: error: in call : CQL0302: first and third arguments must be compatible in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {window_func_inv}: err
  |     |     | {call}: err
  |     |     | | {name lag}: ok
  |     |     | | {call_arg_list}
  |     |     |   | {call_filter_clause}
  |     |     |   | {arg_list}: err
  |     |     |     | {name cost}: cost: real<dollars>
  |     |     |     | {arg_list}
  |     |     |       | {int 1}: integer notnull
  |     |     |       | {arg_list}
  |     |     |         | {name id}: err
  |     |     | {window_defn}: ok
  |     |       | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { with_kind: with_kind }
  |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
  |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
  |       |   | {name with_kind}: TABLE { with_kind: with_kind }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 1.3, 0) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0301: second argument must be an integer (between 0 and max integer) in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {dbl 1.3}: real notnull
  |     |       |       | {arg_list}
  |     |       |         | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, X, 0) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name lag}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {name X}: X: integer variable was_set
  |     |       |       | {arg_list}
  |     |       |         | {int 0}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 1) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer }
  | {select_core_list}: select: { id: integer notnull, id: integer }
  | | {select_core}: select: { id: integer notnull, id: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer
  |     |     | {window_func_inv}: id: integer
  |     |       | {call}: id: integer
  |     |       | | {name lag}: id: integer
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(info, 1) OVER ()
  FROM with_sensitive;

  {select_stmt}: select: { id: integer, info: integer sensitive }
  | {select_core_list}: select: { id: integer, info: integer sensitive }
  | | {select_core}: select: { id: integer, info: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer, info: integer sensitive }
  |     | {select_expr_list}: select: { id: integer, info: integer sensitive }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: info: integer sensitive
  |     |     | {window_func_inv}: info: integer sensitive
  |     |       | {call}: info: integer sensitive
  |     |       | | {name lag}: info: integer sensitive
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name info}: info: integer sensitive
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id * 3, 1, info) OVER ()
  FROM with_sensitive;

  {select_stmt}: select: { id: integer, _anon: integer sensitive }
  | {select_core_list}: select: { id: integer, _anon: integer sensitive }
  | | {select_core}: select: { id: integer, _anon: integer sensitive }
  |   | {select_expr_list_con}: select: { id: integer, _anon: integer sensitive }
  |     | {select_expr_list}: select: { id: integer, _anon: integer sensitive }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: integer sensitive
  |     |     | {window_func_inv}: integer sensitive
  |     |       | {call}: integer sensitive
  |     |       | | {name lag}: integer sensitive
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {mul}: integer
  |     |       |     | | {name id}: id: integer
  |     |       |     | | {int 3}: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {name info}: info: integer sensitive
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, -1) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0301: second argument must be an integer (between 0 and max integer) in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {uminus}: integer notnull
  |     |       |         | {int 1}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id | " ") OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0008: right operand cannot be a string in '|'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {bin_or}: err
  |     |       |       | {name id}: id: integer notnull
  |     |       |       | {strlit ' '}: text notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag(id, 0, 0.7) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'REAL' in 0.7
test/sem_test.sql:XXXX:1: error: in call : CQL0302: first and third arguments must be compatible in function 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: ok
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: err
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 0}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {dbl 0.7}: real notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lag() OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'lag'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name lag}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  lead(id, 1, id * 3) OVER ()
  FROM foo;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer notnull
  |     |     | {window_func_inv}: id: integer notnull
  |     |       | {call}: id: integer notnull
  |     |       | | {name lead}: id: integer notnull
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       |     | {arg_list}
  |     |       |       | {int 1}: integer notnull
  |     |       |       | {arg_list}
  |     |       |         | {mul}: integer notnull
  |     |       |           | {name id}: id: integer notnull
  |     |       |           | {int 3}: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  first_value(id) OVER () AS first
  FROM foo;

  {select_stmt}: select: { id: integer notnull, first: integer notnull }
  | {select_core_list}: select: { id: integer notnull, first: integer notnull }
  | | {select_core}: select: { id: integer notnull, first: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, first: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, first: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: first: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |     | | {call}: integer notnull
  |     |     | | | {name first_value}: integer notnull
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {name id}: id: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name first}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 
  first_value(id) OVER () AS first
  FROM with_kind;

  {select_stmt}: select: { first: integer<some_key> }
  | {select_core_list}: select: { first: integer<some_key> }
  | | {select_core}: select: { first: integer<some_key> }
  |   | {select_expr_list_con}: select: { first: integer<some_key> }
  |     | {select_expr_list}: select: { first: integer<some_key> }
  |     | | {select_expr}: first: integer<some_key>
  |     |   | {window_func_inv}: integer<some_key>
  |     |   | | {call}: integer<some_key>
  |     |   | | | {name first_value}: integer<some_key>
  |     |   | | | {call_arg_list}
  |     |   | |   | {call_filter_clause}
  |     |   | |   | {arg_list}: ok
  |     |   | |     | {name id}: id: integer<some_key>
  |     |   | | {window_defn}: ok
  |     |   |   | {window_defn_orderby}
  |     |   | {opt_as_alias}
  |     |     | {name first}
  |     | {select_from_etc}: TABLE { with_kind: with_kind }
  |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
  |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
  |       |   | {name with_kind}: TABLE { with_kind: with_kind }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 
  last_value(id) OVER () AS last
  FROM with_kind;

  {select_stmt}: select: { last: integer<some_key> }
  | {select_core_list}: select: { last: integer<some_key> }
  | | {select_core}: select: { last: integer<some_key> }
  |   | {select_expr_list_con}: select: { last: integer<some_key> }
  |     | {select_expr_list}: select: { last: integer<some_key> }
  |     | | {select_expr}: last: integer<some_key>
  |     |   | {window_func_inv}: integer<some_key>
  |     |   | | {call}: integer<some_key>
  |     |   | | | {name last_value}: integer<some_key>
  |     |   | | | {call_arg_list}
  |     |   | |   | {call_filter_clause}
  |     |   | |   | {arg_list}: ok
  |     |   | |     | {name id}: id: integer<some_key>
  |     |   | | {window_defn}: ok
  |     |   |   | {window_defn_orderby}
  |     |   | {opt_as_alias}
  |     |     | {name last}
  |     | {select_from_etc}: TABLE { with_kind: with_kind }
  |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
  |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
  |       |   | {name with_kind}: TABLE { with_kind: with_kind }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 
  nth_value(id, 5) OVER () AS nth
  FROM with_kind;

  {select_stmt}: select: { nth: integer<some_key> }
  | {select_core_list}: select: { nth: integer<some_key> }
  | | {select_core}: select: { nth: integer<some_key> }
  |   | {select_expr_list_con}: select: { nth: integer<some_key> }
  |     | {select_expr_list}: select: { nth: integer<some_key> }
  |     | | {select_expr}: nth: integer<some_key>
  |     |   | {window_func_inv}: integer<some_key>
  |     |   | | {call}: integer<some_key>
  |     |   | | | {name nth_value}: integer<some_key>
  |     |   | | | {call_arg_list}
  |     |   | |   | {call_filter_clause}
  |     |   | |   | {arg_list}: ok
  |     |   | |     | {name id}: id: integer<some_key>
  |     |   | |     | {arg_list}
  |     |   | |       | {int 5}: integer notnull
  |     |   | | {window_defn}: ok
  |     |   |   | {window_defn_orderby}
  |     |   | {opt_as_alias}
  |     |     | {name nth}
  |     | {select_from_etc}: TABLE { with_kind: with_kind }
  |       | {table_or_subquery_list}: TABLE { with_kind: with_kind }
  |       | | {table_or_subquery}: TABLE { with_kind: with_kind }
  |       |   | {name with_kind}: TABLE { with_kind: with_kind }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE first_value(7);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'first_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name first_value}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  last_value(id) OVER () AS last
  FROM foo;

  {select_stmt}: select: { id: integer notnull, last: integer notnull }
  | {select_core_list}: select: { id: integer notnull, last: integer notnull }
  | | {select_core}: select: { id: integer notnull, last: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, last: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, last: integer notnull }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: last: integer notnull
  |     |     | {window_func_inv}: integer notnull
  |     |     | | {call}: integer notnull
  |     |     | | | {name last_value}: integer notnull
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {name id}: id: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name last}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id, 1) OVER () AS nth
  FROM foo;

  {select_stmt}: select: { id: integer notnull, nth: integer }
  | {select_core_list}: select: { id: integer notnull, nth: integer }
  | | {select_core}: select: { id: integer notnull, nth: integer }
  |   | {select_expr_list_con}: select: { id: integer notnull, nth: integer }
  |     | {select_expr_list}: select: { id: integer notnull, nth: integer }
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: nth: integer
  |     |     | {window_func_inv}: integer
  |     |     | | {call}: integer
  |     |     | | | {name nth_value}: integer
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {name id}: id: integer notnull
  |     |     | |     | {arg_list}
  |     |     | |       | {int 1}: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name nth}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id
  FROM foo
  WHERE nth_value(7, 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     |   | {name id}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {opt_where}: err
  |         | | {call}: err
  |         |   | {name nth_value}
  |         |   | {call_arg_list}
  |         |     | {call_filter_clause}
  |         |     | {arg_list}: ok
  |         |       | {int 7}: integer notnull
  |         |       | {arg_list}
  |         |         | {int 1}: integer notnull
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id) OVER ()
  FROM foo;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |       | {call}: err
  |     |       | | {name nth_value}: err
  |     |       | | {call_arg_list}
  |     |       |   | {call_filter_clause}
  |     |       |   | {arg_list}: ok
  |     |       |     | {name id}: id: integer notnull
  |     |       | {window_defn}: ok
  |     |         | {window_defn_orderby}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, 
  nth_value(id, 0) OVER () AS nth
  FROM foo;

test/sem_test.sql:XXXX:1: error: in call : CQL0303: second argument must be an integer between 1 and max integer in function 'nth_value'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}: err
  |     |     | {window_func_inv}: err
  |     |     | | {call}: err
  |     |     | | | {name nth_value}: ok
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: err
  |     |     | |     | {name id}: id: integer notnull
  |     |     | |     | {arg_list}
  |     |     | |       | {int 0}: integer notnull
  |     |     | | {window_defn}: ok
  |     |     |   | {window_defn_orderby}
  |     |     | {opt_as_alias}
  |     |       | {name nth}
  |     | {select_from_etc}: TABLE { foo: foo }
  |       | {table_or_subquery_list}: TABLE { foo: foo }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       |   | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT total(info) AS t
  FROM with_sensitive;

  {select_stmt}: select: { t: real notnull sensitive }
  | {select_core_list}: select: { t: real notnull sensitive }
  | | {select_core}: select: { t: real notnull sensitive }
  |   | {select_expr_list_con}: select: { t: real notnull sensitive }
  |     | {select_expr_list}: select: { t: real notnull sensitive }
  |     | | {select_expr}: t: real notnull sensitive
  |     |   | {call}: real notnull sensitive
  |     |   | | {name total}: real notnull sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name info}: info: integer sensitive
  |     |   | {opt_as_alias}
  |     |     | {name t}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC insert_using_args_with_dummy (x INTEGER NOT NULL, y REAL NOT NULL)
BEGIN
  INSERT INTO referenceable(a, b, c, d, e) VALUES(x, y, printf('c_%d', _seed_), printf('d_%d', _seed_), _seed_) @DUMMY_SEED(1) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name insert_using_args_with_dummy}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: real notnull variable in
    |     | {param_detail}: y: real notnull variable in
    |       | {name y}: y: real notnull variable in
    |       | {notnull}: real notnull
    |         | {type_real}: real
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | | {seed_stub}
        |   | {int 1}: integer notnull
        |   | {int 2}
        | {name_columns_values}
          | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real
            |     | {name_list}
            |       | {name c}: c: text
            |       | {name_list}
            |         | {name d}: d: text
            |         | {name_list}
            |           | {name e}: e: longint
            | {insert_list}
              | {dot}: x: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name x}
              | {insert_list}
                | {dot}: y: real notnull variable in
                | | {name ARGUMENTS}
                | | {name y}
                | {insert_list}
                  | {call}: text notnull
                  | | {name printf}: text notnull
                  | | {call_arg_list}
                  |   | {call_filter_clause}
                  |   | {arg_list}: ok
                  |     | {strlit 'c_%d'}: text notnull
                  |     | {arg_list}
                  |       | {name _seed_}: _seed_: integer notnull variable
                  | {insert_list}
                    | {call}: text notnull
                    | | {name printf}: text notnull
                    | | {call_arg_list}
                    |   | {call_filter_clause}
                    |   | {arg_list}: ok
                    |     | {strlit 'd_%d'}: text notnull
                    |     | {arg_list}
                    |       | {name _seed_}: _seed_: integer notnull variable
                    | {insert_list}
                      | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_using_args_with_dummy (x INTEGER NOT NULL, y REAL NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE referenceable;
  FETCH C(a, b, c, d, e) FROM VALUES(x, y, printf('c_%d', _seed_), printf('d_%d', _seed_), _seed_) @DUMMY_SEED(1) @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok
  | {name fetch_using_args_with_dummy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: real notnull variable in
    |     | {param_detail}: y: real notnull variable in
    |       | {name y}: y: real notnull variable in
    |       | {notnull}: real notnull
    |         | {type_real}: real
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
      | | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
      | | {shape_def}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      |   | {like}: ok
      |     | {name referenceable}
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 1}: integer notnull
        | | {int 2}
        | {name_columns_values}
          | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer notnull
            |   | {name_list}
            |     | {name b}: b: real
            |     | {name_list}
            |       | {name c}: c: text
            |       | {name_list}
            |         | {name d}: d: text
            |         | {name_list}
            |           | {name e}: e: longint
            | {insert_list}: ok
              | {dot}: x: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name x}
              | {insert_list}
                | {dot}: y: real notnull variable in
                | | {name ARGUMENTS}
                | | {name y}
                | {insert_list}
                  | {call}: text notnull
                  | | {name printf}: text notnull
                  | | {call_arg_list}
                  |   | {call_filter_clause}
                  |   | {arg_list}: ok
                  |     | {strlit 'c_%d'}: text notnull
                  |     | {arg_list}
                  |       | {name _seed_}: _seed_: integer notnull variable
                  | {insert_list}
                    | {call}: text notnull
                    | | {name printf}: text notnull
                    | | {call_arg_list}
                    |   | {call_filter_clause}
                    |   | {arg_list}: ok
                    |     | {strlit 'd_%d'}: text notnull
                    |     | {arg_list}
                    |       | {name _seed_}: _seed_: integer notnull variable
                    | {insert_list}
                      | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC fetch_from_empty_col_list ()
BEGIN
  DECLARE C CURSOR LIKE referenceable;
  FETCH C(a, b, c, d, e) FROM VALUES(1, 2, 'x', 'y', 5);
  OUT C;
END;

  {create_proc_stmt}: C: fetch_from_empty_col_list: { a: integer notnull, b: real, c: text, d: text, e: longint } variable shape_storage uses_out value_cursor
  | {name fetch_from_empty_col_list}: C: fetch_from_empty_col_list: { a: integer notnull, b: real, c: text, d: text, e: longint } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
      | | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
      | | {shape_def}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
      |   | {like}: ok
      |     | {name referenceable}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name a}: a: integer notnull
      |     |   | {name_list}
      |     |     | {name b}: b: real
      |     |     | {name_list}
      |     |       | {name c}: c: text
      |     |       | {name_list}
      |     |         | {name d}: d: text
      |     |         | {name_list}
      |     |           | {name e}: e: longint
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      |         | {insert_list}
      |           | {strlit 'x'}: text notnull
      |           | {insert_list}
      |             | {strlit 'y'}: text notnull
      |             | {insert_list}
      |               | {int 5}: integer notnull
      | {out_stmt}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
        | {name C}: C: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor

The statement ending at line XXXX

DECLARE c_bar CURSOR LIKE referenceable;

  {declare_cursor_like_name}: c_bar: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
  | {name c_bar}: c_bar: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint } variable shape_storage value_cursor
  | {shape_def}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {like}: ok
      | {name referenceable}

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) VALUES(c_bar.a, c_bar.b, c_bar.c, c_bar.d, c_bar.e);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name a}: a: integer notnull
      |   | {name_list}
      |     | {name b}: b: real
      |     | {name_list}
      |       | {name c}: c: text
      |       | {name_list}
      |         | {name d}: d: text
      |         | {name_list}
      |           | {name e}: e: longint
      | {insert_list}
        | {dot}: c_bar.a: integer notnull variable primary_key
        | | {name c_bar}
        | | {name a}
        | {insert_list}
          | {dot}: c_bar.b: real variable unique_key
          | | {name c_bar}
          | | {name b}
          | {insert_list}
            | {dot}: c_bar.c: text variable
            | | {name c_bar}
            | | {name c}
            | {insert_list}
              | {dot}: c_bar.d: text variable
              | | {name c_bar}
              | | {name d}
              | {insert_list}
                | {dot}: c_bar.e: longint variable
                  | {name c_bar}
                  | {name e}

The statement ending at line XXXX

INSERT INTO referenceable() FROM c_bar;

test/sem_test.sql:XXXX:1: error: in from_shape : CQL0297: FROM [shape] is redundant if column list is empty

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | {from_shape}
        | {name c_bar}

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM fetch_cursor(_anon, _anon, _anon);

test/sem_test.sql:XXXX:1: error: in str : CQL0298: cannot read from a cursor without fields 'fetch_cursor'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_shape}: ok
        | {column_spec}
        | | {name_list}
        |   | {name _anon}
        |   | {name_list}
        |     | {name _anon}
        |     | {name_list}
        |       | {name _anon}
        | {name fetch_cursor}: err

The statement ending at line XXXX

DECLARE small_cursor CURSOR LIKE SELECT 1 AS x;

  {declare_cursor_like_select}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {select_stmt}: select: { x: integer notnull }
    | {select_core_list}: select: { x: integer notnull }
    | | {select_core}: select: { x: integer notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull }
    |     | {select_expr_list}: select: { x: integer notnull }
    |     | | {select_expr}: x: integer notnull
    |     |   | {int 1}: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name x}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM small_cursor(x);

test/sem_test.sql:XXXX:1: error: in columns_values : CQL0299: [shape] has too few fields 'small_cursor'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_shape}: ok
        | {column_spec}
        | | {name_list}
        |   | {name x}
        | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor

The statement ending at line XXXX

INSERT INTO referenceable(a, b, c, d, e) FROM X;

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'X'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name referenceable}: referenceable: { a: integer notnull primary_key, b: real unique_key, c: text, d: text, e: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name a}
      |   | {name_list}
      |     | {name b}
      |     | {name_list}
      |       | {name c}
      |       | {name_list}
      |         | {name d}
      |         | {name_list}
      |           | {name e}
      | {from_shape}
        | {name X}: err

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES(2);

  {update_cursor_stmt}: ok
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}: ok
      | {int 2}: integer notnull

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES('x');

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'x'

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}: ok
      | {strlit 'x'}: err

The statement ending at line XXXX

UPDATE CURSOR small_cursor(x) FROM VALUES(1, 2);

test/sem_test.sql:XXXX:1: error: in update_cursor_stmt : CQL0157: count of columns differs from count of values

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name x}: x: integer notnull
    | {insert_list}: ok
      | {int 1}
      | {insert_list}
        | {int 2}

The statement ending at line XXXX

UPDATE CURSOR small_cursor(w) FROM VALUES(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'w'

  {update_cursor_stmt}: err
  | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}: err
    |   | {name w}: err
    | {insert_list}: ok
      | {int 1}

The statement ending at line XXXX

UPDATE CURSOR my_cursor(one) FROM VALUES(2);

test/sem_test.sql:XXXX:1: error: in str : CQL0067: cursor was not used with 'fetch [cursor]' 'my_cursor'

  {update_cursor_stmt}: err
  | {name my_cursor}: err
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name one}
    | {insert_list}: ok
      | {int 2}

The statement ending at line XXXX

UPDATE CURSOR my_cursor(LIKE not_a_symbol) FROM VALUES(1);

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {update_cursor_stmt}: err
  | {name my_cursor}: my_cursor: select: { one: integer notnull, two: integer notnull } variable dml_proc fetch_into
  | {columns_values}: err
    | {column_spec}
    | | {shape_def}: err
    |   | {like}: err
    |     | {name not_a_symbol}: err
    | {insert_list}
      | {int 1}

The statement ending at line XXXX

UPDATE CURSOR X(one) FROM VALUES(2);

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'X'

  {update_cursor_stmt}: err
  | {name X}: err
  | {columns_values}
    | {column_spec}
    | | {name_list}
    |   | {name one}
    | {insert_list}
      | {int 2}

The statement ending at line XXXX

WITH
some_cte (a, b, c) AS (SELECT 1 AS a, 'b' AS b, 3.0 AS c)
SELECT *
  FROM some_cte;

  {with_select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: some_cte: { a: integer notnull, b: text notnull, c: real notnull }
  |     | {cte_decl}: some_cte: { a: integer notnull, b: text notnull, c: real notnull }
  |     | | {name some_cte}
  |     | | {name_list}
  |     |   | {name a}
  |     |   | {name_list}
  |     |     | {name b}
  |     |     | {name_list}
  |     |       | {name c}
  |     | {select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       | {select_core_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       | | {select_core}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |   | {select_expr_list_con}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |     | {select_expr_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
  |       |     | | {select_expr}: a: integer notnull
  |       |     | | | {int 1}: integer notnull
  |       |     | | | {opt_as_alias}
  |       |     | |   | {name a}
  |       |     | | {select_expr_list}
  |       |     |   | {select_expr}: b: text notnull
  |       |     |   | | {strlit 'b'}: text notnull
  |       |     |   | | {opt_as_alias}
  |       |     |   |   | {name b}
  |       |     |   | {select_expr_list}
  |       |     |     | {select_expr}: c: real notnull
  |       |     |       | {dbl 3.0}: real notnull
  |       |     |       | {opt_as_alias}
  |       |     |         | {name c}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { a: integer notnull, b: text notnull, c: real notnull }
    | {select_core_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
    | | {select_core}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |   | {select_expr_list_con}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | {select_expr_list}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | | {star}: select: { a: integer notnull, b: text notnull, c: real notnull }
    |     | {select_from_etc}: TABLE { some_cte: some_cte }
    |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
    |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
    |       |   | {name some_cte}: TABLE { some_cte: some_cte }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
some_cte (*) AS (SELECT 1)
SELECT *
  FROM some_cte;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0055: all columns in the select must have a name

  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: err
  |   | {cte_table}: err
  |     | {cte_decl}: err
  |     | | {name some_cte}
  |     | | {star}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}: err
  |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |       |     | {select_expr_list}: select: { _anon: integer notnull }
  |       |     | | {select_expr}: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name some_cte}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE TEMP TABLE foo_data(
  c1 TEXT NOT NULL,
  c2 INTEGER,
  c3 REAL,
  c4 REAL,
  c5 REAL,
  c6 REAL,
  c7 REAL,
  c8 REAL,
  c9 REAL,
  c10 REAL
);

  {create_table_stmt}: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 1}
  | | {name foo_data}
  | {col_key_list}
    | {col_def}: c1: text notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name c1}
    |   | | {type_text}: text
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: c2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name c2}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: c3: real
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name c3}
        |     | {type_real}: real
        | {col_key_list}
          | {col_def}: c4: real
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |     | {name c4}
          |     | {type_real}: real
          | {col_key_list}
            | {col_def}: c5: real
            | | {col_def_type_attrs}: ok
            |   | {col_def_name_type}
            |     | {name c5}
            |     | {type_real}: real
            | {col_key_list}
              | {col_def}: c6: real
              | | {col_def_type_attrs}: ok
              |   | {col_def_name_type}
              |     | {name c6}
              |     | {type_real}: real
              | {col_key_list}
                | {col_def}: c7: real
                | | {col_def_type_attrs}: ok
                |   | {col_def_name_type}
                |     | {name c7}
                |     | {type_real}: real
                | {col_key_list}
                  | {col_def}: c8: real
                  | | {col_def_type_attrs}: ok
                  |   | {col_def_name_type}
                  |     | {name c8}
                  |     | {type_real}: real
                  | {col_key_list}
                    | {col_def}: c9: real
                    | | {col_def_type_attrs}: ok
                    |   | {col_def_name_type}
                    |     | {name c9}
                    |     | {type_real}: real
                    | {col_key_list}
                      | {col_def}: c10: real
                        | {col_def_type_attrs}: ok
                          | {col_def_name_type}
                            | {name c10}
                            | {type_real}: real

The statement ending at line XXXX

DECLARE nully_cursor CURSOR LIKE foo_data;

  {declare_cursor_like_name}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
  | {shape_def}: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real }
    | {like}: ok
      | {name foo_data}

The statement ending at line XXXX

FETCH nully_cursor(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) FROM VALUES('x', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c2}: c2: integer
      |     | {name_list}
      |       | {name c3}: c3: real
      |       | {name_list}
      |         | {name c4}: c4: real
      |         | {name_list}
      |           | {name c5}: c5: real
      |           | {name_list}
      |             | {name c6}: c6: real
      |             | {name_list}
      |               | {name c7}: c7: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}: ok
        | {strlit 'x'}: text notnull
        | {insert_list}
          | {null}: null
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c2) FROM VALUES('x');

test/sem_test.sql:XXXX:1: error: in fetch_values_stmt : CQL0167: required column missing in FETCH statement 'c1'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c2}: c2: integer
      | {insert_list}: ok
        | {strlit 'x'}

The statement ending at line XXXX

DECLARE c1c7 CURSOR LIKE SELECT 'x' AS c1, nullable(3.2) AS c7;

  {declare_cursor_like_select}: c1c7: select: { c1: text notnull, c7: real } variable shape_storage value_cursor
  | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable shape_storage value_cursor
  | {select_stmt}: select: { c1: text notnull, c7: real }
    | {select_core_list}: select: { c1: text notnull, c7: real }
    | | {select_core}: select: { c1: text notnull, c7: real }
    |   | {select_expr_list_con}: select: { c1: text notnull, c7: real }
    |     | {select_expr_list}: select: { c1: text notnull, c7: real }
    |     | | {select_expr}: c1: text notnull
    |     | | | {strlit 'x'}: text notnull
    |     | | | {opt_as_alias}
    |     | |   | {name c1}
    |     | | {select_expr_list}
    |     |   | {select_expr}: c7: real
    |     |     | {call}: real
    |     |     | | {name nullable}: real
    |     |     | | {call_arg_list}
    |     |     |   | {call_filter_clause}
    |     |     |   | {arg_list}: ok
    |     |     |     | {dbl 3.2}: real notnull
    |     |     | {opt_as_alias}
    |     |       | {name c7}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM VALUES('x', 3.2);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      | {insert_list}: ok
        | {strlit 'x'}: text notnull
        | {insert_list}
          | {dbl 3.2}: real notnull

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM VALUES(c1c7.c1, c1c7.c7);

  {update_cursor_stmt}: ok
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}: c1: text notnull
    |   | {name_list}
    |     | {name c7}: c7: real
    | {insert_list}: ok
      | {dot}: c1c7.c1: text notnull variable
      | | {name c1c7}
      | | {name c1}
      | {insert_list}
        | {dot}: c1c7.c7: real variable
          | {name c1c7}
          | {name c7}

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM VALUES(c1c7.c1, c1c7.c7);

  {update_cursor_stmt}: ok
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}: c1: text notnull
    |   | {name_list}
    |     | {name c7}: c7: real
    | {insert_list}: ok
      | {dot}: c1c7.c1: text notnull variable
      | | {name c1c7}
      | | {name c1}
      | {insert_list}
        | {dot}: c1c7.c7: real variable
          | {name c1c7}
          | {name c7}

The statement ending at line XXXX

UPDATE CURSOR nully_cursor(c1, c7) FROM not_a_symbol;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_symbol'

  {update_cursor_stmt}: err
  | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
  | {columns_values}: ok
    | {column_spec}
    | | {name_list}
    |   | {name c1}
    |   | {name_list}
    |     | {name c7}
    | {from_shape}
      | {name not_a_symbol}: err

The statement ending at line XXXX

FETCH nully_cursor(c1, c7, c2, c3, c4, c5, c6, c8, c9, c10) FROM VALUES(c1c7.c1, c1c7.c7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      |     | {name_list}
      |       | {name c2}: c2: integer
      |       | {name_list}
      |         | {name c3}: c3: real
      |         | {name_list}
      |           | {name c4}: c4: real
      |           | {name_list}
      |             | {name c5}: c5: real
      |             | {name_list}
      |               | {name c6}: c6: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}: ok
        | {dot}: c1c7.c1: text notnull variable
        | | {name c1c7}
        | | {name c1}
        | {insert_list}
          | {dot}: c1c7.c7: real variable
          | | {name c1c7}
          | | {name c7}
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c1, c7, c2, c3, c4, c5, c6, c8, c9, c10) FROM VALUES(c1c7.c1, c1c7.c7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      |     | {name_list}
      |       | {name c2}: c2: integer
      |       | {name_list}
      |         | {name c3}: c3: real
      |         | {name_list}
      |           | {name c4}: c4: real
      |           | {name_list}
      |             | {name c5}: c5: real
      |             | {name_list}
      |               | {name c6}: c6: real
      |               | {name_list}
      |                 | {name c8}: c8: real
      |                 | {name_list}
      |                   | {name c9}: c9: real
      |                   | {name_list}
      |                     | {name c10}: c10: real
      | {insert_list}: ok
        | {dot}: c1c7.c1: text notnull variable
        | | {name c1c7}
        | | {name c1}
        | {insert_list}
          | {dot}: c1c7.c7: real variable
          | | {name c1c7}
          | | {name c7}
          | {insert_list}
            | {null}: null
            | {insert_list}
              | {null}: null
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {null}: null
                  | {insert_list}
                    | {null}: null
                    | {insert_list}
                      | {null}: null
                      | {insert_list}
                        | {null}: null
                        | {insert_list}
                          | {null}: null

The statement ending at line XXXX

FETCH nully_cursor(c1, c7) FROM not_a_symbol;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}
      |   | {name_list}
      |     | {name c7}
      | {from_shape}
        | {name not_a_symbol}: err

The statement ending at line XXXX

FETCH nully_cursor(LIKE not_a_symbol) FROM VALUES(1, 2);

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor
    | {columns_values}: err
      | {column_spec}
      | | {shape_def}: err
      |   | {like}: err
      |     | {name not_a_symbol}: err
      | {insert_list}
        | {int 1}
        | {insert_list}
          | {int 2}

The statement ending at line XXXX

DECLARE id_name_cursor CURSOR LIKE SELECT 1 AS id, 'x' AS name;

  {declare_cursor_like_select}: id_name_cursor: select: { id: integer notnull, name: text notnull } variable shape_storage value_cursor
  | {name id_name_cursor}: id_name_cursor: select: { id: integer notnull, name: text notnull } variable shape_storage value_cursor
  | {select_stmt}: select: { id: integer notnull, name: text notnull }
    | {select_core_list}: select: { id: integer notnull, name: text notnull }
    | | {select_core}: select: { id: integer notnull, name: text notnull }
    |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
    |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
    |     | | {select_expr}: id: integer notnull
    |     | | | {int 1}: integer notnull
    |     | | | {opt_as_alias}
    |     | |   | {name id}
    |     | | {select_expr_list}
    |     |   | {select_expr}: name: text notnull
    |     |     | {strlit 'x'}: text notnull
    |     |     | {opt_as_alias}
    |     |       | {name name}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(id, name) VALUES(1, 'x');

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      |   | {name_list}
      |     | {name name}: name: text
      | {select_stmt}: values: { column1: integer notnull, column2: text notnull }
        | {select_core_list}: values: { column1: integer notnull, column2: text notnull }
        | | {select_core}: values: { column1: integer notnull, column2: text notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull, column2: text notnull }
        |     | {insert_list}: ok
        |       | {int 1}: integer notnull
        |       | {insert_list}
        |         | {strlit 'x'}: text notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO bar(LIKE not_a_symbol) VALUES(1, 'x');

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
    | {columns_values}: err
      | {column_spec}
      | | {shape_def}: err
      |   | {like}: err
      |     | {name not_a_symbol}: err
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |       | {int 1}
        |       | {insert_list}
        |         | {strlit 'x'}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM VALUES(nully_cursor.c1, nully_cursor.c7);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}: c1: text notnull
      |   | {name_list}
      |     | {name c7}: c7: real
      | {insert_list}: ok
        | {dot}: nully_cursor.c1: text notnull variable
        | | {name nully_cursor}
        | | {name c1}
        | {insert_list}
          | {dot}: nully_cursor.c7: real variable
            | {name nully_cursor}
            | {name c7}

The statement ending at line XXXX

FETCH c1c7(c1, c7) FROM nully_cursor(LIKE not_a_symbol);

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_symbol'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name c1c7}: c1c7: select: { c1: text notnull, c7: real } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name c1}
      |   | {name_list}
      |     | {name c7}
      | {from_shape}: err
        | {column_spec}
        | | {shape_def}: err
        |   | {like}: err
        |     | {name not_a_symbol}: err
        | {name nully_cursor}: nully_cursor: foo_data: { c1: text notnull, c2: integer, c3: real, c4: real, c5: real, c6: real, c7: real, c8: real, c9: real, c10: real } variable shape_storage value_cursor

The statement ending at line XXXX

DECLARE PROC out_union_user (x INTEGER) OUT UNION (id INTEGER, x TEXT);

  {declare_proc_stmt}: out_union_user: { id: integer, x: text } uses_out_union
  | {proc_name_type}
  | | {name out_union_user}: out_union_user: { id: integer, x: text } uses_out_union
  | | {int 9}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {typed_names}: out_union_user: { id: integer, x: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: x: text
          | {name x}
          | {type_text}: x: text

The statement ending at line XXXX

DECLARE out_union_cursor CURSOR FOR CALL out_union_user(2);

  {declare_cursor}: out_union_cursor: out_union_user: { id: integer, x: text } variable uses_out_union
  | {name out_union_cursor}: out_union_cursor: out_union_user: { id: integer, x: text } variable uses_out_union
  | {call_stmt}: out_union_user: { id: integer, x: text } uses_out_union
    | {name out_union_user}: out_union_user: { id: integer, x: text } uses_out_union
    | {expr_list}: ok
      | {int 2}: integer notnull

The statement ending at line XXXX

CREATE TABLE sens_table(
  t TEXT @SENSITIVE
);

  {create_table_stmt}: sens_table: { t: text sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name sens_table}
  | {col_key_list}
    | {col_def}: t: text sensitive
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name t}
        | | {type_text}: text
        | {sensitive_attr}: ok

The statement ending at line XXXX

DECLARE PROC sens_result_proc () (t TEXT @SENSITIVE);

  {declare_proc_stmt}: sens_result_proc: { t: text sensitive } dml_proc
  | {proc_name_type}
  | | {name sens_result_proc}: sens_result_proc: { t: text sensitive } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: sens_result_proc: { t: text sensitive }
      | {typed_name}: t: text sensitive
        | {name t}
        | {sensitive_attr}: t: text sensitive
          | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test))
CREATE PROC sens_result_proc ()
BEGIN
  SELECT *
    FROM sens_table;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_test}: ok
  | {create_proc_stmt}: sens_result_proc: { t: text sensitive } dml_proc
    | {name sens_result_proc}: sens_result_proc: { t: text sensitive } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { t: text sensitive }
          | {select_core_list}: select: { t: text sensitive }
          | | {select_core}: select: { t: text sensitive }
          |   | {select_expr_list_con}: select: { t: text sensitive }
          |     | {select_expr_list}: select: { t: text sensitive }
          |     | | {star}: select: { t: text sensitive }
          |     | {select_from_etc}: TABLE { sens_table: sens_table }
          |       | {table_or_subquery_list}: TABLE { sens_table: sens_table }
          |       | | {table_or_subquery}: TABLE { sens_table: sens_table }
          |       |   | {name sens_table}: TABLE { sens_table: sens_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE PROC incompatible_result_proc () (t TEXT);

  {declare_proc_stmt}: incompatible_result_proc: { t: text } dml_proc
  | {proc_name_type}
  | | {name incompatible_result_proc}: incompatible_result_proc: { t: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: incompatible_result_proc: { t: text }
      | {typed_name}: t: text
        | {name t}
        | {type_text}: t: text

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=(dummy_test))
CREATE PROC incompatible_result_proc ()
BEGIN
  SELECT 1 AS t;
END;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : DECLARE PROC incompatible_result_proc () (t TEXT)
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : DECLARE PROC incompatible_result_proc () (t INTEGER NOT NULL)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0189: procedure declarations/definitions do not match 'incompatible_result_proc'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {name dummy_test}: ok
  | {create_proc_stmt}: err
    | {name incompatible_result_proc}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { t: integer notnull }
          | {select_core_list}: select: { t: integer notnull }
          | | {select_core}: select: { t: integer notnull }
          |   | {select_expr_list_con}: select: { t: integer notnull }
          |     | {select_expr_list}: select: { t: integer notnull }
          |     | | {select_expr}: t: integer notnull
          |     |   | {int 1}: integer notnull
          |     |   | {opt_as_alias}
          |     |     | {name t}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM bar
ORDER BY name COLLATE nocase;

  {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
  | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
  | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
  |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
  |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
  |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {opt_orderby}: ok
    | | {orderby_list}: ok
    |   | {orderby_item}
    |     | {collate}: name: text
    |       | {name name}: name: text
    |       | {name nocase}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := 'x' COLLATE nocase;

test/sem_test.sql:XXXX:1: error: in collate : CQL0241: COLLATE may only appear in the context of a SQL statement

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {collate}: err
    | {strlit 'x'}: text notnull
    | {name nocase}

The statement ending at line XXXX

SELECT (NOT 'x') COLLATE nocase;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {collate}: err
  |     |     | {not}: err
  |     |     | | {strlit 'x'}: text notnull
  |     |     | {name nocase}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE IF NOT EXISTS foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
);

  {create_table_stmt}: foo: { id: integer notnull primary_key autoinc }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 2}
  | | {name foo}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
            | {col_attrs_autoinc}

The statement ending at line XXXX

CREATE VIEW IF NOT EXISTS MyView AS
SELECT 1 AS f1, 2 AS f2, 3 AS f3;

  {create_view_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
  | {int 2}
  | {view_and_attrs}
    | {name_and_select}
      | {name MyView}
      | {select_stmt}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | {select_core_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        | | {select_core}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |   | {select_expr_list_con}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | {select_expr_list}: MyView: { f1: integer notnull, f2: integer notnull, f3: integer notnull }
        |     | | {select_expr}: f1: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name f1}
        |     | | {select_expr_list}
        |     |   | {select_expr}: f2: integer notnull
        |     |   | | {int 2}: integer notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name f2}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: f3: integer notnull
        |     |       | {int 3}: integer notnull
        |     |       | {opt_as_alias}
        |     |         | {name f3}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER IF NOT EXISTS trigger2
  AFTER INSERT ON bar
BEGIN
  DELETE FROM bar WHERE rate > new.id;
END;

  {create_trigger_stmt}: ok
  | {int 2}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger2}
      | {trigger_condition}
        | {int 8}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 128}
          | {trigger_target_action}
            | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
                    | {opt_where}: bool
                      | {gt}: bool
                        | {name rate}: rate: longint
                        | {dot}: id: integer notnull
                          | {name new}
                          | {name id}

The statement ending at line XXXX

CREATE INDEX IF NOT EXISTS index_1 ON foo (id);

  {create_index_stmt}: ok
  | {create_index_on_list}
  | | {name index_1}
  | | {name foo}
  | {flags_names_attrs}
    | {int 2}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}: id: integer notnull

The statement ending at line XXXX

SELECT x'FAB1';

  {select_stmt}: select: { _anon: blob notnull }
  | {select_core_list}: select: { _anon: blob notnull }
  | | {select_core}: select: { _anon: blob notnull }
  |   | {select_expr_list_con}: select: { _anon: blob notnull }
  |     | {select_expr_list}: select: { _anon: blob notnull }
  |     | | {select_expr}: blob notnull
  |     |   | {blob x'FAB1'}: blob notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=blob_stuff)
CREATE PROC blob_base_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT id_ AS id, x'123456' AS bl)
  SELECT *
    FROM blob_stuff;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name blob_stuff}: ok
  | {create_proc_stmt}: blob_base_fragment: { id: integer notnull, bl: blob notnull } dml_proc
    | {name blob_base_fragment}: blob_base_fragment: { id: integer notnull, bl: blob notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |     | {cte_decl}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |     | | {name blob_stuff}
          |     | | {name_list}
          |     |   | {name id}
          |     |   | {name_list}
          |     |     | {name bl}
          |     | {select_stmt}: select: { id: integer notnull variable in, bl: blob notnull }
          |       | {select_core_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |       | | {select_core}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |       |     | | {select_expr}: id: integer notnull variable in
          |       |     | | | {name id_}: id_: integer notnull variable in
          |       |     | | | {opt_as_alias}
          |       |     | |   | {name id}
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: bl: blob notnull
          |       |     |     | {blob x'123456'}: blob notnull
          |       |     |     | {opt_as_alias}
          |       |     |       | {name bl}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull }
            |     | {select_from_etc}: TABLE { blob_stuff: blob_stuff }
            |       | {table_or_subquery_list}: TABLE { blob_stuff: blob_stuff }
            |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
            |       |   | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=blob_stuff)
CREATE PROC blob_ext_fragment (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT 1 AS id, x'123456' AS bl),
  blob_ext (id, bl, bl2) AS (SELECT blob_stuff.*, T2.*
    FROM blob_stuff
    LEFT OUTER JOIN (SELECT x'abcd' AS bl2) AS T2)
  SELECT *
    FROM blob_ext;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name blob_stuff}: ok
  | {create_proc_stmt}: blob_ext_fragment: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {name blob_ext_fragment}: blob_ext_fragment: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull, bl: blob notnull }
          |   | | {cte_decl}: blob_stuff: { id: integer notnull, bl: blob notnull }
          |   | | | {name blob_stuff}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | |   | {name_list}
          |   | |     | {name bl}
          |   | | {select_stmt}: select: { id: integer notnull, bl: blob notnull }
          |   |   | {select_core_list}: select: { id: integer notnull, bl: blob notnull }
          |   |   | | {select_core}: select: { id: integer notnull, bl: blob notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull }
          |   |   |     | | {select_expr}: id: integer notnull
          |   |   |     | | | {int 1}: integer notnull
          |   |   |     | | | {opt_as_alias}
          |   |   |     | |   | {name id}
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: bl: blob notnull
          |   |   |     |     | {blob x'123456'}: blob notnull
          |   |   |     |     | {opt_as_alias}
          |   |   |     |       | {name bl}
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | {cte_decl}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | | {name blob_ext}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name bl}
          |       |     | {name_list}
          |       |       | {name bl2}
          |       | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | | {table_star}: blob_stuff: blob_stuff: { id: integer notnull, bl: blob notnull }
          |         |     | | | {name blob_stuff}
          |         |     | | {select_expr_list}
          |         |     |   | {table_star}: T2: select: { bl2: blob }
          |         |     |     | {name T2}
          |         |     | {select_from_etc}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | {join_clause}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
          |         |       | | | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { T2: select }
          |         |       |         | {select_stmt}: select: { bl2: blob notnull }
          |         |       |         | | {select_core_list}: select: { bl2: blob notnull }
          |         |       |         | | | {select_core}: select: { bl2: blob notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { bl2: blob notnull }
          |         |       |         | |     | {select_expr_list}: select: { bl2: blob notnull }
          |         |       |         | |     | | {select_expr}: bl2: blob notnull
          |         |       |         | |     |   | {blob x'abcd'}: blob notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name bl2}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name T2}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_from_etc}: TABLE { blob_ext: blob_ext }
            |       | {table_or_subquery_list}: TABLE { blob_ext: blob_ext }
            |       | | {table_or_subquery}: TABLE { blob_ext: blob_ext }
            |       |   | {name blob_ext}: TABLE { blob_ext: blob_ext }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=blob_stuff)
CREATE PROC blob_stuff (id_ INTEGER NOT NULL)
BEGIN
  WITH
  blob_stuff (id, bl) AS (SELECT id_ AS id, x'123456' AS bl),
  blob_ext (id, bl, bl2) AS (SELECT blob_stuff.*, T2.*
    FROM blob_stuff
    LEFT OUTER JOIN (SELECT x'abcd' AS bl2) AS T2)
  SELECT *
    FROM blob_ext;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name blob_stuff}: ok
  | {create_proc_stmt}: blob_stuff: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {name blob_stuff}: blob_stuff: { id: integer notnull, bl: blob notnull, bl2: blob } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |   | | {cte_decl}: blob_stuff: { id: integer notnull variable in, bl: blob notnull }
          |   | | | {name blob_stuff}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | |   | {name_list}
          |   | |     | {name bl}
          |   | | {select_stmt}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   | {select_core_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   | | {select_core}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull variable in, bl: blob notnull }
          |   |   |     | | {select_expr}: id: integer notnull variable in
          |   |   |     | | | {name id_}: id_: integer notnull variable in
          |   |   |     | | | {opt_as_alias}
          |   |   |     | |   | {name id}
          |   |   |     | | {select_expr_list}
          |   |   |     |   | {select_expr}: bl: blob notnull
          |   |   |     |     | {blob x'123456'}: blob notnull
          |   |   |     |     | {opt_as_alias}
          |   |   |     |       | {name bl}
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | {cte_decl}: blob_ext: { id: integer notnull, bl: blob notnull, bl2: blob }
          |       | | {name blob_ext}
          |       | | {name_list}
          |       |   | {name id}
          |       |   | {name_list}
          |       |     | {name bl}
          |       |     | {name_list}
          |       |       | {name bl2}
          |       | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
          |         |     | | {table_star}: blob_stuff: blob_stuff: { id: integer notnull, bl: blob notnull }
          |         |     | | | {name blob_stuff}
          |         |     | | {select_expr_list}
          |         |     |   | {table_star}: T2: select: { bl2: blob }
          |         |     |     | {name T2}
          |         |     | {select_from_etc}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | {join_clause}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       | | {table_or_subquery}: TABLE { blob_stuff: blob_stuff }
          |         |       | | | {name blob_stuff}: TABLE { blob_stuff: blob_stuff }
          |         |       | | {join_target_list}
          |         |       |   | {join_target}: JOIN { blob_stuff: blob_stuff, T2: select }
          |         |       |     | {int 3} {join_left_outer}
          |         |       |     | {table_join}
          |         |       |       | {table_or_subquery}: TABLE { T2: select }
          |         |       |         | {select_stmt}: select: { bl2: blob notnull }
          |         |       |         | | {select_core_list}: select: { bl2: blob notnull }
          |         |       |         | | | {select_core}: select: { bl2: blob notnull }
          |         |       |         | |   | {select_expr_list_con}: select: { bl2: blob notnull }
          |         |       |         | |     | {select_expr_list}: select: { bl2: blob notnull }
          |         |       |         | |     | | {select_expr}: bl2: blob notnull
          |         |       |         | |     |   | {blob x'abcd'}: blob notnull
          |         |       |         | |     |   | {opt_as_alias}
          |         |       |         | |     |     | {name bl2}
          |         |       |         | |     | {select_from_etc}: ok
          |         |       |         | |       | {select_where}
          |         |       |         | |         | {select_groupby}
          |         |       |         | |           | {select_having}
          |         |       |         | | {select_orderby}
          |         |       |         |   | {select_limit}
          |         |       |         |     | {select_offset}
          |         |       |         | {opt_as_alias}
          |         |       |           | {name T2}
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | {select_core_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            | | {select_core}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |   | {select_expr_list_con}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_expr_list}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | | {star}: select: { id: integer notnull, bl: blob notnull, bl2: blob }
            |     | {select_from_etc}: TABLE { blob_ext: blob_ext }
            |       | {table_or_subquery_list}: TABLE { blob_ext: blob_ext }
            |       | | {table_or_subquery}: TABLE { blob_ext: blob_ext }
            |       |   | {name blob_ext}: TABLE { blob_ext: blob_ext }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_literal_out (OUT b BLOB)
BEGIN
  SET b := x'12abcdef';
END;

test/sem_test.sql:XXXX:1: error: in blb : CQL0313: blob literals may only appear in the context of a SQL statement

  {create_proc_stmt}: err
  | {name blob_literal_out}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: b: blob variable out
    |   | {out}
    |   | {param_detail}: b: blob variable out
    |     | {name b}: b: blob variable out
    |     | {type_blob}: blob
    | {stmt_list}: err
      | {assign}: err
        | {name b}: b: blob variable out
        | {blob x'12abcdef'}: err

The statement ending at line XXXX

SELECT nullif(id)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'nullif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name nullif}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullif(id, 1) AS n
  FROM bar;

  {select_stmt}: select: { n: integer }
  | {select_core_list}: select: { n: integer }
  | | {select_core}: select: { n: integer }
  |   | {select_expr_list_con}: select: { n: integer }
  |     | {select_expr_list}: select: { n: integer }
  |     | | {select_expr}: n: integer
  |     |   | {call}: integer
  |     |   | | {name nullif}: integer
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer notnull
  |     |   |     | {arg_list}
  |     |   |       | {int 1}: integer notnull
  |     |   | {opt_as_alias}
  |     |     | {name n}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullif(price_d, price_d) AS p;

  {select_stmt}: select: { p: real<dollars> variable was_set }
  | {select_core_list}: select: { p: real<dollars> variable was_set }
  | | {select_core}: select: { p: real<dollars> variable was_set }
  |   | {select_expr_list_con}: select: { p: real<dollars> variable was_set }
  |     | {select_expr_list}: select: { p: real<dollars> variable was_set }
  |     | | {select_expr}: p: real<dollars> variable was_set
  |     |   | {call}: real<dollars> variable was_set
  |     |   | | {name nullif}: real<dollars> variable was_set
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name price_d}: price_d: real<dollars> variable was_set
  |     |   |     | {arg_list}
  |     |   |       | {name price_d}: price_d: real<dollars> variable was_set
  |     |   | {opt_as_alias}
  |     |     | {name p}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT nullif(price_d, price_e);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name nullif}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name price_d}: price_d: real<dollars> variable was_set
  |     |         | {arg_list}
  |     |           | {name price_e}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, nullif(name, 1)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'NULLIF'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: id: integer notnull
  |     | | | {name id}: id: integer notnull
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {call}
  |     |       | {name nullif}
  |     |       | {call_arg_list}
  |     |         | {call_filter_clause}
  |     |         | {arg_list}: ok
  |     |           | {name name}: err
  |     |           | {arg_list}
  |     |             | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := nullif('x', 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'nullif'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name nullif}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

SELECT nullif(name, 'a') AS n
  FROM with_sensitive;

  {select_stmt}: select: { n: text sensitive }
  | {select_core_list}: select: { n: text sensitive }
  | | {select_core}: select: { n: text sensitive }
  |   | {select_expr_list_con}: select: { n: text sensitive }
  |     | {select_expr_list}: select: { n: text sensitive }
  |     | | {select_expr}: n: text sensitive
  |     |   | {call}: text sensitive
  |     |   | | {name nullif}: text sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name name}: name: text sensitive
  |     |   |     | {arg_list}
  |     |   |       | {strlit 'a'}: text notnull
  |     |   | {opt_as_alias}
  |     |     | {name n}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC nullif (value INTEGER, defaultValue INTEGER NOT NULL) INTEGER;

test/sem_test.sql:XXXX:1: error: in str : CQL0314: select function does not require a declaration, it is a CQL built-in 'nullif'

  {declare_select_func_stmt}: err
  | {name nullif}: integer
  | {func_params_return}
    | {params}: ok
    | | {param}: value: integer variable in
    | | | {param_detail}: value: integer variable in
    | |   | {name value}: value: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: defaultValue: integer notnull variable in
    |     | {param_detail}: defaultValue: integer notnull variable in
    |       | {name defaultValue}: defaultValue: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {type_int}: integer

The statement ending at line XXXX

SELECT upper(name)
  FROM with_sensitive;

  {select_stmt}: select: { _anon: text sensitive }
  | {select_core_list}: select: { _anon: text sensitive }
  | | {select_core}: select: { _anon: text sensitive }
  |   | {select_expr_list_con}: select: { _anon: text sensitive }
  |     | {select_expr_list}: select: { _anon: text sensitive }
  |     | | {select_expr}: text sensitive
  |     |   | {call}: text sensitive
  |     |     | {name upper}: text sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT upper(id)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0086: first argument must be a string in function 'upper'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name upper}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name id}: id: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT upper(name, 1)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'upper'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name upper}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text
  |     |         | {arg_list}
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := upper('x');

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'upper'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name upper}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

SELECT char(id, info) AS c
  FROM with_sensitive;

  {select_stmt}: select: { c: text sensitive }
  | {select_core_list}: select: { c: text sensitive }
  | | {select_core}: select: { c: text sensitive }
  |   | {select_expr_list_con}: select: { c: text sensitive }
  |     | {select_expr_list}: select: { c: text sensitive }
  |     | | {select_expr}: c: text sensitive
  |     |   | {call}: text sensitive
  |     |   | | {name char}: text sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name id}: id: integer
  |     |   |     | {arg_list}
  |     |   |       | {name info}: info: integer sensitive
  |     |   | {opt_as_alias}
  |     |     | {name c}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT char(name)
  FROM bar;

test/sem_test.sql:XXXX:1: error: in call : CQL0317: char function arguments must be integer 'char'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name char}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name name}: name: text
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT char()
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'char'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name char}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET a_string := char(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'char'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name char}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT abs(info)
  FROM with_sensitive;

  {select_stmt}: select: { info: integer sensitive }
  | {select_core_list}: select: { info: integer sensitive }
  | | {select_core}: select: { info: integer sensitive }
  |   | {select_expr_list_con}: select: { info: integer sensitive }
  |     | {select_expr_list}: select: { info: integer sensitive }
  |     | | {select_expr}: info: integer sensitive
  |     |   | {call}: info: integer sensitive
  |     |     | {name abs}: info: integer sensitive
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name info}: info: integer sensitive
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT abs(price_d) );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_stmt}: price_d: real<dollars> variable was_set
    | {select_core_list}: select: { price_d: real<dollars> variable was_set }
    | | {select_core}: select: { price_d: real<dollars> variable was_set }
    |   | {select_expr_list_con}: select: { price_d: real<dollars> variable was_set }
    |     | {select_expr_list}: select: { price_d: real<dollars> variable was_set }
    |     | | {select_expr}: price_d: real<dollars> variable was_set
    |     |   | {call}: price_d: real<dollars> variable was_set
    |     |     | {name abs}: price_d: real<dollars> variable was_set
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name price_d}: price_d: real<dollars> variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT abs()
  FROM bar;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'abs'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name abs}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: TABLE { bar: bar }
  |       | {table_or_subquery_list}: TABLE { bar: bar }
  |       | | {table_or_subquery}: TABLE { bar: bar }
  |       |   | {name bar}: TABLE { bar: bar }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT abs('Horty');

test/sem_test.sql:XXXX:1: error: in str : CQL0082: argument must be numeric 'abs'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name abs}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'Horty'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT abs(NULL);

  {select_stmt}: select: { _anon: null }
  | {select_core_list}: select: { _anon: null }
  | | {select_core}: select: { _anon: null }
  |   | {select_expr_list_con}: select: { _anon: null }
  |     | {select_expr_list}: select: { _anon: null }
  |     | | {select_expr}: null
  |     |   | {call}: null
  |     |     | {name abs}: null
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET an_int := instr(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'instr'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {call}: err
    | {name instr}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

SELECT instr();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'instr'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name instr}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr(name, 'a') AS x
  FROM with_sensitive;

  {select_stmt}: select: { x: integer sensitive }
  | {select_core_list}: select: { x: integer sensitive }
  | | {select_core}: select: { x: integer sensitive }
  |   | {select_expr_list_con}: select: { x: integer sensitive }
  |     | {select_expr_list}: select: { x: integer sensitive }
  |     | | {select_expr}: x: integer sensitive
  |     |   | {call}: integer sensitive
  |     |   | | {name instr}: integer sensitive
  |     |   | | {call_arg_list}
  |     |   |   | {call_filter_clause}
  |     |   |   | {arg_list}: ok
  |     |   |     | {name name}: name: text sensitive
  |     |   |     | {arg_list}
  |     |   |       | {strlit 'a'}: text notnull
  |     |   | {opt_as_alias}
  |     |     | {name x}
  |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
  |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
  |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
  |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr('a', 'a');

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name instr}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'a'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT instr(1, 'a');

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'instr'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name instr}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 1}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'a'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=1)
CREATE PROC wonky_value_type (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {int 1}: ok
  | {create_proc_stmt}: ok
    | {name wonky_value_type}: ok
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC dup_base (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0318: more than one fragment annotation on procedure 'dup_base'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name base_fragment}
  | | | {name foo}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}: ok
  | {create_proc_stmt}: err
    | {name dup_base}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC mixed_frag_types1 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types1'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name extension_fragment}
  | | | {name foo}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}: ok
  | {create_proc_stmt}: err
    | {name mixed_frag_types1}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=foo)
@ATTRIBUTE(cql:assembly_fragment=goo)
CREATE PROC mixed_frag_types2 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types2'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name extension_fragment}
  | | | {name foo}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name assembly_fragment}
  |     | {name goo}: ok
  | {create_proc_stmt}: err
    | {name mixed_frag_types2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=foo)
@ATTRIBUTE(cql:base_fragment=goo)
CREATE PROC mixed_frag_types3 (id_ INTEGER)
BEGIN
  DECLARE x INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0318: more than one fragment annotation on procedure 'mixed_frag_types3'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name assembly_fragment}
  | | | {name foo}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name base_fragment}
  |     | {name goo}: ok
  | {create_proc_stmt}: err
    | {name mixed_frag_types3}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      |   | {param_detail}: id_: integer variable in
      |     | {name id_}: id_: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {declare_vars_type}: integer
          | {name_list}: x: integer variable
          | | {name x}: x: integer variable
          | {type_int}: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:assembly_fragment=core)
CREATE PROC wrong_assembly_frag_name (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (x, y, z) AS (SELECT id, name, rate
    FROM bar
    WHERE id = id_)
  SELECT *
    FROM core;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0319: name of the assembly procedure must match the name of the base fragment 'wrong_assembly_frag_name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name assembly_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name wrong_assembly_frag_name}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull, y: text, z: longint }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { x: integer notnull, y: text, z: longint }
          |     | {cte_decl}: core: { x: integer notnull, y: text, z: longint }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name x}
          |     |   | {name_list}
          |     |     | {name y}
          |     |     | {name_list}
          |     |       | {name z}
          |     | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          |       | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          |       | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |       |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |       |     | | {select_expr}: id: integer notnull
          |       |     | | | {name id}: id: integer notnull
          |       |     | | {select_expr_list}
          |       |     |   | {select_expr}: name: text
          |       |     |   | | {name name}: name: text
          |       |     |   | {select_expr_list}
          |       |     |     | {select_expr}: rate: longint
          |       |     |       | {name rate}: rate: longint
          |       |     | {select_from_etc}: TABLE { bar: bar }
          |       |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |       |   | {name bar}: TABLE { bar: bar }
          |       |       | {select_where}
          |       |         | {opt_where}: bool notnull
          |       |         | | {eq}: bool notnull
          |       |         |   | {name id}: id: integer notnull
          |       |         |   | {name id_}: id_: integer notnull variable in
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull, y: text, z: longint }
            | {select_core_list}: select: { x: integer notnull, y: text, z: longint }
            | | {select_core}: select: { x: integer notnull, y: text, z: longint }
            |   | {select_expr_list_con}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_expr_list}: select: { x: integer notnull, y: text, z: longint }
            |     | | {star}: select: { x: integer notnull, y: text, z: longint }
            |     | {select_from_etc}: TABLE { core: core }
            |       | {table_or_subquery_list}: TABLE { core: core }
            |       | | {table_or_subquery}: TABLE { core: core }
            |       |   | {name core}: TABLE { core: core }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_1 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT 1 AS x;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name base_frag_broken_1}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {select_expr}: x: integer notnull
            |     |   | {int 1}: integer notnull
            |     |   | {opt_as_alias}
            |     |     | {name x}
            |     | {select_from_etc}: ok
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_2 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM (SELECT 1 AS x) AS y;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name base_frag_broken_2}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { y: select }
            |       | {table_or_subquery_list}: TABLE { y: select }
            |       | | {table_or_subquery}: TABLE { y: select }
            |       |   | {select_stmt}: select: { x: integer notnull }
            |       |   | | {select_core_list}: select: { x: integer notnull }
            |       |   | | | {select_core}: select: { x: integer notnull }
            |       |   | |   | {select_expr_list_con}: select: { x: integer notnull }
            |       |   | |     | {select_expr_list}: select: { x: integer notnull }
            |       |   | |     | | {select_expr}: x: integer notnull
            |       |   | |     |   | {int 1}: integer notnull
            |       |   | |     |   | {opt_as_alias}
            |       |   | |     |     | {name x}
            |       |   | |     | {select_from_etc}: ok
            |       |   | |       | {select_where}
            |       |   | |         | {select_groupby}
            |       |   | |           | {select_having}
            |       |   | | {select_orderby}
            |       |   |   | {select_limit}
            |       |   |     | {select_offset}
            |       |   | {opt_as_alias}
            |       |     | {name y}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL JOIN;

  {enforce_normal_stmt}: ok
  | {int 3}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_3 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM foo,
  (SELECT 1 AS xyz);
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name base_frag_broken_3}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, xyz: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, xyz: integer notnull }
            | | {select_core}: select: { id: integer notnull, xyz: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, xyz: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull, xyz: integer notnull }
            |     | | {star}: select: { id: integer notnull, xyz: integer notnull }
            |     | {select_from_etc}: JOIN { foo: foo, select: select }
            |       | {table_or_subquery_list}: JOIN { foo: foo, select: select }
            |       | | {table_or_subquery}: TABLE { foo: foo }
            |       | | | {name foo}: TABLE { foo: foo }
            |       | | {table_or_subquery_list}: TABLE { select: select }
            |       |   | {table_or_subquery}: TABLE { select: select }
            |       |     | {select_stmt}: select: { xyz: integer notnull }
            |       |       | {select_core_list}: select: { xyz: integer notnull }
            |       |       | | {select_core}: select: { xyz: integer notnull }
            |       |       |   | {select_expr_list_con}: select: { xyz: integer notnull }
            |       |       |     | {select_expr_list}: select: { xyz: integer notnull }
            |       |       |     | | {select_expr}: xyz: integer notnull
            |       |       |     |   | {int 1}: integer notnull
            |       |       |     |   | {opt_as_alias}
            |       |       |     |     | {name xyz}
            |       |       |     | {select_from_etc}: ok
            |       |       |       | {select_where}
            |       |       |         | {select_groupby}
            |       |       |           | {select_having}
            |       |       | {select_orderby}
            |       |         | {select_limit}
            |       |           | {select_offset}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=core)
CREATE PROC base_frag_broken_4 (id_ INTEGER NOT NULL)
BEGIN
  WITH
  core (id) AS (SELECT *
    FROM foo)
  SELECT *
    FROM foo
    INNER JOIN (SELECT 2 AS x) AS T;
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0251: fragment must end with exactly 'SELECT * FROM core'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name core}: ok
  | {create_proc_stmt}: err
    | {name base_frag_broken_4}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: integer notnull, x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: core: { id: integer notnull }
          |     | {cte_decl}: core: { id: integer notnull }
          |     | | {name core}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { foo: foo }
          |       |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |       |   | {name foo}: TABLE { foo: foo }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: err
            | {select_core_list}: select: { id: integer notnull, x: integer notnull }
            | | {select_core}: select: { id: integer notnull, x: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull, x: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull, x: integer notnull }
            |     | | {star}: select: { id: integer notnull, x: integer notnull }
            |     | {select_from_etc}: JOIN { foo: foo, T: select }
            |       | {join_clause}: JOIN { foo: foo, T: select }
            |       | | {table_or_subquery}: TABLE { foo: foo }
            |       | | | {name foo}: TABLE { foo: foo }
            |       | | {join_target_list}
            |       |   | {join_target}: JOIN { foo: foo, T: select }
            |       |     | {int 1} {join_inner}
            |       |     | {table_join}
            |       |       | {table_or_subquery}: TABLE { T: select }
            |       |         | {select_stmt}: select: { x: integer notnull }
            |       |         | | {select_core_list}: select: { x: integer notnull }
            |       |         | | | {select_core}: select: { x: integer notnull }
            |       |         | |   | {select_expr_list_con}: select: { x: integer notnull }
            |       |         | |     | {select_expr_list}: select: { x: integer notnull }
            |       |         | |     | | {select_expr}: x: integer notnull
            |       |         | |     |   | {int 2}: integer notnull
            |       |         | |     |   | {opt_as_alias}
            |       |         | |     |     | {name x}
            |       |         | |     | {select_from_etc}: ok
            |       |         | |       | {select_where}
            |       |         | |         | {select_groupby}
            |       |         | |           | {select_having}
            |       |         | | {select_orderby}
            |       |         |   | {select_limit}
            |       |         |     | {select_offset}
            |       |         | {opt_as_alias}
            |       |           | {name T}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE bogus_reference_in_fk(
  col1 TEXT,
  col2 INTEGER,
  FOREIGN KEY (col2) REFERENCES this_table_does_not_exist (col1) ON UPDATE CASCADE ON DELETE CASCADE
) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0021: foreign key refers to non-existent table 'this_table_does_not_exist'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_reference_in_fk}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: col2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name col2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: err
          | {fk_info}
            | {name_list}
            | | {name col2}: col2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name this_table_does_not_exist}
              | | {name_list}
              |   | {name col1}
              | {int 51}

The statement ending at line XXXX

CALL some_external_thing();

test/sem_test.sql:XXXX:1: error: in call_stmt : CQL0323: calls to undeclared procedures are forbidden; declaration missing or typo 'some_external_thing'

  {call_stmt}: err
  | {name some_external_thing}

The statement ending at line XXXX

DECLARE PROC some_external_thing NO CHECK;

  {declare_proc_no_check_stmt}: ok
  | {name some_external_thing}

The statement ending at line XXXX

CALL some_external_thing('x', 5.0);

  {call_stmt}: ok
  | {name some_external_thing}: ok
  | {expr_list}: ok
    | {strlit 'x'}: text notnull
    | {expr_list}
      | {dbl 5.0}: real notnull

The statement ending at line XXXX

LET result_of_some_external_thing := some_external_thing('x', 5.0);

test/sem_test.sql:XXXX:1: error: in str : CQL0405: procedure of an unknown type used in an expression 'some_external_thing'

  {let_stmt}: err
  | {name result_of_some_external_thing}
  | {call}: err
    | {name some_external_thing}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}
        | {arg_list}
          | {dbl 5.0}

The statement ending at line XXXX

DECLARE FUNC some_external_thing (t TEXT, r REAL) INTEGER;

  {declare_func_stmt}: integer
  | {name some_external_thing}: integer
  | {func_params_return}
    | {params}: ok
    | | {param}: t: text variable in
    | | | {param_detail}: t: text variable in
    | |   | {name t}: t: text variable in
    | |   | {type_text}: text
    | | {params}
    |   | {param}: r: real variable in
    |     | {param_detail}: r: real variable in
    |       | {name r}: r: real variable in
    |       | {type_real}: real
    | {type_int}: integer

The statement ending at line XXXX

LET result_of_some_external_thing := some_external_thing('x', 5.0);

  {let_stmt}: result_of_some_external_thing: integer variable
  | {name result_of_some_external_thing}: result_of_some_external_thing: integer variable
  | {call}: integer
    | {name some_external_thing}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {dbl 5.0}: real notnull

The statement ending at line XXXX

DECLARE PROC _stuff () (id INTEGER, name TEXT);

  {declare_proc_stmt}: _stuff: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff}: _stuff: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff1 () (id INTEGER, name TEXT);

  {declare_proc_stmt}: _stuff1: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff1}: _stuff1: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff1: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff2 () (h1 INTEGER, id INTEGER, name TEXT, t1 INTEGER);

  {declare_proc_stmt}: _stuff2: { h1: integer, id: integer, name: text, t1: integer } dml_proc
  | {proc_name_type}
  | | {name _stuff2}: _stuff2: { h1: integer, id: integer, name: text, t1: integer } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff2: { h1: integer, id: integer, name: text, t1: integer }
      | {typed_name}: h1: integer
      | | {name h1}
      | | {type_int}: h1: integer
      | {typed_names}
        | {typed_name}: id: integer
        | | {name id}
        | | {type_int}: id: integer
        | {typed_names}
          | {typed_name}: name: text
          | | {name name}
          | | {type_text}: name: text
          | {typed_names}
            | {typed_name}: t1: integer
              | {name t1}
              | {type_int}: t1: integer

The statement ending at line XXXX

DECLARE PROC _stuff3 () (h2 INTEGER, h1 INTEGER, id INTEGER, name TEXT, t1 INTEGER, t2 INTEGER);

  {declare_proc_stmt}: _stuff3: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer } dml_proc
  | {proc_name_type}
  | | {name _stuff3}: _stuff3: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff3: { h2: integer, h1: integer, id: integer, name: text, t1: integer, t2: integer }
      | {typed_name}: h2: integer
      | | {name h2}
      | | {type_int}: h2: integer
      | {typed_names}
        | {typed_name}: h1: integer
        | | {name h1}
        | | {type_int}: h1: integer
        | {typed_names}
          | {typed_name}: id: integer
          | | {name id}
          | | {type_int}: id: integer
          | {typed_names}
            | {typed_name}: name: text
            | | {name name}
            | | {type_text}: name: text
            | {typed_names}
              | {typed_name}: t1: integer
              | | {name t1}
              | | {type_int}: t1: integer
              | {typed_names}
                | {typed_name}: t2: integer
                  | {name t2}
                  | {type_int}: t2: integer

The statement ending at line XXXX

DECLARE PROC _stuff4 () (LIKE invalid_type_name);

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'invalid_type_name'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name _stuff4}
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: err
      | {typed_name}: err
        | {shape_def}: err
          | {like}: err
            | {name invalid_type_name}: err

The statement ending at line XXXX

DECLARE PROC _stuff5 () (id INTEGER, name TEXT);

  {declare_proc_stmt}: _stuff5: { id: integer, name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff5}: _stuff5: { id: integer, name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff5: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE PROC _stuff6 () (x_id INTEGER, x_name TEXT, y_id INTEGER, y_name TEXT);

  {declare_proc_stmt}: _stuff6: { x_id: integer, x_name: text, y_id: integer, y_name: text } dml_proc
  | {proc_name_type}
  | | {name _stuff6}: _stuff6: { x_id: integer, x_name: text, y_id: integer, y_name: text } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: _stuff6: { x_id: integer, x_name: text, y_id: integer, y_name: text }
      | {typed_name}: x_id: integer
      | | {name x_id}
      | | {type_int}: x_id: integer
      | {typed_names}
        | {typed_name}: x_name: text
        | | {name x_name}
        | | {type_text}: x_name: text
        | {typed_names}
          | {typed_name}: y_id: integer
          | | {name y_id}
          | | {type_int}: y_id: integer
          | {typed_names}
            | {typed_name}: y_name: text
              | {name y_name}
              | {type_text}: y_name: text

The statement ending at line XXXX

CREATE PROC using_like_shape (x_id INTEGER, x_name TEXT)
BEGIN
  CALL printf("%s\n", x.id);
END;

  {create_proc_stmt}: ok
  | {name using_like_shape}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_id: integer variable in
    | | | {param_detail}: x_id: integer variable in
    | |   | {name x_id}: x_id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: x_name: text variable in
    |     | {param_detail}: x_name: text variable in
    |       | {name x_name}: x_name: text variable in
    |       | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {strlit '%s
'}: text notnull
          | {expr_list}
            | {dot}: x_id: integer variable in
              | {name x}
              | {name id}

The statement ending at line XXXX

CREATE PROC using_like_shape_bad_name (x_id INTEGER, x_name TEXT)
BEGIN
  CALL printf("%s\n", x.xyzzy);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0068: field not found in shape 'xyzzy'

  {create_proc_stmt}: err
  | {name using_like_shape_bad_name}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_id: integer variable in
    | | | {param_detail}: x_id: integer variable in
    | |   | {name x_id}: x_id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: x_name: text variable in
    |     | {param_detail}: x_name: text variable in
    |       | {name x_name}: x_name: text variable in
    |       | {type_text}: text
    | {stmt_list}: err
      | {call_stmt}: err
        | {name printf}: ok
        | {expr_list}: err
          | {strlit '%s
'}: text notnull
          | {expr_list}
            | {dot}: err
              | {name x}
              | {name xyzzy}

The statement ending at line XXXX

CREATE PROC arg_shape_forwarder (args_arg1 INTEGER, args_arg2 TEXT, extra_args_id INTEGER, extra_args_name TEXT)
BEGIN
  CALL proc2(args.arg1, args.arg2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_shape_forwarder}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: args_arg1: integer variable in
    | | | {param_detail}: args_arg1: integer variable in
    | |   | {name args_arg1}: args_arg1: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: args_arg2: text variable in
    |   | | {param_detail}: args_arg2: text variable in
    |   |   | {name args_arg2}: args_arg2: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: extra_args_id: integer variable in
    |     | | {param_detail}: extra_args_id: integer variable in
    |     |   | {name extra_args_id}: extra_args_id: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: extra_args_name: text variable in
    |         | {param_detail}: extra_args_name: text variable in
    |           | {name extra_args_name}: extra_args_name: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok dml_proc
        | {name proc2}: ok dml_proc
        | {expr_list}: ok
          | {dot}: args_arg1: integer variable in
          | | {name args}
          | | {name arg1}
          | {expr_list}
            | {dot}: args_arg2: text variable in
              | {name args}
              | {name arg2}

The statement ending at line XXXX

CREATE TABLE from_the_future(
  col1 TEXT PRIMARY KEY
) @CREATE(5);

  {create_table_stmt}: from_the_future: { col1: text notnull primary_key } @create(5)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 5}
  | | {name from_the_future}
  | {col_key_list}
    | {col_def}: col1: text notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name col1}
        | | {type_text}: text
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

CREATE TABLE in_the_past(
  col1 TEXT,
  FOREIGN KEY (col1) REFERENCES from_the_future (col1)
) @CREATE(4);

test/sem_test.sql:XXXX:1: error: in fk_def : CQL0324: referenced table was created in a later version so it cannot be used in a foreign key 'from_the_future'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 4}
  | | {name in_the_past}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: err
        | {fk_info}
          | {name_list}
          | | {name col1}: col1: text
          | {fk_target_options}
            | {fk_target}
            | | {name from_the_future}
            | | {name_list}
            |   | {name col1}
            | {int 0}

The statement ending at line XXXX

CREATE TABLE in_the_future(
  col1 TEXT,
  FOREIGN KEY (col1) REFERENCES from_the_future (col1)
) @CREATE(5);

  {create_table_stmt}: in_the_future: { col1: text foreign_key } @create(5)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 5}
  | | {name in_the_future}
  | {col_key_list}
    | {col_def}: col1: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name col1}
    |     | {type_text}: text
    | {col_key_list}
      | {fk_def}: ok
        | {fk_info}
          | {name_list}
          | | {name col1}: col1: text
          | {fk_target_options}
            | {fk_target}
            | | {name from_the_future}
            | | {name_list}
            |   | {name col1}: col1: text notnull
            | {int 0}

The statement ending at line XXXX

DECLARE PROC basic_source () OUT UNION (id INTEGER, name TEXT);

  {declare_proc_stmt}: basic_source: { id: integer, name: text } uses_out_union
  | {proc_name_type}
  | | {name basic_source}: basic_source: { id: integer, name: text } uses_out_union
  | | {int 9}
  | {proc_params_stmts}
    | {typed_names}: basic_source: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

CREATE PROC basic_wrapper_out ()
BEGIN
  DECLARE C CURSOR FOR CALL basic_source();
  FETCH C;
  OUT C;
END;

  {create_proc_stmt}: C: basic_wrapper_out: { id: integer, name: text } variable dml_proc shape_storage uses_out
  | {name basic_wrapper_out}: C: basic_wrapper_out: { id: integer, name: text } variable dml_proc shape_storage uses_out
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: basic_source: { id: integer, name: text } variable uses_out_union
      | | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | | {call_stmt}: basic_source: { id: integer, name: text } uses_out_union
      |   | {name basic_source}: basic_source: { id: integer, name: text } uses_out_union
      | {fetch_stmt}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | {out_stmt}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
        | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union

The statement ending at line XXXX

CREATE PROC basic_wrapper_out_union ()
BEGIN
  DECLARE C CURSOR FOR CALL basic_source();
  FETCH C;
  OUT UNION C;
END;

  {create_proc_stmt}: C: basic_wrapper_out_union: { id: integer, name: text } variable dml_proc shape_storage uses_out_union
  | {name basic_wrapper_out_union}: C: basic_wrapper_out_union: { id: integer, name: text } variable dml_proc shape_storage uses_out_union
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: basic_source: { id: integer, name: text } variable uses_out_union
      | | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | | {call_stmt}: basic_source: { id: integer, name: text } uses_out_union
      |   | {name basic_source}: basic_source: { id: integer, name: text } uses_out_union
      | {fetch_stmt}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
      | {out_union_stmt}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union
        | {name C}: C: basic_source: { id: integer, name: text } variable shape_storage uses_out_union

The statement ending at line XXXX

CREATE TABLE self_ref1(
  id INTEGER PRIMARY KEY,
  id2 INTEGER REFERENCES self_ref1 (id)
);

  {create_table_stmt}: self_ref1: { id: integer notnull primary_key, id2: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref1}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: integer foreign_key
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref1}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref2(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref2 (id)
);

  {create_table_stmt}: self_ref2: { id: integer notnull primary_key, id2: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: ok
          | {fk_info}
            | {name_list}
            | | {name id2}: id2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref2}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref3(
  id INTEGER PRIMARY KEY,
  id2 INTEGER REFERENCES self_ref3 (idx)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'idx'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref3}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_fk}: err
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref3}
              | | {name_list}: err
              |   | {name idx}: err
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref4(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref4 (idx)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0171: name not found 'idx'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref4}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}
          | {fk_info}
            | {name_list}
            | | {name id2}: id2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref4}
              | | {name_list}: err
              |   | {name idx}: err
              | {int 0}

The statement ending at line XXXX

CREATE TABLE self_ref5(
  id INTEGER PRIMARY KEY,
  id2 INTEGER,
  FOREIGN KEY (id2) REFERENCES self_ref5 (id2)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'self_ref5'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name self_ref5}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id2}
      |     | {type_int}: integer
      | {col_key_list}
        | {fk_def}: err
          | {fk_info}
            | {name_list}
            | | {name id2}: id2: integer
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref5}
              | | {name_list}
              |   | {name id2}: id2: integer
              | {int 0}

The statement ending at line XXXX

CREATE TABLE fk_to_non_key(
  id INTEGER REFERENCES self_ref2 (id2)
);

test/sem_test.sql:XXXX:1: error: in name_list : CQL0272: columns referenced in the foreign key statement should match exactly a unique key in the parent table 'self_ref2'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_to_non_key}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name self_ref2}
            | | {name_list}
            |   | {name id2}: id2: integer foreign_key
            | {int 0}

The statement ending at line XXXX

@ATTRIBUTE(cql:autotest=((dummy_test, (self_ref1, (id, id2), (1, NULL), (2, 1)))))
CREATE PROC self_ref_proc_table ()
BEGIN
  SELECT *
    FROM self_ref1;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name autotest}
  |   | {misc_attr_value_list}: ok
  |     | {misc_attr_value_list}: ok
  |       | {name dummy_test}: ok
  |       | {misc_attr_value_list}
  |         | {misc_attr_value_list}: ok
  |           | {name self_ref1}: ok
  |           | {misc_attr_value_list}
  |             | {misc_attr_value_list}: ok
  |             | | {name id}: ok
  |             | | {misc_attr_value_list}
  |             |   | {name id2}: ok
  |             | {misc_attr_value_list}
  |               | {misc_attr_value_list}: ok
  |               | | {int 1}: ok
  |               | | {misc_attr_value_list}
  |               |   | {null}: ok
  |               | {misc_attr_value_list}
  |                 | {misc_attr_value_list}: ok
  |                   | {int 2}: ok
  |                   | {misc_attr_value_list}
  |                     | {int 1}: ok
  | {create_proc_stmt}: self_ref_proc_table: { id: integer notnull, id2: integer } dml_proc
    | {name self_ref_proc_table}: self_ref_proc_table: { id: integer notnull, id2: integer } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, id2: integer }
          | {select_core_list}: select: { id: integer notnull, id2: integer }
          | | {select_core}: select: { id: integer notnull, id2: integer }
          |   | {select_expr_list_con}: select: { id: integer notnull, id2: integer }
          |     | {select_expr_list}: select: { id: integer notnull, id2: integer }
          |     | | {star}: select: { id: integer notnull, id2: integer }
          |     | {select_from_etc}: TABLE { self_ref1: self_ref1 }
          |       | {table_or_subquery_list}: TABLE { self_ref1: self_ref1 }
          |       | | {table_or_subquery}: TABLE { self_ref1: self_ref1 }
          |       |   | {name self_ref1}: TABLE { self_ref1: self_ref1 }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=foo)
CREATE PROC ok_table_scan ()
BEGIN
  SELECT *
    FROM foo;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {name foo}: ok
  | {create_proc_stmt}: ok_table_scan: { id: integer notnull } dml_proc
    | {name ok_table_scan}: ok_table_scan: { id: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull }
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {star}: select: { id: integer notnull }
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=(foo, 1))
CREATE PROC ok_table_scan_value ()
BEGIN
  SELECT *
    FROM foo;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0325: ok_table_scan attribute must be a name

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {misc_attr_value_list}: ok
  |     | {name foo}: ok
  |     | {misc_attr_value_list}
  |       | {int 1}: err
  | {create_proc_stmt}: err
    | {name ok_table_scan_value}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=bogus)
@ATTRIBUTE(cql:attr)
CREATE PROC ok_table_scan_bogus ()
BEGIN
  SELECT *
    FROM foo;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0326: the table name in ok_table_scan does not exist 'bogus'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name ok_table_scan}
  | | | {name bogus}: err
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |       | {name cql}
  |       | {name attr}
  | {create_proc_stmt}: err
    | {name ok_table_scan_bogus}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=1)
CREATE PROC ok_table_scan_value_int ()
BEGIN
  SELECT *
    FROM foo;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0325: ok_table_scan attribute must be a name

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {int 1}: err
  | {create_proc_stmt}: err
    | {name ok_table_scan_value_int}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name foo}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:ok_table_scan=foo)
SELECT *
  FROM foo;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0329: ok_table_scan attribute can only be used in a create procedure statement

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name ok_table_scan}
  |   | {name foo}: ok
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan)
SELECT *
  FROM foo;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0328: no_table_scan attribute may only be added to a create table statement

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name no_table_scan}
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan)
CREATE TABLE no_table_scan(
  id TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name no_table_scan}
  | {create_table_stmt}: no_table_scan: { id: text }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name no_table_scan}
    | {col_key_list}
      | {col_def}: id: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name id}
            | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:no_table_scan=1)
SELECT *
  FROM foo;

test/sem_test.sql:XXXX:1: error: in num : CQL0327: a value should not be assigned to no_table_scan attribute

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name no_table_scan}
  |   | {int 1}: err
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

VALUES(1);

  {select_stmt}: values: { column1: integer notnull }
  | {select_core_list}: values: { column1: integer notnull }
  | | {select_core}: values: { column1: integer notnull }
  |   | {select_values}
  |   | {values}: values: { column1: integer notnull }
  |     | {insert_list}: ok
  |       | {int 1}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (5);

  {select_stmt}: values: { column1: integer notnull }
  | {select_core_list}: values: { column1: integer notnull }
  | | {select_core}: values: { column1: integer notnull }
  |   | {select_values}
  |   | {values}: values: { column1: integer notnull }
  |     | {insert_list}: ok
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {int 5}: integer notnull
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (_sens);

  {select_stmt}: values: { column1: integer sensitive }
  | {select_core_list}: values: { column1: integer sensitive }
  | | {select_core}: values: { column1: integer sensitive }
  |   | {select_values}
  |   | {values}: values: { column1: integer sensitive }
  |     | {insert_list}: ok
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {name _sens}: _sens: integer variable sensitive was_set
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES(1), (3, 4.5);

test/sem_test.sql:XXXX:1: error: in num : CQL0337: the number of columns values for each row should be identical in VALUES clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}: ok
  |     | | {int 1}: integer notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {int 3}: integer notnull
  |         | {insert_list}
  |           | {dbl 4.5}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES("ok"), (1);

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'VALUES clause'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}: ok
  |     | | {strlit 'ok'}: text notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {int 1}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1)
UNION
VALUES(2) @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        | | | {select_values}
        | | | {values}
        | |   | {insert_list}
        | |     | {int 1}
        | | {select_core_compound}
        |   | {int 1}
        |   | {select_core_list}
        |     | {select_core}
        |       | {select_values}
        |       | {values}
        |         | {insert_list}
        |           | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) WITH
T (x) AS (VALUES(1), (2), (3))
SELECT *
  FROM T @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in with_select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {with_select_stmt}: err
        | {with}
        | | {cte_tables}
        |   | {cte_table}
        |     | {cte_decl}
        |     | | {name T}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}
        |       | {select_core_list}
        |       | | {select_core}
        |       |   | {select_values}
        |       |   | {values}
        |       |     | {insert_list}
        |       |     | | {int 1}
        |       |     | {values}
        |       |       | {insert_list}
        |       |       | | {int 2}
        |       |       | {values}
        |       |         | {insert_list}
        |       |           | {int 3}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name T}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) WITH
T (x) AS (VALUES(1), (2), (3))
SELECT *
  FROM T;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {with_select_stmt}: select: { x: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: T: { x: integer notnull }
        |     | {cte_decl}: T: { x: integer notnull }
        |     | | {name T}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: values: { column1: integer notnull }
        |       | {select_core_list}: values: { column1: integer notnull }
        |       | | {select_core}: values: { column1: integer notnull }
        |       |   | {select_values}
        |       |   | {values}: values: { column1: integer notnull }
        |       |     | {insert_list}: ok
        |       |     | | {int 1}: integer notnull
        |       |     | {values}
        |       |       | {insert_list}: ok
        |       |       | | {int 2}: integer notnull
        |       |       | {values}
        |       |         | {insert_list}: ok
        |       |           | {int 3}: integer notnull
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { x: integer notnull }
          | {select_core_list}: select: { x: integer notnull }
          | | {select_core}: select: { x: integer notnull }
          |   | {select_expr_list_con}: select: { x: integer notnull }
          |     | {select_expr_list}: select: { x: integer notnull }
          |     | | {star}: select: { x: integer notnull }
          |     | {select_from_etc}: TABLE { T: T }
          |       | {table_or_subquery_list}: TABLE { T: T }
          |       | | {table_or_subquery}: TABLE { T: T }
          |       |   | {name T}: TABLE { T: T }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT 1 @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1), (2) @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |     | | {int 1}
        |     | {values}
        |       | {insert_list}
        |         | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(bogus) @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {insert_stmt}: err
  | {insert_normal}
  | | {seed_stub}
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {name bogus}: err

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(NULL) @DUMMY_SEED(1);

  {insert_stmt}: ok
  | {insert_normal}
  | | {seed_stub}
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {null}: null

The statement ending at line XXXX

INSERT INTO foo(id) VALUES("k") @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'id'

  {insert_stmt}: err
  | {insert_normal}
  | | {seed_stub}
  |   | {int 1}: integer notnull
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {insert_list}
        | {strlit 'k'}: err

The statement ending at line XXXX

VALUES(l);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'l'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}: ok
  |       | {name l}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1)
UNION ALL
SELECT 2 AS column1;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: UNION ALL: { column1: integer notnull }
        | {select_core_list}: UNION ALL: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        | | | {select_values}
        | | | {values}: values: { column1: integer notnull }
        | |   | {insert_list}: ok
        | |     | {int 1}: integer notnull
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { column1: integer notnull }
        |     | {select_core}: select: { column1: integer notnull }
        |       | {select_expr_list_con}: select: { column1: integer notnull }
        |         | {select_expr_list}: select: { column1: integer notnull }
        |         | | {select_expr}: column1: integer notnull
        |         |   | {int 2}: integer notnull
        |         |   | {opt_as_alias}
        |         |     | {name column1}
        |         | {select_from_etc}: ok
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1), (2) @DUMMY_SEED(1);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0334: @dummy_seed @dummy_nullables @dummy_defaults many only be used with a single VALUES row

  {insert_stmt}: err
  | {insert_normal}
  | | {insert_dummy_spec}
  |   | {int 1}
  |   | {int 0}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: err
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}
        | | {select_core}
        |   | {select_values}
        |   | {values}
        |     | {insert_list}
        |     | | {int 1}
        |     | {values}
        |       | {insert_list}
        |         | {int 2}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

VALUES(1, 2), (10);

test/sem_test.sql:XXXX:1: error: in num : CQL0337: the number of columns values for each row should be identical in VALUES clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}: ok
  |     | | {int 1}: integer notnull
  |     | | {insert_list}
  |     |   | {int 2}: integer notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {int 10}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

VALUES("ok"), (bogus);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'bogus'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_values}
  |   | {values}: err
  |     | {insert_list}: ok
  |     | | {strlit 'ok'}: text notnull
  |     | {values}
  |       | {insert_list}: ok
  |         | {name bogus}: err
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE values_table(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT
);

  {create_table_stmt}: values_table: { id: integer notnull primary_key autoinc, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name values_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key autoinc
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    |       | {col_attrs_autoinc}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

INSERT INTO values_table(name, id) VALUES("ok", NULL);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name values_table}: values_table: { id: integer notnull primary_key autoinc, name: text }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name name}: name: text
      |   | {name_list}
      |     | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: text notnull, column2: null }
        | {select_core_list}: values: { column1: text notnull, column2: null }
        | | {select_core}: values: { column1: text notnull, column2: null }
        |   | {select_values}
        |   | {values}: values: { column1: text notnull, column2: null }
        |     | {insert_list}: ok
        |       | {strlit 'ok'}: text notnull
        |       | {insert_list}
        |         | {null}: null
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT WITHOUT ROWID;

  {enforce_strict_stmt}: ok
  | {int 7}

The statement ending at line XXXX

CREATE TABLE table_with_invalid_without_rowid_mode(
  id INTEGER PRIMARY KEY
) WITHOUT ROWID;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0339: WITHOUT ROWID tables are forbidden if strict without rowid mode is enabled 'table_with_invalid_without_rowid_mode'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name table_with_invalid_without_rowid_mode}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

@ENFORCE_NORMAL WITHOUT ROWID;

  {enforce_normal_stmt}: ok
  | {int 7}

The statement ending at line XXXX

CREATE TABLE table_with_valid_without_rowid_mode(
  id INTEGER PRIMARY KEY
) WITHOUT ROWID;

  {create_table_stmt}: table_with_valid_without_rowid_mode: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 4}
  | | {name table_with_valid_without_rowid_mode}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

CREATE PROC min_int_64_test ()
BEGIN
  SELECT -9223372036854775808L AS x;
END;

  {create_proc_stmt}: min_int_64_test: { x: longint notnull } dml_proc
  | {name min_int_64_test}: min_int_64_test: { x: longint notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { x: longint notnull }
        | {select_core_list}: select: { x: longint notnull }
        | | {select_core}: select: { x: longint notnull }
        |   | {select_expr_list_con}: select: { x: longint notnull }
        |     | {select_expr_list}: select: { x: longint notnull }
        |     | | {select_expr}: x: longint notnull
        |     |   | {uminus}: longint notnull
        |     |   | | {longint 9223372036854775808}: longint notnull
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC exotic_literals ()
BEGIN
  SELECT 2147483647 AS a, 2147483648L AS b, 3.4e11 AS c, .001e+5 AS d, .4e-9 AS e;
END;

  {create_proc_stmt}: exotic_literals: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull } dml_proc
  | {name exotic_literals}: exotic_literals: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        | {select_core_list}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        | | {select_core}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |   | {select_expr_list_con}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |     | {select_expr_list}: select: { a: integer notnull, b: longint notnull, c: real notnull, d: real notnull, e: real notnull }
        |     | | {select_expr}: a: integer notnull
        |     | | | {int 2147483647}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: longint notnull
        |     |   | | {longint 2147483648}: longint notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: real notnull
        |     |     | | {dbl 3.4e11}: real notnull
        |     |     | | {opt_as_alias}
        |     |     |   | {name c}
        |     |     | {select_expr_list}
        |     |       | {select_expr}: d: real notnull
        |     |       | | {dbl .001e+5}: real notnull
        |     |       | | {opt_as_alias}
        |     |       |   | {name d}
        |     |       | {select_expr_list}
        |     |         | {select_expr}: e: real notnull
        |     |           | {dbl .4e-9}: real notnull
        |     |           | {opt_as_alias}
        |     |             | {name e}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC hex_literals ()
BEGIN
  SELECT 0x13aF AS a, 0x234L AS b, 0x123456789L AS c;
END;

  {create_proc_stmt}: hex_literals: { a: integer notnull, b: longint notnull, c: longint notnull } dml_proc
  | {name hex_literals}: hex_literals: { a: integer notnull, b: longint notnull, c: longint notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        | {select_core_list}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        | | {select_core}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |   | {select_expr_list_con}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |     | {select_expr_list}: select: { a: integer notnull, b: longint notnull, c: longint notnull }
        |     | | {select_expr}: a: integer notnull
        |     | | | {int 0x13aF}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name a}
        |     | | {select_expr_list}
        |     |   | {select_expr}: b: longint notnull
        |     |   | | {longint 0x234}: longint notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name b}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: c: longint notnull
        |     |       | {longint 0x123456789}: longint notnull
        |     |       | {opt_as_alias}
        |     |         | {name c}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE PROC shape () (x INTEGER NOT NULL, y TEXT NOT NULL);

  {declare_proc_stmt}: shape: { x: integer notnull, y: text notnull } dml_proc
  | {proc_name_type}
  | | {name shape}: shape: { x: integer notnull, y: text notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: shape: { x: integer notnull, y: text notnull }
      | {typed_name}: x: integer notnull
      | | {name x}
      | | {notnull}: x: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: y: text notnull
          | {name y}
          | {notnull}: y: text notnull
            | {type_text}: text

The statement ending at line XXXX

DECLARE PROC small_shape () (y TEXT NOT NULL);

  {declare_proc_stmt}: small_shape: { y: text notnull } dml_proc
  | {proc_name_type}
  | | {name small_shape}: small_shape: { y: text notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: small_shape: { y: text notnull }
      | {typed_name}: y: text notnull
        | {name y}
        | {notnull}: y: text notnull
          | {type_text}: text

The statement ending at line XXXX

DECLARE PROC shape_consumer (x_ INTEGER NOT NULL, y_ TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name shape_consumer}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_: integer notnull variable in
      | | {param_detail}: x_: integer notnull variable in
      |   | {name x_}: x_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: y_: text notnull variable in
          | {param_detail}: y_: text notnull variable in
            | {name y_}: y_: text notnull variable in
            | {notnull}: text notnull
              | {type_text}: text

The statement ending at line XXXX

CREATE PROC shape_all_columns ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_consumer(C.x, C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_all_columns}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {shape_def}: shape: { x: integer notnull, y: text notnull } dml_proc
      |   | {like}: ok
      |     | {name shape}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: ok
        | {name shape_consumer}: ok
        | {expr_list}: ok
          | {dot}: C.x: integer notnull variable
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}: C.y: text notnull variable
              | {name C}
              | {name y}

The statement ending at line XXXX

CREATE PROC shape_thing_bogus_cursor ()
BEGIN
  CALL shape_consumer(FROM not_a_cursor);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name shape_thing_bogus_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name shape_consumer}
        | {expr_list}: err
          | {from_shape}
            | {name not_a_cursor}: err

The statement ending at line XXXX

CREATE PROC shape_some_columns_statement_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x, 'y' AS y;
  CALL shape_consumer(C.x, C.y);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0067: cursor was not used with 'fetch [cursor]' 'C'

  {create_proc_stmt}: err
  | {name shape_some_columns_statement_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name C}: C: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {call_stmt}: err
        | {name shape_consumer}: ok
        | {expr_list}: ok
          | {dot}: err
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}
              | {name C}
              | {name y}

The statement ending at line XXXX

DECLARE PROC shape_y_only (y_ TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name shape_y_only}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: y_: text notnull variable in
        | {param_detail}: y_: text notnull variable in
          | {name y_}: y_: text notnull variable in
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC shape_some_columns ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_y_only(C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_some_columns}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {shape_def}: shape: { x: integer notnull, y: text notnull } dml_proc
      |   | {like}: ok
      |     | {name shape}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: ok
        | {name shape_y_only}: ok
        | {expr_list}: ok
          | {dot}: C.y: text notnull variable
            | {name C}
            | {name y}

The statement ending at line XXXX

CREATE PROC shape_some_columns_bogus_name ()
BEGIN
  DECLARE C CURSOR LIKE shape;
  FETCH C(x, y) FROM VALUES(1, 'x');
  CALL shape_y_only(FROM C LIKE not_a_real_shape);
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_real_shape'

  {create_proc_stmt}: err
  | {name shape_some_columns_bogus_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | | {shape_def}: shape: { x: integer notnull, y: text notnull } dml_proc
      |   | {like}: ok
      |     | {name shape}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: text notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {strlit 'x'}: text notnull
      | {call_stmt}: err
        | {name shape_y_only}
        | {expr_list}: err
          | {from_shape}
            | {name C}: C: shape: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
            | {shape_def}: err
              | {like}: err
                | {name not_a_real_shape}: err

The statement ending at line XXXX

DECLARE PROC lotsa_ints (a INTEGER NOT NULL, b INTEGER NOT NULL, c INTEGER NOT NULL, d INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name lotsa_ints}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable in
      | | {param_detail}: a: integer notnull variable in
      |   | {name a}: a: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: b: integer notnull variable in
        | | {param_detail}: b: integer notnull variable in
        |   | {name b}: b: integer notnull variable in
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: c: integer notnull variable in
          | | {param_detail}: c: integer notnull variable in
          |   | {name c}: c: integer notnull variable in
          |   | {notnull}: integer notnull
          |     | {type_int}: integer
          | {params}
            | {param}: d: integer notnull variable in
              | {param_detail}: d: integer notnull variable in
                | {name d}: d: integer notnull variable in
                | {notnull}: integer notnull
                  | {type_int}: integer

The statement ending at line XXXX

CREATE PROC shape_args_middle ()
BEGIN
  DECLARE C CURSOR LIKE SELECT 1 AS x, 2 AS y;
  FETCH C(x, y) FROM VALUES(1, 2);
  CALL lotsa_ints(C.x, C.y, 1, 2);
  CALL lotsa_ints(1, C.x, C.y, 2);
  CALL lotsa_ints(1, 2, C.x, C.y);
  CALL lotsa_ints(C.x, C.y, C.x, C.y);
END;

  {create_proc_stmt}: ok
  | {name shape_args_middle}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: C: select: { x: integer notnull, y: integer notnull } variable shape_storage value_cursor
      | | {name C}: C: select: { x: integer notnull, y: integer notnull } variable shape_storage value_cursor
      | | {select_stmt}: select: { x: integer notnull, y: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: integer notnull }
      |   | | {select_core}: select: { x: integer notnull, y: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: integer notnull
      |   |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: select: { x: integer notnull, y: integer notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer notnull
      |     |   | {name_list}
      |     |     | {name y}: y: integer notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: C.x: integer notnull variable
      |   | | {name C}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: C.y: integer notnull variable
      |     | | {name C}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: C.x: integer notnull variable
      |     | | {name C}
      |     | | {name x}
      |     | {expr_list}
      |       | {dot}: C.y: integer notnull variable
      |       | | {name C}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: C.x: integer notnull variable
      |       | | {name C}
      |       | | {name x}
      |       | {expr_list}
      |         | {dot}: C.y: integer notnull variable
      |           | {name C}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: C.x: integer notnull variable
          | | {name C}
          | | {name x}
          | {expr_list}
            | {dot}: C.y: integer notnull variable
            | | {name C}
            | | {name y}
            | {expr_list}
              | {dot}: C.x: integer notnull variable
              | | {name C}
              | | {name x}
              | {expr_list}
                | {dot}: C.y: integer notnull variable
                  | {name C}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_rewrite_simple (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(x, y, 1, 2);
  CALL lotsa_ints(1, x, y, 2);
  CALL lotsa_ints(1, 2, x, y);
  CALL lotsa_ints(x, y, x, y);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_simple}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: integer notnull variable in
    |     | {param_detail}: y: integer notnull variable in
    |       | {name y}: y: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: x: integer notnull variable in
      |   | | {name ARGUMENTS}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: y: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: x: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name x}
      |     | {expr_list}
      |       | {dot}: y: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: x: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name x}
      |       | {expr_list}
      |         | {dot}: y: integer notnull variable in
      |           | {name ARGUMENTS}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: x: integer notnull variable in
          | | {name ARGUMENTS}
          | | {name x}
          | {expr_list}
            | {dot}: y: integer notnull variable in
            | | {name ARGUMENTS}
            | | {name y}
            | {expr_list}
              | {dot}: x: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name x}
              | {expr_list}
                | {dot}: y: integer notnull variable in
                  | {name ARGUMENTS}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_rewrite_no_args ()
BEGIN
  CALL lotsa_ints(FROM ARGUMENTS, 1, 2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0340: FROM ARGUMENTS used in a procedure with no arguments 'arg_rewrite_no_args'

  {create_proc_stmt}: err
  | {name arg_rewrite_no_args}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}
        | {expr_list}: err
          | {from_shape}
          | | {name ARGUMENTS}: err
          | {expr_list}
            | {int 1}
            | {expr_list}
              | {int 2}

The statement ending at line XXXX

CALL lotsa_ints(FROM ARGUMENTS, 1, 2);

test/sem_test.sql:XXXX:1: error: in str : CQL0163: FROM ARGUMENTS construct is only valid inside a procedure

  {call_stmt}: err
  | {name lotsa_ints}
  | {expr_list}: err
    | {from_shape}
    | | {name ARGUMENTS}: err
    | {expr_list}
      | {int 1}
      | {expr_list}
        | {int 2}

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like (x INTEGER NOT NULL, y INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(y, 1, 2, 3);
  CALL lotsa_ints(1, y, 2, 3);
  CALL lotsa_ints(1, 2, y, 3);
  CALL lotsa_ints(1, 2, 3, y);
  CALL lotsa_ints(y, y, y, y);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y: integer notnull variable in
    |     | {param_detail}: y: integer notnull variable in
    |       | {name y}: y: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: y: integer notnull variable in
      |   | | {name ARGUMENTS}
      |   | | {name y}
      |   | {expr_list}
      |     | {int 1}: integer notnull
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: y: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: y: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {int 3}: integer notnull
      |       | {expr_list}
      |         | {dot}: y: integer notnull variable in
      |           | {name ARGUMENTS}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: y: integer notnull variable in
          | | {name ARGUMENTS}
          | | {name y}
          | {expr_list}
            | {dot}: y: integer notnull variable in
            | | {name ARGUMENTS}
            | | {name y}
            | {expr_list}
              | {dot}: y: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name y}
              | {expr_list}
                | {dot}: y: integer notnull variable in
                  | {name ARGUMENTS}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like_with_underscore (x INTEGER NOT NULL, y_ INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(y_, 1, 2, 3);
  CALL lotsa_ints(1, y_, 2, 3);
  CALL lotsa_ints(1, 2, y_, 3);
  CALL lotsa_ints(1, 2, 3, y_);
  CALL lotsa_ints(y_, y_, y_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like_with_underscore}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer notnull variable in
    | | | {param_detail}: x: integer notnull variable in
    | |   | {name x}: x: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: integer notnull variable in
    |     | {param_detail}: y_: integer notnull variable in
    |       | {name y_}: y_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: y_: integer notnull variable in
      |   | | {name ARGUMENTS}
      |   | | {name y}
      |   | {expr_list}
      |     | {int 1}: integer notnull
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: y_: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 2}: integer notnull
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: y_: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 3}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {int 3}: integer notnull
      |       | {expr_list}
      |         | {dot}: y_: integer notnull variable in
      |           | {name ARGUMENTS}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: y_: integer notnull variable in
          | | {name ARGUMENTS}
          | | {name y}
          | {expr_list}
            | {dot}: y_: integer notnull variable in
            | | {name ARGUMENTS}
            | | {name y}
            | {expr_list}
              | {dot}: y_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name y}
              | {expr_list}
                | {dot}: y_: integer notnull variable in
                  | {name ARGUMENTS}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_rewrite_with_like_many_cols_with_underscore (x_ INTEGER NOT NULL, y_ INTEGER NOT NULL)
BEGIN
  CALL lotsa_ints(x_, y_, 1, 2);
  CALL lotsa_ints(1, x_, y_, 2);
  CALL lotsa_ints(1, 2, x_, y_);
  CALL lotsa_ints(x_, y_, x_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_rewrite_with_like_many_cols_with_underscore}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: integer notnull variable in
    |     | {param_detail}: y_: integer notnull variable in
    |       | {name y_}: y_: integer notnull variable in
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {dot}: x_: integer notnull variable in
      |   | | {name ARGUMENTS}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: y_: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name y}
      |     | {expr_list}
      |       | {int 1}: integer notnull
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {dot}: x_: integer notnull variable in
      |     | | {name ARGUMENTS}
      |     | | {name x}
      |     | {expr_list}
      |       | {dot}: y_: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name y}
      |       | {expr_list}
      |         | {int 2}: integer notnull
      | {call_stmt}: ok
      | | {name lotsa_ints}: ok
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      |   | {expr_list}
      |     | {int 2}: integer notnull
      |     | {expr_list}
      |       | {dot}: x_: integer notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name x}
      |       | {expr_list}
      |         | {dot}: y_: integer notnull variable in
      |           | {name ARGUMENTS}
      |           | {name y}
      | {call_stmt}: ok
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {dot}: x_: integer notnull variable in
          | | {name ARGUMENTS}
          | | {name x}
          | {expr_list}
            | {dot}: y_: integer notnull variable in
            | | {name ARGUMENTS}
            | | {name y}
            | {expr_list}
              | {dot}: x_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name x}
              | {expr_list}
                | {dot}: y_: integer notnull variable in
                  | {name ARGUMENTS}
                  | {name y}

The statement ending at line XXXX

CREATE PROC call_with_missing_type (x INTEGER)
BEGIN
  CALL lotsa_ints(1, 2, 3, ARGUMENTS.id);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0201: expanding FROM ARGUMENTS, there is no argument matching 'id'

  {create_proc_stmt}: err
  | {name call_with_missing_type}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}: ok
        | {expr_list}: ok
          | {int 1}: integer notnull
          | {expr_list}
            | {int 2}: integer notnull
            | {expr_list}
              | {int 3}: integer notnull
              | {expr_list}
                | {dot}: err
                  | {name ARGUMENTS}
                  | {name id}

The statement ending at line XXXX

CREATE PROC call_from_arguments_bogus_type (x INTEGER)
BEGIN
  CALL lotsa_ints(1, 2, 3, FROM ARGUMENTS LIKE no_such_type_dude);
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'no_such_type_dude'

  {create_proc_stmt}: err
  | {name call_from_arguments_bogus_type}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {call_stmt}: err
        | {name lotsa_ints}
        | {expr_list}: err
          | {int 1}
          | {expr_list}
            | {int 2}
            | {expr_list}
              | {int 3}
              | {expr_list}
                | {from_shape}
                  | {name ARGUMENTS}: ARGUMENTS: ARGUMENTS: { x: integer variable in } shape_storage
                  | {shape_def}: err
                    | {like}: err
                      | {name no_such_type_dude}: err

The statement ending at line XXXX

DECLARE PROC funclike (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name funclike}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x_: integer notnull variable in
      | | {param_detail}: x_: integer notnull variable in
      |   | {name x_}: x_: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: y_: text notnull variable in
        | | {param_detail}: y_: text notnull variable in
        |   | {name y_}: y_: text notnull variable in
        |   | {notnull}: text notnull
        |     | {type_text}: text
        | {params}
          | {param}: z: integer notnull variable out
            | {out}
            | {param_detail}: z: integer notnull variable out
              | {name z}: z: integer notnull variable out
              | {notnull}: integer notnull
                | {type_int}: integer

The statement ending at line XXXX

CREATE PROC arg_caller (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL)
BEGIN
  SET z := funclike(x_, y_);
END;

  {create_proc_stmt}: ok
  | {name arg_caller}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: text notnull variable in
    |   | | {param_detail}: y_: text notnull variable in
    |   |   | {name y_}: y_: text notnull variable in
    |   |   | {notnull}: text notnull
    |   |     | {type_text}: text
    |   | {params}
    |     | {param}: z: integer notnull variable out was_set
    |       | {out}
    |       | {param_detail}: z: integer notnull variable out was_set
    |         | {name z}: z: integer notnull variable out was_set
    |         | {notnull}: integer notnull
    |           | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: z: integer notnull variable out was_set
        | {name z}: z: integer notnull variable out was_set
        | {call}: integer notnull
          | {name funclike}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {dot}: x_: integer notnull variable in
              | | {name ARGUMENTS}
              | | {name x}
              | {arg_list}
                | {dot}: y_: text notnull variable in
                  | {name ARGUMENTS}
                  | {name y}

The statement ending at line XXXX

CREATE PROC arg_caller_bogus_shape (x_ INTEGER NOT NULL, y_ TEXT NOT NULL, OUT z INTEGER NOT NULL)
BEGIN
  SET z := funclike(FROM ARGUMENTS LIKE not_a_shape);
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_shape'

  {create_proc_stmt}: err
  | {name arg_caller_bogus_shape}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer notnull variable in
    | | | {param_detail}: x_: integer notnull variable in
    | |   | {name x_}: x_: integer notnull variable in
    | |   | {notnull}: integer notnull
    | |     | {type_int}: integer
    | | {params}
    |   | {param}: y_: text notnull variable in
    |   | | {param_detail}: y_: text notnull variable in
    |   |   | {name y_}: y_: text notnull variable in
    |   |   | {notnull}: text notnull
    |   |     | {type_text}: text
    |   | {params}
    |     | {param}: z: integer notnull variable out
    |       | {out}
    |       | {param_detail}: z: integer notnull variable out
    |         | {name z}: z: integer notnull variable out
    |         | {notnull}: integer notnull
    |           | {type_int}: integer
    | {stmt_list}: err
      | {assign}: err
        | {name z}: z: integer notnull variable out
        | {call}: err
          | {name funclike}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: err
              | {from_shape}
                | {name ARGUMENTS}: ARGUMENTS: ARGUMENTS: { x: integer notnull variable in, y: text notnull variable in, z: integer notnull variable out } shape_storage
                | {shape_def}: err
                  | {like}: err
                    | {name not_a_shape}: err

The statement ending at line XXXX

SET a_string := @PROC;

test/sem_test.sql:XXXX:1: error: in str : CQL0252: @PROC literal can only appear inside of procedures

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {name @PROC}: err

The statement ending at line XXXX

SAVEPOINT @PROC;

test/sem_test.sql:XXXX:1: error: in str : CQL0252: @PROC literal can only appear inside of procedures

  {savepoint_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

RELEASE @PROC;

test/sem_test.sql:XXXX:1: error: in str : CQL0252: @PROC literal can only appear inside of procedures

  {release_savepoint_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

ROLLBACK TO @PROC;

test/sem_test.sql:XXXX:1: error: in str : CQL0252: @PROC literal can only appear inside of procedures

  {rollback_trans_stmt}: err
  | {name @PROC}: err

The statement ending at line XXXX

CREATE PROC savepoint_proc_stuff ()
BEGIN
  DECLARE p TEXT;
  SET p := 'savepoint_proc_stuff';
  SAVEPOINT savepoint_proc_stuff;
  ROLLBACK TO savepoint_proc_stuff;
  RELEASE savepoint_proc_stuff;
END;

  {create_proc_stmt}: ok dml_proc
  | {name savepoint_proc_stuff}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text
      | | {name_list}: p: text variable was_set
      | | | {name p}: p: text variable was_set
      | | {type_text}: text
      | {assign}: p: text variable was_set
      | | {name p}: p: text variable was_set
      | | {strlit 'savepoint_proc_stuff'}: text notnull
      | {savepoint_stmt}: ok
      | | {name savepoint_proc_stuff}: ok
      | {rollback_trans_stmt}: ok
      | | {name savepoint_proc_stuff}: ok
      | {release_savepoint_stmt}: ok
        | {name savepoint_proc_stuff}: ok

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(1, "bogus");

test/sem_test.sql:XXXX:1: error: in num : CQL0341: argument must be a variable in function 'cql_cursor_diff_col'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name cql_cursor_diff_col}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: err
        | {arg_list}
          | {strlit 'bogus'}: text notnull

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(an_int, an_int2);

test/sem_test.sql:XXXX:1: error: in str : CQL0205: not a cursor 'an_int'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name cql_cursor_diff_col}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: err
        | {arg_list}
          | {name an_int2}: an_int2: integer variable was_set

The statement ending at line XXXX

SET a_string := cql_cursor_diff_col(an_int, an_int2, 1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_cursor_diff_col'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name cql_cursor_diff_col}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: an_int: integer variable was_set
        | {arg_list}
          | {name an_int2}: an_int2: integer variable was_set
          | {arg_list}
            | {int 1}: integer notnull

The statement ending at line XXXX

SET a_string := cql_cursor_diff_val(an_int, an_int2, 1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_cursor_diff_val'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name cql_cursor_diff_val}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name an_int}: an_int: integer variable was_set
        | {arg_list}
          | {name an_int2}: an_int2: integer variable was_set
          | {arg_list}
            | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_without_cursor_arg ()
BEGIN
  DECLARE x INTEGER NOT NULL;
  DECLARE y TEXT NOT NULL;
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  FETCH c1 INTO x, y;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0067: cursor was not used with 'fetch [cursor]' 'c1'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_without_cursor_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer notnull
      | | {name_list}: x: integer notnull variable was_set
      | | | {name x}: x: integer notnull variable was_set
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_vars_type}: text notnull
      | | {name_list}: y: text notnull variable init_required was_set
      | | | {name y}: y: text notnull variable init_required was_set
      | | {notnull}: text notnull
      |   | {type_text}: text
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc fetch_into
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc fetch_into
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name_list}
      |   | {name x}: x: integer notnull variable was_set
      |   | {name_list}
      |     | {name y}: y: text notnull variable init_required was_set
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {assign}: err
        | {name a_string}: a_string: text variable was_set
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: err
              | {arg_list}
                | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC cql_cursor_unfetched ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS x;
  IF C THEN
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0067: cursor was not used with 'fetch [cursor]' 'C'

  {create_proc_stmt}: err
  | {name cql_cursor_unfetched}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { x: integer notnull } variable dml_proc
      | | {name C}: C: select: { x: integer notnull } variable dml_proc
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {if_stmt}: err
        | {cond_action}: err
        | | {name C}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_wrong_cursor_type ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x;
  DECLARE c2 CURSOR FOR SELECT '1' AS x;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0061: in cql_cursor_diff_col, all columns must be an exact type match (expected integer notnull; found text notnull) 'x'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_wrong_cursor_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: text notnull } variable dml_proc
      | | {name c2}: c2: select: { x: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: text notnull }
      |   | {select_core_list}: select: { x: text notnull }
      |   | | {select_core}: select: { x: text notnull }
      |   |   | {select_expr_list_con}: select: { x: text notnull }
      |   |     | {select_expr_list}: select: { x: text notnull }
      |   |     | | {select_expr}: x: text notnull
      |   |     |   | {strlit '1'}: text notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { x: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: text notnull } variable dml_proc shape_storage
      | {assign}: err
        | {name a_string}: a_string: text variable was_set
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: c1: select: { x: integer notnull } variable dml_proc shape_storage
              | {arg_list}
                | {name c2}: err

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_with_wrong_col_count_arg ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'z' AS z;
  DECLARE c2 CURSOR FOR SELECT 1 AS x;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0342: cursor arguments must have identical column count 'cql_cursor_diff_col'

  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_with_wrong_col_count_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull, z: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, z: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, z: text notnull }
      |   | | {select_core}: select: { x: integer notnull, z: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, z: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, z: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: z: text notnull
      |   |     |     | {strlit 'z'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name z}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull } variable dml_proc
      | | {name c2}: c2: select: { x: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull }
      |   | {select_core_list}: select: { x: integer notnull }
      |   | | {select_core}: select: { x: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name x}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, z: text notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { x: integer notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: integer notnull } variable dml_proc shape_storage
      | {assign}: err
        | {name a_string}: a_string: text variable was_set
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: c1: select: { x: integer notnull, z: text notnull } variable dml_proc shape_storage
              | {arg_list}
                | {name c2}: c2: select: { x: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_compatible_cursor_with_diff_col_name ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS z, 'v' AS v;
  FETCH c1;
  FETCH c2;
  SET a_string := cql_cursor_diff_col(c1, c2);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0058: in cql_cursor_diff_col, all column names must be identical so they have unambiguous names; error in column 1: 'x' vs. 'z'
test/sem_test.sql:XXXX:1: error: in str : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 2 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 2 columns

only in 1st: x integer notnull
only in 1st: y text notnull
only in 2nd: z integer notnull
only in 2nd: v text notnull


  {create_proc_stmt}: err
  | {name cql_cursor_diff_col_compatible_cursor_with_diff_col_name}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { z: integer notnull, v: text notnull } variable dml_proc
      | | {name c2}: c2: select: { z: integer notnull, v: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { z: integer notnull, v: text notnull }
      |   | {select_core_list}: select: { z: integer notnull, v: text notnull }
      |   | | {select_core}: select: { z: integer notnull, v: text notnull }
      |   |   | {select_expr_list_con}: select: { z: integer notnull, v: text notnull }
      |   |     | {select_expr_list}: select: { z: integer notnull, v: text notnull }
      |   |     | | {select_expr}: z: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name z}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: v: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name v}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { z: integer notnull, v: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { z: integer notnull, v: text notnull } variable dml_proc shape_storage
      | {assign}: err
        | {name a_string}: a_string: text variable was_set
        | {call}: err
          | {name cql_cursor_diff_col}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
              | {arg_list}
                | {name c2}: err

The statement ending at line XXXX

CREATE PROC cql_cursor_diff_col_with_shape_storage ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  FETCH c1;
  FETCH c2;
  SET a_string := CASE WHEN c1.x IS NOT c2.x THEN 'x'
  WHEN c1.y IS NOT c2.y THEN 'y'
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name cql_cursor_diff_col_with_shape_storage}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {assign}: a_string: text variable was_set
        | {name a_string}: a_string: text variable was_set
        | {case_expr}: text
          | {connector}: text
            | {case_list}: text notnull
              | {when}: text notnull
              | | {is_not}: bool notnull
              | | | {dot}: c1.x: integer notnull variable
              | | | | {name c1}
              | | | | {name x}
              | | | {dot}: c2.x: integer notnull variable
              | |   | {name c2}
              | |   | {name x}
              | | {strlit 'x'}: text notnull
              | {case_list}: text notnull
                | {when}: text notnull
                  | {is_not}: bool notnull
                  | | {dot}: c1.y: text notnull variable
                  | | | {name c1}
                  | | | {name y}
                  | | {dot}: c2.y: text notnull variable
                  |   | {name c2}
                  |   | {name y}
                  | {strlit 'y'}: text notnull

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_diff_col ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT 1 AS x, 'v' AS y;
  FETCH c1;
  FETCH c2;
  CALL printf(CASE WHEN c1.x IS NOT c2.x THEN 'x'
  WHEN c1.y IS NOT c2.y THEN 'y'
  END);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_diff_col}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer notnull, y: text notnull }
      |   | {select_core_list}: select: { x: integer notnull, y: text notnull }
      |   | | {select_core}: select: { x: integer notnull, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
      |   |     | | {select_expr}: x: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: integer notnull, y: text notnull } variable dml_proc shape_storage
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {case_expr}: text
            | {connector}: text
              | {case_list}: text notnull
                | {when}: text notnull
                | | {is_not}: bool notnull
                | | | {dot}: c1.x: integer notnull variable
                | | | | {name c1}
                | | | | {name x}
                | | | {dot}: c2.x: integer notnull variable
                | |   | {name c2}
                | |   | {name x}
                | | {strlit 'x'}: text notnull
                | {case_list}: text notnull
                  | {when}: text notnull
                    | {is_not}: bool notnull
                    | | {dot}: c1.y: text notnull variable
                    | | | {name c1}
                    | | | {name y}
                    | | {dot}: c2.y: text notnull variable
                    |   | {name c2}
                    |   | {name y}
                    | {strlit 'y'}: text notnull

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_diff_val ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT nullable(1) AS x, 'y' AS y;
  DECLARE c2 CURSOR FOR SELECT nullable(1) AS x, 'v' AS y;
  FETCH c1;
  FETCH c2;
  CALL printf(CASE WHEN c1.x IS NOT c2.x THEN printf('column:%s c1:%s c2:%s', 'x', CASE WHEN c1.x IS NULL THEN 'null'
  ELSE printf('%d', c1.x)
  END, CASE WHEN c2.x IS NULL THEN 'null'
  ELSE printf('%d', c2.x)
  END)
  WHEN c1.y IS NOT c2.y THEN printf('column:%s c1:%s c2:%s', 'y', CASE WHEN nullable(c1.y) IS NULL THEN 'null'
  ELSE printf('%s', c1.y)
  END, CASE WHEN nullable(c2.y) IS NULL THEN 'null'
  ELSE printf('%s', c2.y)
  END)
  END);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_diff_val}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { x: integer, y: text notnull } variable dml_proc
      | | {name c1}: c1: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer, y: text notnull }
      |   | {select_core_list}: select: { x: integer, y: text notnull }
      |   | | {select_core}: select: { x: integer, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer, y: text notnull }
      |   |     | | {select_expr}: x: integer
      |   |     | | | {call}: integer
      |   |     | | | | {name nullable}: integer
      |   |     | | | | {call_arg_list}
      |   |     | | |   | {call_filter_clause}
      |   |     | | |   | {arg_list}: ok
      |   |     | | |     | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'y'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c2: select: { x: integer, y: text notnull } variable dml_proc
      | | {name c2}: c2: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer, y: text notnull }
      |   | {select_core_list}: select: { x: integer, y: text notnull }
      |   | | {select_core}: select: { x: integer, y: text notnull }
      |   |   | {select_expr_list_con}: select: { x: integer, y: text notnull }
      |   |     | {select_expr_list}: select: { x: integer, y: text notnull }
      |   |     | | {select_expr}: x: integer
      |   |     | | | {call}: integer
      |   |     | | | | {name nullable}: integer
      |   |     | | | | {call_arg_list}
      |   |     | | |   | {call_filter_clause}
      |   |     | | |   | {arg_list}: ok
      |   |     | | |     | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name x}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: y: text notnull
      |   |     |     | {strlit 'v'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name y}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | {fetch_stmt}: c2: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | | {name c2}: c2: select: { x: integer, y: text notnull } variable dml_proc shape_storage
      | {call_stmt}: ok
        | {name printf}: ok
        | {expr_list}: ok
          | {case_expr}: text
            | {connector}: text
              | {case_list}: text notnull
                | {when}: text notnull
                | | {is_not}: bool notnull
                | | | {dot}: c1.x: integer variable
                | | | | {name c1}
                | | | | {name x}
                | | | {dot}: c2.x: integer variable
                | |   | {name c2}
                | |   | {name x}
                | | {call}: text notnull
                |   | {name printf}: text notnull
                |   | {call_arg_list}
                |     | {call_filter_clause}
                |     | {arg_list}: ok
                |       | {strlit 'column:%s c1:%s c2:%s'}: text notnull
                |       | {arg_list}
                |         | {strlit 'x'}: text notnull
                |         | {arg_list}
                |           | {case_expr}: text notnull
                |           | | {connector}: text notnull
                |           |   | {case_list}: text notnull
                |           |   | | {when}: text notnull
                |           |   |   | {is}: bool notnull
                |           |   |   | | {dot}: c1.x: integer variable
                |           |   |   | | | {name c1}
                |           |   |   | | | {name x}
                |           |   |   | | {null}: null
                |           |   |   | {strlit 'null'}: text notnull
                |           |   | {call}: text notnull
                |           |     | {name printf}: text notnull
                |           |     | {call_arg_list}
                |           |       | {call_filter_clause}
                |           |       | {arg_list}: ok
                |           |         | {strlit '%d'}: text notnull
                |           |         | {arg_list}
                |           |           | {call}: c1.x: integer notnull variable
                |           |             | {name cql_inferred_notnull}: c1.x: integer notnull variable
                |           |             | {call_arg_list}
                |           |               | {call_filter_clause}
                |           |               | {arg_list}: ok
                |           |                 | {dot}: c1.x: integer inferred_notnull variable
                |           |                   | {name c1}
                |           |                   | {name x}
                |           | {arg_list}
                |             | {case_expr}: text notnull
                |               | {connector}: text notnull
                |                 | {case_list}: text notnull
                |                 | | {when}: text notnull
                |                 |   | {is}: bool notnull
                |                 |   | | {dot}: c2.x: integer variable
                |                 |   | | | {name c2}
                |                 |   | | | {name x}
                |                 |   | | {null}: null
                |                 |   | {strlit 'null'}: text notnull
                |                 | {call}: text notnull
                |                   | {name printf}: text notnull
                |                   | {call_arg_list}
                |                     | {call_filter_clause}
                |                     | {arg_list}: ok
                |                       | {strlit '%d'}: text notnull
                |                       | {arg_list}
                |                         | {call}: c2.x: integer notnull variable
                |                           | {name cql_inferred_notnull}: c2.x: integer notnull variable
                |                           | {call_arg_list}
                |                             | {call_filter_clause}
                |                             | {arg_list}: ok
                |                               | {dot}: c2.x: integer inferred_notnull variable
                |                                 | {name c2}
                |                                 | {name x}
                | {case_list}: text notnull
                  | {when}: text notnull
                    | {is_not}: bool notnull
                    | | {dot}: c1.y: text notnull variable
                    | | | {name c1}
                    | | | {name y}
                    | | {dot}: c2.y: text notnull variable
                    |   | {name c2}
                    |   | {name y}
                    | {call}: text notnull
                      | {name printf}: text notnull
                      | {call_arg_list}
                        | {call_filter_clause}
                        | {arg_list}: ok
                          | {strlit 'column:%s c1:%s c2:%s'}: text notnull
                          | {arg_list}
                            | {strlit 'y'}: text notnull
                            | {arg_list}
                              | {case_expr}: text notnull
                              | | {connector}: text notnull
                              |   | {case_list}: text notnull
                              |   | | {when}: text notnull
                              |   |   | {is}: bool notnull
                              |   |   | | {call}: c1.y: text variable
                              |   |   | | | {name nullable}: c1.y: text variable
                              |   |   | | | {call_arg_list}
                              |   |   | |   | {call_filter_clause}
                              |   |   | |   | {arg_list}: ok
                              |   |   | |     | {dot}: c1.y: text notnull variable
                              |   |   | |       | {name c1}
                              |   |   | |       | {name y}
                              |   |   | | {null}: null
                              |   |   | {strlit 'null'}: text notnull
                              |   | {call}: text notnull
                              |     | {name printf}: text notnull
                              |     | {call_arg_list}
                              |       | {call_filter_clause}
                              |       | {arg_list}: ok
                              |         | {strlit '%s'}: text notnull
                              |         | {arg_list}
                              |           | {dot}: c1.y: text notnull variable
                              |             | {name c1}
                              |             | {name y}
                              | {arg_list}
                                | {case_expr}: text notnull
                                  | {connector}: text notnull
                                    | {case_list}: text notnull
                                    | | {when}: text notnull
                                    |   | {is}: bool notnull
                                    |   | | {call}: c2.y: text variable
                                    |   | | | {name nullable}: c2.y: text variable
                                    |   | | | {call_arg_list}
                                    |   | |   | {call_filter_clause}
                                    |   | |   | {arg_list}: ok
                                    |   | |     | {dot}: c2.y: text notnull variable
                                    |   | |       | {name c2}
                                    |   | |       | {name y}
                                    |   | | {null}: null
                                    |   | {strlit 'null'}: text notnull
                                    | {call}: text notnull
                                      | {name printf}: text notnull
                                      | {call_arg_list}
                                        | {call_filter_clause}
                                        | {arg_list}: ok
                                          | {strlit '%s'}: text notnull
                                          | {arg_list}
                                            | {dot}: c2.y: text notnull variable
                                              | {name c2}
                                              | {name y}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x", "y") );

  {assign}: a_string: text variable was_set
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name trim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x") );

  {assign}: a_string: text variable was_set
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name trim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE kind_string TEXT<surname>;

  {declare_vars_type}: text<surname>
  | {name_list}: kind_string: text<surname> variable was_set
  | | {name kind_string}: kind_string: text<surname> variable was_set
  | {type_text}: text<surname>
    | {name surname}

The statement ending at line XXXX

SET kind_string := ( SELECT substr(kind_string, 2, 3) );

  {assign}: kind_string: text<surname> variable was_set
  | {name kind_string}: kind_string: text<surname> variable was_set
  | {select_stmt}: _anon: text<surname>
    | {select_core_list}: select: { _anon: text<surname> }
    | | {select_core}: select: { _anon: text<surname> }
    |   | {select_expr_list_con}: select: { _anon: text<surname> }
    |     | {select_expr_list}: select: { _anon: text<surname> }
    |     | | {select_expr}: text<surname>
    |     |   | {call}: text<surname>
    |     |     | {name substr}: text<surname>
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name kind_string}: kind_string: text<surname> variable
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET kind_string := ( SELECT replace(kind_string, 'b', 'c') );

  {assign}: kind_string: text<surname> variable was_set
  | {name kind_string}: kind_string: text<surname> variable was_set
  | {select_stmt}: _anon: text<surname>
    | {select_core_list}: select: { _anon: text<surname> }
    | | {select_core}: select: { _anon: text<surname> }
    |   | {select_expr_list_con}: select: { _anon: text<surname> }
    |     | {select_expr_list}: select: { _anon: text<surname> }
    |     | | {select_expr}: text<surname>
    |     |   | {call}: text<surname>
    |     |     | {name replace}: text<surname>
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name kind_string}: kind_string: text<surname> variable was_set
    |     |         | {arg_list}
    |     |           | {strlit 'b'}: text notnull
    |     |           | {arg_list}
    |     |             | {strlit 'c'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET kind_string := ( SELECT trim(kind_string) );

  {assign}: kind_string: text<surname> variable was_set
  | {name kind_string}: kind_string: text<surname> variable was_set
  | {select_stmt}: _anon: text<surname>
    | {select_core_list}: select: { _anon: text<surname> }
    | | {select_core}: select: { _anon: text<surname> }
    |   | {select_expr_list_con}: select: { _anon: text<surname> }
    |     | {select_expr_list}: select: { _anon: text<surname> }
    |     | | {select_expr}: text<surname>
    |     |   | {call}: text<surname>
    |     |     | {name trim}: text<surname>
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name kind_string}: kind_string: text<surname> variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET kind_string := ( SELECT upper(kind_string) );

  {assign}: kind_string: text<surname> variable was_set
  | {name kind_string}: kind_string: text<surname> variable was_set
  | {select_stmt}: _anon: text<surname> variable was_set
    | {select_core_list}: select: { _anon: text<surname> variable was_set }
    | | {select_core}: select: { _anon: text<surname> variable was_set }
    |   | {select_expr_list_con}: select: { _anon: text<surname> variable was_set }
    |     | {select_expr_list}: select: { _anon: text<surname> variable was_set }
    |     | | {select_expr}: text<surname> variable was_set
    |     |   | {call}: text<surname> variable was_set
    |     |     | {name upper}: text<surname> variable was_set
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name kind_string}: kind_string: text<surname> variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET kind_string := ( SELECT lower(kind_string) );

  {assign}: kind_string: text<surname> variable was_set
  | {name kind_string}: kind_string: text<surname> variable was_set
  | {select_stmt}: _anon: text<surname> variable was_set
    | {select_core_list}: select: { _anon: text<surname> variable was_set }
    | | {select_core}: select: { _anon: text<surname> variable was_set }
    |   | {select_expr_list_con}: select: { _anon: text<surname> variable was_set }
    |     | {select_expr_list}: select: { _anon: text<surname> variable was_set }
    |     | | {select_expr}: text<surname> variable was_set
    |     |   | {call}: text<surname> variable was_set
    |     |     | {name lower}: text<surname> variable was_set
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name kind_string}: kind_string: text<surname> variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT ltrim("x", "y") );

  {assign}: a_string: text variable was_set
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name ltrim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT rtrim("x", "y") );

  {assign}: a_string: text variable was_set
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: _anon: text notnull
    | {select_core_list}: select: { _anon: text notnull }
    | | {select_core}: select: { _anon: text notnull }
    |   | {select_expr_list_con}: select: { _anon: text notnull }
    |     | {select_expr_list}: select: { _anon: text notnull }
    |     | | {select_expr}: text notnull
    |     |   | {call}: text notnull
    |     |     | {name rtrim}: text notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {strlit 'y'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim() );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim(1, 2, 3) );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim(1, "x") );

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := ( SELECT trim("x", 1) );

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name trim}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     |         | {arg_list}
    |     |           | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET a_string := trim("x", 1);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'trim'

  {assign}: err
  | {name a_string}: a_string: text variable was_set
  | {call}: err
    | {name trim}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

SET sens_text := ( SELECT trim(name)
  FROM with_sensitive );

  {assign}: sens_text: text variable sensitive was_set
  | {name sens_text}: sens_text: text variable sensitive was_set
  | {select_stmt}: _anon: text sensitive
    | {select_core_list}: select: { _anon: text sensitive }
    | | {select_core}: select: { _anon: text sensitive }
    |   | {select_expr_list_con}: select: { _anon: text sensitive }
    |     | {select_expr_list}: select: { _anon: text sensitive }
    |     | | {select_expr}: text sensitive
    |     |   | {call}: text sensitive
    |     |     | {name trim}: text sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name name}: name: text sensitive
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET sens_text := ( SELECT trim("xyz", name) AS result
  FROM with_sensitive );

  {assign}: sens_text: text variable sensitive was_set
  | {name sens_text}: sens_text: text variable sensitive was_set
  | {select_stmt}: result: text notnull sensitive
    | {select_core_list}: select: { result: text notnull sensitive }
    | | {select_core}: select: { result: text notnull sensitive }
    |   | {select_expr_list_con}: select: { result: text notnull sensitive }
    |     | {select_expr_list}: select: { result: text notnull sensitive }
    |     | | {select_expr}: result: text notnull sensitive
    |     |   | {call}: text notnull sensitive
    |     |   | | {name trim}: text notnull sensitive
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {strlit 'xyz'}: text notnull
    |     |   |     | {arg_list}
    |     |   |       | {name name}: name: text sensitive
    |     |   | {opt_as_alias}
    |     |     | {name result}
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC print_call_cql_cursor_format ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT TRUE AS a, 1 AS b, 99L AS c, 'x' AS d, nullable(1.1) AS e, CAST('y' AS BLOB) AS f;
  FETCH c1;
  SET a_string := cql_cursor_format(c1);
END;

  {create_proc_stmt}: ok dml_proc
  | {name print_call_cql_cursor_format}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull } variable dml_proc
      | | {name c1}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull } variable dml_proc shape_storage serialize
      | | {select_stmt}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull }
      |   | {select_core_list}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull }
      |   | | {select_core}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull }
      |   |   | {select_expr_list_con}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull }
      |   |     | {select_expr_list}: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull }
      |   |     | | {select_expr}: a: bool notnull
      |   |     | | | {bool 1}: bool notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name a}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: b: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name b}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: c: longint notnull
      |   |     |     | | {longint 99}: longint notnull
      |   |     |     | | {opt_as_alias}
      |   |     |     |   | {name c}
      |   |     |     | {select_expr_list}
      |   |     |       | {select_expr}: d: text notnull
      |   |     |       | | {strlit 'x'}: text notnull
      |   |     |       | | {opt_as_alias}
      |   |     |       |   | {name d}
      |   |     |       | {select_expr_list}
      |   |     |         | {select_expr}: e: real
      |   |     |         | | {call}: real
      |   |     |         | | | {name nullable}: real
      |   |     |         | | | {call_arg_list}
      |   |     |         | |   | {call_filter_clause}
      |   |     |         | |   | {arg_list}: ok
      |   |     |         | |     | {dbl 1.1}: real notnull
      |   |     |         | | {opt_as_alias}
      |   |     |         |   | {name e}
      |   |     |         | {select_expr_list}
      |   |     |           | {select_expr}: f: blob notnull
      |   |     |             | {cast_expr}: blob notnull
      |   |     |             | | {strlit 'y'}: text notnull
      |   |     |             | | {type_blob}: blob
      |   |     |             | {opt_as_alias}
      |   |     |               | {name f}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull } variable dml_proc shape_storage
      | {assign}: a_string: text variable was_set
        | {name a_string}: a_string: text variable was_set
        | {call}: text notnull create_func
          | {name cql_cursor_format}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c1}: c1: select: { a: bool notnull, b: integer notnull, c: longint notnull, d: text notnull, e: real, f: blob notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC select_cql_cursor_format ()
BEGIN
  DECLARE c1 CURSOR FOR SELECT 1 AS a;
  FETCH c1;
  SELECT cql_cursor_format(c1) AS p;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0088: user function may not appear in the context of a SQL statement 'cql_cursor_format'

  {create_proc_stmt}: err
  | {name select_cql_cursor_format}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c1: select: { a: integer notnull } variable dml_proc
      | | {name c1}: c1: select: { a: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: integer notnull }
      |   | {select_core_list}: select: { a: integer notnull }
      |   | | {select_core}: select: { a: integer notnull }
      |   |   | {select_expr_list_con}: select: { a: integer notnull }
      |   |     | {select_expr_list}: select: { a: integer notnull }
      |   |     | | {select_expr}: a: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name a}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c1: select: { a: integer notnull } variable dml_proc shape_storage
      | | {name c1}: c1: select: { a: integer notnull } variable dml_proc shape_storage
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name cql_cursor_format}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {name c1}
        |     |   | {opt_as_alias}
        |     |     | {name p}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC print_call_cql_not_fetch_cursor_format ()
BEGIN
  DECLARE c CURSOR FOR SELECT 1;
  DECLARE x INTEGER NOT NULL;
  FETCH C INTO x;
  SET a_string := cql_cursor_format(c);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0067: cursor was not used with 'fetch [cursor]' 'c'

  {create_proc_stmt}: err
  | {name print_call_cql_not_fetch_cursor_format}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { _anon: integer notnull } variable dml_proc
      | | {name c}: c: select: { _anon: integer notnull } variable dml_proc fetch_into
      | | {select_stmt}: select: { _anon: integer notnull }
      |   | {select_core_list}: select: { _anon: integer notnull }
      |   | | {select_core}: select: { _anon: integer notnull }
      |   |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |   |     | {select_expr_list}: select: { _anon: integer notnull }
      |   |     | | {select_expr}: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_vars_type}: integer notnull
      | | {name_list}: x: integer notnull variable was_set
      | | | {name x}: x: integer notnull variable was_set
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {fetch_stmt}: c: select: { _anon: integer notnull } variable dml_proc fetch_into
      | | {name C}: c: select: { _anon: integer notnull } variable dml_proc
      | | {name_list}
      |   | {name x}: x: integer notnull variable was_set
      | {assign}: err
        | {name a_string}: a_string: text variable was_set
        | {call}: err
          | {name cql_cursor_format}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c}: err

The statement ending at line XXXX

SET an_int := 1L;

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'LONG_INT' in 1L

  {assign}: err
  | {name an_int}: err
  | {longint 1}: longint notnull

The statement ending at line XXXX

SET an_int := 1.0;

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'REAL' in 1.0

  {assign}: err
  | {name an_int}: err
  | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET ll := 1.0;

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'REAL' in 1.0

  {assign}: err
  | {name ll}: err
  | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET an_int := ( SELECT length() );

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name length}: err
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := ( SELECT length(1) );

test/sem_test.sql:XXXX:1: error: in call : CQL0085: all arguments must be strings 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name length}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := length("x");

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'length'

  {assign}: err
  | {name an_int}: an_int: integer variable was_set
  | {call}: err
    | {name length}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET _sens := ( SELECT length(name)
  FROM with_sensitive );

  {assign}: _sens: integer variable sensitive was_set
  | {name _sens}: _sens: integer variable sensitive was_set
  | {select_stmt}: _anon: integer sensitive
    | {select_core_list}: select: { _anon: integer sensitive }
    | | {select_core}: select: { _anon: integer sensitive }
    |   | {select_expr_list_con}: select: { _anon: integer sensitive }
    |     | {select_expr_list}: select: { _anon: integer sensitive }
    |     | | {select_expr}: integer sensitive
    |     |   | {call}: integer sensitive
    |     |     | {name length}: integer sensitive
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {name name}: name: text sensitive
    |     | {select_from_etc}: TABLE { with_sensitive: with_sensitive }
    |       | {table_or_subquery_list}: TABLE { with_sensitive: with_sensitive }
    |       | | {table_or_subquery}: TABLE { with_sensitive: with_sensitive }
    |       |   | {name with_sensitive}: TABLE { with_sensitive: with_sensitive }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET an_int := ( SELECT length("x") );

  {assign}: an_int: integer variable was_set
  | {name an_int}: an_int: integer variable was_set
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name length}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'x'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

CREATE PROC cursor_box (OUT B OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET B FROM CURSOR C;
END;

  {create_proc_stmt}: ok dml_proc
  | {name cursor_box}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: B: object<bar CURSOR> variable out
    |   | {out}
    |   | {param_detail}: B: object<bar CURSOR> variable out
    |     | {name B}: B: object<bar CURSOR> variable out
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc boxed
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc boxed
        | {name B}: B: object<bar CURSOR> variable out
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc

The statement ending at line XXXX

CREATE PROC cursor_unbox (box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

  {create_proc_stmt}: ok
  | {name cursor_unbox}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable in
    |   | {param_detail}: box: object<bar CURSOR> variable in
    |     | {name box}: box: object<bar CURSOR> variable in
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: ok
      | {declare_cursor}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
        | {name box}: box: object<bar CURSOR> variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_untyped (box OBJECT)
BEGIN
  DECLARE C CURSOR FOR box;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0346: expression must be of type object<T cursor> where T is a valid shape name 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_untyped}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object variable in
    |   | {param_detail}: box: object variable in
    |     | {name box}: box: object variable in
    |     | {type_object}: object
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: box: object variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_cursor (box OBJECT<bar>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0343: variable must be of type object<T CURSOR> or object<T SET> where T is a valid shape name 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_cursor}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar> variable in
    |   | {param_detail}: box: object<bar> variable in
    |     | {name box}: box: object<bar> variable in
    |     | {type_object}: object<bar>
    |       | {name bar}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: box: object<bar> variable in

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_a_type (box OBJECT<not_a_type CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'not_a_type'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_a_type}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {name box}
    |     | {type_object}: err
    |       | {name not_a_type CURSOR}
    | {stmt_list}
      | {declare_cursor}
        | {name C}
        | {name box}

The statement ending at line XXXX

CREATE PROC cursor_unbox_duplicate (box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR FOR box;
  DECLARE C CURSOR FOR box;
END;

test/sem_test.sql:XXXX:1: error: in declare_cursor : CQL0197: duplicate variable name in the same scope 'C'

  {create_proc_stmt}: err
  | {name cursor_unbox_duplicate}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable in
    |   | {param_detail}: box: object<bar CURSOR> variable in
    |     | {name box}: box: object<bar CURSOR> variable in
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable boxed
      | | {name box}: box: object<bar CURSOR> variable in
      | {declare_cursor}: err
        | {name C}: err
        | {name box}

The statement ending at line XXXX

CREATE PROC cursor_unbox_not_exists ()
BEGIN
  DECLARE C CURSOR FOR box;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'box'

  {create_proc_stmt}: err
  | {name cursor_unbox_not_exists}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: err
        | {name C}
        | {name box}: err

The statement ending at line XXXX

CREATE PROC cursor_box_value (OUT box OBJECT<bar CURSOR>)
BEGIN
  DECLARE C CURSOR LIKE bar;
  SET box FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0261: cursor did not originate from a SQLite statement, it only has values 'C'

  {create_proc_stmt}: err
  | {name cursor_box_value}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<bar CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<bar CURSOR> variable out
    |     | {name box}: box: object<bar CURSOR> variable out
    |     | {type_object}: object<bar CURSOR>
    |       | {name bar CURSOR}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {shape_def}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {like}: ok
      |     | {name bar}
      | {set_from_cursor}: err
        | {name box}: box: object<bar CURSOR> variable out
        | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC cursor_box_not_a_shape (OUT box OBJECT<barf CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'barf'

  {create_proc_stmt}: err
  | {name cursor_box_not_a_shape}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {out}
    |   | {param_detail}
    |     | {name box}
    |     | {type_object}: err
    |       | {name barf CURSOR}
    | {stmt_list}
      | {declare_cursor}
      | | {name C}
      | | {select_stmt}
      |   | {select_core_list}
      |   | | {select_core}
      |   |   | {select_expr_list_con}
      |   |     | {select_expr_list}
      |   |     | | {star}
      |   |     | {select_from_etc}
      |   |       | {table_or_subquery_list}
      |   |       | | {table_or_subquery}
      |   |       |   | {name bar}
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}
        | {name box}
        | {name C}

The statement ending at line XXXX

CREATE PROC cursor_box_wrong_shape (OUT box OBJECT<foo CURSOR>)
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0057: in the cursor and the variable type, all must have the same column count
test/sem_test.sql:XXXX:1: error: in create_table_stmt : additional difference diagnostic info:

test/sem_test.sql:XXXX:1: error: likely end location of the 1st item
  this item has 1 columns
test/sem_test.sql:XXXX:1: error: likely end location of the 2nd item
  this item has 3 columns

only in 2nd: name text
only in 2nd: rate longint


  {create_proc_stmt}: err
  | {name cursor_box_wrong_shape}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<foo CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<foo CURSOR> variable out
    |     | {name box}: box: object<foo CURSOR> variable out
    |     | {type_object}: object<foo CURSOR>
    |       | {name foo CURSOR}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: err
        | {name box}: box: object<foo CURSOR> variable out
        | {name C}: err

The statement ending at line XXXX

CREATE PROC cursor_box_not_a_cursor (OUT box OBJECT<foo CURSOR>)
BEGIN
  SET box FROM CURSOR XYZZY;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'XYZZY'

  {create_proc_stmt}: err
  | {name cursor_box_not_a_cursor}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: box: object<foo CURSOR> variable out
    |   | {out}
    |   | {param_detail}: box: object<foo CURSOR> variable out
    |     | {name box}: box: object<foo CURSOR> variable out
    |     | {type_object}: object<foo CURSOR>
    |       | {name foo CURSOR}
    | {stmt_list}: err
      | {set_from_cursor}: err
        | {name box}
        | {name XYZZY}: err

The statement ending at line XXXX

CREATE PROC cursor_box_var_not_found ()
BEGIN
  DECLARE C CURSOR FOR SELECT *
    FROM bar;
  SET box FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in set_from_cursor : CQL0173: variable not found 'box'

  {create_proc_stmt}: err
  | {name cursor_box_var_not_found}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
      |   | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
      |   | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
      |   |     | {select_from_etc}: TABLE { bar: bar }
      |   |       | {table_or_subquery_list}: TABLE { bar: bar }
      |   |       | | {table_or_subquery}: TABLE { bar: bar }
      |   |       |   | {name bar}: TABLE { bar: bar }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {set_from_cursor}: err
        | {name box}
        | {name C}: C: select: { id: integer notnull, name: text, rate: longint } variable dml_proc

The statement ending at line XXXX

SET an_long := cql_get_blob_size(blob_var);

  {assign}: an_long: longint variable was_set
  | {name an_long}: an_long: longint variable was_set
  | {call}: longint notnull
    | {name cql_get_blob_size}: longint notnull
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name blob_var}: blob_var: blob variable was_set

The statement ending at line XXXX

SET an_long := cql_get_blob_size(blob_var, 0);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable was_set
  | {call}: err
    | {name cql_get_blob_size}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name blob_var}: blob_var: blob variable was_set
        | {arg_list}
          | {int 0}: integer notnull

The statement ending at line XXXX

SET an_long := cql_get_blob_size(an_int);

test/sem_test.sql:XXXX:1: error: in call : CQL0345: argument must be of type blob 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable was_set
  | {call}: err
    | {name cql_get_blob_size}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {call}: an_int: integer notnull variable was_set
          | {name cql_inferred_notnull}: an_int: integer notnull variable was_set
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name an_int}: an_int: integer inferred_notnull variable was_set

The statement ending at line XXXX

SET an_long := ( SELECT cql_get_blob_size(an_int) );

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_get_blob_size'

  {assign}: err
  | {name an_long}: an_long: longint variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name cql_get_blob_size}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {call}: an_int: integer notnull variable was_set
    |     |           | {name cql_inferred_notnull}: an_int: integer notnull variable was_set
    |     |           | {call_arg_list}
    |     |             | {call_filter_clause}
    |     |             | {arg_list}: ok
    |     |               | {name an_int}: an_int: integer inferred_notnull variable was_set
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

DECLARE PROC some_proc (id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in
      | | {param_detail}: id: integer variable in
      |   | {name id}: id: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: t: text variable in
        | | {param_detail}: t: text variable in
        |   | {name t}: t: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: t1: text notnull variable in
          | | {param_detail}: t1: text notnull variable in
          |   | {name t1}: t1: text notnull variable in
          |   | {notnull}: text notnull
          |     | {type_text}: text
          | {params}
            | {param}: b: blob variable in
            | | {param_detail}: b: blob variable in
            |   | {name b}: b: blob variable in
            |   | {type_blob}: blob
            | {params}
              | {param}: x: integer notnull variable out
                | {out}
                | {param_detail}: x: integer notnull variable out
                  | {name x}: x: integer notnull variable out
                  | {notnull}: integer notnull
                    | {type_int}: integer

The statement ending at line XXXX

DECLARE Q CURSOR LIKE some_proc ARGUMENTS;

  {declare_cursor_like_name}: Q: some_proc[arguments]: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull in } variable shape_storage value_cursor
  | {name Q}: Q: some_proc[arguments]: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull in } variable shape_storage value_cursor
  | {shape_def}: some_proc[arguments]: { id: integer in, t: text in, t1: text notnull in, b: blob in, x: integer notnull in }
    | {like}
      | {name some_proc}
      | {name some_proc}

The statement ending at line XXXX

CREATE PROC some_proc_proxy (id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL)
BEGIN
  CALL some_proc(id, t, t1, b, x);
END;

  {create_proc_stmt}: ok
  | {name some_proc_proxy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in
    | | | {param_detail}: id: integer variable in
    | |   | {name id}: id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |   | | {param_detail}: t: text variable in
    |   |   | {name t}: t: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: t1: text notnull variable in
    |     | | {param_detail}: t1: text notnull variable in
    |     |   | {name t1}: t1: text notnull variable in
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: b: blob variable in
    |       | | {param_detail}: b: blob variable in
    |       |   | {name b}: b: blob variable in
    |       |   | {type_blob}: blob
    |       | {params}
    |         | {param}: x: integer notnull variable out was_set
    |           | {out}
    |           | {param_detail}: x: integer notnull variable out was_set
    |             | {name x}: x: integer notnull variable out was_set
    |             | {notnull}: integer notnull
    |               | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name some_proc}: ok
        | {expr_list}: ok
          | {dot}: id: integer variable in
          | | {name ARGUMENTS}
          | | {name id}
          | {expr_list}
            | {dot}: t: text variable in
            | | {name ARGUMENTS}
            | | {name t}
            | {expr_list}
              | {dot}: t1: text notnull variable in
              | | {name ARGUMENTS}
              | | {name t1}
              | {expr_list}
                | {dot}: b: blob variable in
                | | {name ARGUMENTS}
                | | {name b}
                | {expr_list}
                  | {dot}: x: integer notnull variable out was_set
                    | {name ARGUMENTS}
                    | {name x}

The statement ending at line XXXX

DECLARE PROC some_proc2 (INOUT id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc2}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id: integer variable in out
      | | {inout}
      | | {param_detail}: id: integer variable in out
      |   | {name id}: id: integer variable in out
      |   | {type_int}: integer
      | {params}
        | {param}: t: text variable in
        | | {param_detail}: t: text variable in
        |   | {name t}: t: text variable in
        |   | {type_text}: text
        | {params}
          | {param}: t1: text notnull variable in
          | | {param_detail}: t1: text notnull variable in
          |   | {name t1}: t1: text notnull variable in
          |   | {notnull}: text notnull
          |     | {type_text}: text
          | {params}
            | {param}: b: blob variable in
            | | {param_detail}: b: blob variable in
            |   | {name b}: b: blob variable in
            |   | {type_blob}: blob
            | {params}
              | {param}: x: integer notnull variable out
                | {out}
                | {param_detail}: x: integer notnull variable out
                  | {name x}: x: integer notnull variable out
                  | {notnull}: integer notnull
                    | {type_int}: integer

The statement ending at line XXXX

CREATE PROC some_proc2_proxy (INOUT id INTEGER, t TEXT, t1 TEXT NOT NULL, b BLOB, OUT x INTEGER NOT NULL)
BEGIN
  CALL some_proc(id, t, t1, b, x);
END;

  {create_proc_stmt}: ok
  | {name some_proc2_proxy}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: id: integer variable in out
    | | | {inout}
    | | | {param_detail}: id: integer variable in out
    | |   | {name id}: id: integer variable in out
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: t: text variable in
    |   | | {param_detail}: t: text variable in
    |   |   | {name t}: t: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: t1: text notnull variable in
    |     | | {param_detail}: t1: text notnull variable in
    |     |   | {name t1}: t1: text notnull variable in
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: b: blob variable in
    |       | | {param_detail}: b: blob variable in
    |       |   | {name b}: b: blob variable in
    |       |   | {type_blob}: blob
    |       | {params}
    |         | {param}: x: integer notnull variable out was_set
    |           | {out}
    |           | {param_detail}: x: integer notnull variable out was_set
    |             | {name x}: x: integer notnull variable out was_set
    |             | {notnull}: integer notnull
    |               | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name some_proc}: ok
        | {expr_list}: ok
          | {dot}: id: integer variable in out
          | | {name ARGUMENTS}
          | | {name id}
          | {expr_list}
            | {dot}: t: text variable in
            | | {name ARGUMENTS}
            | | {name t}
            | {expr_list}
              | {dot}: t1: text notnull variable in
              | | {name ARGUMENTS}
              | | {name t1}
              | {expr_list}
                | {dot}: b: blob variable in
                | | {name ARGUMENTS}
                | | {name b}
                | {expr_list}
                  | {dot}: x: integer notnull variable out was_set
                    | {name ARGUMENTS}
                    | {name x}

The statement ending at line XXXX

CREATE PROC some_proc3_proxy (LIKE some_proc3 ARGUMENTS)
BEGIN
  CALL some_proc(FROM ARGUMENTS);
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0069: name not found 'some_proc3'

  {create_proc_stmt}: err
  | {name some_proc3_proxy}: err
  | {proc_params_stmts}
    | {params}: err
    | | {param}: err
    |   | {param_detail}
    |     | {shape_def}: err
    |       | {like}: err
    |         | {name some_proc3}: err
    |         | {name some_proc3}: err
    | {stmt_list}
      | {call_stmt}
        | {name some_proc}
        | {expr_list}
          | {from_shape}
            | {name ARGUMENTS}

The statement ending at line XXXX

CREATE PROC some_proc4_proxy (LIKE proc1 ARGUMENTS)
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0262: LIKE ... ARGUMENTS used on a procedure with no arguments 'proc1'

  {create_proc_stmt}: err
  | {name some_proc4_proxy}: err
  | {proc_params_stmts}
    | {params}: err
      | {param}: err
        | {param_detail}
          | {shape_def}: err
            | {like}: err
              | {name proc1}: err
              | {name proc1}: err

The statement ending at line XXXX

DECLARE cursor_with_object CURSOR LIKE obj_proc ARGUMENTS;

  {declare_cursor_like_name}: cursor_with_object: obj_proc[arguments]: { an_obj: object in } variable shape_storage value_cursor
  | {name cursor_with_object}: cursor_with_object: obj_proc[arguments]: { an_obj: object in } variable shape_storage value_cursor
  | {shape_def}: obj_proc[arguments]: { an_obj: object in }
    | {like}
      | {name obj_proc}
      | {name obj_proc}

The statement ending at line XXXX

CREATE PROC try_to_emit_object ()
BEGIN
  OUT cursor_with_object;
END;

  {create_proc_stmt}: cursor_with_object: try_to_emit_object: { an_obj: object } variable shape_storage uses_out value_cursor
  | {name try_to_emit_object}: cursor_with_object: try_to_emit_object: { an_obj: object } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {out_stmt}: cursor_with_object: obj_proc[arguments]: { an_obj: object in } variable shape_storage value_cursor
        | {name cursor_with_object}: cursor_with_object: obj_proc[arguments]: { an_obj: object in } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC test_fetch_using ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  FETCH C(id, name, rate) FROM VALUES(1, NULL, 99);
END;

  {create_proc_stmt}: ok
  | {name test_fetch_using}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {shape_def}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {like}: ok
      |     | {name bar}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}: ok
              | {int 1}: integer notnull
              | {insert_list}
                | {null}: null
                | {insert_list}
                  | {int 99}: integer notnull

The statement ending at line XXXX

CREATE PROC test_fetch_using_with_dummy_seed ()
BEGIN
  DECLARE C CURSOR LIKE bar;
  FETCH C(id, name, rate) FROM VALUES(1, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(9) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok
  | {name test_fetch_using_with_dummy_seed}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
      | | {shape_def}: bar: { id: integer notnull, name: text, rate: longint }
      |   | {like}: ok
      |     | {name bar}
      | {fetch_values_stmt}: ok
        | {insert_dummy_spec}: integer notnull
        | | {int 9}: integer notnull
        | | {int 3}
        | {name_columns_values}
          | {name C}: C: bar: { id: integer notnull, name: text, rate: longint } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}: ok
              | {int 1}: integer notnull
              | {insert_list}
                | {call}: text notnull
                | | {name printf}: text notnull
                | | {call_arg_list}
                |   | {call_filter_clause}
                |   | {arg_list}: ok
                |     | {strlit 'name_%d'}: text notnull
                |     | {arg_list}
                |       | {name _seed_}: _seed_: integer notnull variable
                | {insert_list}
                  | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

DECLARE SELECT FUNC returns_object_is_bogus () OBJECT;

test/sem_test.sql:XXXX:1: error: in str : CQL0347: select function may not return type OBJECT 'returns_object_is_bogus'

  {declare_select_func_stmt}: err
  | {name returns_object_is_bogus}: object
  | {func_params_return}
    | {type_object}: object

The statement ending at line XXXX

CREATE TABLE with_check(
  id INTEGER,
  lo INTEGER CHECK(lo <= hi) ,
  hi INTEGER
);

  {create_table_stmt}: with_check: { id: integer, lo: integer has_check, hi: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: lo: integer has_check
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name lo}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: ok
      |     | {le}: bool
      |       | {name lo}: lo: integer has_check
      |       | {name hi}: hi: integer
      | {col_key_list}
        | {col_def}: hi: integer
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name hi}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE with_check_bogus_column(
  id INTEGER,
  lo INTEGER CHECK(lo <= hip) ,
  hi INTEGER
);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'hip'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_bogus_column}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: lo: integer has_check
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name lo}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: err
      |     | {le}: err
      |       | {name lo}: lo: integer has_check
      |       | {name hip}: err
      | {col_key_list}
        | {col_def}: hi: integer
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name hi}
              | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE with_collate(
  id INTEGER,
  t TEXT COLLATE garbonzo
);

  {create_table_stmt}: with_collate: { id: integer, t: text has_collate }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_collate}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: t: text has_collate
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name t}
          | | {type_text}: text
          | {col_attrs_collate}: ok
            | {name garbonzo}

The statement ending at line XXXX

CREATE TABLE with_collate(
  id INTEGER,
  i REAL COLLATE garbonzo
);

test/sem_test.sql:XXXX:1: error: in str : CQL0348: collate applied to a non-text column 'i'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_collate}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name i}
          | | {type_real}: real
          | {col_attrs_collate}: err
            | {name garbonzo}

The statement ending at line XXXX

CREATE TABLE bad_order(
  id INTEGER,
  PRIMARY KEY (id),
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in col_def : CQL0349: column definitions may not come after constraints 'id'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bad_order}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {pk_def}
      | | {indexed_columns_conflict_clause}
      |   | {indexed_columns}
      |     | {indexed_column}
      |       | {name id}
      | {col_key_list}
        | {col_def}
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name t}
              | {type_text}

The statement ending at line XXXX

CREATE PROC test_insert_using ()
BEGIN
  INSERT INTO foo(id) VALUES(1);
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_insert_using}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name foo}: foo: { id: integer notnull primary_key autoinc }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {insert_list}
              | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC test_insert_using_with_dummy_seed ()
BEGIN
  INSERT INTO bar(id, name, rate) VALUES(1, printf('name_%d', _seed_), _seed_) @DUMMY_SEED(9) @DUMMY_DEFAULTS @DUMMY_NULLABLES;
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_insert_using_with_dummy_seed}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | | {seed_stub}
        |   | {int 9}: integer notnull
        |   | {int 3}
        | {name_columns_values}
          | {name bar}: bar: { id: integer notnull, name: text, rate: longint }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name id}: id: integer notnull
            |   | {name_list}
            |     | {name name}: name: text
            |     | {name_list}
            |       | {name rate}: rate: longint
            | {insert_list}
              | {int 1}: integer notnull
              | {insert_list}
                | {call}: text notnull
                | | {name printf}: text notnull
                | | {call_arg_list}
                |   | {call_filter_clause}
                |   | {arg_list}: ok
                |     | {strlit 'name_%d'}: text notnull
                |     | {arg_list}
                |       | {name _seed_}: _seed_: integer notnull variable
                | {insert_list}
                  | {name _seed_}: _seed_: integer notnull variable

The statement ending at line XXXX

CREATE PROC test_insert_using ()
BEGIN
  INSERT INTO foo USING 1 AS bogus;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0186: duplicate stored proc name 'test_insert_using'

  {create_proc_stmt}: err
  | {name test_insert_using}: err
  | {proc_params_stmts}
    | {stmt_list}
      | {insert_stmt}
        | {insert_normal}
        | {name_columns_values}
          | {name foo}
          | {expr_names}
            | {expr_name}
              | {int 1}
              | {opt_as_alias}
                | {name bogus}

The statement ending at line XXXX

SELECT CASE WHEN an_int IS NULL THEN 3
ELSE 2
END;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {case_expr}: integer notnull
  |     |     | {connector}: integer notnull
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {is}: bool notnull
  |     |       |   | | {name an_int}: an_int: integer variable was_set
  |     |       |   | | {null}: null
  |     |       |   | {int 3}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT iif(an_int IS NULL, 2, 3, 4);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name iif}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {is}
  |     |         | | {name an_int}
  |     |         | | {null}
  |     |         | {arg_list}
  |     |           | {int 2}
  |     |           | {arg_list}
  |     |             | {int 3}
  |     |             | {arg_list}
  |     |               | {int 4}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN not_found THEN 2
ELSE 3
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_found'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |       | | {when}
  |     |       |   | {name not_found}: err
  |     |       |   | {int 2}
  |     |       | {int 3}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 THEN not_found
ELSE 3
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_found'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |       | | {when}
  |     |       |   | {int 1}: integer notnull
  |     |       |   | {name not_found}: err
  |     |       | {int 3}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 1 THEN 2
ELSE not_found
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_found'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       |   | {int 2}: integer notnull
  |     |       | {name not_found}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN 'x' THEN 2
ELSE 3
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: err
  |     |       | | {when}
  |     |       |   | {strlit 'x'}: err
  |     |       |   | {int 2}
  |     |       | {int 3}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CASE WHEN an_int IS NULL THEN 2
ELSE x'23'
END;

test/sem_test.sql:XXXX:1: error: in blb : CQL0012: incompatible types in expression 'iif'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {case_expr}: err
  |     |     | {connector}
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {is}: bool notnull
  |     |       |   | | {name an_int}: an_int: integer variable was_set
  |     |       |   | | {null}: null
  |     |       |   | {int 2}: integer notnull
  |     |       | {blob x'23'}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET an_int := CASE WHEN an_int IS NULL THEN CASE WHEN 4 THEN 5
ELSE 6
END
ELSE 2
END;

  {assign}: an_int: integer variable was_set
  | {name an_int}: an_int: integer variable was_set
  | {case_expr}: integer notnull
    | {connector}: integer notnull
      | {case_list}: integer notnull
      | | {when}: integer notnull
      |   | {is}: bool notnull
      |   | | {name an_int}: an_int: integer variable was_set
      |   | | {null}: null
      |   | {case_expr}: integer notnull
      |     | {connector}: integer notnull
      |       | {case_list}: integer notnull
      |       | | {when}: integer notnull
      |       |   | {int 4}: integer notnull
      |       |   | {int 5}: integer notnull
      |       | {int 6}: integer notnull
      | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC test_update_cursor_using ()
BEGIN
  UPDATE CURSOR small_cursor(x) FROM VALUES(2);
END;

  {create_proc_stmt}: ok dml_proc
  | {name test_update_cursor_using}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {update_cursor_stmt}: ok
        | {name small_cursor}: small_cursor: select: { x: integer notnull } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name x}: x: integer notnull
          | {insert_list}: ok
            | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC proc_savepoint_basic ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      ROLLBACK RETURN;
    ELSE
      COMMIT RETURN;
    END IF;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc_savepoint_basic}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {proc_savepoint_stmt}: ok
        | {stmt_list}: ok
          | {if_stmt}: integer notnull
            | {cond_action}: integer notnull
            | | {int 1}: integer notnull
            | | {stmt_list}: ok
            |   | {rollback_return_stmt}: ok
            | {if_alt}: ok
              | {else}: ok
                | {stmt_list}: ok
                  | {commit_return_stmt}: ok

The statement ending at line XXXX

CREATE PROC proc_savepoint_error_in_stmt_list ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    SET X := NOT 'x';
  END;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name proc_savepoint_error_in_stmt_list}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {proc_savepoint_stmt}: err
        | {stmt_list}: err
          | {assign}: err
            | {name X}: X: integer variable was_set
            | {not}: err
              | {strlit 'x'}: text notnull

The statement ending at line XXXX

PROC SAVEPOINT
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in proc_savepoint_stmt : CQL0351: statement should be in a procedure and at the top level

  {proc_savepoint_stmt}: err

The statement ending at line XXXX

CREATE PROC savepoint_nested ()
BEGIN
  IF 1 THEN
    PROC SAVEPOINT
    BEGIN
    END;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in proc_savepoint_stmt : CQL0351: statement should be in a procedure and at the top level

  {create_proc_stmt}: err
  | {name savepoint_nested}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {proc_savepoint_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC rollback_return_invalid ()
BEGIN
  IF 1 THEN
    ROLLBACK RETURN;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in rollback_return_stmt : CQL0350: statement must appear inside of a PROC SAVEPOINT block

  {create_proc_stmt}: err
  | {name rollback_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {rollback_return_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC commit_return_invalid ()
BEGIN
  IF 1 THEN
    COMMIT RETURN;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in commit_return_stmt : CQL0350: statement must appear inside of a PROC SAVEPOINT block

  {create_proc_stmt}: err
  | {name commit_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {int 1}: integer notnull
        | | {stmt_list}: err
        |   | {commit_return_stmt}: err
        | {if_alt}

The statement ending at line XXXX

CREATE PROC regular_return_invalid ()
BEGIN
  PROC SAVEPOINT
  BEGIN
    RETURN;
  END;
END;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0352: use COMMIT RETURN or ROLLBACK RETURN in within a proc savepoint block

  {create_proc_stmt}: err
  | {name regular_return_invalid}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {proc_savepoint_stmt}: err
        | {stmt_list}: err
          | {return_stmt}: err

The statement ending at line XXXX

DECLARE ENUM integer_things INTEGER (
  pen,
  paper = 7,
  pencil
);

  {declare_enum_stmt}: integer_things: integer<integer_things> notnull
  | {typed_name}: integer_things: integer<integer_things> notnull
  | | {name integer_things}
  | | {type_int}: integer_things: integer<integer_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name pen}: integer = 1 notnull
    | {enum_values}
      | {enum_value}
      | | {name paper}: integer = 7 notnull
      | | {int 7}: integer notnull
      | {enum_values}
        | {enum_value}
          | {name pencil}: integer = 8 notnull

The statement ending at line XXXX

DECLARE PROC test_shape () (x INTEGER<integer_things> NOT NULL);

  {declare_proc_stmt}: test_shape: { x: integer<integer_things> notnull } dml_proc
  | {proc_name_type}
  | | {name test_shape}: test_shape: { x: integer<integer_things> notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: test_shape: { x: integer<integer_things> notnull }
      | {typed_name}: x: integer<integer_things> notnull
        | {name x}
        | {notnull}: x: integer<integer_things> notnull
          | {type_int}: integer<integer_things>
            | {name integer_things}

The statement ending at line XXXX

CREATE PROC enum_users ()
BEGIN
  DECLARE C CURSOR LIKE test_shape;
  FETCH C(x) FROM VALUES(1);
  LET z := C.x;
END;

  {create_proc_stmt}: ok
  | {name enum_users}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      | | {name C}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      | | {shape_def}: test_shape: { x: integer<integer_things> notnull } dml_proc
      |   | {like}: ok
      |     | {name test_shape}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer<integer_things> notnull
      |     | {insert_list}: ok
      |       | {int 1}: integer<integer_things> notnull
      | {let_stmt}: z: integer<integer_things> notnull variable
        | {name z}: z: integer<integer_things> notnull variable
        | {dot}: C.x: integer<integer_things> notnull variable
          | {name C}
          | {name x}

The statement ending at line XXXX

DECLARE PROC enum_users_out (i INTEGER<integer_things> NOT NULL) OUT (x INTEGER<integer_things> NOT NULL);

  {declare_proc_stmt}: enum_users_out: { x: integer<integer_things> notnull } uses_out
  | {proc_name_type}
  | | {name enum_users_out}: enum_users_out: { x: integer<integer_things> notnull } uses_out
  | | {int 5}
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer<integer_things> notnull variable in
    |   | {param_detail}: i: integer<integer_things> notnull variable in
    |     | {name i}: i: integer<integer_things> notnull variable in
    |     | {notnull}: integer<integer_things> notnull
    |       | {type_int}: integer<integer_things>
    |         | {name integer_things}
    | {typed_names}: enum_users_out: { x: integer<integer_things> notnull }
      | {typed_name}: x: integer<integer_things> notnull
        | {name x}
        | {notnull}: x: integer<integer_things> notnull
          | {type_int}: integer<integer_things>
            | {name integer_things}

The statement ending at line XXXX

CREATE PROC enum_users_out (i INTEGER<integer_things> NOT NULL)
BEGIN
  DECLARE C CURSOR LIKE test_shape;
  FETCH C(x) FROM VALUES(i);
  OUT C;
END;

  {create_proc_stmt}: C: enum_users_out: { x: integer<integer_things> notnull } variable shape_storage uses_out value_cursor
  | {name enum_users_out}: C: enum_users_out: { x: integer<integer_things> notnull } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: i: integer<integer_things> notnull variable in
    |   | {param_detail}: i: integer<integer_things> notnull variable in
    |     | {name i}: i: integer<integer_things> notnull variable in
    |     | {notnull}: integer<integer_things> notnull
    |       | {type_int}: integer<integer_things>
    |         | {name integer_things}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      | | {name C}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      | | {shape_def}: test_shape: { x: integer<integer_things> notnull } dml_proc
      |   | {like}: ok
      |     | {name test_shape}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name C}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer<integer_things> notnull
      |     | {insert_list}: ok
      |       | {name i}: i: integer<integer_things> notnull variable in
      | {out_stmt}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor
        | {name C}: C: test_shape: { x: integer<integer_things> notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC enum_in_bundle (b_x INTEGER<integer_things> NOT NULL)
BEGIN
  LET u := b.x;
  LET v := b_x;
END;

  {create_proc_stmt}: ok
  | {name enum_in_bundle}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: b_x: integer<integer_things> notnull variable in
    |   | {param_detail}: b_x: integer<integer_things> notnull variable in
    |     | {name b_x}: b_x: integer<integer_things> notnull variable in
    |     | {notnull}: integer<integer_things> notnull
    |       | {type_int}: integer<integer_things>
    |         | {name integer_things}
    | {stmt_list}: ok
      | {let_stmt}: u: integer<integer_things> notnull variable
      | | {name u}: u: integer<integer_things> notnull variable
      | | {dot}: b_x: integer<integer_things> notnull variable in
      |   | {name b}
      |   | {name x}
      | {let_stmt}: v: integer<integer_things> notnull variable
        | {name v}: v: integer<integer_things> notnull variable
        | {name b_x}: b_x: integer<integer_things> notnull variable in

The statement ending at line XXXX

DECLARE PROC shape_result_test () (x INTEGER<integer_things> NOT NULL);

  {declare_proc_stmt}: shape_result_test: { x: integer<integer_things> notnull } dml_proc
  | {proc_name_type}
  | | {name shape_result_test}: shape_result_test: { x: integer<integer_things> notnull } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: shape_result_test: { x: integer<integer_things> notnull }
      | {typed_name}: x: integer<integer_things> notnull
        | {name x}
        | {notnull}: x: integer<integer_things> notnull
          | {type_int}: integer<integer_things>
            | {name integer_things}

The statement ending at line XXXX

DECLARE ENUM integer_things INTEGER (
  pen,
  paper = 7,
  pencil
);

  {declare_enum_stmt}: integer_things: integer<integer_things> notnull
  | {typed_name}: integer_things: integer<integer_things> notnull
  | | {name integer_things}
  | | {type_int}: integer_things: integer<integer_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name pen}: integer = 1 notnull
    | {enum_values}
      | {enum_value}
      | | {name paper}: integer = 7 notnull
      | | {int 7}: integer notnull
      | {enum_values}
        | {enum_value}
          | {name pencil}: integer = 8 notnull

The statement ending at line XXXX

DECLARE ENUM real_things REAL (
  pen,
  paper = 7,
  pencil
);

  {declare_enum_stmt}: real_things: real<real_things> notnull
  | {typed_name}: real_things: real<real_things> notnull
  | | {name real_things}
  | | {type_real}: real_things: real<real_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name pen}: real = 1.000000e+00 notnull
    | {enum_values}
      | {enum_value}
      | | {name paper}: real = 7.000000e+00 notnull
      | | {int 7}: integer notnull
      | {enum_values}
        | {enum_value}
          | {name pencil}: real = 8.000000e+00 notnull

The statement ending at line XXXX

DECLARE rt REAL<real_things> NOT NULL;

  {declare_vars_type}: real<real_things> notnull
  | {name_list}: rt: real<real_things> notnull variable was_set
  | | {name rt}: rt: real<real_things> notnull variable was_set
  | {notnull}: real<real_things> notnull
    | {type_real}: real<real_things>
      | {name real_things}

The statement ending at line XXXX

SET rt := 1.000000e+00;

  {assign}: rt: real<real_things> notnull variable was_set
  | {name rt}: rt: real<real_things> notnull variable was_set
  | {dbl 1.000000e+00}: real<real_things> notnull

The statement ending at line XXXX

SET rt := 1;

test/sem_test.sql:XXXX:1: error: in dot : CQL0070: expressions of different kinds can't be mixed: 'real_things' vs. 'integer_things'

  {assign}: err
  | {name rt}: rt: real<real_things> notnull variable was_set
  | {int 1}: integer<integer_things> notnull

The statement ending at line XXXX

SELECT 8.000000e+00;

  {select_stmt}: select: { _anon: real<real_things> notnull }
  | {select_core_list}: select: { _anon: real<real_things> notnull }
  | | {select_core}: select: { _anon: real<real_things> notnull }
  |   | {select_expr_list_con}: select: { _anon: real<real_things> notnull }
  |     | {select_expr_list}: select: { _anon: real<real_things> notnull }
  |     | | {select_expr}: real<real_things> notnull
  |     |   | {dbl 8.000000e+00}: real<real_things> notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT real_things.nope;

test/sem_test.sql:XXXX:1: error: in dot : CQL0357: enum does not contain 'nope'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {dot}: err
  |     |     | {name real_things}
  |     |     | {name nope}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE ENUM bool_things BOOL (
  pen,
  paper = 7,
  pencil
);

  {declare_enum_stmt}: bool_things: bool<bool_things> notnull
  | {typed_name}: bool_things: bool<bool_things> notnull
  | | {name bool_things}
  | | {type_bool}: bool_things: bool<bool_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name pen}: bool = 1 notnull
    | {enum_values}
      | {enum_value}
      | | {name paper}: bool = 1 notnull
      | | {int 7}: integer notnull
      | {enum_values}
        | {enum_value}
          | {name pencil}: bool = 0 notnull

The statement ending at line XXXX

DECLARE ENUM long_things LONG_INT (
  pen,
  paper = -7,
  pencil
);

  {declare_enum_stmt}: long_things: longint<long_things> notnull
  | {typed_name}: long_things: longint<long_things> notnull
  | | {name long_things}
  | | {type_long}: long_things: longint<long_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name pen}: longint = 1 notnull
    | {enum_values}
      | {enum_value}
      | | {name paper}: longint = -7 notnull
      | | {uminus}: integer notnull
      |   | {int 7}: integer notnull
      | {enum_values}
        | {enum_value}
          | {name pencil}: longint = -6 notnull

The statement ending at line XXXX

DECLARE ENUM long_things INTEGER (
  foo
);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_enum_stmt : DECLARE ENUM long_things INTEGER (
  foo
)
test/sem_test.sql:XXXX:1: error: in declare_enum_stmt : DECLARE ENUM long_things LONG_INT (
  pen,
  paper = -7,
  pencil
)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_enum_stmt : CQL0356: enum definitions do not match 'long_things'

  {declare_enum_stmt}: err
  | {typed_name}: long_things: integer<long_things> notnull
  | | {name long_things}
  | | {type_int}: long_things: integer<long_things> notnull
  | {enum_values}
    | {enum_value}
      | {name foo}: integer = 1 notnull

The statement ending at line XXXX

DECLARE ENUM duplicated_things INTEGER (
  two,
  two
);

test/sem_test.sql:XXXX:1: error: in enum_value : CQL0354: duplicate enum member 'two'

  {declare_enum_stmt}: err
  | {typed_name}: duplicated_things: integer<duplicated_things> notnull
  | | {name duplicated_things}
  | | {type_int}: duplicated_things: integer<duplicated_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name two}: integer = 1 notnull
    | {enum_values}
      | {enum_value}
        | {name two}

The statement ending at line XXXX

DECLARE ENUM invalid_things INTEGER (
  boo = 1 / 0
);

test/sem_test.sql:XXXX:1: error: in enum_value : CQL0355: evaluation failed 'boo'

  {declare_enum_stmt}: err
  | {typed_name}: invalid_things: integer<invalid_things> notnull
  | | {name invalid_things}
  | | {type_int}: invalid_things: integer<invalid_things> notnull
  | {enum_values}
    | {enum_value}
      | {name boo}
      | {div}: integer notnull
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

DECLARE ENUM sizes REAL (
  big = 100,
  medium = 1.000000e+02 / 2,
  small = 5.000000e+01 / 2,
  tiny = 2.500000e+01 / 2
);

  {declare_enum_stmt}: sizes: real<sizes> notnull
  | {typed_name}: sizes: real<sizes> notnull
  | | {name sizes}
  | | {type_real}: sizes: real<sizes> notnull
  | {enum_values}
    | {enum_value}
    | | {name big}: real = 1.000000e+02 notnull
    | | {int 100}: integer notnull
    | {enum_values}
      | {enum_value}
      | | {name medium}: real = 5.000000e+01 notnull
      | | {div}: real notnull
      |   | {dbl 1.000000e+02}: real notnull
      |   | {int 2}: integer notnull
      | {enum_values}
        | {enum_value}
        | | {name small}: real = 2.500000e+01 notnull
        | | {div}: real notnull
        |   | {dbl 5.000000e+01}: real notnull
        |   | {int 2}: integer notnull
        | {enum_values}
          | {enum_value}
            | {name tiny}: real = 1.250000e+01 notnull
            | {div}: real notnull
              | {dbl 2.500000e+01}: real notnull
              | {int 2}: integer notnull

The statement ending at line XXXX

DECLARE ENUM misc REAL (
  one = 1.000000e+02 - 2.500000e+01,
  two = 7.500000e+01 - 1.250000e+01
);

  {declare_enum_stmt}: misc: real<misc> notnull
  | {typed_name}: misc: real<misc> notnull
  | | {name misc}
  | | {type_real}: misc: real<misc> notnull
  | {enum_values}
    | {enum_value}
    | | {name one}: real = 7.500000e+01 notnull
    | | {sub}: real<sizes> notnull
    |   | {dbl 1.000000e+02}: real<sizes> notnull
    |   | {dbl 2.500000e+01}: real<sizes> notnull
    | {enum_values}
      | {enum_value}
        | {name two}: real = 6.250000e+01 notnull
        | {sub}: real<sizes> notnull
          | {dbl 7.500000e+01}: real notnull
          | {dbl 1.250000e+01}: real<sizes> notnull

The statement ending at line XXXX

CREATE PROC enum_in_proc_bogus ()
BEGIN
  DECLARE ENUM bogus_inside_proc INTEGER (
    foo
  );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0358: declared enums must be top level 'bogus_inside_proc'

  {create_proc_stmt}: err
  | {name enum_in_proc_bogus}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_enum_stmt}: err
        | {typed_name}: bogus_inside_proc: integer<bogus_inside_proc> notnull
        | | {name bogus_inside_proc}
        | | {type_int}: bogus_inside_proc: integer<bogus_inside_proc> notnull
        | {enum_values}
          | {enum_value}
            | {name foo}

The statement ending at line XXXX

CREATE TABLE SalesInfo(
  month INTEGER,
  amount REAL
);

  {create_table_stmt}: SalesInfo: { month: integer, amount: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name SalesInfo}
  | {col_key_list}
    | {col_def}: month: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name month}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: amount: real
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name amount}
            | {type_real}: real

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND sum(month) FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: real
  |     |       | | | {name AVG}: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {orderby_list}: ok
  |     |       |     |   | {orderby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: err
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {call}: err
  |     |       |           | {name sum}
  |     |       |           | {call_arg_list}
  |     |       |             | {call_filter_clause}
  |     |       |             | {arg_list}: ok
  |     |       |               | {name month}: month: integer
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (PARTITION BY sum(month) ROWS BETWEEN 1 PRECEDING AND 3 FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: real
  |     |       | | | {name AVG}: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {opt_partition_by}: err
  |     |       |   | | {expr_list}: err
  |     |       |   |   | {call}: err
  |     |       |   |     | {name sum}
  |     |       |   |     | {call_arg_list}
  |     |       |   |       | {call_filter_clause}
  |     |       |   |       | {arg_list}: ok
  |     |       |   |         | {name month}: month: integer
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_frame_spec}: ok
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {int 3}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) OVER (ORDER BY month ROWS BETWEEN sum(month) PRECEDING AND 1 FOLLOWING) AS SalesMovingAverage
  FROM SalesInfo;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: real
  |     |       | | | {name AVG}: real
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | {arg_list}: ok
  |     |       | |     | {name amount}: amount: real
  |     |       | | {window_defn}: err
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {orderby_list}: ok
  |     |       |     |   | {orderby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: err
  |     |       |       | {int 266370}
  |     |       |       | {expr_list}
  |     |       |         | {call}: err
  |     |       |         | | {name sum}
  |     |       |         | | {call_arg_list}
  |     |       |         |   | {call_filter_clause}
  |     |       |         |   | {arg_list}: ok
  |     |       |         |     | {name month}: month: integer
  |     |       |         | {int 1}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT month, amount, 
  AVG(amount) FILTER (WHERE sum(month) = 1) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 2 FOLLOWING EXCLUDE NO OTHERS) AS SalesMovingAverage
  FROM SalesInfo;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'sum'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: month: integer
  |     | | | {name month}: month: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: amount: real
  |     |   | | {name amount}: amount: real
  |     |   | {select_expr_list}
  |     |     | {select_expr}: err
  |     |       | {window_func_inv}: err
  |     |       | | {call}: err
  |     |       | | | {name AVG}
  |     |       | | | {call_arg_list}
  |     |       | |   | {call_filter_clause}
  |     |       | |   | | {opt_filter_clause}: err
  |     |       | |   |   | {opt_where}: err
  |     |       | |   |     | {eq}: err
  |     |       | |   |       | {call}: err
  |     |       | |   |       | | {name sum}
  |     |       | |   |       | | {call_arg_list}
  |     |       | |   |       |   | {call_filter_clause}
  |     |       | |   |       |   | {arg_list}: ok
  |     |       | |   |       |     | {name month}: month: integer
  |     |       | |   |       | {int 1}: integer notnull
  |     |       | |   | {arg_list}
  |     |       | |     | {name amount}
  |     |       | | {window_defn}: ok
  |     |       |   | {window_defn_orderby}
  |     |       |     | {opt_orderby}: ok
  |     |       |     | | {orderby_list}: ok
  |     |       |     |   | {orderby_item}
  |     |       |     |     | {name month}: month: integer
  |     |       |     | {opt_frame_spec}: ok
  |     |       |       | {int 20610}
  |     |       |       | {expr_list}
  |     |       |         | {int 1}: integer notnull
  |     |       |         | {int 2}: integer notnull
  |     |       | {opt_as_alias}
  |     |         | {name SalesMovingAverage}
  |     | {select_from_etc}: TABLE { SalesInfo: SalesInfo }
  |       | {table_or_subquery_list}: TABLE { SalesInfo: SalesInfo }
  |       | | {table_or_subquery}: TABLE { SalesInfo: SalesInfo }
  |       |   | {name SalesInfo}: TABLE { SalesInfo: SalesInfo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE AB(
  a INTEGER,
  b TEXT
);

  {create_table_stmt}: AB: { a: integer, b: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name AB}
  | {col_key_list}
    | {col_def}: a: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name a}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: b: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name b}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE CD(
  c INTEGER,
  d TEXT
);

  {create_table_stmt}: CD: { c: integer, d: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name CD}
  | {col_key_list}
    | {col_def}: c: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name c}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: d: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name d}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE BA(
  b INTEGER,
  a TEXT
);

  {create_table_stmt}: BA: { b: integer, a: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name BA}
  | {col_key_list}
    | {col_def}: b: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name b}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: a: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name a}
            | {type_text}: text

The statement ending at line XXXX

DECLARE PROC use_c () (c INTEGER);

  {declare_proc_stmt}: use_c: { c: integer } dml_proc
  | {proc_name_type}
  | | {name use_c}: use_c: { c: integer } dml_proc
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: use_c: { c: integer }
      | {typed_name}: c: integer
        | {name c}
        | {type_int}: c: integer

The statement ending at line XXXX

CREATE PROC arg_bundle_1 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a) VALUES(a2.c);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_1}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            | {insert_list}
              | {dot}: a2_c: integer variable in
                | {name a2}
                | {name c}

The statement ending at line XXXX

CREATE PROC arg_bundle_2 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a) VALUES(a2.c);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_2}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            | {insert_list}
              | {dot}: a2_c: integer variable in
                | {name a2}
                | {name c}

The statement ending at line XXXX

CREATE PROC arg_bundle_3 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a) VALUES(a2.c);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_3}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            | {insert_list}
              | {dot}: a2_c: integer variable in
                | {name a2}
                | {name c}

The statement ending at line XXXX

CREATE PROC arg_bundle_4 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a, b) VALUES(a1.a, a1.b);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_4}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}
              | {dot}: a1_a: integer variable in
              | | {name a1}
              | | {name a}
              | {insert_list}
                | {dot}: a1_b: text variable in
                  | {name a1}
                  | {name b}

The statement ending at line XXXX

CREATE PROC arg_bundle_5 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a, b) VALUES(a1.b, a1.a);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0012: incompatible types in expression 'a'

  {create_proc_stmt}: err
  | {name arg_bundle_5}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}
              | {dot}: err
              | | {name a1}
              | | {name b}
              | {insert_list}
                | {dot}
                  | {name a1}
                  | {name a}

The statement ending at line XXXX

CREATE PROC arg_bundle_6 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(b, a) VALUES(a1.b, a1.a);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_6}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name b}: b: text
            |   | {name_list}
            |     | {name a}: a: integer
            | {insert_list}
              | {dot}: a1_b: text variable in
              | | {name a1}
              | | {name b}
              | {insert_list}
                | {dot}: a1_a: integer variable in
                  | {name a1}
                  | {name a}

The statement ending at line XXXX

CREATE PROC arg_bundle_7 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(a, b) VALUES(a2.c, a2.d);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_7}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {insert_stmt}: ok
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}
              | {dot}: a2_c: integer variable in
              | | {name a2}
              | | {name c}
              | {insert_list}
                | {dot}: a2_d: text variable in
                  | {name a2}
                  | {name d}

The statement ending at line XXXX

CREATE PROC arg_bundle_8 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(b, a) VALUES(a1.a, a1.b);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0009: incompatible types in expression 'b'

  {create_proc_stmt}: err
  | {name arg_bundle_8}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name b}: b: text
            |   | {name_list}
            |     | {name a}: a: integer
            | {insert_list}
              | {dot}: err
              | | {name a1}
              | | {name a}
              | {insert_list}
                | {dot}
                  | {name a1}
                  | {name b}

The statement ending at line XXXX

CREATE PROC arg_bundle_9 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  INSERT INTO AB(b, a) VALUES(a2.c, a2.d);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0009: incompatible types in expression 'b'

  {create_proc_stmt}: err
  | {name arg_bundle_9}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name AB}: AB: { a: integer, b: text }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name b}: b: text
            |   | {name_list}
            |     | {name a}: a: integer
            | {insert_list}
              | {dot}: err
              | | {name a2}
              | | {name c}
              | {insert_list}
                | {dot}
                  | {name a2}
                  | {name d}

The statement ending at line XXXX

CREATE PROC arg_bundle_10 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  FETCH C(a, b) FROM VALUES(a2.c, a2.d);
END;

  {create_proc_stmt}: ok
  | {name arg_bundle_10}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}: ok
              | {dot}: a2_c: integer variable in
              | | {name a2}
              | | {name c}
              | {insert_list}
                | {dot}: a2_d: text variable in
                  | {name a2}
                  | {name d}

The statement ending at line XXXX

CREATE PROC arg_bundle_11 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  FETCH C(a, b) FROM VALUES(a1.a, a1.b);
END;

  {create_proc_stmt}: ok
  | {name arg_bundle_11}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}: ok
              | {dot}: a1_a: integer variable in
              | | {name a1}
              | | {name a}
              | {insert_list}
                | {dot}: a1_b: text variable in
                  | {name a1}
                  | {name b}

The statement ending at line XXXX

CREATE PROC arg_bundle_12 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  FETCH C(a, b) FROM VALUES(a1.a, NULL);
END;

  {create_proc_stmt}: ok
  | {name arg_bundle_12}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {fetch_values_stmt}: ok
        | {name_columns_values}
          | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name a}: a: integer
            |   | {name_list}
            |     | {name b}: b: text
            | {insert_list}: ok
              | {dot}: a1_a: integer variable in
              | | {name a1}
              | | {name a}
              | {insert_list}
                | {null}: null

The statement ending at line XXXX

CREATE PROC arg_bundle_13 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  UPDATE CURSOR C(a, b) FROM VALUES(a1.a, a1.b);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_13}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {update_cursor_stmt}: ok
        | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name a}: a: integer
          |   | {name_list}
          |     | {name b}: b: text
          | {insert_list}: ok
            | {dot}: a1_a: integer variable in
            | | {name a1}
            | | {name a}
            | {insert_list}
              | {dot}: a1_b: text variable in
                | {name a1}
                | {name b}

The statement ending at line XXXX

CREATE PROC arg_bundle_14 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  UPDATE CURSOR C(a) FROM VALUES(a2.c);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_14}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {update_cursor_stmt}: ok
        | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name a}: a: integer
          | {insert_list}: ok
            | {dot}: a2_c: integer variable in
              | {name a2}
              | {name c}

The statement ending at line XXXX

CREATE PROC arg_bundle_15 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE AB;
  UPDATE CURSOR C(a, b) FROM VALUES(a2.c, a2.d);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_15}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: AB: { a: integer, b: text }
      |   | {like}: ok
      |     | {name AB}
      | {update_cursor_stmt}: ok
        | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name a}: a: integer
          |   | {name_list}
          |     | {name b}: b: text
          | {insert_list}: ok
            | {dot}: a2_c: integer variable in
            | | {name a2}
            | | {name c}
            | {insert_list}
              | {dot}: a2_d: text variable in
                | {name a2}
                | {name d}

The statement ending at line XXXX

CREATE PROC arg_bundle_16 (a1_a INTEGER, a1_b TEXT, a2_c INTEGER, a2_d TEXT)
BEGIN
  DECLARE C CURSOR LIKE a1;
  UPDATE CURSOR C(a, b) FROM VALUES(a2.c, a2.d);
END;

  {create_proc_stmt}: ok dml_proc
  | {name arg_bundle_16}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a1_a: integer variable in
    | | | {param_detail}: a1_a: integer variable in
    | |   | {name a1_a}: a1_a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: a1_b: text variable in
    |   | | {param_detail}: a1_b: text variable in
    |   |   | {name a1_b}: a1_b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: a2_c: integer variable in
    |     | | {param_detail}: a2_c: integer variable in
    |     |   | {name a2_c}: a2_c: integer variable in
    |     |   | {type_int}: integer
    |     | {params}
    |       | {param}: a2_d: text variable in
    |         | {param_detail}: a2_d: text variable in
    |           | {name a2_d}: a2_d: text variable in
    |           | {type_text}: text
    | {stmt_list}: ok
      | {declare_cursor_like_name}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
      | | {shape_def}: a1: AB: { a: integer, b: text } shape_storage
      |   | {like}: ok
      |     | {name a1}
      | {update_cursor_stmt}: ok
        | {name C}: C: AB: { a: integer, b: text } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name a}: a: integer
          |   | {name_list}
          |     | {name b}: b: text
          | {insert_list}: ok
            | {dot}: a2_c: integer variable in
            | | {name a2}
            | | {name c}
            | {insert_list}
              | {dot}: a2_d: text variable in
                | {name a2}
                | {name d}

The statement ending at line XXXX

CREATE VIRTUAL TABLE basic_virtual USING module_name (this, that, the_other) AS (
  id INTEGER,
  t TEXT
);

  {create_virtual_table_stmt}: basic_virtual: { id: integer, t: text } virtual @recreate
  | {module_info}
  | | {name module_name}
  | | {misc_attr_value_list}
  |   | {name this}
  |   | {misc_attr_value_list}
  |     | {name that}
  |     | {misc_attr_value_list}
  |       | {name the_other}
  | {create_table_stmt}: basic_virtual: { id: integer, t: text } virtual @recreate
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name basic_virtual}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

CREATE VIRTUAL TABLE broken_virtual_table USING module_name AS (
  id INTEGER,
  id INTEGER
);

test/sem_test.sql:XXXX:1: error: in str : CQL0142: duplicate column name 'id'

  {create_virtual_table_stmt}: err
  | {module_info}
  | | {name module_name}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name broken_virtual_table}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: id: integer
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name id}
              | {type_int}: integer

The statement ending at line XXXX

CREATE INDEX some_index ON basic_virtual (id);

test/sem_test.sql:XXXX:1: error: in str : CQL0159: cannot add an index to a virtual table 'basic_virtual'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name some_index}
  | | {name basic_virtual}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

CREATE TRIGGER no_triggers_on_virtual
  BEFORE DELETE ON basic_virtual
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0162: cannot add a trigger to a virtual table 'basic_virtual'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name no_triggers_on_virtual}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name basic_virtual}
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

ALTER TABLE basic_virtual ADD COLUMN xname TEXT;

test/sem_test.sql:XXXX:1: error: in str : CQL0164: cannot use ALTER TABLE on a virtual table 'basic_virtual'

  {alter_table_add_column_stmt}: err
  | {name basic_virtual}: basic_virtual: { id: integer, t: text } virtual @recreate
  | {col_def}
    | {col_def_type_attrs}
      | {col_def_name_type}
        | {name xname}
        | {type_text}

The statement ending at line XXXX

CREATE VIRTUAL TABLE deleting_virtual USING module_name (this, that, the_other) AS (
  id INTEGER,
  t TEXT
) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in version_annotation : CQL0392: when deleting a virtual table you must specify @delete(nn, cql:module_must_not_be_deleted_see_docs_for_CQL0392) as a reminder not to delete the module for this virtual table 'deleting_virtual'

  {create_virtual_table_stmt}: err
  | {module_info}
  | | {name module_name}
  | | {misc_attr_value_list}
  |   | {name this}
  |   | {misc_attr_value_list}
  |     | {name that}
  |     | {misc_attr_value_list}
  |       | {name the_other}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {delete_attr}
    | |   | {version_annotation}
    | |     | {int 1}
    | | {name deleting_virtual}
    | {col_key_list}
      | {col_def}
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}
      | {col_key_list}
        | {col_def}
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name t}
              | {type_text}

The statement ending at line XXXX

CREATE TABLE any_table_at_all(
  id INTEGER,
  t TEXT
) @CREATE(1, cql:module_must_not_be_deleted_see_docs_for_CQL0392);

test/sem_test.sql:XXXX:1: error: in dot : CQL0378: built-in migration procedure not valid in this context 'cql:module_must_not_be_deleted_see_docs_for_CQL0392'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}: err
  | |   | {version_annotation}
  | |     | {int 1}
  | |     | {dot}: err
  | |       | {name cql}
  | |       | {name module_must_not_be_deleted_see_docs_for_CQL0392}
  | | {name any_table_at_all}
  | {col_key_list}
    | {col_def}
    | | {col_def_type_attrs}
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}
    | {col_key_list}
      | {col_def}
        | {col_def_type_attrs}
          | {col_def_name_type}
            | {name t}
            | {type_text}

The statement ending at line XXXX

CREATE VIRTUAL TABLE deleting_virtual_correctly USING module_name (this, that, the_other) AS (
  id INTEGER,
  t TEXT
) @DELETE(1, cql:module_must_not_be_deleted_see_docs_for_CQL0392);

  {create_virtual_table_stmt}: deleting_virtual_correctly: { id: integer, t: text } deleted virtual @delete(1)
  | {module_info}
  | | {name module_name}
  | | {misc_attr_value_list}
  |   | {name this}
  |   | {misc_attr_value_list}
  |     | {name that}
  |     | {misc_attr_value_list}
  |       | {name the_other}
  | {create_table_stmt}: deleting_virtual_correctly: { id: integer, t: text } deleted virtual @delete(1)
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {delete_attr}
    | |   | {version_annotation}
    | |     | {int 1}
    | |     | {dot}: ok
    | |       | {name cql}
    | |       | {name module_must_not_be_deleted_see_docs_for_CQL0392}
    | | {name deleting_virtual_correctly}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@EMIT_ENUMS ints;

  {emit_enums_stmt}: ok
  | {name_list}
    | {name ints}

The statement ending at line XXXX

@EMIT_ENUMS bogus_enum_name;

test/sem_test.sql:XXXX:1: error: in str : CQL0169: enum not found 'bogus_enum_name'

  {emit_enums_stmt}: err
  | {name_list}
    | {name bogus_enum_name}

The statement ending at line XXXX

CREATE TABLE with_check_expr(
  v INTEGER,
  CHECK (v > 5)
);

  {create_table_stmt}: with_check_expr: { v: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: ok
        | {gt}: bool
          | {name v}: v: integer
          | {int 5}: integer notnull

The statement ending at line XXXX

CREATE TABLE with_check_expr_random(
  v INTEGER,
  CHECK (v > random())
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'random'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_random}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: err
        | {gt}: err
          | {name v}: v: integer
          | {call}: err
            | {name random}
            | {call_arg_list}
              | {call_filter_clause}

The statement ending at line XXXX

CREATE TABLE with_check_expr_changes(
  v INTEGER,
  CHECK (v > changes())
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'changes'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_changes}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: err
        | {gt}: err
          | {name v}: v: integer
          | {call}: err
            | {name changes}
            | {call_arg_list}
              | {call_filter_clause}

The statement ending at line XXXX

CREATE TABLE with_check_expr_udf(
  v INTEGER,
  CHECK (v > SqlUserFunc(1))
);

test/sem_test.sql:XXXX:1: error: in call : CQL0393: not deterministic user function cannot appear in a constraint expression  'SqlUserFunc'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_udf}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: err
        | {gt}: err
          | {name v}: v: integer
          | {call}: err
            | {name SqlUserFunc}
            | {call_arg_list}
              | {call_filter_clause}
              | {arg_list}: ok
                | {int 1}

The statement ending at line XXXX

SELECT random(5);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'random'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name random}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT random();

  {select_stmt}: select: { _anon: longint notnull }
  | {select_core_list}: select: { _anon: longint notnull }
  | | {select_core}: select: { _anon: longint notnull }
  |   | {select_expr_list_con}: select: { _anon: longint notnull }
  |     | {select_expr_list}: select: { _anon: longint notnull }
  |     | | {select_expr}: longint notnull
  |     |   | {call}: longint notnull
  |     |     | {name random}: longint notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT likely(TRUE);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {call}: bool notnull
  |     |     | {name likely}: bool notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {bool 1}: bool notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT likely(42);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name likely}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT likely();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'likely'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name likely}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET test := likely(TRUE);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'likely'

  {let_stmt}: err
  | {name test}
  | {call}: err
    | {name likely}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {bool 1}: bool notnull

The statement ending at line XXXX

CREATE TABLE with_check_expr_select(
  v INTEGER,
  CHECK (v > ( SELECT 5 ))
);

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0394: nested select expressions may not appear inside of a constraint expression

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_select}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: err
        | {gt}: err
          | {name v}: v: integer
          | {select_stmt}: err
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {select_expr}
            |     |   | {int 5}
            |     | {select_from_etc}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE with_check_expr_strftime(
  t TEXT CHECK(t > strftime('%s', 'now')) 
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'strftime'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_strftime}
  | {col_key_list}
    | {col_def}: t: text has_check
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name t}
        | | {type_text}: text
        | {col_attrs_check}: err
          | {gt}: err
            | {name t}: t: text has_check
            | {call}: err
              | {name strftime}
              | {call_arg_list}
                | {call_filter_clause}
                | {arg_list}: ok
                  | {strlit '%s'}: text notnull
                  | {arg_list}
                    | {strlit 'now'}: text notnull

The statement ending at line XXXX

CREATE TABLE with_check_expr_date(
  t TEXT CHECK(t > date('now')) 
);

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'date'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_check_expr_date}
  | {col_key_list}
    | {col_def}: t: text has_check
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name t}
        | | {type_text}: text
        | {col_attrs_check}: err
          | {gt}: err
            | {name t}: t: text has_check
            | {call}: err
              | {name date}
              | {call_arg_list}
                | {call_filter_clause}
                | {arg_list}: ok
                  | {strlit 'now'}: text notnull

The statement ending at line XXXX

CREATE TABLE with_bogus_check_expr(
  v INTEGER,
  CHECK (q > 5)
);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'q'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_bogus_check_expr}
  | {col_key_list}
    | {col_def}: v: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name v}
    |     | {type_int}: integer
    | {col_key_list}
      | {check_def}: err
        | {gt}: err
          | {name q}: err
          | {int 5}: integer notnull

The statement ending at line XXXX

DECLARE my_type TYPE TEXT @SENSITIVE;

  {declare_named_type}: text sensitive
  | {name my_type}: text sensitive
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE redundant_sensitive TEXT @SENSITIVE @SENSITIVE;

test/sem_test.sql:XXXX:1: error: in sensitive_attr : CQL0367: an attribute was specified twice '@sensitive'

  {declare_vars_type}: err
  | {name_list}
  | | {name redundant_sensitive}
  | {sensitive_attr}: err
    | {sensitive_attr}: text sensitive
      | {type_text}: text

The statement ending at line XXXX

DECLARE adding_notnull TEXT @SENSITIVE NOT NULL;

  {declare_vars_type}: text notnull sensitive
  | {name_list}: adding_notnull: text notnull variable init_required sensitive
  | | {name adding_notnull}: adding_notnull: text notnull variable init_required sensitive
  | {notnull}: text notnull sensitive
    | {sensitive_attr}: text sensitive
      | {type_text}: text

The statement ending at line XXXX

DECLARE FUNC adding_attr_to_func_redundant () CREATE TEXT @SENSITIVE @SENSITIVE;

test/sem_test.sql:XXXX:1: error: in sensitive_attr : CQL0367: an attribute was specified twice '@sensitive'

  {declare_func_stmt}: err
  | {name adding_attr_to_func_redundant}
  | {func_params_return}
    | {create_data_type}: err
      | {sensitive_attr}: err
        | {sensitive_attr}: text sensitive
          | {type_text}: text

The statement ending at line XXXX

DECLARE text_nn TYPE TEXT NOT NULL;

  {declare_named_type}: text notnull
  | {name text_nn}: text notnull
  | {notnull}: text notnull
    | {type_text}: text

The statement ending at line XXXX

DECLARE nn_var_redundant TEXT NOT NULL NOT NULL @SENSITIVE;

test/sem_test.sql:XXXX:1: error: in notnull : CQL0367: an attribute was specified twice 'not null'

  {declare_vars_type}: err
  | {name_list}
  | | {name nn_var_redundant}
  | {sensitive_attr}: err
    | {notnull}: err
      | {notnull}: text notnull
        | {type_text}: text

The statement ending at line XXXX

DECLARE nn_var_sens TEXT NOT NULL @SENSITIVE;

  {declare_vars_type}: text notnull sensitive
  | {name_list}: nn_var_sens: text notnull variable init_required sensitive
  | | {name nn_var_sens}: nn_var_sens: text notnull variable init_required sensitive
  | {sensitive_attr}: text notnull sensitive
    | {notnull}: text notnull
      | {type_text}: text

The statement ending at line XXXX

DECLARE my_type_1 TYPE TEXT @SENSITIVE;

  {declare_named_type}: text sensitive
  | {name my_type_1}: text sensitive
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE my_type_2 TYPE TEXT @SENSITIVE;

  {declare_named_type}: text sensitive
  | {name my_type_2}: text sensitive
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE my_type TYPE bogus_type;

test/sem_test.sql:XXXX:1: error: in str : CQL0360: unknown type 'bogus_type'

  {declare_named_type}: err
  | {name my_type}
  | {name bogus_type}: err

The statement ending at line XXXX

DECLARE my_type TYPE INTEGER;

test/sem_test.sql:XXXX:1: error: in declare_named_type : CQL0359: duplicate type declaration 'my_type'

  {declare_named_type}: err
  | {name my_type}: integer
  | {type_int}: integer

The statement ending at line XXXX

DECLARE my_var TEXT @SENSITIVE;

  {declare_vars_type}: text sensitive
  | {name_list}: my_var: text variable sensitive
  | | {name my_var}: my_var: text variable sensitive
  | {sensitive_attr}: text sensitive
    | {type_text}: text

The statement ending at line XXXX

DECLARE my_var bogus_type;

test/sem_test.sql:XXXX:1: error: in str : CQL0360: unknown type 'bogus_type'

  {declare_vars_type}: err
  | {name_list}
  | | {name my_var}
  | {name bogus_type}: err

The statement ending at line XXXX

CREATE PROC named_type ()
BEGIN
  DECLARE my_type TYPE INTEGER;
  DECLARE my_var INTEGER;
END;

  {create_proc_stmt}: ok
  | {name named_type}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_named_type}: integer
      | | {name my_type}: integer
      | | {type_int}: integer
      | {declare_vars_type}: integer
        | {name_list}: my_var: integer variable
        | | {name my_var}: my_var: integer variable
        | {type_int}: integer

The statement ending at line XXXX

DECLARE my_type_sens_not TYPE TEXT NOT NULL @SENSITIVE;

  {declare_named_type}: text notnull sensitive
  | {name my_type_sens_not}: text notnull sensitive
  | {sensitive_attr}: text notnull sensitive
    | {notnull}: text notnull
      | {type_text}: text

The statement ending at line XXXX

DECLARE PROC some_proc_with_an_arg_of_a_named_type (x TEXT @SENSITIVE);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc_with_an_arg_of_a_named_type}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x: text variable in sensitive
        | {param_detail}: x: text variable in sensitive
          | {name x}: x: text variable in sensitive
          | {sensitive_attr}: text sensitive
            | {type_text}: text

The statement ending at line XXXX

DECLARE PROC some_proc_with_an_arg_of_a_named_type (x TEXT @SENSITIVE);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name some_proc_with_an_arg_of_a_named_type}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x: text variable in sensitive
        | {param_detail}: x: text variable in sensitive
          | {name x}: x: text variable in sensitive
          | {sensitive_attr}: text sensitive
            | {type_text}: text

The statement ending at line XXXX

DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 TEXT @SENSITIVE;
  DECLARE some_group_var2 TEXT @SENSITIVE;
END;

  {declare_group_stmt}: ok
  | {name some_group_with_a_var_of_a_named_type}
  | {stmt_list}
    | {declare_vars_type}: text sensitive
    | | {name_list}: some_group_var1: text variable sensitive
    | | | {name some_group_var1}: some_group_var1: text variable sensitive
    | | {sensitive_attr}: text sensitive
    |   | {type_text}: text
    | {declare_vars_type}: text sensitive
      | {name_list}: some_group_var2: text variable sensitive
      | | {name some_group_var2}: some_group_var2: text variable sensitive
      | {sensitive_attr}: text sensitive
        | {type_text}: text

The statement ending at line XXXX

DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 my_type;
  DECLARE some_group_var2 TEXT @SENSITIVE;
END;

  {declare_group_stmt}: ok
  | {name some_group_with_a_var_of_a_named_type}
  | {stmt_list}
    | {declare_vars_type}
    | | {name_list}
    | | | {name some_group_var1}
    | | {name my_type}
    | {declare_vars_type}
      | {name_list}
      | | {name some_group_var2}
      | {sensitive_attr}
        | {type_text}

The statement ending at line XXXX

DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 TEXT @SENSITIVE;
  DECLARE some_group_var2 my_type;
END;

  {declare_group_stmt}: ok
  | {name some_group_with_a_var_of_a_named_type}
  | {stmt_list}
    | {declare_vars_type}
    | | {name_list}
    | | | {name some_group_var1}
    | | {sensitive_attr}
    |   | {type_text}
    | {declare_vars_type}
      | {name_list}
      | | {name some_group_var2}
      | {name my_type}

The statement ending at line XXXX

DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 some_bogus_named_type;
  DECLARE some_group_var2 TEXT @SENSITIVE;
END;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 ;
  DECLARE some_group_var2 TEXT @SENSITIVE;
END
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : DECLARE GROUP some_group_with_a_var_of_a_named_type
BEGIN
  DECLARE some_group_var1 TEXT @SENSITIVE;
  DECLARE some_group_var2 TEXT @SENSITIVE;
END
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : CQL0463: variable definitions do not match in group 'some_group_with_a_var_of_a_named_type'

  {declare_group_stmt}: err
  | {name some_group_with_a_var_of_a_named_type}
  | {stmt_list}
    | {declare_vars_type}
    | | {name_list}
    | | | {name some_group_var1}
    | | {name some_bogus_named_type}
    | {declare_vars_type}
      | {name_list}
      | | {name some_group_var2}
      | {sensitive_attr}
        | {type_text}

The statement ending at line XXXX

CREATE TABLE t(
  id TEXT @SENSITIVE NOT NULL
);

  {create_table_stmt}: t: { id: text notnull sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name t}
  | {col_key_list}
    | {col_def}: id: text notnull sensitive
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_text}: text
        | {sensitive_attr}: ok
          | {col_attrs_not_null}

The statement ending at line XXXX

CREATE TABLE t(
  id bogus_type
);

test/sem_test.sql:XXXX:1: error: in col_def_type_attrs : CQL0360: unknown type 'bogus_type'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name t}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: err
        | {col_def_name_type}
          | {name id}
          | {name bogus_type}

The statement ending at line XXXX

SELECT CAST(1 AS TEXT);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {cast_expr}: text notnull
  |     |     | {int 1}: integer notnull
  |     |     | {type_text}: text
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT CAST(1 AS bogus_type);

test/sem_test.sql:XXXX:1: error: in str : CQL0360: unknown type 'bogus_type'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {cast_expr}: err
  |     |     | {int 1}: integer notnull
  |     |     | {name bogus_type}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE PROC decl_type (label TEXT @SENSITIVE)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name decl_type}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: label: text variable in sensitive
        | {param_detail}: label: text variable in sensitive
          | {name label}: label: text variable in sensitive
          | {sensitive_attr}: text sensitive
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC decl_type_err (label bogus_type)
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0360: unknown type 'bogus_type'

  {create_proc_stmt}: err
  | {name decl_type_err}: err
  | {proc_params_stmts}
    | {params}: err
      | {param}: err
        | {param_detail}
          | {name label}
          | {name bogus_type}: err

The statement ending at line XXXX

DECLARE FUNC decl_type_func (arg1 INTEGER) TEXT @SENSITIVE;

  {declare_func_stmt}: text sensitive
  | {name decl_type_func}: text sensitive
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer variable in
    |   | {param_detail}: arg1: integer variable in
    |     | {name arg1}: arg1: integer variable in
    |     | {type_int}: integer
    | {sensitive_attr}: text sensitive
      | {type_text}: text

The statement ending at line XXXX

DECLARE FUNC decl_type_func_err (arg1 INTEGER) bogus_type;

test/sem_test.sql:XXXX:1: error: in str : CQL0360: unknown type 'bogus_type'

  {declare_func_stmt}: err
  | {name decl_type_func_err}
  | {func_params_return}
    | {params}: ok
    | | {param}: arg1: integer variable in
    |   | {param_detail}: arg1: integer variable in
    |     | {name arg1}: arg1: integer variable in
    |     | {type_int}: integer
    | {name bogus_type}: err

The statement ending at line XXXX

CREATE TABLE to_copy(
  f1 INTEGER,
  f2 INTEGER NOT NULL,
  f3 INTEGER NOT NULL @SENSITIVE,
  f4 INTEGER @SENSITIVE
);

  {create_table_stmt}: to_copy: { f1: integer, f2: integer notnull, f3: integer notnull sensitive, f4: integer sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name to_copy}
  | {col_key_list}
    | {col_def}: f1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name f1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull sensitive
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name f3}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        |     | {sensitive_attr}
        | {col_key_list}
          | {col_def}: f4: integer sensitive
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
              | | {name f4}
              | | {type_int}: integer
              | {sensitive_attr}: ok

The statement ending at line XXXX

CREATE TABLE the_copy(
  f1 INTEGER,
  f2 INTEGER NOT NULL,
  f3 INTEGER @SENSITIVE NOT NULL,
  f4 INTEGER @SENSITIVE
);

  {create_table_stmt}: the_copy: { f1: integer, f2: integer notnull, f3: integer notnull sensitive, f4: integer sensitive }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name the_copy}
  | {col_key_list}
    | {col_def}: f1: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name f1}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: f2: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name f2}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: f3: integer notnull sensitive
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name f3}
        |   | | {type_int}: integer
        |   | {sensitive_attr}: ok
        |     | {col_attrs_not_null}
        | {col_key_list}
          | {col_def}: f4: integer sensitive
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
              | | {name f4}
              | | {type_int}: integer
              | {sensitive_attr}: ok

The statement ending at line XXXX

CREATE PROC uses_complex_table_attrs (f1_ INTEGER, f2_ INTEGER NOT NULL, f3_ INTEGER NOT NULL @SENSITIVE, f4_ INTEGER @SENSITIVE)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name uses_complex_table_attrs}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: f1_: integer variable in
      | | {param_detail}: f1_: integer variable in
      |   | {name f1_}: f1_: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: f2_: integer notnull variable in
        | | {param_detail}: f2_: integer notnull variable in
        |   | {name f2_}: f2_: integer notnull variable in
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: f3_: integer notnull variable in sensitive
          | | {param_detail}: f3_: integer notnull variable in sensitive
          |   | {name f3_}: f3_: integer notnull variable in sensitive
          |   | {sensitive_attr}: integer notnull sensitive
          |     | {notnull}: integer notnull
          |       | {type_int}: integer
          | {params}
            | {param}: f4_: integer variable in sensitive
              | {param_detail}: f4_: integer variable in sensitive
                | {name f4_}: f4_: integer variable in sensitive
                | {sensitive_attr}: integer sensitive
                  | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC uses_complex_table_attrs (f1_ INTEGER, f2_ INTEGER NOT NULL, f3_ INTEGER NOT NULL @SENSITIVE, f4_ INTEGER @SENSITIVE);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name uses_complex_table_attrs}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: f1_: integer variable in
      | | {param_detail}: f1_: integer variable in
      |   | {name f1_}: f1_: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: f2_: integer notnull variable in
        | | {param_detail}: f2_: integer notnull variable in
        |   | {name f2_}: f2_: integer notnull variable in
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: f3_: integer notnull variable in sensitive
          | | {param_detail}: f3_: integer notnull variable in sensitive
          |   | {name f3_}: f3_: integer notnull variable in sensitive
          |   | {sensitive_attr}: integer notnull sensitive
          |     | {notnull}: integer notnull
          |       | {type_int}: integer
          | {params}
            | {param}: f4_: integer variable in sensitive
              | {param_detail}: f4_: integer variable in sensitive
                | {name f4_}: f4_: integer variable in sensitive
                | {sensitive_attr}: integer sensitive
                  | {type_int}: integer

The statement ending at line XXXX

DECLARE FUNC function_uses_complex_table_attrs (f1_ INTEGER, f2_ INTEGER NOT NULL, f3_ INTEGER NOT NULL @SENSITIVE, f4_ INTEGER @SENSITIVE) INTEGER;

  {declare_func_stmt}: integer
  | {name function_uses_complex_table_attrs}: integer
  | {func_params_return}
    | {params}: ok
    | | {param}: f1_: integer variable in
    | | | {param_detail}: f1_: integer variable in
    | |   | {name f1_}: f1_: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: f2_: integer notnull variable in
    |   | | {param_detail}: f2_: integer notnull variable in
    |   |   | {name f2_}: f2_: integer notnull variable in
    |   |   | {notnull}: integer notnull
    |   |     | {type_int}: integer
    |   | {params}
    |     | {param}: f3_: integer notnull variable in sensitive
    |     | | {param_detail}: f3_: integer notnull variable in sensitive
    |     |   | {name f3_}: f3_: integer notnull variable in sensitive
    |     |   | {sensitive_attr}: integer notnull sensitive
    |     |     | {notnull}: integer notnull
    |     |       | {type_int}: integer
    |     | {params}
    |       | {param}: f4_: integer variable in sensitive
    |         | {param_detail}: f4_: integer variable in sensitive
    |           | {name f4_}: f4_: integer variable in sensitive
    |           | {sensitive_attr}: integer sensitive
    |             | {type_int}: integer
    | {type_int}: integer

The statement ending at line XXXX

DECLARE complex_attr_cursor CURSOR LIKE to_copy;

  {declare_cursor_like_name}: complex_attr_cursor: to_copy: { f1: integer, f2: integer notnull, f3: integer notnull sensitive, f4: integer sensitive } variable shape_storage value_cursor
  | {name complex_attr_cursor}: complex_attr_cursor: to_copy: { f1: integer, f2: integer notnull, f3: integer notnull sensitive, f4: integer sensitive } variable shape_storage value_cursor
  | {shape_def}: to_copy: { f1: integer, f2: integer notnull, f3: integer notnull sensitive, f4: integer sensitive }
    | {like}: ok
      | {name to_copy}

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_sensitive () CREATE OBJECT @SENSITIVE;

  {declare_func_stmt}: object create_func sensitive
  | {name maybe_create_func_sensitive}: object create_func sensitive
  | {func_params_return}
    | {create_data_type}: object create_func sensitive
      | {sensitive_attr}: object sensitive
        | {type_object}: object

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_blob () CREATE BLOB NOT NULL;

  {declare_func_stmt}: blob notnull create_func
  | {name maybe_create_func_blob}: blob notnull create_func
  | {func_params_return}
    | {create_data_type}: blob notnull create_func
      | {notnull}: blob notnull
        | {type_blob}: blob

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_text () CREATE TEXT;

  {declare_func_stmt}: text create_func
  | {name maybe_create_func_text}: text create_func
  | {func_params_return}
    | {create_data_type}: text create_func
      | {type_text}: text

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_int () CREATE INTEGER;

test/sem_test.sql:XXXX:1: error: in create_data_type : CQL0361: return data type in a create function declaration can only be text, blob or object

  {declare_func_stmt}: err
  | {name maybe_create_func_int}
  | {func_params_return}
    | {create_data_type}: err
      | {type_int}: integer

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_bool () CREATE BOOL;

test/sem_test.sql:XXXX:1: error: in create_data_type : CQL0361: return data type in a create function declaration can only be text, blob or object

  {declare_func_stmt}: err
  | {name maybe_create_func_bool}
  | {func_params_return}
    | {create_data_type}: err
      | {type_bool}: bool

The statement ending at line XXXX

DECLARE FUNC maybe_create_func_long () CREATE LONG_INT NOT NULL @SENSITIVE;

test/sem_test.sql:XXXX:1: error: in create_data_type : CQL0361: return data type in a create function declaration can only be text, blob or object

  {declare_func_stmt}: err
  | {name maybe_create_func_long}
  | {func_params_return}
    | {create_data_type}: err
      | {sensitive_attr}: longint notnull sensitive
        | {notnull}: longint notnull
          | {type_long}: longint

The statement ending at line XXXX

DECLARE type_obj_foo TYPE OBJECT<Foo> NOT NULL @SENSITIVE;

  {declare_named_type}: object<Foo> notnull sensitive
  | {name type_obj_foo}: object<Foo> notnull sensitive
  | {sensitive_attr}: object<Foo> notnull sensitive
    | {notnull}: object<Foo> notnull
      | {type_object}: object<Foo>
        | {name Foo}

The statement ending at line XXXX

DECLARE FUNC type_func_return_create_obj () CREATE OBJECT<Foo> NOT NULL @SENSITIVE;

  {declare_func_stmt}: object<Foo> notnull create_func sensitive
  | {name type_func_return_create_obj}: object<Foo> notnull create_func sensitive
  | {func_params_return}
    | {create_data_type}: object<Foo> notnull create_func sensitive
      | {sensitive_attr}: object<Foo> notnull sensitive
        | {notnull}: object<Foo> notnull
          | {type_object}: object<Foo>
            | {name Foo}

The statement ending at line XXXX

DECLARE FUNC type_func_return_create_bogus_obj () CREATE bogus_type;

test/sem_test.sql:XXXX:1: error: in create_data_type : CQL0360: unknown type 'bogus_type'

  {declare_func_stmt}: err
  | {name type_func_return_create_bogus_obj}
  | {func_params_return}
    | {create_data_type}: err
      | {name bogus_type}

The statement ending at line XXXX

DECLARE FUNC type_func_return_obj () OBJECT<Foo> NOT NULL @SENSITIVE;

  {declare_func_stmt}: object<Foo> notnull sensitive
  | {name type_func_return_obj}: object<Foo> notnull sensitive
  | {func_params_return}
    | {sensitive_attr}: object<Foo> notnull sensitive
      | {notnull}: object<Foo> notnull
        | {type_object}: object<Foo>
          | {name Foo}

The statement ending at line XXXX

DECLARE my_enum_type TYPE INTEGER<ints> NOT NULL;

  {declare_named_type}: integer<ints> notnull
  | {name my_enum_type}: integer<ints> notnull
  | {notnull}: integer<ints> notnull
    | {type_int}: integer<ints>
      | {name ints}

The statement ending at line XXXX

DECLARE ENUM my_type INTEGER (
  negative_one = -1,
  postive_one = 1
);

test/sem_test.sql:XXXX:1: error: in declare_enum_stmt : CQL0359: duplicate type declaration 'my_type'

  {declare_enum_stmt}: err
  | {typed_name}: my_type: integer<my_type> notnull
  | | {name my_type}
  | | {type_int}: my_type: integer<my_type> notnull
  | {enum_values}
    | {enum_value}
    | | {name negative_one}: integer = -1 notnull
    | | {uminus}: integer notnull
    |   | {int 1}: integer notnull
    | {enum_values}
      | {enum_value}
        | {name postive_one}: integer = 1 notnull
        | {int 1}: integer notnull

The statement ending at line XXXX

DECLARE x1, x2, x3 INTEGER<x_coord>;

  {declare_vars_type}: integer<x_coord>
  | {name_list}: x1: integer<x_coord> variable was_set
  | | {name x1}: x1: integer<x_coord> variable was_set
  | | {name_list}: x2: integer<x_coord> variable
  |   | {name x2}: x2: integer<x_coord> variable
  |   | {name_list}: x3: integer<x_coord> variable
  |     | {name x3}: x3: integer<x_coord> variable
  | {type_int}: integer<x_coord>
    | {name x_coord}

The statement ending at line XXXX

DECLARE y1, y2, y3 INTEGER<y_coord>;

  {declare_vars_type}: integer<y_coord>
  | {name_list}: y1: integer<y_coord> variable
  | | {name y1}: y1: integer<y_coord> variable
  | | {name_list}: y2: integer<y_coord> variable
  |   | {name y2}: y2: integer<y_coord> variable
  |   | {name_list}: y3: integer<y_coord> variable
  |     | {name y3}: y3: integer<y_coord> variable
  | {type_int}: integer<y_coord>
    | {name y_coord}

The statement ending at line XXXX

SET x1 := y1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {name y1}: err

The statement ending at line XXXX

SET x1 := y1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {name y1}: err

The statement ending at line XXXX

SET x1 := x1 + y1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {add}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name y1}: err

The statement ending at line XXXX

SET x1 := x1 * 2;

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {mul}: integer<x_coord>
    | {name x1}: x1: integer<x_coord> variable was_set
    | {int 2}: integer notnull

The statement ending at line XXXX

SET x1 := x1 + x2;

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {add}: integer<x_coord>
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name x2}: x2: integer<x_coord> variable

The statement ending at line XXXX

DECLARE bb BOOL;

  {declare_vars_type}: bool
  | {name_list}: bb: bool variable was_set
  | | {name bb}: bb: bool variable was_set
  | {type_bool}: bool

The statement ending at line XXXX

SET bb := x1 = x2;

  {assign}: bb: bool variable was_set
  | {name bb}: bb: bool variable was_set
  | {eq}: bool
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name x2}: x2: integer<x_coord> variable

The statement ending at line XXXX

SET bb := x1 < x2;

  {assign}: bb: bool variable was_set
  | {name bb}: bb: bool variable was_set
  | {lt}: bool
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name x2}: x2: integer<x_coord> variable

The statement ending at line XXXX

SET bb := x1 = y1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name bb}: bb: bool variable was_set
  | {eq}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name y1}: err

The statement ending at line XXXX

SET bb := x1 < y1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name bb}: bb: bool variable was_set
  | {lt}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {name y1}: err

The statement ending at line XXXX

DECLARE _x TYPE INTEGER<x_coord>;

  {declare_named_type}: integer<x_coord>
  | {name _x}: integer<x_coord>
  | {type_int}: integer<x_coord>
    | {name x_coord}

The statement ending at line XXXX

DECLARE _y TYPE INTEGER<y_coord>;

  {declare_named_type}: integer<y_coord>
  | {name _y}: integer<y_coord>
  | {type_int}: integer<y_coord>
    | {name y_coord}

The statement ending at line XXXX

DECLARE x4 INTEGER<x_coord>;

  {declare_vars_type}: integer<x_coord>
  | {name_list}: x4: integer<x_coord> variable
  | | {name x4}: x4: integer<x_coord> variable
  | {type_int}: integer<x_coord>
    | {name x_coord}

The statement ending at line XXXX

SET x1 := x4;

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {name x4}: x4: integer<x_coord> variable

The statement ending at line XXXX

CREATE TABLE xy(
  x INTEGER<x_coord>,
  y INTEGER<y_coord>
);

  {create_table_stmt}: xy: { x: integer<x_coord>, y: integer<y_coord> }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name xy}
  | {col_key_list}
    | {col_def}: x: integer<x_coord>
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer<x_coord>
    |       | {name x_coord}
    | {col_key_list}
      | {col_def}: y: integer<y_coord>
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name y}
            | {type_int}: integer<y_coord>
              | {name y_coord}

The statement ending at line XXXX

INSERT INTO xy(x, y) VALUES(x1, y1);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {insert_list}
        | {name x1}: x1: integer<x_coord> variable was_set
        | {insert_list}
          | {name y1}: y1: integer<y_coord> variable

The statement ending at line XXXX

INSERT INTO xy(x, y) VALUES(y1, x1);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {insert_list}
        | {name y1}: err
        | {insert_list}
          | {name x1}

The statement ending at line XXXX

INSERT INTO xy(x, y) SELECT xy.x, xy.y
  FROM xy
  WHERE xy.x = 1;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {select_stmt}: select: { x: integer<x_coord>, y: integer<y_coord> }
        | {select_core_list}: select: { x: integer<x_coord>, y: integer<y_coord> }
        | | {select_core}: select: { x: integer<x_coord>, y: integer<y_coord> }
        |   | {select_expr_list_con}: select: { x: integer<x_coord>, y: integer<y_coord> }
        |     | {select_expr_list}: select: { x: integer<x_coord>, y: integer<y_coord> }
        |     | | {select_expr}: x: integer<x_coord>
        |     | | | {dot}: x: integer<x_coord>
        |     | |   | {name xy}
        |     | |   | {name x}
        |     | | {select_expr_list}
        |     |   | {select_expr}: y: integer<y_coord>
        |     |     | {dot}: y: integer<y_coord>
        |     |       | {name xy}
        |     |       | {name y}
        |     | {select_from_etc}: TABLE { xy: xy }
        |       | {table_or_subquery_list}: TABLE { xy: xy }
        |       | | {table_or_subquery}: TABLE { xy: xy }
        |       |   | {name xy}: TABLE { xy: xy }
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: x: integer<x_coord>
        |         |   | | {name xy}
        |         |   | | {name x}
        |         |   | {int 1}: integer notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO xy(x, y) SELECT xy.y, xy.x
  FROM xy
  WHERE xy.x = 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'y_coord' vs. 'x_coord'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: err
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {select_stmt}: select: { y: integer<y_coord>, x: integer<x_coord> }
        | {select_core_list}: select: { y: integer<y_coord>, x: integer<x_coord> }
        | | {select_core}: select: { y: integer<y_coord>, x: integer<x_coord> }
        |   | {select_expr_list_con}: select: { y: integer<y_coord>, x: integer<x_coord> }
        |     | {select_expr_list}: select: { y: integer<y_coord>, x: integer<x_coord> }
        |     | | {select_expr}: y: integer<y_coord>
        |     | | | {dot}: y: integer<y_coord>
        |     | |   | {name xy}
        |     | |   | {name y}
        |     | | {select_expr_list}
        |     |   | {select_expr}: x: integer<x_coord>
        |     |     | {dot}: x: integer<x_coord>
        |     |       | {name xy}
        |     |       | {name x}
        |     | {select_from_etc}: TABLE { xy: xy }
        |       | {table_or_subquery_list}: TABLE { xy: xy }
        |       | | {table_or_subquery}: TABLE { xy: xy }
        |       |   | {name xy}: TABLE { xy: xy }
        |       | {select_where}
        |         | {opt_where}: bool
        |         | | {eq}: bool
        |         |   | {dot}: x: integer<x_coord>
        |         |   | | {name xy}
        |         |   | | {name x}
        |         |   | {int 1}: integer notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

SELECT x1 AS x, y1 AS y
UNION ALL
SELECT x2 AS x, y2 AS y;

  {select_stmt}: UNION ALL: { x: integer<x_coord>, y: integer<y_coord> }
  | {select_core_list}: UNION ALL: { x: integer<x_coord>, y: integer<y_coord> }
  | | {select_core}: select: { x: integer<x_coord> variable was_set, y: integer<y_coord> variable }
  | | | {select_expr_list_con}: select: { x: integer<x_coord> variable was_set, y: integer<y_coord> variable }
  | |   | {select_expr_list}: select: { x: integer<x_coord> variable was_set, y: integer<y_coord> variable }
  | |   | | {select_expr}: x: integer<x_coord> variable was_set
  | |   | | | {name x1}: x1: integer<x_coord> variable was_set
  | |   | | | {opt_as_alias}
  | |   | |   | {name x}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: y: integer<y_coord> variable
  | |   |     | {name y1}: y1: integer<y_coord> variable
  | |   |     | {opt_as_alias}
  | |   |       | {name y}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: select: { x: integer<x_coord> variable, y: integer<y_coord> variable }
  |     | {select_core}: select: { x: integer<x_coord> variable, y: integer<y_coord> variable }
  |       | {select_expr_list_con}: select: { x: integer<x_coord> variable, y: integer<y_coord> variable }
  |         | {select_expr_list}: select: { x: integer<x_coord> variable, y: integer<y_coord> variable }
  |         | | {select_expr}: x: integer<x_coord> variable
  |         | | | {name x2}: x2: integer<x_coord> variable
  |         | | | {opt_as_alias}
  |         | |   | {name x}
  |         | | {select_expr_list}
  |         |   | {select_expr}: y: integer<y_coord> variable
  |         |     | {name y2}: y2: integer<y_coord> variable
  |         |     | {opt_as_alias}
  |         |       | {name y}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT x1 AS x, y1 AS y
UNION ALL
SELECT y2 AS x, x2 AS y;

test/sem_test.sql:XXXX:1: error: in select_core : CQL0070: expressions of different kinds can't be mixed: 'y_coord' vs. 'x_coord'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  | | | {select_expr_list_con}: select: { x: integer<x_coord> variable was_set, y: integer<y_coord> variable }
  | |   | {select_expr_list}: select: { x: integer<x_coord> variable was_set, y: integer<y_coord> variable }
  | |   | | {select_expr}: x: integer<x_coord> variable was_set
  | |   | | | {name x1}: x1: integer<x_coord> variable was_set
  | |   | | | {opt_as_alias}
  | |   | |   | {name x}
  | |   | | {select_expr_list}
  | |   |   | {select_expr}: y: integer<y_coord> variable
  | |   |     | {name y1}: y1: integer<y_coord> variable
  | |   |     | {opt_as_alias}
  | |   |       | {name y}
  | |   | {select_from_etc}: ok
  | |     | {select_where}
  | |       | {select_groupby}
  | |         | {select_having}
  | | {select_core_compound}
  |   | {int 2}
  |   | {select_core_list}: err
  |     | {select_core}: select: { x: integer<y_coord> variable, y: integer<x_coord> variable }
  |       | {select_expr_list_con}: select: { x: integer<y_coord> variable, y: integer<x_coord> variable }
  |         | {select_expr_list}: select: { x: integer<y_coord> variable, y: integer<x_coord> variable }
  |         | | {select_expr}: x: integer<y_coord> variable
  |         | | | {name y2}: y2: integer<y_coord> variable
  |         | | | {opt_as_alias}
  |         | |   | {name x}
  |         | | {select_expr_list}
  |         |   | {select_expr}: y: integer<x_coord> variable
  |         |     | {name x2}: x2: integer<x_coord> variable
  |         |     | {opt_as_alias}
  |         |       | {name y}
  |         | {select_from_etc}: ok
  |           | {select_where}
  |             | {select_groupby}
  |               | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

INSERT INTO xy(x, y) VALUES(x1, y1), (x2, y2);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {select_stmt}: values: { column1: integer, column2: integer }
        | {select_core_list}: values: { column1: integer, column2: integer }
        | | {select_core}: values: { column1: integer, column2: integer }
        |   | {select_values}
        |   | {values}: values: { column1: integer, column2: integer }
        |     | {insert_list}: ok
        |     | | {name x1}: x1: integer<x_coord> variable was_set
        |     | | {insert_list}
        |     |   | {name y1}: y1: integer<y_coord> variable
        |     | {values}
        |       | {insert_list}: ok
        |         | {name x2}: x2: integer<x_coord> variable
        |         | {insert_list}
        |           | {name y2}: y2: integer<y_coord> variable
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO xy(x, y) VALUES(x1, y1), (y2, x2), (x3, y3);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name xy}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {select_stmt}: values: { column1: integer, column2: integer }
        | {select_core_list}: values: { column1: integer, column2: integer }
        | | {select_core}: values: { column1: integer, column2: integer }
        |   | {select_values}
        |   | {values}: values: { column1: integer, column2: integer }
        |     | {insert_list}: ok
        |     | | {name x1}: x1: integer<x_coord> variable was_set
        |     | | {insert_list}
        |     |   | {name y1}: y1: integer<y_coord> variable
        |     | {values}
        |       | {insert_list}: ok
        |       | | {name y2}: err
        |       | | {insert_list}
        |       |   | {name x2}: x2: integer<x_coord> variable
        |       | {values}
        |         | {insert_list}: ok
        |           | {name x3}: x3: integer<x_coord> variable
        |           | {insert_list}
        |             | {name y3}: y3: integer<y_coord> variable
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE xy_curs CURSOR LIKE xy;

  {declare_cursor_like_name}: xy_curs: xy: { x: integer<x_coord>, y: integer<y_coord> } variable shape_storage value_cursor
  | {name xy_curs}: xy_curs: xy: { x: integer<x_coord>, y: integer<y_coord> } variable shape_storage value_cursor
  | {shape_def}: xy: { x: integer<x_coord>, y: integer<y_coord> }
    | {like}: ok
      | {name xy}

The statement ending at line XXXX

FETCH xy_curs(x, y) FROM VALUES(x1, y1);

  {fetch_values_stmt}: ok
  | {name_columns_values}
    | {name xy_curs}: xy_curs: xy: { x: integer<x_coord>, y: integer<y_coord> } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: x: integer<x_coord>
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {insert_list}: ok
        | {name x1}: x1: integer<x_coord> variable was_set
        | {insert_list}
          | {name y1}: y1: integer<y_coord> variable

The statement ending at line XXXX

FETCH xy_curs(x, y) FROM VALUES(y1, x1);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'y_coord' vs. 'x_coord'

  {fetch_values_stmt}: err
  | {name_columns_values}
    | {name xy_curs}: xy_curs: xy: { x: integer<x_coord>, y: integer<y_coord> } variable shape_storage value_cursor
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name x}: err
      |   | {name_list}
      |     | {name y}: y: integer<y_coord>
      | {insert_list}: ok
        | {name y1}: y1: integer<y_coord> variable
        | {insert_list}
          | {name x1}

The statement ending at line XXXX

DECLARE v1, v2, v3 INTEGER<v>;

  {declare_vars_type}: integer<v>
  | {name_list}: v1: integer<v> variable was_set
  | | {name v1}: v1: integer<v> variable was_set
  | | {name_list}: v2: integer<v> variable
  |   | {name v2}: v2: integer<v> variable
  |   | {name_list}: v3: integer<v> variable
  |     | {name v3}: v3: integer<v> variable
  | {type_int}: integer<v>
    | {name v}

The statement ending at line XXXX

SET x1 := CASE WHEN 1 THEN x1
ELSE x1
END;

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {case_expr}: integer<x_coord>
    | {connector}: integer<x_coord>
      | {case_list}: integer<x_coord> variable was_set
      | | {when}: x1: integer<x_coord> variable was_set
      |   | {int 1}: integer notnull
      |   | {name x1}: x1: integer<x_coord> variable was_set
      | {name x1}: x1: integer<x_coord> variable was_set

The statement ending at line XXXX

SET x1 := CASE WHEN 1 THEN x1
ELSE y1
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {case_expr}: err
    | {connector}
      | {case_list}: integer<x_coord> variable was_set
      | | {when}: x1: integer<x_coord> variable was_set
      |   | {int 1}: integer notnull
      |   | {name x1}: x1: integer<x_coord> variable was_set
      | {name y1}: err

The statement ending at line XXXX

SET v1 := CASE x1 WHEN x2 THEN v1
ELSE v2
END;

  {assign}: v1: integer<v> variable was_set
  | {name v1}: v1: integer<v> variable was_set
  | {case_expr}: integer<v>
    | {name x1}: x1: integer<x_coord> variable was_set
    | {connector}: integer<v>
      | {case_list}: integer<v> variable
      | | {when}: v1: integer<v> variable
      |   | {name x2}: x2: integer<x_coord> variable
      |   | {name v1}: v1: integer<v> variable
      | {name v2}: v2: integer<v> variable

The statement ending at line XXXX

SET v1 := CASE x1 WHEN x2 THEN v1
WHEN y1 THEN v2
ELSE v3
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name v1}: v1: integer<v> variable was_set
  | {case_expr}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {connector}
      | {case_list}: err
      | | {when}: v1: integer<v> variable was_set
      | | | {name x2}: x2: integer<x_coord> variable
      | | | {name v1}: v1: integer<v> variable was_set
      | | {case_list}: err
      |   | {when}
      |     | {name y1}: err
      |     | {name v2}
      | {name v3}

The statement ending at line XXXX

DECLARE b0 BOOL;

  {declare_vars_type}: bool
  | {name_list}: b0: bool variable was_set
  | | {name b0}: b0: bool variable was_set
  | {type_bool}: bool

The statement ending at line XXXX

SET b0 := x1 IN (x1, x2, x3);

  {assign}: b0: bool variable was_set
  | {name b0}: b0: bool variable was_set
  | {in_pred}: bool
    | {name x1}: x1: integer<x_coord> variable was_set
    | {expr_list}: x1: integer<x_coord> variable was_set
      | {name x1}: x1: integer<x_coord> variable was_set
      | {expr_list}: x2: integer<x_coord> variable
        | {name x2}: x2: integer<x_coord> variable
        | {expr_list}: x3: integer<x_coord> variable
          | {name x3}: x3: integer<x_coord> variable

The statement ending at line XXXX

SET b0 := x1 IN (x1, y2, x3);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name b0}: b0: bool variable was_set
  | {in_pred}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {expr_list}: x1: integer<x_coord> variable was_set
      | {name x1}: x1: integer<x_coord> variable was_set
      | {expr_list}: y2: integer<y_coord> variable
        | {name y2}: err
        | {expr_list}
          | {name x3}

The statement ending at line XXXX

SET b0 := ( SELECT x1 IN (SELECT x2) );

  {assign}: b0: bool variable was_set
  | {name b0}: b0: bool variable was_set
  | {select_stmt}: _anon: bool
    | {select_core_list}: select: { _anon: bool }
    | | {select_core}: select: { _anon: bool }
    |   | {select_expr_list_con}: select: { _anon: bool }
    |     | {select_expr_list}: select: { _anon: bool }
    |     | | {select_expr}: bool
    |     |   | {in_pred}: bool
    |     |     | {name x1}: x1: integer<x_coord> variable was_set
    |     |     | {select_stmt}: x2: integer<x_coord> variable
    |     |       | {select_core_list}: select: { x2: integer<x_coord> variable }
    |     |       | | {select_core}: select: { x2: integer<x_coord> variable }
    |     |       |   | {select_expr_list_con}: select: { x2: integer<x_coord> variable }
    |     |       |     | {select_expr_list}: select: { x2: integer<x_coord> variable }
    |     |       |     | | {select_expr}: x2: integer<x_coord> variable
    |     |       |     |   | {name x2}: x2: integer<x_coord> variable
    |     |       |     | {select_from_etc}: ok
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET b0 := ( SELECT x1 IN (SELECT y1) );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name b0}: b0: bool variable was_set
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {in_pred}: err
    |     |     | {name x1}: x1: integer<x_coord> variable was_set
    |     |     | {select_stmt}: err
    |     |       | {select_core_list}: select: { y1: integer<y_coord> variable }
    |     |       | | {select_core}: select: { y1: integer<y_coord> variable }
    |     |       |   | {select_expr_list_con}: select: { y1: integer<y_coord> variable }
    |     |       |     | {select_expr_list}: select: { y1: integer<y_coord> variable }
    |     |       |     | | {select_expr}: y1: integer<y_coord> variable
    |     |       |     |   | {name y1}: y1: integer<y_coord> variable
    |     |       |     | {select_from_etc}: ok
    |     |       |       | {select_where}
    |     |       |         | {select_groupby}
    |     |       |           | {select_having}
    |     |       | {select_orderby}
    |     |         | {select_limit}
    |     |           | {select_offset}
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET b0 := BETWEEN REWRITE _between_0_ := x1 CHECK (_between_0_ >= x2 AND _between_0_ <= x3);

  {assign}: b0: bool variable was_set
  | {name b0}: b0: bool variable was_set
  | {between_rewrite}: bool
    | {name x1}: x1: integer<x_coord> variable was_set
    | {range}
      | {name _between_0_}: _between_0_: integer variable was_set
      | {and}: bool
        | {ge}: bool
        | | {name _between_0_}: _between_0_: integer variable was_set
        | | {name x2}: x2: integer<x_coord> variable
        | {le}: bool
          | {name _between_0_}: _between_0_: integer variable was_set
          | {name x3}: x3: integer<x_coord> variable

The statement ending at line XXXX

SET b0 := x1 BETWEEN y2 AND 12;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name b0}: b0: bool variable was_set
  | {between}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {range}
      | {name y2}: err
      | {int 12}: integer notnull

The statement ending at line XXXX

SET b0 := x1 BETWEEN 34 AND y3;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name b0}: b0: bool variable was_set
  | {between}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {range}
      | {int 34}: integer notnull
      | {name y3}: err

The statement ending at line XXXX

SET b0 := 56 BETWEEN x2 AND y3;

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name b0}: b0: bool variable was_set
  | {between}: err
    | {int 56}: integer notnull
    | {range}
      | {name x2}: x2: integer<x_coord> variable
      | {name y3}: err

The statement ending at line XXXX

SET x1 := -x2;

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {uminus}: integer<x_coord>
    | {name x2}: x2: integer<x_coord> variable

The statement ending at line XXXX

SET x1 := -y1;

test/sem_test.sql:XXXX:1: error: in uminus : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {uminus}: err
    | {name y1}: y1: integer<y_coord> variable

The statement ending at line XXXX

SET x1 := coalesce(x1, x2, x3);

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {call}: integer<x_coord>
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name x1}: x1: integer<x_coord> variable was_set
        | {arg_list}
          | {name x2}: x2: integer<x_coord> variable
          | {arg_list}
            | {name x3}: x3: integer<x_coord> variable

The statement ending at line XXXX

SET x1 := coalesce(x1, y2, x3);

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {call}: err
    | {name coalesce}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name x1}: x1: integer<x_coord> variable was_set
        | {arg_list}
          | {name y2}: err
          | {arg_list}
            | {name x3}: x3: integer<x_coord> variable

The statement ending at line XXXX

SET x1 := CAST(y1 AS INTEGER<x_coord>);

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {cast_expr}: integer<x_coord>
    | {name y1}: y1: integer<y_coord> variable
    | {type_int}: integer<x_coord>
      | {name x_coord}

The statement ending at line XXXX

SET x1 := CAST(y1 AS INTEGER<x_coord>);

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {cast_expr}: integer<x_coord>
    | {name y1}: y1: integer<y_coord> variable
    | {type_int}: integer<x_coord>
      | {name x_coord}

The statement ending at line XXXX

SET x1 := CAST(y1 AS INTEGER);

  {assign}: x1: integer<x_coord> variable was_set
  | {name x1}: x1: integer<x_coord> variable was_set
  | {cast_expr}: integer
    | {name y1}: y1: integer<y_coord> variable
    | {type_int}: integer

The statement ending at line XXXX

SET x1 := CAST(x1 AS INTEGER<y_coord>);

test/sem_test.sql:XXXX:1: error: in cast_expr : CQL0070: expressions of different kinds can't be mixed: 'x_coord' vs. 'y_coord'

  {assign}: err
  | {name x1}: x1: integer<x_coord> variable was_set
  | {cast_expr}: err
    | {name x1}: x1: integer<x_coord> variable was_set
    | {type_int}: integer<y_coord>
      | {name y_coord}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive)
SELECT *
  FROM foo;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0328: vault_sensitive attribute may only be added to a create procedure statement

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name vault_sensitive}
  | {select_stmt}: err
    | {select_core_list}
    | | {select_core}
    |   | {select_expr_list_con}
    |     | {select_expr_list}
    |     | | {star}
    |     | {select_from_etc}
    |       | {table_or_subquery_list}
    |       | | {table_or_subquery}
    |       |   | {name foo}
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(bogus, nan))
CREATE PROC vault_sensitive_with_invalid_values ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'bogus'
test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'nan'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name bogus}: ok
  |     | {misc_attr_value_list}
  |       | {name nan}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_invalid_values}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, rate))
CREATE PROC vault_sensitive_with_valid_values ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {name rate}: ok
  | {create_proc_stmt}: vault_sensitive_with_valid_values: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name vault_sensitive_with_valid_values}: vault_sensitive_with_valid_values: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=bogus)
CREATE PROC vault_sensitive_with_invalid_single_column ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'bogus'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {name bogus}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_invalid_single_column}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=1)
CREATE PROC vault_sensitive_with_not_string_value_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {int 1}: err
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_not_string_value_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, 1, 'lol'))
CREATE PROC vault_sensitive_with_not_strings_value_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {int 1}: err
  |       | {misc_attr_value_list}
  |         | {strlit 'lol'}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_not_strings_value_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive='lol')
CREATE PROC vault_sensitive_with_lit_string_value_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {strlit 'lol'}: err
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_lit_string_value_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(bogus, (nan)))
CREATE PROC vault_sensitive_with_invalid_encode_context_columns ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'bogus'
test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'nan'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name bogus}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name nan}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_invalid_encode_context_columns}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(1, (name)))
CREATE PROC vault_sensitive_with_not_string_vault_context_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {int 1}: err
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name name}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_not_string_vault_context_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=('lol', (name)))
CREATE PROC vault_sensitive_with_literal_string_vault_context_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {strlit 'lol'}: err
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name name}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_literal_string_vault_context_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (1)))
CREATE PROC vault_sensitive_with_not_string_vault_column_proc_val ()
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {int 1}: err
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_not_string_vault_column_proc_val}
    | {proc_params_stmts}

The statement ending at line XXXX

CREATE TABLE bar_with_sensitive(
  id INTEGER NOT NULL,
  name TEXT @SENSITIVE @CREATE(2),
  title TEXT @SENSITIVE @CREATE(2),
  intro TEXT @CREATE(2)
);

  {create_table_stmt}: bar_with_sensitive: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name bar_with_sensitive}
  | {col_key_list}
    | {col_def}: id: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: name: text sensitive @create(2)
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name name}
      |   | | {type_text}: text
      |   | {sensitive_attr}: ok
      |     | {create_attr}
      |       | {version_annotation}
      |         | {int 2}
      | {col_key_list}
        | {col_def}: title: text sensitive @create(2)
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name title}
        |   | | {type_text}: text
        |   | {sensitive_attr}: ok
        |     | {create_attr}
        |       | {version_annotation}
        |         | {int 2}
        | {col_key_list}
          | {col_def}: intro: text @create(2)
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
              | | {name intro}
              | | {type_text}: text
              | {create_attr}: ok
                | {version_annotation}
                  | {int 2}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (id, title)))
CREATE PROC vault_sensitive_with_sensitive_encode_context_column_proc_val ()
BEGIN
  SELECT *
    FROM bar_with_sensitive;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0400: encode context column can't be sensitive 'name'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name id}: ok
  |         | {misc_attr_value_list}
  |           | {name title}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_sensitive_encode_context_column_proc_val}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          | {select_core_list}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          | | {select_core}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | {select_expr_list}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | | {star}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | {select_from_etc}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | {table_or_subquery_list}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | | {table_or_subquery}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       |   | {name bar_with_sensitive}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(intro, (id, (title))))
CREATE PROC vault_sensitive_with_invalid_nested_vault_column_proc_val ()
BEGIN
  SELECT *
    FROM bar_with_sensitive;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0363: all arguments must be names 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name intro}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name id}: ok
  |         | {misc_attr_value_list}
  |           | {misc_attr_value_list}: err
  |             | {name title}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_invalid_nested_vault_column_proc_val}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name bar_with_sensitive}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(intro, (name), id))
CREATE PROC vault_sensitive_with_multi_encode_context_columns_proc_val ()
BEGIN
  SELECT *
    FROM bar_with_sensitive;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0408: encode context column can be only specified once 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name intro}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |       | | {name name}: ok
  |       | {misc_attr_value_list}
  |         | {name id}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_multi_encode_context_columns_proc_val}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name bar_with_sensitive}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(intro, (name, title)))
CREATE PROC vault_sensitive_with_valid_context_and_encode_columns ()
BEGIN
  SELECT *
    FROM bar_with_sensitive;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name intro}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name name}: ok
  |         | {misc_attr_value_list}
  |           | {name title}: ok
  | {create_proc_stmt}: vault_sensitive_with_valid_context_and_encode_columns: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text } dml_proc
    | {name vault_sensitive_with_valid_context_and_encode_columns}: vault_sensitive_with_valid_context_and_encode_columns: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          | {select_core_list}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          | | {select_core}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | {select_expr_list}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | | {star}: select: { id: integer notnull, name: text sensitive, title: text sensitive, intro: text }
          |     | {select_from_etc}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | {table_or_subquery_list}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | | {table_or_subquery}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       |   | {name bar_with_sensitive}: TABLE { bar_with_sensitive: bar_with_sensitive }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT COLUMN;

  {enforce_strict_stmt}: ok
  | {int 13}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, rate))
CREATE PROC vault_sensitive_with_only_encode_columns_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0401: context column must be specified if strict encode context column mode is enabled 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_only_encode_columns_strict_mode}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name bar}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=name)
CREATE PROC vault_sensitive_with_only_encode_column_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0401: context column must be specified if strict encode context column mode is enabled 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {name name}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_only_encode_column_strict_mode}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name bar}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_sensitive_with_no_columns_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0401: context column must be specified if strict encode context column mode is enabled 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name vault_sensitive}
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_no_columns_strict_mode}
    | {proc_params_stmts}
      | {stmt_list}
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name bar}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(id, (name)))
CREATE PROC vault_sensitive_with_integer_encode_context ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name id}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name name}: ok
  | {create_proc_stmt}: vault_sensitive_with_integer_encode_context: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name vault_sensitive_with_integer_encode_context}: vault_sensitive_with_integer_encode_context: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE INTEGER;

  {enforce_strict_stmt}: ok
  | {int 14}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_encode_context_integer_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_encode_context_integer_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE INTEGER;

  {enforce_normal_stmt}: ok
  | {int 14}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE LONG_INTEGER;

  {enforce_strict_stmt}: ok
  | {int 15}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_encode_context_long_integer_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_encode_context_long_integer_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE LONG_INTEGER;

  {enforce_normal_stmt}: ok
  | {int 15}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE REAL;

  {enforce_strict_stmt}: ok
  | {int 16}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_encode_context_real_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_encode_context_real_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE REAL;

  {enforce_normal_stmt}: ok
  | {int 16}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE BOOL;

  {enforce_strict_stmt}: ok
  | {int 17}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_encode_context_bool_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_encode_context_bool_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE BOOL;

  {enforce_normal_stmt}: ok
  | {int 17}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE BLOB;

  {enforce_strict_stmt}: ok
  | {int 19}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_encode_context_blob_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_encode_context_blob_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE BLOB;

  {enforce_normal_stmt}: ok
  | {int 19}

The statement ending at line XXXX

@ENFORCE_STRICT ENCODE CONTEXT TYPE TEXT;

  {enforce_strict_stmt}: ok
  | {int 18}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(id, (name, rate)))
CREATE PROC vault_sensitive_with_integer_encode_context_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0402: vault context column in vault_senstive attribute must match the specified type in strict mode 'vault_sensitive'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name id}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name name}: ok
  |         | {misc_attr_value_list}
  |           | {name rate}: ok
  | {create_proc_stmt}: err
    | {name vault_sensitive_with_integer_encode_context_strict_mode}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive=(name, (rate)))
CREATE PROC vault_sensitive_with_text_encode_context_strict_mode ()
BEGIN
  SELECT *
    FROM bar;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name vault_sensitive}
  |   | {misc_attr_value_list}: ok
  |     | {name name}: ok
  |     | {misc_attr_value_list}
  |       | {misc_attr_value_list}: ok
  |         | {name rate}: ok
  | {create_proc_stmt}: vault_sensitive_with_text_encode_context_strict_mode: { id: integer notnull, name: text, rate: longint } dml_proc
    | {name vault_sensitive_with_text_encode_context_strict_mode}: vault_sensitive_with_text_encode_context_strict_mode: { id: integer notnull, name: text, rate: longint } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text, rate: longint }
          | {select_core_list}: select: { id: integer notnull, name: text, rate: longint }
          | | {select_core}: select: { id: integer notnull, name: text, rate: longint }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_expr_list}: select: { id: integer notnull, name: text, rate: longint }
          |     | | {star}: select: { id: integer notnull, name: text, rate: longint }
          |     | {select_from_etc}: TABLE { bar: bar }
          |       | {table_or_subquery_list}: TABLE { bar: bar }
          |       | | {table_or_subquery}: TABLE { bar: bar }
          |       |   | {name bar}: TABLE { bar: bar }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT TYPE TEXT;

  {enforce_normal_stmt}: ok
  | {int 18}

The statement ending at line XXXX

@ENFORCE_NORMAL ENCODE CONTEXT COLUMN;

  {enforce_normal_stmt}: ok
  | {int 13}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_sensitive_proc ()
BEGIN
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name vault_sensitive}
  | {create_proc_stmt}: ok
    | {name vault_sensitive_proc}: ok
    | {proc_params_stmts}

The statement ending at line XXXX

@ATTRIBUTE(cql:vault_sensitive)
CREATE PROC vault_sensitive_proc_dml ()
BEGIN
  DECLARE y TEXT;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0364: vault_sensitive annotation can only go on a procedure that uses the database

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name vault_sensitive}
  | {create_proc_stmt}: err
    | {name vault_sensitive_proc_dml}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {declare_vars_type}: text
          | {name_list}: y: text variable
          | | {name y}: y: text variable
          | {type_text}: text

The statement ending at line XXXX

SELECT CASE WHEN 1 THEN 2
ELSE ifnull(x, y)
END;

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: integer
  |     |   | {case_expr}: integer
  |     |     | {connector}: integer
  |     |       | {case_list}: integer notnull
  |     |       | | {when}: integer notnull
  |     |       |   | {int 1}: integer notnull
  |     |       |   | {int 2}: integer notnull
  |     |       | {call}: integer
  |     |         | {name ifnull}
  |     |         | {call_arg_list}
  |     |           | {call_filter_clause}
  |     |           | {arg_list}: ok
  |     |             | {name x}: X: integer variable was_set
  |     |             | {arg_list}
  |     |               | {name y}: Y: integer variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE hidden_ignored_on_normal_tables(
  x INTEGER HIDDEN NOT NULL,
  y INTEGER
);

  {create_table_stmt}: hidden_ignored_on_normal_tables: { x: integer notnull, y: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name hidden_ignored_on_normal_tables}
  | {col_key_list}
    | {col_def}: x: integer notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name x}
    |   | | {type_int}: integer
    |   | {col_attrs_hidden}: ok
    |     | {col_attrs_not_null}
    | {col_key_list}
      | {col_def}: y: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name y}
            | {type_int}: integer

The statement ending at line XXXX

CREATE VIRTUAL TABLE virtual_with_hidden USING module_name AS (
  x INTEGER HIDDEN NOT NULL,
  y INTEGER
);

  {create_virtual_table_stmt}: virtual_with_hidden: { x: integer notnull hidden_col, y: integer } virtual @recreate
  | {module_info}
  | | {name module_name}
  | {create_table_stmt}: virtual_with_hidden: { x: integer notnull hidden_col, y: integer } virtual @recreate
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name virtual_with_hidden}
    | {col_key_list}
      | {col_def}: x: integer notnull hidden_col
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name x}
      |   | | {type_int}: integer
      |   | {col_attrs_hidden}: ok
      |     | {col_attrs_not_null}
      | {col_key_list}
        | {col_def}: y: integer
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name y}
              | {type_int}: integer

The statement ending at line XXXX

CREATE VIRTUAL TABLE virtual_with_hidden_wrong USING module_name AS (
  x INTEGER NOT NULL HIDDEN,
  y INTEGER
);

test/sem_test.sql:XXXX:1: error: in col_attrs_hidden : CQL0362: HIDDEN column attribute must be the first attribute if present

  {create_virtual_table_stmt}: err
  | {module_info}
  | | {name module_name}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name virtual_with_hidden_wrong}
    | {col_key_list}
      | {col_def}: err
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name x}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: err
      |     | {col_attrs_hidden}
      | {col_key_list}
        | {col_def}
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name y}
              | {type_int}

The statement ending at line XXXX

@ENFORCE_PUSH;

  {enforce_push_stmt}: ok

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_RESET;

  {enforce_reset_stmt}: ok

The statement ending at line XXXX

CREATE TABLE fk_strict_err_0(
  id INTEGER REFERENCES foo (id)
);

  {create_table_stmt}: fk_strict_err_0: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_err_0}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

@ENFORCE_PUSH;

  {enforce_push_stmt}: ok

The statement ending at line XXXX

@ENFORCE_STRICT FOREIGN KEY ON UPDATE;

  {enforce_strict_stmt}: ok
  | {int 1}

The statement ending at line XXXX

CREATE TABLE fk_strict_err_1(
  id INTEGER REFERENCES foo (id)
);

test/sem_test.sql:XXXX:1: error: in col_attrs_fk : CQL0237: strict FK validation requires that some ON UPDATE option be selected for every foreign key

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_err_1}
  | {col_key_list}
    | {col_def}: err
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: err
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

@ENFORCE_POP;

  {enforce_pop_stmt}: ok

The statement ending at line XXXX

CREATE TABLE fk_strict_err_2(
  id INTEGER REFERENCES foo (id)
);

  {create_table_stmt}: fk_strict_err_2: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name fk_strict_err_2}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name foo}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

@ENFORCE_POP;

  {enforce_pop_stmt}: ok

The statement ending at line XXXX

@ENFORCE_POP;

test/sem_test.sql:XXXX:1: error: in enforce_pop_stmt : CQL0365: @enforce_pop used but there is nothing to pop

  {enforce_pop_stmt}: err

The statement ending at line XXXX

@ENFORCE_STRICT TRANSACTION;

  {enforce_strict_stmt}: ok
  | {int 8}

The statement ending at line XXXX

BEGIN;

test/sem_test.sql:XXXX:1: error: in begin_trans_stmt : CQL0366: transaction operations disallowed while STRICT TRANSACTION enforcement is on.

  {begin_trans_stmt}: err
  | {int 1}

The statement ending at line XXXX

@ENFORCE_NORMAL TRANSACTION;

  {enforce_normal_stmt}: ok
  | {int 8}

The statement ending at line XXXX

BEGIN;

  {begin_trans_stmt}: ok
  | {int 1}

The statement ending at line XXXX

@ENFORCE_STRICT SELECT IF NOTHING;

  {enforce_strict_stmt}: ok
  | {int 9}

The statement ending at line XXXX

SET price_d := ( SELECT id
  FROM foo );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_stmt}: err
    | {select_core_list}: select: { id: integer notnull }
    | | {select_core}: select: { id: integer notnull }
    |   | {select_expr_list_con}: select: { id: integer notnull }
    |     | {select_expr_list}: select: { id: integer notnull }
    |     | | {select_expr}: id: integer notnull
    |     |   | {name id}: id: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 );

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: _anon: integer notnull
  |     |   | {select_stmt}: _anon: integer notnull
  |     |     | {select_core_list}: select: { _anon: integer notnull }
  |     |     | | {select_core}: select: { _anon: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     |     | | {select_expr}: integer notnull
  |     |     |     |   | {int 1}: integer notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING -1 );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: integer notnull
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {uminus}: integer notnull
      | {int 1}: integer notnull

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING OR NULL -1 );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_or_null_expr}: integer notnull
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {uminus}: integer notnull
      | {int 1}: integer notnull

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING OR NULL NULL );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_or_null_expr : CQL0372: SELECT ... IF NOTHING OR NULL NULL is redundant; use SELECT ... IF NOTHING NULL instead

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_or_null_expr}: err
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {null}: null

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING OR NULL ( SELECT NULL OR 1 ) );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_or_null_expr}: integer
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {select_stmt}: _anon: bool
      | {select_core_list}: select: { _anon: bool }
      | | {select_core}: select: { _anon: bool }
      |   | {select_expr_list_con}: select: { _anon: bool }
      |     | {select_expr_list}: select: { _anon: bool }
      |     | | {select_expr}: bool
      |     |   | {or}: bool
      |     |     | {null}: null
      |     |     | {int 1}: integer notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING ( SELECT id
  FROM foo ) );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: err
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {select_stmt}: err
      | {select_core_list}: select: { id: integer notnull }
      | | {select_core}: select: { id: integer notnull }
      |   | {select_expr_list_con}: select: { id: integer notnull }
      |     | {select_expr_list}: select: { id: integer notnull }
      |     | | {select_expr}: id: integer notnull
      |     |   | {name id}: id: integer notnull
      |     | {select_from_etc}: TABLE { foo: foo }
      |       | {table_or_subquery_list}: TABLE { foo: foo }
      |       | | {table_or_subquery}: TABLE { foo: foo }
      |       |   | {name foo}: TABLE { foo: foo }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING ( SELECT 1 ) );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: integer notnull
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {select_stmt}: _anon: integer notnull
      | {select_core_list}: select: { _anon: integer notnull }
      | | {select_core}: select: { _anon: integer notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull }
      |     | | {select_expr}: integer notnull
      |     |   | {int 1}: integer notnull
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

SET price_d := ( SELECT id
  FROM foo IF NOTHING THROW );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_throw_expr}: id: integer notnull
    | {select_stmt}: id: integer notnull
      | {select_core_list}: select: { id: integer notnull }
      | | {select_core}: select: { id: integer notnull }
      |   | {select_expr_list_con}: select: { id: integer notnull }
      |     | {select_expr_list}: select: { id: integer notnull }
      |     | | {select_expr}: id: integer notnull
      |     |   | {name id}: id: integer notnull
      |     | {select_from_etc}: TABLE { foo: foo }
      |       | {table_or_subquery_list}: TABLE { foo: foo }
      |       | | {table_or_subquery}: TABLE { foo: foo }
      |       |   | {name foo}: TABLE { foo: foo }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

LET val_count := ( SELECT count(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_count: integer notnull variable
  | {name val_count}: val_count: integer notnull variable
  | {select_stmt}: _anon: integer notnull
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name count}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_total := ( SELECT total(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_total: real notnull variable
  | {name val_total}: val_total: real notnull variable
  | {select_stmt}: _anon: real notnull
    | {select_core_list}: select: { _anon: real notnull }
    | | {select_core}: select: { _anon: real notnull }
    |   | {select_expr_list_con}: select: { _anon: real notnull }
    |     | {select_expr_list}: select: { _anon: real notnull }
    |     | | {select_expr}: real notnull
    |     |   | {call}: real notnull
    |     |     | {name total}: real notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_avg := ( SELECT avg(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_avg: real variable was_set
  | {name val_avg}: val_avg: real variable was_set
  | {select_stmt}: _anon: real
    | {select_core_list}: select: { _anon: real }
    | | {select_core}: select: { _anon: real }
    |   | {select_expr_list_con}: select: { _anon: real }
    |     | {select_expr_list}: select: { _anon: real }
    |     | | {select_expr}: real
    |     |   | {call}: real
    |     |     | {name avg}: real
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_sum := ( SELECT sum(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_sum: integer variable
  | {name val_sum}: val_sum: integer variable
  | {select_stmt}: _anon: integer
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name sum}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_group_concat := ( SELECT group_concat(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_group_concat: text variable
  | {name val_group_concat}: val_group_concat: text variable
  | {select_stmt}: _anon: text
    | {select_core_list}: select: { _anon: text }
    | | {select_core}: select: { _anon: text }
    |   | {select_expr_list_con}: select: { _anon: text }
    |     | {select_expr_list}: select: { _anon: text }
    |     | | {select_expr}: text
    |     |   | {call}: text
    |     |     | {name group_concat}: text
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_max := ( SELECT max(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_max: integer variable
  | {name val_max}: val_max: integer variable
  | {select_stmt}: _anon: integer
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name max}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

LET val_min := ( SELECT min(1)
  FROM foo
  WHERE 0 );

  {let_stmt}: val_min: integer variable
  | {name val_min}: val_min: integer variable
  | {select_stmt}: _anon: integer
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name min}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET val_max := ( SELECT max(1, 2, 3)
  FROM foo
  WHERE 0 );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_max}: val_max: integer variable
  | {select_stmt}: err
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name max}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET val_min := ( SELECT min(1, 2, 3)
  FROM foo
  WHERE 0 );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_min}: val_min: integer variable
  | {select_stmt}: err
    | {select_core_list}: select: { _anon: integer notnull }
    | | {select_core}: select: { _anon: integer notnull }
    |   | {select_expr_list_con}: select: { _anon: integer notnull }
    |     | {select_expr_list}: select: { _anon: integer notnull }
    |     | | {select_expr}: integer notnull
    |     |   | {call}: integer notnull
    |     |     | {name min}: integer notnull
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     |         | {arg_list}
    |     |           | {int 2}: integer notnull
    |     |           | {arg_list}
    |     |             | {int 3}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET val_min := ( SELECT min(1)
  FROM foo
  WHERE 0
  GROUP BY id );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_min}: val_min: integer variable
  | {select_stmt}: err
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name min}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {opt_groupby}: ok
    |           | | {groupby_list}: ok
    |           |   | {groupby_item}
    |           |     | {name id}: id: integer notnull
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET val_sum := ( SELECT sum(1)
  FROM foo
  WHERE 0
  GROUP BY id );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_sum}: val_sum: integer variable
  | {select_stmt}: err
    | {select_core_list}: select: { _anon: integer }
    | | {select_core}: select: { _anon: integer }
    |   | {select_expr_list_con}: select: { _anon: integer }
    |     | {select_expr_list}: select: { _anon: integer }
    |     | | {select_expr}: integer
    |     |   | {call}: integer
    |     |     | {name sum}: integer
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {int 1}: integer notnull
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {opt_where}: integer notnull
    |         | | {int 0}: integer notnull
    |         | {select_groupby}
    |           | {opt_groupby}: ok
    |           | | {groupby_list}: ok
    |           |   | {groupby_item}
    |           |     | {name id}: id: integer notnull
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET val_avg := ( SELECT avg(id) AS col
  FROM foo
LIMIT 1 - 1 );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_avg}: val_avg: real variable was_set
  | {select_stmt}: err
    | {select_core_list}: select: { col: real }
    | | {select_core}: select: { col: real }
    |   | {select_expr_list_con}: select: { col: real }
    |     | {select_expr_list}: select: { col: real }
    |     | | {select_expr}: col: real
    |     |   | {call}: real
    |     |   | | {name avg}: real
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {name id}: id: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name col}
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {opt_limit}: integer notnull
        | | {sub}: integer notnull
        |   | {int 1}: integer notnull
        |   | {int 1}: integer notnull
        | {select_offset}

The statement ending at line XXXX

CREATE PROC val_avg_proc (lim INTEGER)
BEGIN
  LET val_avg := ( SELECT avg(id) AS col
    FROM foo
  LIMIT lim );
END;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {create_proc_stmt}: err
  | {name val_avg_proc}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: lim: integer variable in
    |   | {param_detail}: lim: integer variable in
    |     | {name lim}: lim: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {let_stmt}: err
        | {name val_avg}
        | {select_stmt}: err
          | {select_core_list}: select: { col: real }
          | | {select_core}: select: { col: real }
          |   | {select_expr_list_con}: select: { col: real }
          |     | {select_expr_list}: select: { col: real }
          |     | | {select_expr}: col: real
          |     |   | {call}: real
          |     |   | | {name avg}: real
          |     |   | | {call_arg_list}
          |     |   |   | {call_filter_clause}
          |     |   |   | {arg_list}: ok
          |     |   |     | {name id}: id: integer notnull
          |     |   | {opt_as_alias}
          |     |     | {name col}
          |     | {select_from_etc}: TABLE { foo: foo }
          |       | {table_or_subquery_list}: TABLE { foo: foo }
          |       | | {table_or_subquery}: TABLE { foo: foo }
          |       |   | {name foo}: TABLE { foo: foo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {opt_limit}: lim: integer variable in
              | | {name lim}: lim: integer variable in
              | {select_offset}

The statement ending at line XXXX

SET val_avg := ( SELECT avg(id) AS col
  FROM foo
LIMIT 2 + 4 * 10 );

  {assign}: val_avg: real variable was_set
  | {name val_avg}: val_avg: real variable was_set
  | {select_stmt}: col: real
    | {select_core_list}: select: { col: real }
    | | {select_core}: select: { col: real }
    |   | {select_expr_list_con}: select: { col: real }
    |     | {select_expr_list}: select: { col: real }
    |     | | {select_expr}: col: real
    |     |   | {call}: real
    |     |   | | {name avg}: real
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {name id}: id: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name col}
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {opt_limit}: integer notnull
        | | {add}: integer notnull
        |   | {int 2}: integer notnull
        |   | {mul}: integer notnull
        |     | {int 4}: integer notnull
        |     | {int 10}: integer notnull
        | {select_offset}

The statement ending at line XXXX

SET val_avg := ( SELECT avg(id) AS col
  FROM foo
LIMIT 2 + 4 * 10
OFFSET 1 );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0368: strict select if nothing requires that all (select ...) expressions include 'if nothing'

  {assign}: err
  | {name val_avg}: val_avg: real variable was_set
  | {select_stmt}: err
    | {select_core_list}: select: { col: real }
    | | {select_core}: select: { col: real }
    |   | {select_expr_list_con}: select: { col: real }
    |     | {select_expr_list}: select: { col: real }
    |     | | {select_expr}: col: real
    |     |   | {call}: real
    |     |   | | {name avg}: real
    |     |   | | {call_arg_list}
    |     |   |   | {call_filter_clause}
    |     |   |   | {arg_list}: ok
    |     |   |     | {name id}: id: integer notnull
    |     |   | {opt_as_alias}
    |     |     | {name col}
    |     | {select_from_etc}: TABLE { foo: foo }
    |       | {table_or_subquery_list}: TABLE { foo: foo }
    |       | | {table_or_subquery}: TABLE { foo: foo }
    |       |   | {name foo}: TABLE { foo: foo }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {opt_limit}: integer notnull
        | | {add}: integer notnull
        |   | {int 2}: integer notnull
        |   | {mul}: integer notnull
        |     | {int 4}: integer notnull
        |     | {int 10}: integer notnull
        | {select_offset}
          | {opt_offset}: integer notnull
            | {int 1}: integer notnull

The statement ending at line XXXX

@ENFORCE_NORMAL SELECT IF NOTHING;

  {enforce_normal_stmt}: ok
  | {int 9}

The statement ending at line XXXX

SET price_d := ( SELECT 1 IF NOTHING 2.0 );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: real notnull
    | {select_stmt}: _anon: integer notnull
    | | {select_core_list}: select: { _anon: integer notnull }
    | | | {select_core}: select: { _anon: integer notnull }
    | |   | {select_expr_list_con}: select: { _anon: integer notnull }
    | |     | {select_expr_list}: select: { _anon: integer notnull }
    | |     | | {select_expr}: integer notnull
    | |     |   | {int 1}: integer notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {dbl 2.0}: real notnull

The statement ending at line XXXX

SET price_d := ( SELECT 3.0 IF NOTHING 4 );

  {assign}: price_d: real<dollars> variable was_set
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: real notnull
    | {select_stmt}: _anon: real notnull
    | | {select_core_list}: select: { _anon: real notnull }
    | | | {select_core}: select: { _anon: real notnull }
    | |   | {select_expr_list_con}: select: { _anon: real notnull }
    | |     | {select_expr_list}: select: { _anon: real notnull }
    | |     | | {select_expr}: real notnull
    | |     |   | {dbl 3.0}: real notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {int 4}: integer notnull

The statement ending at line XXXX

SET price_d := ( SELECT 3.0 IF NOTHING price_e );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_expr : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_expr}: err
    | {select_stmt}: _anon: real notnull
    | | {select_core_list}: select: { _anon: real notnull }
    | | | {select_core}: select: { _anon: real notnull }
    | |   | {select_expr_list_con}: select: { _anon: real notnull }
    | |     | {select_expr_list}: select: { _anon: real notnull }
    | |     | | {select_expr}: real notnull
    | |     |   | {dbl 3.0}: real notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {name price_e}: price_e: real<euros> variable

The statement ending at line XXXX

SET my_real := ( SELECT price_d IF NOTHING price_e );

test/sem_test.sql:XXXX:1: error: in str : CQL0070: expressions of different kinds can't be mixed: 'dollars' vs. 'euros'

  {assign}: err
  | {name my_real}: my_real: real variable was_set
  | {select_if_nothing_expr}: err
    | {select_stmt}: price_d: real<dollars> variable was_set
    | | {select_core_list}: select: { price_d: real<dollars> variable was_set }
    | | | {select_core}: select: { price_d: real<dollars> variable was_set }
    | |   | {select_expr_list_con}: select: { price_d: real<dollars> variable was_set }
    | |     | {select_expr_list}: select: { price_d: real<dollars> variable was_set }
    | |     | | {select_expr}: price_d: real<dollars> variable was_set
    | |     |   | {name price_d}: price_d: real<dollars> variable was_set
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {name price_e}: err

The statement ending at line XXXX

SET price_d := ( SELECT "x" IF NOTHING OR NULL price_e );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_or_null_expr : CQL0009: incompatible types in expression 'IF NOTHING OR NULL'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_or_null_expr}: err
    | {select_stmt}: _anon: text notnull
    | | {select_core_list}: select: { _anon: text notnull }
    | | | {select_core}: select: { _anon: text notnull }
    | |   | {select_expr_list_con}: select: { _anon: text notnull }
    | |     | {select_expr_list}: select: { _anon: text notnull }
    | |     | | {select_expr}: text notnull
    | |     |   | {strlit 'x'}: text notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {name price_e}: price_e: real<euros> variable

The statement ending at line XXXX

SET price_d := ( SELECT "x" IF NOTHING OR NULL obj_var );

test/sem_test.sql:XXXX:1: error: in str : CQL0003: right operand cannot be an object in 'IF NOTHING OR NULL'

  {assign}: err
  | {name price_d}: price_d: real<dollars> variable was_set
  | {select_if_nothing_or_null_expr}: err
    | {select_stmt}: _anon: text notnull
    | | {select_core_list}: select: { _anon: text notnull }
    | | | {select_core}: select: { _anon: text notnull }
    | |   | {select_expr_list_con}: select: { _anon: text notnull }
    | |     | {select_expr_list}: select: { _anon: text notnull }
    | |     | | {select_expr}: text notnull
    | |     |   | {strlit 'x'}: text notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {name obj_var}: obj_var: object variable was_set

The statement ending at line XXXX

DECLARE real_nn REAL NOT NULL;

  {declare_vars_type}: real notnull
  | {name_list}: real_nn: real notnull variable was_set
  | | {name real_nn}: real_nn: real notnull variable was_set
  | {notnull}: real notnull
    | {type_real}: real

The statement ending at line XXXX

SET real_nn := ( SELECT my_real IF NOTHING OR NULL 1.0 );

  {assign}: real_nn: real notnull variable was_set
  | {name real_nn}: real_nn: real notnull variable was_set
  | {select_if_nothing_or_null_expr}: real notnull
    | {select_stmt}: my_real: real variable was_set
    | | {select_core_list}: select: { my_real: real variable was_set }
    | | | {select_core}: select: { my_real: real variable was_set }
    | |   | {select_expr_list_con}: select: { my_real: real variable was_set }
    | |     | {select_expr_list}: select: { my_real: real variable was_set }
    | |     | | {select_expr}: my_real: real variable was_set
    | |     |   | {name my_real}: my_real: real variable was_set
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET real_nn := ( SELECT my_real IF NOTHING 1.0 );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_expr : CQL0013: cannot assign/copy possibly null expression to not null target 'real_nn'

  {assign}: err
  | {name real_nn}: err
  | {select_if_nothing_expr}: real
    | {select_stmt}: my_real: real variable was_set
    | | {select_core_list}: select: { my_real: real variable was_set }
    | | | {select_core}: select: { my_real: real variable was_set }
    | |   | {select_expr_list_con}: select: { my_real: real variable was_set }
    | |     | {select_expr_list}: select: { my_real: real variable was_set }
    | |     | | {select_expr}: my_real: real variable was_set
    | |     |   | {name my_real}: my_real: real variable was_set
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {dbl 1.0}: real notnull

The statement ending at line XXXX

SET real_nn := ( SELECT NOT 'x' IF NOTHING 1.0 );

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name real_nn}: real_nn: real notnull variable was_set
  | {select_if_nothing_expr}: err
    | {select_stmt}: err
    | | {select_core_list}: err
    | | | {select_core}: err
    | |   | {select_expr_list_con}: err
    | |     | {select_expr_list}: err
    | |     | | {select_expr}: err
    | |     |   | {not}: err
    | |     |     | {strlit 'x'}: text notnull
    | |     | {select_from_etc}: ok
    | |       | {select_where}
    | |         | {select_groupby}
    | |           | {select_having}
    | | {select_orderby}
    |   | {select_limit}
    |     | {select_offset}
    | {dbl 1.0}: real notnull

The statement ending at line XXXX

SELECT ( SELECT 0 IF NOTHING -1 );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_expr : CQL0369: (SELECT ... IF NOTHING) construct is for use in top level expressions, not inside of other DML

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {select_if_nothing_expr}: err
  |     |     | {select_stmt}: err
  |     |     | | {select_core_list}
  |     |     | | | {select_core}
  |     |     | |   | {select_expr_list_con}
  |     |     | |     | {select_expr_list}
  |     |     | |     | | {select_expr}
  |     |     | |     |   | {int 0}
  |     |     | |     | {select_from_etc}
  |     |     | |       | {select_where}
  |     |     | |         | {select_groupby}
  |     |     | |           | {select_having}
  |     |     | | {select_orderby}
  |     |     |   | {select_limit}
  |     |     |     | {select_offset}
  |     |     | {uminus}: integer notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DELETE FROM foo WHERE id = ( SELECT 33 IF NOTHING 0 );

test/sem_test.sql:XXXX:1: error: in select_if_nothing_expr : CQL0369: (SELECT ... IF NOTHING) construct is for use in top level expressions, not inside of other DML

  {delete_stmt}: err
  | {name foo}: foo: { id: integer notnull primary_key autoinc }
  | {opt_where}: err
    | {eq}: err
      | {name id}: id: integer notnull
      | {select_if_nothing_expr}: err
        | {select_stmt}: err
        | | {select_core_list}
        | | | {select_core}
        | |   | {select_expr_list_con}
        | |     | {select_expr_list}
        | |     | | {select_expr}
        | |     |   | {int 33}
        | |     | {select_from_etc}
        | |       | {select_where}
        | |         | {select_groupby}
        | |           | {select_having}
        | | {select_orderby}
        |   | {select_limit}
        |     | {select_offset}
        | {int 0}: integer notnull

The statement ending at line XXXX

SELECT ( SELECT count(*)
  FROM foo
  WHERE 0 );

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: _anon: integer notnull
  |     |   | {select_stmt}: _anon: integer notnull
  |     |     | {select_core_list}: select: { _anon: integer notnull }
  |     |     | | {select_core}: select: { _anon: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     |     | | {select_expr}: integer notnull
  |     |     |     |   | {call}: integer notnull
  |     |     |     |     | {name count}: integer notnull
  |     |     |     |     | {call_arg_list}
  |     |     |     |       | {call_filter_clause}
  |     |     |     |       | {arg_list}: ok
  |     |     |     |         | {star}: integer
  |     |     |     | {select_from_etc}: TABLE { foo: foo }
  |     |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |     |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |     |     |       |   | {name foo}: TABLE { foo: foo }
  |     |     |       | {select_where}
  |     |     |         | {opt_where}: integer notnull
  |     |     |         | | {int 0}: integer notnull
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT *
  FROM (SELECT 1 AS x) AS T );

  {select_stmt}: select: { x: integer }
  | {select_core_list}: select: { x: integer }
  | | {select_core}: select: { x: integer }
  |   | {select_expr_list_con}: select: { x: integer }
  |     | {select_expr_list}: select: { x: integer }
  |     | | {select_expr}: x: integer
  |     |   | {select_stmt}: x: integer
  |     |     | {select_core_list}: select: { x: integer notnull }
  |     |     | | {select_core}: select: { x: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { x: integer notnull }
  |     |     |     | {select_expr_list}: select: { x: integer notnull }
  |     |     |     | | {star}: select: { x: integer notnull }
  |     |     |     | {select_from_etc}: TABLE { T: select }
  |     |     |       | {table_or_subquery_list}: TABLE { T: select }
  |     |     |       | | {table_or_subquery}: TABLE { T: select }
  |     |     |       |   | {select_stmt}: select: { x: integer notnull }
  |     |     |       |   | | {select_core_list}: select: { x: integer notnull }
  |     |     |       |   | | | {select_core}: select: { x: integer notnull }
  |     |     |       |   | |   | {select_expr_list_con}: select: { x: integer notnull }
  |     |     |       |   | |     | {select_expr_list}: select: { x: integer notnull }
  |     |     |       |   | |     | | {select_expr}: x: integer notnull
  |     |     |       |   | |     |   | {int 1}: integer notnull
  |     |     |       |   | |     |   | {opt_as_alias}
  |     |     |       |   | |     |     | {name x}
  |     |     |       |   | |     | {select_from_etc}: ok
  |     |     |       |   | |       | {select_where}
  |     |     |       |   | |         | {select_groupby}
  |     |     |       |   | |           | {select_having}
  |     |     |       |   | | {select_orderby}
  |     |     |       |   |   | {select_limit}
  |     |     |       |   |     | {select_offset}
  |     |     |       |   | {opt_as_alias}
  |     |     |       |     | {name T}
  |     |     |       | {select_where}
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT sum(id)
  FROM foo
  WHERE 0 );

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: _anon: integer
  |     |   | {select_stmt}: _anon: integer
  |     |     | {select_core_list}: select: { _anon: integer }
  |     |     | | {select_core}: select: { _anon: integer }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer }
  |     |     |     | {select_expr_list}: select: { _anon: integer }
  |     |     |     | | {select_expr}: integer
  |     |     |     |   | {call}: integer
  |     |     |     |     | {name sum}: integer
  |     |     |     |     | {call_arg_list}
  |     |     |     |       | {call_filter_clause}
  |     |     |     |       | {arg_list}: ok
  |     |     |     |         | {name id}: id: integer notnull
  |     |     |     | {select_from_etc}: TABLE { foo: foo }
  |     |     |       | {table_or_subquery_list}: TABLE { foo: foo }
  |     |     |       | | {table_or_subquery}: TABLE { foo: foo }
  |     |     |       |   | {name foo}: TABLE { foo: foo }
  |     |     |       | {select_where}
  |     |     |         | {opt_where}: integer notnull
  |     |     |         | | {int 0}: integer notnull
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1 + 3
  WHERE 0 );

  {select_stmt}: select: { _anon: integer }
  | {select_core_list}: select: { _anon: integer }
  | | {select_core}: select: { _anon: integer }
  |   | {select_expr_list_con}: select: { _anon: integer }
  |     | {select_expr_list}: select: { _anon: integer }
  |     | | {select_expr}: _anon: integer
  |     |   | {select_stmt}: _anon: integer
  |     |     | {select_core_list}: select: { _anon: integer notnull }
  |     |     | | {select_core}: select: { _anon: integer notnull }
  |     |     |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |     |     | {select_expr_list}: select: { _anon: integer notnull }
  |     |     |     | | {select_expr}: integer notnull
  |     |     |     |   | {add}: integer notnull
  |     |     |     |     | {int 1}: integer notnull
  |     |     |     |     | {int 3}: integer notnull
  |     |     |     | {select_from_etc}: ok
  |     |     |       | {select_where}
  |     |     |         | {opt_where}: integer notnull
  |     |     |         | | {int 0}: integer notnull
  |     |     |         | {select_groupby}
  |     |     |           | {select_having}
  |     |     | {select_orderby}
  |     |       | {select_limit}
  |     |         | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( WITH
y (x) AS (SELECT 1 AS x)
SELECT *
  FROM y );

  {select_stmt}: select: { x: integer }
  | {select_core_list}: select: { x: integer }
  | | {select_core}: select: { x: integer }
  |   | {select_expr_list_con}: select: { x: integer }
  |     | {select_expr_list}: select: { x: integer }
  |     | | {select_expr}: x: integer
  |     |   | {with_select_stmt}: x: integer
  |     |     | {with}
  |     |     | | {cte_tables}: ok
  |     |     |   | {cte_table}: y: { x: integer notnull }
  |     |     |     | {cte_decl}: y: { x: integer notnull }
  |     |     |     | | {name y}
  |     |     |     | | {name_list}
  |     |     |     |   | {name x}
  |     |     |     | {select_stmt}: select: { x: integer notnull }
  |     |     |       | {select_core_list}: select: { x: integer notnull }
  |     |     |       | | {select_core}: select: { x: integer notnull }
  |     |     |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |     |     |       |     | {select_expr_list}: select: { x: integer notnull }
  |     |     |       |     | | {select_expr}: x: integer notnull
  |     |     |       |     |   | {int 1}: integer notnull
  |     |     |       |     |   | {opt_as_alias}
  |     |     |       |     |     | {name x}
  |     |     |       |     | {select_from_etc}: ok
  |     |     |       |       | {select_where}
  |     |     |       |         | {select_groupby}
  |     |     |       |           | {select_having}
  |     |     |       | {select_orderby}
  |     |     |         | {select_limit}
  |     |     |           | {select_offset}
  |     |     | {select_stmt}: select: { x: integer notnull }
  |     |       | {select_core_list}: select: { x: integer notnull }
  |     |       | | {select_core}: select: { x: integer notnull }
  |     |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |     |       |     | {select_expr_list}: select: { x: integer notnull }
  |     |       |     | | {star}: select: { x: integer notnull }
  |     |       |     | {select_from_etc}: TABLE { y: y }
  |     |       |       | {table_or_subquery_list}: TABLE { y: y }
  |     |       |       | | {table_or_subquery}: TABLE { y: y }
  |     |       |       |   | {name y}: TABLE { y: y }
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ( SELECT 1
UNION ALL
SELECT 2 ) AS x;

  {select_stmt}: select: { x: integer }
  | {select_core_list}: select: { x: integer }
  | | {select_core}: select: { x: integer }
  |   | {select_expr_list_con}: select: { x: integer }
  |     | {select_expr_list}: select: { x: integer }
  |     | | {select_expr}: x: integer
  |     |   | {select_stmt}: _anon: integer
  |     |   | | {select_core_list}: UNION ALL: { _anon: integer notnull }
  |     |   | | | {select_core}: select: { _anon: integer notnull }
  |     |   | | | | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   | | |   | {select_expr_list}: select: { _anon: integer notnull }
  |     |   | | |   | | {select_expr}: integer notnull
  |     |   | | |   |   | {int 1}: integer notnull
  |     |   | | |   | {select_from_etc}: ok
  |     |   | | |     | {select_where}
  |     |   | | |       | {select_groupby}
  |     |   | | |         | {select_having}
  |     |   | | | {select_core_compound}
  |     |   | |   | {int 2}
  |     |   | |   | {select_core_list}: select: { _anon: integer notnull }
  |     |   | |     | {select_core}: select: { _anon: integer notnull }
  |     |   | |       | {select_expr_list_con}: select: { _anon: integer notnull }
  |     |   | |         | {select_expr_list}: select: { _anon: integer notnull }
  |     |   | |         | | {select_expr}: integer notnull
  |     |   | |         |   | {int 2}: integer notnull
  |     |   | |         | {select_from_etc}: ok
  |     |   | |           | {select_where}
  |     |   | |             | {select_groupby}
  |     |   | |               | {select_having}
  |     |   | | {select_orderby}
  |     |   |   | {select_limit}
  |     |   |     | {select_offset}
  |     |   | {opt_as_alias}
  |     |     | {name x}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT INSERT SELECT;

  {enforce_strict_stmt}: ok
  | {int 10}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT 1;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: select: { _anon: integer notnull }
        | {select_core_list}: select: { _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     |   | {int 1}: integer notnull
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT 1
UNION ALL
SELECT 1;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0370: due to a memory leak bug in old SQLite versions, the select part of an insert must not have a top level join or compound operator. Use WITH and a CTE, or a nested select to work around this.

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: UNION ALL: { _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull }
        | | | {select_expr_list_con}: select: { _anon: integer notnull }
        | |   | {select_expr_list}: select: { _anon: integer notnull }
        | |   | | {select_expr}: integer notnull
        | |   |   | {int 1}: integer notnull
        | |   | {select_from_etc}: ok
        | |     | {select_where}
        | |       | {select_groupby}
        | |         | {select_having}
        | | {select_core_compound}
        |   | {int 2}
        |   | {select_core_list}: select: { _anon: integer notnull }
        |     | {select_core}: select: { _anon: integer notnull }
        |       | {select_expr_list_con}: select: { _anon: integer notnull }
        |         | {select_expr_list}: select: { _anon: integer notnull }
        |         | | {select_expr}: integer notnull
        |         |   | {int 1}: integer notnull
        |         | {select_from_etc}: ok
        |           | {select_where}
        |             | {select_groupby}
        |               | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) SELECT 1
  FROM (SELECT 1) AS T1
  INNER JOIN (SELECT 2) AS T2;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0370: due to a memory leak bug in old SQLite versions, the select part of an insert must not have a top level join or compound operator. Use WITH and a CTE, or a nested select to work around this.

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}
      | {select_stmt}: err
        | {select_core_list}: select: { _anon: integer notnull }
        | | {select_core}: select: { _anon: integer notnull }
        |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |     | {select_expr_list}: select: { _anon: integer notnull }
        |     | | {select_expr}: integer notnull
        |     |   | {int 1}: integer notnull
        |     | {select_from_etc}: JOIN { T1: select, T2: select }
        |       | {join_clause}: JOIN { T1: select, T2: select }
        |       | | {table_or_subquery}: TABLE { T1: select }
        |       | | | {select_stmt}: select: { _anon: integer notnull }
        |       | | | | {select_core_list}: select: { _anon: integer notnull }
        |       | | | | | {select_core}: select: { _anon: integer notnull }
        |       | | | |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       | | | |     | {select_expr_list}: select: { _anon: integer notnull }
        |       | | | |     | | {select_expr}: integer notnull
        |       | | | |     |   | {int 1}: integer notnull
        |       | | | |     | {select_from_etc}: ok
        |       | | | |       | {select_where}
        |       | | | |         | {select_groupby}
        |       | | | |           | {select_having}
        |       | | | | {select_orderby}
        |       | | |   | {select_limit}
        |       | | |     | {select_offset}
        |       | | | {opt_as_alias}
        |       | |   | {name T1}
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { T1: select, T2: select }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { T2: select }
        |       |         | {select_stmt}: select: { _anon: integer notnull }
        |       |         | | {select_core_list}: select: { _anon: integer notnull }
        |       |         | | | {select_core}: select: { _anon: integer notnull }
        |       |         | |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |         | |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |         | |     | | {select_expr}: integer notnull
        |       |         | |     |   | {int 2}: integer notnull
        |       |         | |     | {select_from_etc}: ok
        |       |         | |       | {select_where}
        |       |         | |         | {select_groupby}
        |       |         | |           | {select_having}
        |       |         | | {select_orderby}
        |       |         |   | {select_limit}
        |       |         |     | {select_offset}
        |       |         | {opt_as_alias}
        |       |           | {name T2}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) WITH
cte (id) AS (SELECT 1)
SELECT *
  FROM cte;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {with_select_stmt}: select: { id: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: cte: { id: integer notnull }
        |     | {cte_decl}: cte: { id: integer notnull }
        |     | | {name cte}
        |     | | {name_list}
        |     |   | {name id}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { id: integer notnull }
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {star}: select: { id: integer notnull }
          |     | {select_from_etc}: TABLE { cte: cte }
          |       | {table_or_subquery_list}: TABLE { cte: cte }
          |       | | {table_or_subquery}: TABLE { cte: cte }
          |       |   | {name cte}: TABLE { cte: cte }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

INSERT INTO foo(id) VALUES(1), (2), (3);

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name foo}: foo: { id: integer notnull primary_key autoinc }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer notnull
      | {select_stmt}: values: { column1: integer notnull }
        | {select_core_list}: values: { column1: integer notnull }
        | | {select_core}: values: { column1: integer notnull }
        |   | {select_values}
        |   | {values}: values: { column1: integer notnull }
        |     | {insert_list}: ok
        |     | | {int 1}: integer notnull
        |     | {values}
        |       | {insert_list}: ok
        |       | | {int 2}: integer notnull
        |       | {values}
        |         | {insert_list}: ok
        |           | {int 3}: integer notnull
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL INSERT SELECT;

  {enforce_normal_stmt}: ok
  | {int 10}

The statement ending at line XXXX

@ENFORCE_STRICT TABLE FUNCTION;

  {enforce_strict_stmt}: ok
  | {int 11}

The statement ending at line XXXX

SELECT *
  FROM foo
  INNER JOIN tvf(1);

  {select_stmt}: select: { id: integer notnull, foo: text }
  | {select_core_list}: select: { id: integer notnull, foo: text }
  | | {select_core}: select: { id: integer notnull, foo: text }
  |   | {select_expr_list_con}: select: { id: integer notnull, foo: text }
  |     | {select_expr_list}: select: { id: integer notnull, foo: text }
  |     | | {star}: select: { id: integer notnull, foo: text }
  |     | {select_from_etc}: JOIN { foo: foo, tvf: select }
  |       | {join_clause}: JOIN { foo: foo, tvf: select }
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { foo: foo, tvf: select }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { tvf: select } table_valued_function
  |       |         | {table_function}: TABLE { tvf: select } table_valued_function
  |       |           | {name tvf}: TABLE { tvf: select } table_valued_function
  |       |           | {arg_list}: ok
  |       |             | {int 1}: integer notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo
  LEFT JOIN tvf(1);

test/sem_test.sql:XXXX:1: error: in join_target : CQL0371: table valued function used in a left/right/cross context; this would hit a SQLite bug.  Wrap it in a CTE instead.

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { foo: foo }
  |       | | | {name foo}: TABLE { foo: foo }
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 5} {join_left}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { tvf: select } table_valued_function
  |       |         | {table_function}: TABLE { tvf: select } table_valued_function
  |       |           | {name tvf}: TABLE { tvf: select } table_valued_function
  |       |           | {arg_list}: ok
  |       |             | {int 1}: integer notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM tvf(1)
  RIGHT JOIN foo;

test/sem_test.sql:XXXX:1: error: in join_target : CQL0371: table valued function used in a left/right/cross context; this would hit a SQLite bug.  Wrap it in a CTE instead.

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {join_clause}: err
  |       | | {table_or_subquery}: TABLE { tvf: select } table_valued_function
  |       | | | {table_function}: TABLE { tvf: select } table_valued_function
  |       | |   | {name tvf}: TABLE { tvf: select } table_valued_function
  |       | |   | {arg_list}: ok
  |       | |     | {int 1}: integer notnull
  |       | | {join_target_list}
  |       |   | {join_target}: err
  |       |     | {int 6} {join_right}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { foo: foo }
  |       |         | {name foo}: TABLE { foo: foo }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT *
  FROM foo AS T1
  CROSS JOIN foo AS T2;

  {select_stmt}: select: { id: integer notnull, id: integer notnull }
  | {select_core_list}: select: { id: integer notnull, id: integer notnull }
  | | {select_core}: select: { id: integer notnull, id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull, id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull, id: integer notnull }
  |     | | {star}: select: { id: integer notnull, id: integer notnull }
  |     | {select_from_etc}: JOIN { T1: foo, T2: foo }
  |       | {join_clause}: JOIN { T1: foo, T2: foo }
  |       | | {table_or_subquery}: TABLE { T1: foo }
  |       | | | {name foo}: TABLE { T1: foo }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: foo, T2: foo }
  |       |     | {int 2} {join_cross}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: foo }
  |       |         | {name foo}: TABLE { T2: foo }
  |       |         | {opt_as_alias}
  |       |           | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ENFORCE_NORMAL TABLE FUNCTION;

  {enforce_normal_stmt}: ok
  | {int 11}

The statement ending at line XXXX

LET int_var := 1;

  {let_stmt}: int_var: integer notnull variable
  | {name int_var}: int_var: integer notnull variable
  | {int 1}: integer notnull

The statement ending at line XXXX

LET long_var := 1L;

  {let_stmt}: long_var: longint notnull variable
  | {name long_var}: long_var: longint notnull variable
  | {longint 1}: longint notnull

The statement ending at line XXXX

LET price_dd := price_d;

  {let_stmt}: price_dd: real<dollars> variable
  | {name price_dd}: price_dd: real<dollars> variable
  | {name price_d}: price_d: real<dollars> variable was_set

The statement ending at line XXXX

LET bool_var := 1 = 1;

  {let_stmt}: bool_var: bool notnull variable
  | {name bool_var}: bool_var: bool notnull variable
  | {eq}: bool notnull
    | {int 1}: integer notnull
    | {int 1}: integer notnull

The statement ending at line XXXX

LET pen_var := 1.000000e+00;

  {let_stmt}: pen_var: real<real_things> notnull variable
  | {name pen_var}: pen_var: real<real_things> notnull variable
  | {dbl 1.000000e+00}: real<real_things> notnull

The statement ending at line XXXX

LET created_obj := creater_func();

  {let_stmt}: created_obj: object notnull variable
  | {name created_obj}: created_obj: object notnull variable
  | {call}: object notnull create_func
    | {name creater_func}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

LET null_is_no_good := NULL;

test/sem_test.sql:XXXX:1: error: in let_stmt : CQL0056: NULL expression has no type to imply the declaration of variable 'null_is_no_good'

  {let_stmt}: err
  | {name null_is_no_good}
  | {null}: null

The statement ending at line XXXX

LET bad_result := NOT 'x';

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {let_stmt}: err
  | {name bad_result}
  | {not}: err
    | {strlit 'x'}: text notnull

The statement ending at line XXXX

LET created_obj := 1;

test/sem_test.sql:XXXX:1: error: in str : CQL0197: duplicate variable name in the same scope 'created_obj'

  {let_stmt}: err
  | {name created_obj}
  | {int 1}

The statement ending at line XXXX

LET z := 1;

  {let_stmt}: z: integer notnull variable
  | {name z}: z: integer notnull variable
  | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH NOT 'x'
  WHEN 1 THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {not}: err
    | | {strlit 'x'}: text notnull
    | {switch_case}
      | {connector}
        | {expr_list}
          | {int 1}

The statement ending at line XXXX

SWITCH 1.5
  WHEN 1 THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0381: case expression must be a not-null integral type

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {dbl 1.5}: real notnull
    | {switch_case}
      | {connector}
        | {expr_list}
          | {int 1}

The statement ending at line XXXX

SWITCH z
  WHEN 1L THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0382: type of a WHEN expression is bigger than the type of the SWITCH expression

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
        | {expr_list}: err
          | {longint 1}: longint notnull

The statement ending at line XXXX

SWITCH z
  WHEN 1 + x THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0380: WHEN expression cannot be evaluated to a constant

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
        | {expr_list}: err
          | {add}: integer
            | {int 1}: integer notnull
            | {name x}: X: integer variable was_set

The statement ending at line XXXX

SWITCH z
  WHEN NOT "x" THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
        | {expr_list}: err
          | {not}: err
            | {strlit 'x'}: text notnull

The statement ending at line XXXX

SWITCH z
  WHEN 1 THEN
    IF NOT "x" THEN
    END IF;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 1}: integer notnull
        | {stmt_list}: err
          | {if_stmt}: err
            | {cond_action}: err
            | | {not}: err
            |   | {strlit 'x'}: text notnull
            | {if_alt}

The statement ending at line XXXX

SWITCH z
  WHEN 1 THEN NOTHING
  WHEN 2 THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in switch_case : CQL0384: switch statement did not have any actual statements in it

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
      | | {expr_list}: ok
      |   | {int 1}: integer notnull
      | {switch_case}
        | {connector}
          | {expr_list}: ok
            | {int 2}: integer notnull

The statement ending at line XXXX

LET thing := 1;

  {let_stmt}: thing: integer<integer_things> notnull variable
  | {name thing}: thing: integer<integer_things> notnull variable
  | {int 1}: integer<integer_things> notnull

The statement ending at line XXXX

SWITCH thing ALL VALUES
  WHEN 1, 8 THEN
    SET x := 10;
  WHEN 7 THEN
    SET x := 20;
  ELSE
    SET x := 30;
END;

test/sem_test.sql:XXXX:1: error: in switch_case : CQL0383: switch ... ALL VALUES is useless with an ELSE clause

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {name thing}: thing: integer<integer_things> notnull variable
    | {switch_case}: err
      | {connector}
      | | {expr_list}: ok
      | | | {int 1}: integer<integer_things> notnull
      | | | {expr_list}
      | |   | {int 8}: integer<integer_things> notnull
      | | {stmt_list}: ok
      |   | {assign}: X: integer variable was_set
      |     | {name x}: X: integer variable was_set
      |     | {int 10}: integer notnull
      | {switch_case}
        | {connector}
        | | {expr_list}: ok
        | | | {int 7}: integer<integer_things> notnull
        | | {stmt_list}: ok
        |   | {assign}: X: integer variable was_set
        |     | {name x}: X: integer variable was_set
        |     | {int 20}: integer notnull
        | {switch_case}
          | {connector}
            | {stmt_list}
              | {assign}
                | {name x}
                | {int 30}

The statement ending at line XXXX

SWITCH z
  WHEN 1, 2 THEN
    SET x := 10;
  WHEN 2 THEN
    SET x := 20;
  ELSE
    SET x := 30;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0385: WHEN clauses contain duplicate values '2'

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: err
      | {connector}
      | | {expr_list}: ok
      | | | {int 1}: integer notnull
      | | | {expr_list}
      | |   | {int 2}: integer notnull
      | | {stmt_list}: ok
      |   | {assign}: X: integer variable was_set
      |     | {name x}: X: integer variable was_set
      |     | {int 10}: integer notnull
      | {switch_case}
        | {connector}
        | | {expr_list}: ok
        | | | {int 2}: integer notnull
        | | {stmt_list}: ok
        |   | {assign}: X: integer variable was_set
        |     | {name x}: X: integer variable was_set
        |     | {int 20}: integer notnull
        | {switch_case}
          | {connector}
            | {stmt_list}: ok
              | {assign}: X: integer variable was_set
                | {name x}: X: integer variable was_set
                | {int 30}: integer notnull

The statement ending at line XXXX

SWITCH x
  WHEN 1 THEN NOTHING
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0381: case expression must be a not-null integral type

  {switch_stmt}: err
  | {int 0}
  | {switch_body}
    | {name x}: X: integer variable was_set
    | {switch_case}
      | {connector}
        | {expr_list}
          | {int 1}

The statement ending at line XXXX

SWITCH z
  WHEN 1, 2 THEN
    SET y := 1;
  WHEN 3 THEN NOTHING
  ELSE
    SET y := 2;
END;

  {switch_stmt}: ok
  | {int 0}
  | {switch_body}
    | {name z}: z: integer notnull variable
    | {switch_case}: ok
      | {connector}
      | | {expr_list}: ok
      | | | {int 1}: integer notnull
      | | | {expr_list}
      | |   | {int 2}: integer notnull
      | | {stmt_list}: ok
      |   | {assign}: Y: integer variable was_set
      |     | {name y}: Y: integer variable was_set
      |     | {int 1}: integer notnull
      | {switch_case}
        | {connector}
        | | {expr_list}: ok
        |   | {int 3}: integer notnull
        | {switch_case}
          | {connector}
            | {stmt_list}: ok
              | {assign}: Y: integer variable was_set
                | {name y}: Y: integer variable was_set
                | {int 2}: integer notnull

The statement ending at line XXXX

DECLARE ENUM three_things INTEGER (
  zip = 0,
  zero = 0,
  one = 1,
  two = 2,
  _count = 3
);

  {declare_enum_stmt}: three_things: integer<three_things> notnull
  | {typed_name}: three_things: integer<three_things> notnull
  | | {name three_things}
  | | {type_int}: three_things: integer<three_things> notnull
  | {enum_values}
    | {enum_value}
    | | {name zip}: integer = 0 notnull
    | | {int 0}: integer notnull
    | {enum_values}
      | {enum_value}
      | | {name zero}: integer = 0 notnull
      | | {int 0}: integer notnull
      | {enum_values}
        | {enum_value}
        | | {name one}: integer = 1 notnull
        | | {int 1}: integer notnull
        | {enum_values}
          | {enum_value}
          | | {name two}: integer = 2 notnull
          | | {int 2}: integer notnull
          | {enum_values}
            | {enum_value}
              | {name _count}: integer = 3 notnull
              | {int 3}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN 0, 1, 2 THEN
    SET x := 1;
END;

  {switch_stmt}: ok
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: ok
      | {connector}
        | {expr_list}: ok
        | | {int 0}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 1}: integer<three_things> notnull
        |   | {expr_list}
        |     | {int 2}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 1 ALL VALUES
  WHEN 1, 2 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0386: SWITCH ... ALL VALUES is used but the switch expression is not an enum type

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 1}: err
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 1}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 2}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN 1, 2 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0387: a value exists in the enum that is not present in the switch 'zero'

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 1}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 2}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN 0, 2 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0387: a value exists in the enum that is not present in the switch 'one'

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 0}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 2}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN 0, 1 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0387: a value exists in the enum that is not present in the switch 'two'

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 0}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 1}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN -1, 0, 1, 2 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in uminus : CQL0388: a value exists in the switch that is not present in the enum '-1'

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {uminus}: integer notnull
        | | | {int 1}: integer notnull
        | | {expr_list}
        |   | {int 0}: integer<three_things> notnull
        |   | {expr_list}
        |     | {int 1}: integer<three_things> notnull
        |     | {expr_list}
        |       | {int 2}: integer<three_things> notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SWITCH 0 ALL VALUES
  WHEN 0, 1, 2, 5 THEN
    SET x := 1;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0388: a value exists in the switch that is not present in the enum '5'

  {switch_stmt}: err
  | {int 1}
  | {switch_body}
    | {int 0}: integer<three_things> notnull
    | {switch_case}: err
      | {connector}
        | {expr_list}: ok
        | | {int 0}: integer<three_things> notnull
        | | {expr_list}
        |   | {int 1}: integer<three_things> notnull
        |   | {expr_list}
        |     | {int 2}: integer<three_things> notnull
        |     | {expr_list}
        |       | {int 5}: integer notnull
        | {stmt_list}: ok
          | {assign}: X: integer variable was_set
            | {name x}: X: integer variable was_set
            | {int 1}: integer notnull

The statement ending at line XXXX

SELECT 1 = NULL;

test/sem_test.sql:XXXX:1: error: in eq : CQL0373: comparing against NULL always yields NULL; use IS and IS NOT instead

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {eq}: err
  |     |     | {int 1}: integer notnull
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 <> NULL;

test/sem_test.sql:XXXX:1: error: in ne : CQL0373: comparing against NULL always yields NULL; use IS and IS NOT instead

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {ne}: err
  |     |     | {int 1}: integer notnull
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 + ( SELECT NULL );

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0374: SELECT expression is equivalent to NULL

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {int 1}: integer notnull
  |     |     | {select_stmt}: err
  |     |       | {select_core_list}: select: { _anon: null }
  |     |       | | {select_core}: select: { _anon: null }
  |     |       |   | {select_expr_list_con}: select: { _anon: null }
  |     |       |     | {select_expr_list}: select: { _anon: null }
  |     |       |     | | {select_expr}: null
  |     |       |     |   | {null}: null
  |     |       |     | {select_from_etc}: ok
  |     |       |       | {select_where}
  |     |       |         | {select_groupby}
  |     |       |           | {select_having}
  |     |       | {select_orderby}
  |     |         | {select_limit}
  |     |           | {select_offset}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE PROC out2_proc (x INTEGER, OUT y INTEGER NOT NULL, OUT z INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name out2_proc}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: x: integer variable in
      | | {param_detail}: x: integer variable in
      |   | {name x}: x: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: y: integer notnull variable out
        | | {out}
        | | {param_detail}: y: integer notnull variable out
        |   | {name y}: y: integer notnull variable out
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: z: integer notnull variable out
            | {out}
            | {param_detail}: z: integer notnull variable out
              | {name z}: z: integer notnull variable out
              | {notnull}: integer notnull
                | {type_int}: integer

The statement ending at line XXXX

DECLARE OUT CALL not_defined();

test/sem_test.sql:XXXX:1: error: in declare_out_call_stmt : CQL0389: DECLARE OUT requires that the procedure be already declared 'not_defined'

  {declare_out_call_stmt}: err
  | {call_stmt}
    | {name not_defined}

The statement ending at line XXXX

DECLARE OUT CALL decl1(1);

test/sem_test.sql:XXXX:1: error: in str : CQL0390: DECLARE OUT CALL used on a procedure with no missing OUT arguments 'decl1'

  {declare_out_call_stmt}: err
  | {call_stmt}
    | {name decl1}
    | {expr_list}
      | {int 1}

The statement ending at line XXXX

CREATE PROC decl_test_err ()
BEGIN
  DECLARE OUT CALL out2_proc(NOT 'x', u, v);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name decl_test_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_out_call_stmt}: err
        | {call_stmt}: err
          | {name out2_proc}: ok
          | {expr_list}: ok
            | {not}: err
            | | {strlit 'x'}: text notnull
            | {expr_list}
              | {name u}
              | {expr_list}
                | {name v}

The statement ending at line XXXX

DECLARE OUT CALL decl_test_err(1, 2, 3);

test/sem_test.sql:XXXX:1: error: in declare_out_call_stmt : CQL0213: procedure had errors, can't call 'decl_test_err'

  {declare_out_call_stmt}: err
  | {call_stmt}
    | {name decl_test_err}
    | {expr_list}
      | {int 1}
      | {expr_list}
        | {int 2}
        | {expr_list}
          | {int 3}

The statement ending at line XXXX

DECLARE OUT CALL out2_proc(u, u, v);

test/sem_test.sql:XXXX:1: error: in str : CQL0426: OUT or INOUT argument cannot be used again in same call 'u'

  {declare_out_call_stmt}: err
  | {call_stmt}: err
    | {name out2_proc}: ok
    | {expr_list}: ok
      | {name u}: u: integer notnull variable implicit
      | {expr_list}
        | {name u}: u: integer notnull variable implicit
        | {expr_list}
          | {name v}: v: integer notnull variable implicit

The statement ending at line XXXX

DECLARE OUT CALL out2_proc(1, u, u);

test/sem_test.sql:XXXX:1: error: in str : CQL0426: OUT or INOUT argument cannot be used again in same call 'u'

  {declare_out_call_stmt}: err
  | {call_stmt}: err
    | {name out2_proc}: ok
    | {expr_list}: ok
      | {int 1}: integer notnull
      | {expr_list}
        | {name u}: u: integer notnull variable implicit was_set
        | {expr_list}
          | {name u}: u: integer notnull variable implicit was_set

The statement ending at line XXXX

CREATE PROC out_decl_test_2 (x INTEGER)
BEGIN
  DECLARE OUT CALL out2_proc(x, 1 + 3, v);
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0207: expected a variable name for OUT or INOUT argument 'y'

  {create_proc_stmt}: err
  | {name out_decl_test_2}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: err
      | {declare_out_call_stmt}: err
        | {call_stmt}
          | {name out2_proc}
          | {expr_list}
            | {name x}
            | {expr_list}
              | {add}
              | | {int 1}
              | | {int 3}
              | {expr_list}
                | {name v}

The statement ending at line XXXX

CREATE TABLE this_table_is_deleted(
  id INTEGER
) @DELETE(1);

  {create_table_stmt}: this_table_is_deleted: { id: integer } deleted @delete(1)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name this_table_is_deleted}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE INDEX deleted_index ON this_table_is_deleted (xyx) @DELETE(1);

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0397: object is an orphan because its table is deleted. Remove rather than @delete 'deleted_index'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name deleted_index}
  | | {name this_table_is_deleted}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
      | | {indexed_columns}
      |   | {indexed_column}
      |     | {name xyx}
      | {delete_attr}
        | {version_annotation}
          | {int 1}

The statement ending at line XXXX

CREATE TRIGGER trigger_deleted
  BEFORE DELETE ON this_table_is_deleted
BEGIN
  SELECT 1;
END @DELETE(1);

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0397: object is an orphan because its table is deleted. Remove rather than @delete 'trigger_deleted'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
    | | {name trigger_deleted}
    | | {trigger_condition}
    |   | {int 4}
    |   | {trigger_op_target}
    |     | {trigger_operation}
    |     | | {int 64}
    |     | {trigger_target_action}
    |       | {name this_table_is_deleted}
    |       | {trigger_action}
    |         | {int 0}
    |         | {trigger_when_stmts}
    |           | {stmt_list}
    |             | {select_stmt}
    |               | {select_core_list}
    |               | | {select_core}
    |               |   | {select_expr_list_con}
    |               |     | {select_expr_list}
    |               |     | | {select_expr}
    |               |     |   | {int 1}
    |               |     | {select_from_etc}
    |               |       | {select_where}
    |               |         | {select_groupby}
    |               |           | {select_having}
    |               | {select_orderby}
    |                 | {select_limit}
    |                   | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 1}

The statement ending at line XXXX

CREATE PROC out_decl_test_3 (x INTEGER)
BEGIN
  DECLARE OUT CALL out2_proc(x, u, v);
END;

  {create_proc_stmt}: ok
  | {name out_decl_test_3}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_out_call_stmt}: ok
        | {call_stmt}: ok
          | {name out2_proc}: ok
          | {expr_list}: ok
            | {name x}: x: integer variable in
            | {expr_list}
              | {name u}: u: integer notnull variable implicit
              | {expr_list}
                | {name v}: v: integer notnull variable implicit

The statement ending at line XXXX

CREATE PROC out_decl_test_4 (x INTEGER)
BEGIN
  DECLARE OUT CALL out2_proc(x, u, v);
  DECLARE OUT CALL out2_proc(x, u, v);
END;

  {create_proc_stmt}: ok
  | {name out_decl_test_4}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer variable in
    |   | {param_detail}: x: integer variable in
    |     | {name x}: x: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_out_call_stmt}: ok
      | | {call_stmt}: ok
      |   | {name out2_proc}: ok
      |   | {expr_list}: ok
      |     | {name x}: x: integer variable in
      |     | {expr_list}
      |       | {name u}: u: integer notnull variable implicit
      |       | {expr_list}
      |         | {name v}: v: integer notnull variable implicit
      | {declare_out_call_stmt}: ok
        | {call_stmt}: ok
          | {name out2_proc}: ok
          | {expr_list}: ok
            | {name x}: x: integer variable in
            | {expr_list}
              | {name u}: u: integer notnull variable was_set
              | {expr_list}
                | {name v}: v: integer notnull variable was_set

The statement ending at line XXXX

INSERT INTO with_kind(id, cost, value) SELECT 1 AS id, 3.5 AS cost, 4.8 AS value;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer<some_key>
      |   | {name_list}
      |     | {name cost}: cost: real<dollars>
      |     | {name_list}
      |       | {name value}: value: real<dollars>
      | {select_stmt}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        | {select_core_list}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        | | {select_core}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        |   | {select_expr_list_con}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        |     | {select_expr_list}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        |     | | {select_expr}: id: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name id}
        |     | | {select_expr_list}
        |     |   | {select_expr}: cost: real notnull
        |     |   | | {dbl 3.5}: real notnull
        |     |   | | {opt_as_alias}
        |     |   |   | {name cost}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: value: real notnull
        |     |       | {dbl 4.8}: real notnull
        |     |       | {opt_as_alias}
        |     |         | {name value}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

INSERT INTO with_kind USING SELECT 1, 3.5 AS cost, 4.8 AS value;

test/sem_test.sql:XXXX:1: error: in select_stmt : CQL0055: all columns in the select must have a name

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | {select_stmt}: err
      | {select_core_list}: select: { _anon: integer notnull, cost: real notnull, value: real notnull }
      | | {select_core}: select: { _anon: integer notnull, cost: real notnull, value: real notnull }
      |   | {select_expr_list_con}: select: { _anon: integer notnull, cost: real notnull, value: real notnull }
      |     | {select_expr_list}: select: { _anon: integer notnull, cost: real notnull, value: real notnull }
      |     | | {select_expr}: integer notnull
      |     | | | {int 1}: integer notnull
      |     | | {select_expr_list}
      |     |   | {select_expr}: cost: real notnull
      |     |   | | {dbl 3.5}: real notnull
      |     |   | | {opt_as_alias}
      |     |   |   | {name cost}
      |     |   | {select_expr_list}
      |     |     | {select_expr}: value: real notnull
      |     |       | {dbl 4.8}: real notnull
      |     |       | {opt_as_alias}
      |     |         | {name value}
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

INSERT INTO with_kind USING SELECT NOT 'x', 3.5 AS cost, 4.8 AS value;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {insert_stmt}: err
  | {insert_normal}
  | {name_columns_values}
    | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | {select_stmt}: err
      | {select_core_list}: err
      | | {select_core}: err
      |   | {select_expr_list_con}: err
      |     | {select_expr_list}: err
      |     | | {select_expr}: err
      |     | | | {not}: err
      |     | |   | {strlit 'x'}: text notnull
      |     | | {select_expr_list}
      |     |   | {select_expr}
      |     |   | | {dbl 3.5}
      |     |   | | {opt_as_alias}
      |     |   |   | {name cost}
      |     |   | {select_expr_list}
      |     |     | {select_expr}
      |     |       | {dbl 4.8}
      |     |       | {opt_as_alias}
      |     |         | {name value}
      |     | {select_from_etc}: ok
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

INSERT INTO with_kind(id, cost, value) WITH
goo (x) AS (SELECT 1)
SELECT goo.x AS id, 3.5 AS cost, 4.8 AS value
  FROM goo;

  {insert_stmt}: ok
  | {insert_normal}
  | {name_columns_values}
    | {name with_kind}: with_kind: { id: integer<some_key>, cost: real<dollars>, value: real<dollars> }
    | {columns_values}: ok
      | {column_spec}
      | | {name_list}
      |   | {name id}: id: integer<some_key>
      |   | {name_list}
      |     | {name cost}: cost: real<dollars>
      |     | {name_list}
      |       | {name value}: value: real<dollars>
      | {with_select_stmt}: select: { id: integer notnull, cost: real notnull, value: real notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: goo: { x: integer notnull }
        |     | {cte_decl}: goo: { x: integer notnull }
        |     | | {name goo}
        |     | | {name_list}
        |     |   | {name x}
        |     | {select_stmt}: select: { _anon: integer notnull }
        |       | {select_core_list}: select: { _anon: integer notnull }
        |       | | {select_core}: select: { _anon: integer notnull }
        |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
        |       |     | {select_expr_list}: select: { _anon: integer notnull }
        |       |     | | {select_expr}: integer notnull
        |       |     |   | {int 1}: integer notnull
        |       |     | {select_from_etc}: ok
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {select_stmt}: select: { id: integer notnull, cost: real notnull, value: real notnull }
          | {select_core_list}: select: { id: integer notnull, cost: real notnull, value: real notnull }
          | | {select_core}: select: { id: integer notnull, cost: real notnull, value: real notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull, cost: real notnull, value: real notnull }
          |     | {select_expr_list}: select: { id: integer notnull, cost: real notnull, value: real notnull }
          |     | | {select_expr}: id: integer notnull
          |     | | | {dot}: x: integer notnull
          |     | | | | {name goo}
          |     | | | | {name x}
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: cost: real notnull
          |     |   | | {dbl 3.5}: real notnull
          |     |   | | {opt_as_alias}
          |     |   |   | {name cost}
          |     |   | {select_expr_list}
          |     |     | {select_expr}: value: real notnull
          |     |       | {dbl 4.8}: real notnull
          |     |       | {opt_as_alias}
          |     |         | {name value}
          |     | {select_from_etc}: TABLE { goo: goo }
          |       | {table_or_subquery_list}: TABLE { goo: goo }
          |       | | {table_or_subquery}: TABLE { goo: goo }
          |       |   | {name goo}: TABLE { goo: goo }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TABLE moving_to_recreate(
  id INTEGER
) @CREATE(1, cql:from_recreate);

  {create_table_stmt}: moving_to_recreate: { id: integer } @create(1)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | |     | {dot}: ok
  | |       | {name cql}
  | |       | {name from_recreate}
  | | {name moving_to_recreate}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE bogus_builtin_migrator(
  id INTEGER
) @CREATE(1, cql:fxom_recreate);

test/sem_test.sql:XXXX:1: error: in dot : CQL0379: unknown built-in migration procedure 'cql:fxom_recreate'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}: err
  | |   | {version_annotation}
  | |     | {int 1}
  | |     | {dot}: err
  | |       | {name cql}
  | |       | {name fxom_recreate}
  | | {name bogus_builtin_migrator}
  | {col_key_list}
    | {col_def}
      | {col_def_type_attrs}
        | {col_def_name_type}
          | {name id}
          | {type_int}

The statement ending at line XXXX

CREATE TABLE bogus_builtin_migrator_placement(
  id INTEGER,
  id2 INTEGER @CREATE(2, cql:from_recreate)
) @CREATE(1);

test/sem_test.sql:XXXX:1: error: in dot : CQL0378: built-in migration procedure not valid in this context 'cql:from_recreate'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 1}
  | | {name bogus_builtin_migrator_placement}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: err
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {create_attr}: err
            | {version_annotation}
              | {int 2}
              | {dot}: err
                | {name cql}
                | {name from_recreate}

The statement ending at line XXXX

DECLARE PROC proc_as_func (IN transport_key_ TEXT, OUT code_ TEXT NOT NULL @SENSITIVE) USING TRANSACTION;

  {declare_proc_stmt}: ok dml_proc
  | {proc_name_type}
  | | {name proc_as_func}: ok dml_proc
  | | {int 2}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: transport_key_: text variable in
      | | {in}
      | | {param_detail}: transport_key_: text variable in
      |   | {name transport_key_}: transport_key_: text variable in
      |   | {type_text}: text
      | {params}
        | {param}: code_: text notnull variable init_required out sensitive
          | {out}
          | {param_detail}: code_: text notnull variable init_required out sensitive
            | {name code_}: code_: text notnull variable init_required out sensitive
            | {sensitive_attr}: text notnull sensitive
              | {notnull}: text notnull
                | {type_text}: text

The statement ending at line XXXX

LET pr := proc_as_func("t");

  {let_stmt}: pr: text notnull variable sensitive
  | {name pr}: pr: text notnull variable sensitive
  | {call}: text notnull sensitive
    | {name proc_as_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 't'}: text notnull

The statement ending at line XXXX

DECLARE pr2 TEXT;

  {declare_vars_type}: text
  | {name_list}: pr2: text variable was_set
  | | {name pr2}: pr2: text variable was_set
  | {type_text}: text

The statement ending at line XXXX

SET pr2 := proc_as_func("t");

test/sem_test.sql:XXXX:1: error: in call : CQL0014: cannot assign/copy sensitive expression to non-sensitive target 'pr2'

  {assign}: err
  | {name pr2}: err
  | {call}: text notnull sensitive
    | {name proc_as_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 't'}: text notnull

The statement ending at line XXXX

CREATE TABLE conflict_clause_t(
  id INTEGER NOT NULL ON CONFLICT FAIL
);

  {create_table_stmt}: conflict_clause_t: { id: integer notnull }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name conflict_clause_t}
  | {col_key_list}
    | {col_def}: id: integer notnull
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_not_null}: ok
          | {int 2}

The statement ending at line XXXX

CREATE TABLE conflict_clause_pk(
  id INTEGER NOT NULL,
  CONSTRAINT pk1 PRIMARY KEY (id) ON CONFLICT ROLLBACK
);

  {create_table_stmt}: conflict_clause_pk: { id: integer notnull partial_pk }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name conflict_clause_pk}
  | {col_key_list}
    | {col_def}: id: integer notnull partial_pk
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {pk_def}
        | {name pk1}
        | {indexed_columns_conflict_clause}
          | {indexed_columns}
          | | {indexed_column}
          |   | {name id}: id: integer notnull
          | {int 0}

The statement ending at line XXXX

@ATTRIBUTE(cql:base_fragment=id_frag)
CREATE PROC id_frag_base ()
BEGIN
  WITH
  id_frag (id) AS (SELECT 1)
  SELECT *
    FROM id_frag;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name base_fragment}
  |   | {name id_frag}: ok
  | {create_proc_stmt}: id_frag_base: { id: integer notnull } dml_proc
    | {name id_frag_base}: id_frag_base: { id: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { id: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: id_frag: { id: integer notnull }
          |     | {cte_decl}: id_frag: { id: integer notnull }
          |     | | {name id_frag}
          |     | | {name_list}
          |     |   | {name id}
          |     | {select_stmt}: select: { _anon: integer notnull }
          |       | {select_core_list}: select: { _anon: integer notnull }
          |       | | {select_core}: select: { _anon: integer notnull }
          |       |   | {select_expr_list_con}: select: { _anon: integer notnull }
          |       |     | {select_expr_list}: select: { _anon: integer notnull }
          |       |     | | {select_expr}: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { id: integer notnull }
            | {select_core_list}: select: { id: integer notnull }
            | | {select_core}: select: { id: integer notnull }
            |   | {select_expr_list_con}: select: { id: integer notnull }
            |     | {select_expr_list}: select: { id: integer notnull }
            |     | | {star}: select: { id: integer notnull }
            |     | {select_from_etc}: TABLE { id_frag: id_frag }
            |       | {table_or_subquery_list}: TABLE { id_frag: id_frag }
            |       | | {table_or_subquery}: TABLE { id_frag: id_frag }
            |       |   | {name id_frag}: TABLE { id_frag: id_frag }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:extension_fragment=id_frag)
CREATE PROC bogus_ext ()
BEGIN
  WITH
  id_frag (id) AS (SELECT *
    FROM foo),
  ext1 (id) AS (SELECT *
    FROM id_frag
  UNION ALL
  SELECT 3.5 AS id)
  SELECT *
    FROM ext1;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0061: in extension fragment, all columns must be an exact type match (expected integer notnull; found real notnull) 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name extension_fragment}
  |   | {name id_frag}: ok
  | {create_proc_stmt}: err
    | {name bogus_ext}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: select: { id: real notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: id_frag: { id: integer notnull }
          |   | | {cte_decl}: id_frag: { id: integer notnull }
          |   | | | {name id_frag}
          |   | | | {name_list}
          |   | |   | {name id}
          |   | | {select_stmt}: select: { id: integer notnull }
          |   |   | {select_core_list}: select: { id: integer notnull }
          |   |   | | {select_core}: select: { id: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { id: integer notnull }
          |   |   |     | {select_expr_list}: select: { id: integer notnull }
          |   |   |     | | {star}: select: { id: integer notnull }
          |   |   |     | {select_from_etc}: TABLE { foo: foo }
          |   |   |       | {table_or_subquery_list}: TABLE { foo: foo }
          |   |   |       | | {table_or_subquery}: TABLE { foo: foo }
          |   |   |       |   | {name foo}: TABLE { foo: foo }
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: ext1: { id: real notnull }
          |       | {cte_decl}: ext1: { id: real notnull }
          |       | | {name ext1}
          |       | | {name_list}
          |       |   | {name id}
          |       | {select_stmt}: UNION ALL: { id: real notnull }
          |         | {select_core_list}: UNION ALL: { id: real notnull }
          |         | | {select_core}: select: { id: integer notnull }
          |         | | | {select_expr_list_con}: select: { id: integer notnull }
          |         | |   | {select_expr_list}: select: { id: integer notnull }
          |         | |   | | {star}: select: { id: integer notnull }
          |         | |   | {select_from_etc}: TABLE { id_frag: id_frag }
          |         | |     | {table_or_subquery_list}: TABLE { id_frag: id_frag }
          |         | |     | | {table_or_subquery}: TABLE { id_frag: id_frag }
          |         | |     |   | {name id_frag}: TABLE { id_frag: id_frag }
          |         | |     | {select_where}
          |         | |       | {select_groupby}
          |         | |         | {select_having}
          |         | | {select_core_compound}
          |         |   | {int 2}
          |         |   | {select_core_list}: select: { id: real notnull }
          |         |     | {select_core}: select: { id: real notnull }
          |         |       | {select_expr_list_con}: select: { id: real notnull }
          |         |         | {select_expr_list}: select: { id: real notnull }
          |         |         | | {select_expr}: id: real notnull
          |         |         |   | {dbl 3.5}: real notnull
          |         |         |   | {opt_as_alias}
          |         |         |     | {name id}
          |         |         | {select_from_etc}: ok
          |         |           | {select_where}
          |         |             | {select_groupby}
          |         |               | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { id: real notnull }
            | {select_core_list}: select: { id: real notnull }
            | | {select_core}: select: { id: real notnull }
            |   | {select_expr_list_con}: select: { id: real notnull }
            |     | {select_expr_list}: select: { id: real notnull }
            |     | | {star}: select: { id: real notnull }
            |     | {select_from_etc}: TABLE { ext1: ext1 }
            |       | {table_or_subquery_list}: TABLE { ext1: ext1 }
            |       | | {table_or_subquery}: TABLE { ext1: ext1 }
            |       |   | {name ext1}: TABLE { ext1: ext1 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

CREATE TABLE foo(
  id INTEGER
);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE foo(
  id INTEGER PRIMARY KEY AUTOINCREMENT
)
test/sem_test.sql:XXXX:1: error: in create_table_stmt : CREATE TABLE foo(
  id INTEGER
)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in str : CQL0103: duplicate table/view name 'foo'

  {create_table_stmt}: err
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name foo}: err
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE PROC conditionals_improve_nullable_variables ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  LET x0 := a;
  IF a IS NOT NULL THEN
    LET x1 := a;
  ELSE
    LET x2 := a;
    IF a IS NOT NULL THEN
      LET x3 := a;
    ELSE
      LET x4 := a;
    END IF;
  END IF;
  LET x5 := a;
END;

  {create_proc_stmt}: ok
  | {name conditionals_improve_nullable_variables}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable
      | | | {name c}: c: integer variable
      | | {type_int}: integer
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is_not}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x1: integer notnull variable
      | |     | {name x1}: x1: integer notnull variable
      | |     | {call}: a: integer notnull variable
      | |       | {name cql_inferred_notnull}: a: integer notnull variable
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name a}: a: integer inferred_notnull variable
      | | {if_alt}: ok
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {let_stmt}: x2: integer variable
      |       | | {name x2}: x2: integer variable
      |       | | {name a}: a: integer variable
      |       | {if_stmt}: bool notnull
      |         | {cond_action}: bool notnull
      |         | | {is_not}: bool notnull
      |         | | | {name a}: a: integer variable
      |         | | | {null}: null
      |         | | {stmt_list}: ok
      |         |   | {let_stmt}: x3: integer notnull variable
      |         |     | {name x3}: x3: integer notnull variable
      |         |     | {call}: a: integer notnull variable
      |         |       | {name cql_inferred_notnull}: a: integer notnull variable
      |         |       | {call_arg_list}
      |         |         | {call_filter_clause}
      |         |         | {arg_list}: ok
      |         |           | {name a}: a: integer inferred_notnull variable
      |         | {if_alt}: ok
      |           | {else}: ok
      |             | {stmt_list}: ok
      |               | {let_stmt}: x4: integer variable
      |                 | {name x4}: x4: integer variable
      |                 | {name a}: a: integer variable
      | {let_stmt}: x5: integer variable
        | {name x5}: x5: integer variable
        | {name a}: a: integer variable

The statement ending at line XXXX

CREATE PROC conditionals_only_improve_through_ands ()
BEGIN
  DECLARE a TEXT;
  DECLARE b TEXT;
  DECLARE c TEXT;
  IF a IS NOT NULL AND (b IS NOT NULL OR c IS NOT NULL) THEN
    DECLARE c0 CURSOR FOR SELECT a AS a0, b AS b0, c AS c0;
    IF (b IS NOT NULL OR a LIKE "hello") AND c IS NOT NULL THEN
      DECLARE c1 CURSOR FOR SELECT a AS a1, b AS b1, c AS c1;
      IF b IS NOT NULL THEN
        DECLARE c2 CURSOR FOR SELECT a AS a2, b AS b2, c AS c2;
      END IF;
    END IF;
  END IF;
END;

  {create_proc_stmt}: ok dml_proc
  | {name conditionals_only_improve_through_ands}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text
      | | {name_list}: a: text variable
      | | | {name a}: a: text variable
      | | {type_text}: text
      | {declare_vars_type}: text
      | | {name_list}: b: text variable
      | | | {name b}: b: text variable
      | | {type_text}: text
      | {declare_vars_type}: text
      | | {name_list}: c: text variable
      | | | {name c}: c: text variable
      | | {type_text}: text
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {name a}: a: text variable
        | | | | {null}: null
        | | | {or}: bool notnull
        | |   | {is_not}: bool notnull
        | |   | | {name b}: b: text variable
        | |   | | {null}: null
        | |   | {is_not}: bool notnull
        | |     | {name c}: c: text variable
        | |     | {null}: null
        | | {stmt_list}: ok
        |   | {declare_cursor}: c0: select: { a0: text notnull variable, b0: text variable, c0: text variable } variable dml_proc
        |   | | {name c0}: c0: select: { a0: text notnull variable, b0: text variable, c0: text variable } variable dml_proc
        |   | | {select_stmt}: select: { a0: text notnull variable, b0: text variable, c0: text variable }
        |   |   | {select_core_list}: select: { a0: text notnull variable, b0: text variable, c0: text variable }
        |   |   | | {select_core}: select: { a0: text notnull variable, b0: text variable, c0: text variable }
        |   |   |   | {select_expr_list_con}: select: { a0: text notnull variable, b0: text variable, c0: text variable }
        |   |   |     | {select_expr_list}: select: { a0: text notnull variable, b0: text variable, c0: text variable }
        |   |   |     | | {select_expr}: a0: text notnull variable
        |   |   |     | | | {call}: a: text notnull variable
        |   |   |     | | | | {name cql_inferred_notnull}: a: text notnull variable
        |   |   |     | | | | {call_arg_list}
        |   |   |     | | |   | {call_filter_clause}
        |   |   |     | | |   | {arg_list}: ok
        |   |   |     | | |     | {name a}: a: text inferred_notnull variable
        |   |   |     | | | {opt_as_alias}
        |   |   |     | |   | {name a0}
        |   |   |     | | {select_expr_list}
        |   |   |     |   | {select_expr}: b0: text variable
        |   |   |     |   | | {name b}: b: text variable
        |   |   |     |   | | {opt_as_alias}
        |   |   |     |   |   | {name b0}
        |   |   |     |   | {select_expr_list}
        |   |   |     |     | {select_expr}: c0: text variable
        |   |   |     |       | {name c}: c: text variable
        |   |   |     |       | {opt_as_alias}
        |   |   |     |         | {name c0}
        |   |   |     | {select_from_etc}: ok
        |   |   |       | {select_where}
        |   |   |         | {select_groupby}
        |   |   |           | {select_having}
        |   |   | {select_orderby}
        |   |     | {select_limit}
        |   |       | {select_offset}
        |   | {if_stmt}: bool notnull
        |     | {cond_action}: bool notnull
        |     | | {and}: bool notnull
        |     | | | {or}: bool notnull
        |     | | | | {is_not}: bool notnull
        |     | | | | | {name b}: b: text variable
        |     | | | | | {null}: null
        |     | | | | {like}: bool notnull
        |     | | |   | {call}: a: text notnull variable
        |     | | |   | | {name cql_inferred_notnull}: a: text notnull variable
        |     | | |   | | {call_arg_list}
        |     | | |   |   | {call_filter_clause}
        |     | | |   |   | {arg_list}: ok
        |     | | |   |     | {name a}: a: text inferred_notnull variable
        |     | | |   | {strlit 'hello'}: text notnull
        |     | | | {is_not}: bool notnull
        |     | |   | {name c}: c: text variable
        |     | |   | {null}: null
        |     | | {stmt_list}: ok
        |     |   | {declare_cursor}: c1: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable } variable dml_proc
        |     |   | | {name c1}: c1: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable } variable dml_proc
        |     |   | | {select_stmt}: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable }
        |     |   |   | {select_core_list}: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable }
        |     |   |   | | {select_core}: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable }
        |     |   |   |   | {select_expr_list_con}: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable }
        |     |   |   |     | {select_expr_list}: select: { a1: text notnull variable, b1: text variable, c1: text notnull variable }
        |     |   |   |     | | {select_expr}: a1: text notnull variable
        |     |   |   |     | | | {call}: a: text notnull variable
        |     |   |   |     | | | | {name cql_inferred_notnull}: a: text notnull variable
        |     |   |   |     | | | | {call_arg_list}
        |     |   |   |     | | |   | {call_filter_clause}
        |     |   |   |     | | |   | {arg_list}: ok
        |     |   |   |     | | |     | {name a}: a: text inferred_notnull variable
        |     |   |   |     | | | {opt_as_alias}
        |     |   |   |     | |   | {name a1}
        |     |   |   |     | | {select_expr_list}
        |     |   |   |     |   | {select_expr}: b1: text variable
        |     |   |   |     |   | | {name b}: b: text variable
        |     |   |   |     |   | | {opt_as_alias}
        |     |   |   |     |   |   | {name b1}
        |     |   |   |     |   | {select_expr_list}
        |     |   |   |     |     | {select_expr}: c1: text notnull variable
        |     |   |   |     |       | {call}: c: text notnull variable
        |     |   |   |     |       | | {name cql_inferred_notnull}: c: text notnull variable
        |     |   |   |     |       | | {call_arg_list}
        |     |   |   |     |       |   | {call_filter_clause}
        |     |   |   |     |       |   | {arg_list}: ok
        |     |   |   |     |       |     | {name c}: c: text inferred_notnull variable
        |     |   |   |     |       | {opt_as_alias}
        |     |   |   |     |         | {name c1}
        |     |   |   |     | {select_from_etc}: ok
        |     |   |   |       | {select_where}
        |     |   |   |         | {select_groupby}
        |     |   |   |           | {select_having}
        |     |   |   | {select_orderby}
        |     |   |     | {select_limit}
        |     |   |       | {select_offset}
        |     |   | {if_stmt}: bool notnull
        |     |     | {cond_action}: bool notnull
        |     |     | | {is_not}: bool notnull
        |     |     | | | {name b}: b: text variable
        |     |     | | | {null}: null
        |     |     | | {stmt_list}: ok
        |     |     |   | {declare_cursor}: c2: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable } variable dml_proc
        |     |     |     | {name c2}: c2: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable } variable dml_proc
        |     |     |     | {select_stmt}: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable }
        |     |     |       | {select_core_list}: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable }
        |     |     |       | | {select_core}: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable }
        |     |     |       |   | {select_expr_list_con}: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable }
        |     |     |       |     | {select_expr_list}: select: { a2: text notnull variable, b2: text notnull variable, c2: text notnull variable }
        |     |     |       |     | | {select_expr}: a2: text notnull variable
        |     |     |       |     | | | {call}: a: text notnull variable
        |     |     |       |     | | | | {name cql_inferred_notnull}: a: text notnull variable
        |     |     |       |     | | | | {call_arg_list}
        |     |     |       |     | | |   | {call_filter_clause}
        |     |     |       |     | | |   | {arg_list}: ok
        |     |     |       |     | | |     | {name a}: a: text inferred_notnull variable
        |     |     |       |     | | | {opt_as_alias}
        |     |     |       |     | |   | {name a2}
        |     |     |       |     | | {select_expr_list}
        |     |     |       |     |   | {select_expr}: b2: text notnull variable
        |     |     |       |     |   | | {call}: b: text notnull variable
        |     |     |       |     |   | | | {name cql_inferred_notnull}: b: text notnull variable
        |     |     |       |     |   | | | {call_arg_list}
        |     |     |       |     |   | |   | {call_filter_clause}
        |     |     |       |     |   | |   | {arg_list}: ok
        |     |     |       |     |   | |     | {name b}: b: text inferred_notnull variable
        |     |     |       |     |   | | {opt_as_alias}
        |     |     |       |     |   |   | {name b2}
        |     |     |       |     |   | {select_expr_list}
        |     |     |       |     |     | {select_expr}: c2: text notnull variable
        |     |     |       |     |       | {call}: c: text notnull variable
        |     |     |       |     |       | | {name cql_inferred_notnull}: c: text notnull variable
        |     |     |       |     |       | | {call_arg_list}
        |     |     |       |     |       |   | {call_filter_clause}
        |     |     |       |     |       |   | {arg_list}: ok
        |     |     |       |     |       |     | {name c}: c: text inferred_notnull variable
        |     |     |       |     |       | {opt_as_alias}
        |     |     |       |     |         | {name c2}
        |     |     |       |     | {select_from_etc}: ok
        |     |     |       |       | {select_where}
        |     |     |       |         | {select_groupby}
        |     |     |       |           | {select_having}
        |     |     |       | {select_orderby}
        |     |     |         | {select_limit}
        |     |     |           | {select_offset}
        |     |     | {if_alt}: ok
        |     | {if_alt}: ok
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC local_improvements_persist_until_set_to_a_nullable ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  LET x0 := a;
  LET y0 := b;
  IF a IS NOT NULL AND b IS NOT NULL THEN
    LET x1 := a;
    LET y1 := b;
    SET b := NULL;
    LET x2 := a;
    LET y2 := b;
    IF b IS NOT NULL THEN
      LET x3 := a;
      LET y3 := b;
      SET a := NULL;
      LET x4 := a;
      LET y4 := b;
      SET b := NULL;
    END IF;
    LET x5 := a;
    LET y5 := b;
  END IF;
  LET x6 := a;
  LET y6 := b;
END;

  {create_proc_stmt}: ok
  | {name local_improvements_persist_until_set_to_a_nullable}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y0: integer variable
      | | {name y0}: y0: integer variable
      | | {name b}: b: integer variable
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {and}: bool notnull
      | | | | {is_not}: bool notnull
      | | | | | {name a}: a: integer variable
      | | | | | {null}: null
      | | | | {is_not}: bool notnull
      | | |   | {name b}: b: integer variable
      | | |   | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x1: integer notnull variable
      | |   | | {name x1}: x1: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y1: integer notnull variable
      | |   | | {name y1}: y1: integer notnull variable
      | |   | | {call}: b: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | {assign}: b: integer variable was_set
      | |   | | {name b}: b: integer variable was_set
      | |   | | {null}: null
      | |   | {let_stmt}: x2: integer notnull variable
      | |   | | {name x2}: x2: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y2: integer variable
      | |   | | {name y2}: y2: integer variable
      | |   | | {name b}: b: integer variable was_set
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is_not}: bool notnull
      | |   | | | | {name b}: b: integer variable was_set
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {let_stmt}: x3: integer notnull variable
      | |   | |   | | {name x3}: x3: integer notnull variable
      | |   | |   | | {call}: a: integer notnull variable
      | |   | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | |   | {let_stmt}: y3: integer notnull variable
      | |   | |   | | {name y3}: y3: integer notnull variable
      | |   | |   | | {call}: b: integer notnull variable was_set
      | |   | |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name b}: b: integer inferred_notnull variable was_set
      | |   | |   | {assign}: a: integer variable was_set
      | |   | |   | | {name a}: a: integer variable was_set
      | |   | |   | | {null}: null
      | |   | |   | {let_stmt}: x4: integer variable
      | |   | |   | | {name x4}: x4: integer variable
      | |   | |   | | {name a}: a: integer variable was_set
      | |   | |   | {let_stmt}: y4: integer notnull variable
      | |   | |   | | {name y4}: y4: integer notnull variable
      | |   | |   | | {call}: b: integer notnull variable was_set
      | |   | |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name b}: b: integer inferred_notnull variable was_set
      | |   | |   | {assign}: b: integer variable was_set
      | |   | |     | {name b}: b: integer variable was_set
      | |   | |     | {null}: null
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x5: integer variable
      | |   | | {name x5}: x5: integer variable
      | |   | | {name a}: a: integer variable was_set
      | |   | {let_stmt}: y5: integer variable
      | |     | {name y5}: y5: integer variable
      | |     | {name b}: b: integer variable was_set
      | | {if_alt}: ok
      | {let_stmt}: x6: integer variable
      | | {name x6}: x6: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y6: integer variable
        | {name y6}: y6: integer variable
        | {name b}: b: integer variable was_set

The statement ending at line XXXX

CREATE PROC set_can_improve_a_type_if_set_to_something_not_null ()
BEGIN
  DECLARE a INTEGER;
  LET x0 := a;
  SET a := 42;
  LET x1 := a;
  SET a := NULL;
  LET x2 := a;
END;

  {create_proc_stmt}: ok
  | {name set_can_improve_a_type_if_set_to_something_not_null}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 42}: integer notnull
      | {let_stmt}: x1: integer notnull variable
      | | {name x1}: x1: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {null}: null
      | {let_stmt}: x2: integer variable
        | {name x2}: x2: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_added_by_set_do_not_persist_outside_the_statement_list ()
BEGIN
  DECLARE a INTEGER;
  IF 0 THEN
    SET a := 42;
    LET x0 := a;
  END IF;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_added_by_set_do_not_persist_outside_the_statement_list}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |   | | {name a}: a: integer variable was_set
      | |   | | {int 42}: integer notnull
      | |   | {let_stmt}: x0: integer notnull variable
      | |     | {name x0}: x0: integer notnull variable
      | |     | {call}: a: integer notnull variable was_set
      | |       | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name a}: a: integer inferred_notnull variable was_set
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_removed_by_set_do_persist_outside_the_statement_list ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    LET x0 := a;
    IF 1 THEN
      SET a := NULL;
    END IF;
  END IF;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_removed_by_set_do_persist_outside_the_statement_list}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is_not}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {if_stmt}: integer notnull
      | |     | {cond_action}: integer notnull
      | |     | | {int 1}: integer notnull
      | |     | | {stmt_list}: ok
      | |     |   | {assign}: a: integer variable was_set
      | |     |     | {name a}: a: integer variable was_set
      | |     |     | {null}: null
      | |     | {if_alt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_work_in_case_expressions ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  LET x0 := CASE WHEN a IS NOT NULL THEN a + a
  ELSE 42
  END;
  LET y0 := CASE WHEN b IS NULL THEN 42
  WHEN 0 THEN b + b
  ELSE b + b
  END;
  LET x1 := a;
  LET y1 := b;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_in_case_expressions}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {case_expr}: integer notnull
      |   | {connector}: integer notnull
      |     | {case_list}: integer notnull
      |     | | {when}: integer notnull
      |     |   | {is_not}: bool notnull
      |     |   | | {name a}: a: integer variable
      |     |   | | {null}: null
      |     |   | {add}: integer notnull
      |     |     | {call}: a: integer notnull variable
      |     |     | | {name cql_inferred_notnull}: a: integer notnull variable
      |     |     | | {call_arg_list}
      |     |     |   | {call_filter_clause}
      |     |     |   | {arg_list}: ok
      |     |     |     | {name a}: a: integer inferred_notnull variable
      |     |     | {call}: a: integer notnull variable
      |     |       | {name cql_inferred_notnull}: a: integer notnull variable
      |     |       | {call_arg_list}
      |     |         | {call_filter_clause}
      |     |         | {arg_list}: ok
      |     |           | {name a}: a: integer inferred_notnull variable
      |     | {int 42}: integer notnull
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {case_expr}: integer notnull
      |   | {connector}: integer notnull
      |     | {case_list}: integer notnull
      |     | | {when}: integer notnull
      |     | | | {is}: bool notnull
      |     | | | | {name b}: b: integer variable
      |     | | | | {null}: null
      |     | | | {int 42}: integer notnull
      |     | | {case_list}: integer notnull
      |     |   | {when}: integer notnull
      |     |     | {int 0}: integer notnull
      |     |     | {add}: integer notnull
      |     |       | {call}: b: integer notnull variable
      |     |       | | {name cql_inferred_notnull}: b: integer notnull variable
      |     |       | | {call_arg_list}
      |     |       |   | {call_filter_clause}
      |     |       |   | {arg_list}: ok
      |     |       |     | {name b}: b: integer inferred_notnull variable
      |     |       | {call}: b: integer notnull variable
      |     |         | {name cql_inferred_notnull}: b: integer notnull variable
      |     |         | {call_arg_list}
      |     |           | {call_filter_clause}
      |     |           | {arg_list}: ok
      |     |             | {name b}: b: integer inferred_notnull variable
      |     | {add}: integer notnull
      |       | {call}: b: integer notnull variable
      |       | | {name cql_inferred_notnull}: b: integer notnull variable
      |       | | {call_arg_list}
      |       |   | {call_filter_clause}
      |       |   | {arg_list}: ok
      |       |     | {name b}: b: integer inferred_notnull variable
      |       | {call}: b: integer notnull variable
      |         | {name cql_inferred_notnull}: b: integer notnull variable
      |         | {call_arg_list}
      |           | {call_filter_clause}
      |           | {arg_list}: ok
      |             | {name b}: b: integer inferred_notnull variable
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y1: integer variable
        | {name y1}: y1: integer variable
        | {name b}: b: integer variable

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_in_case_expressions_with_matching ()
BEGIN
  DECLARE a INTEGER;
  LET x := CASE FALSE WHEN a IS NOT NULL THEN a + a
  ELSE 42
  END;
END;

  {create_proc_stmt}: ok
  | {name improvements_do_not_work_in_case_expressions_with_matching}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {let_stmt}: x: integer variable
        | {name x}: x: integer variable
        | {case_expr}: integer
          | {bool 0}: bool notnull
          | {connector}: integer
            | {case_list}: integer
            | | {when}: integer
            |   | {is_not}: bool notnull
            |   | | {name a}: a: integer variable
            |   | | {null}: null
            |   | {add}: integer
            |     | {name a}: a: integer variable
            |     | {name a}: a: integer variable
            | {int 42}: integer notnull

The statement ending at line XXXX

CREATE PROC improvements_work_in_iif_expressions ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  LET x0 := CASE WHEN a IS NOT NULL THEN a + a
  ELSE 42
  END;
  LET y0 := CASE WHEN b IS NULL THEN 42
  ELSE b + b
  END;
  LET x1 := a;
  LET y1 := b;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_in_iif_expressions}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {case_expr}: integer notnull
      |   | {connector}: integer notnull
      |     | {case_list}: integer notnull
      |     | | {when}: integer notnull
      |     |   | {is_not}: bool notnull
      |     |   | | {name a}: a: integer variable
      |     |   | | {null}: null
      |     |   | {add}: integer notnull
      |     |     | {call}: a: integer notnull variable
      |     |     | | {name cql_inferred_notnull}: a: integer notnull variable
      |     |     | | {call_arg_list}
      |     |     |   | {call_filter_clause}
      |     |     |   | {arg_list}: ok
      |     |     |     | {name a}: a: integer inferred_notnull variable
      |     |     | {call}: a: integer notnull variable
      |     |       | {name cql_inferred_notnull}: a: integer notnull variable
      |     |       | {call_arg_list}
      |     |         | {call_filter_clause}
      |     |         | {arg_list}: ok
      |     |           | {name a}: a: integer inferred_notnull variable
      |     | {int 42}: integer notnull
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {case_expr}: integer notnull
      |   | {connector}: integer notnull
      |     | {case_list}: integer notnull
      |     | | {when}: integer notnull
      |     |   | {is}: bool notnull
      |     |   | | {name b}: b: integer variable
      |     |   | | {null}: null
      |     |   | {int 42}: integer notnull
      |     | {add}: integer notnull
      |       | {call}: b: integer notnull variable
      |       | | {name cql_inferred_notnull}: b: integer notnull variable
      |       | | {call_arg_list}
      |       |   | {call_filter_clause}
      |       |   | {arg_list}: ok
      |       |     | {name b}: b: integer inferred_notnull variable
      |       | {call}: b: integer notnull variable
      |         | {name cql_inferred_notnull}: b: integer notnull variable
      |         | {call_arg_list}
      |           | {call_filter_clause}
      |           | {arg_list}: ok
      |             | {name b}: b: integer inferred_notnull variable
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y1: integer variable
        | {name y1}: y1: integer variable
        | {name b}: b: integer variable

The statement ending at line XXXX

CREATE PROC sets_out (OUT a INTEGER, OUT b INTEGER)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name sets_out}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer variable out
      | | {out}
      | | {param_detail}: a: integer variable out
      |   | {name a}: a: integer variable out
      |   | {type_int}: integer
      | {params}
        | {param}: b: integer variable out
          | {out}
          | {param_detail}: b: integer variable out
            | {name b}: b: integer variable out
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC local_improvements_persist_until_used_as_out_arg ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE x INTEGER;
  IF a IS NOT NULL AND b IS NOT NULL THEN
    LET x0 := a;
    LET y0 := b;
    CALL sets_out(x, b);
    LET x1 := a;
    LET y1 := b;
    CALL sets_out(a, x);
    LET x2 := a;
    LET y2 := b;
  END IF;
  IF a IS NOT NULL AND b IS NOT NULL THEN
    LET x3 := a;
    LET y3 := b;
    CALL sets_out(a, b);
    LET x4 := a;
    LET y4 := b;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name local_improvements_persist_until_used_as_out_arg}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: x: integer variable was_set
      | | | {name x}: x: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {and}: bool notnull
      | | | | {is_not}: bool notnull
      | | | | | {name a}: a: integer variable
      | | | | | {null}: null
      | | | | {is_not}: bool notnull
      | | |   | {name b}: b: integer variable
      | | |   | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y0: integer notnull variable
      | |   | | {name y0}: y0: integer notnull variable
      | |   | | {call}: b: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | {call_stmt}: ok
      | |   | | {name sets_out}: ok
      | |   | | {expr_list}: ok
      | |   |   | {name x}: x: integer variable
      | |   |   | {expr_list}
      | |   |     | {name b}: b: integer inferred_notnull variable
      | |   | {let_stmt}: x1: integer notnull variable
      | |   | | {name x1}: x1: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y1: integer variable
      | |   | | {name y1}: y1: integer variable
      | |   | | {name b}: b: integer variable was_set
      | |   | {call_stmt}: ok
      | |   | | {name sets_out}: ok
      | |   | | {expr_list}: ok
      | |   |   | {name a}: a: integer inferred_notnull variable
      | |   |   | {expr_list}
      | |   |     | {name x}: x: integer variable was_set
      | |   | {let_stmt}: x2: integer variable
      | |   | | {name x2}: x2: integer variable
      | |   | | {name a}: a: integer variable was_set
      | |   | {let_stmt}: y2: integer variable
      | |     | {name y2}: y2: integer variable
      | |     | {name b}: b: integer variable was_set
      | | {if_alt}: ok
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {name a}: a: integer variable was_set
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {name b}: b: integer variable was_set
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x3: integer notnull variable
        |   | | {name x3}: x3: integer notnull variable
        |   | | {call}: a: integer notnull variable was_set
        |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {name a}: a: integer inferred_notnull variable was_set
        |   | {let_stmt}: y3: integer notnull variable
        |   | | {name y3}: y3: integer notnull variable
        |   | | {call}: b: integer notnull variable was_set
        |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {name b}: b: integer inferred_notnull variable was_set
        |   | {call_stmt}: ok
        |   | | {name sets_out}: ok
        |   | | {expr_list}: ok
        |   |   | {name a}: a: integer inferred_notnull variable was_set
        |   |   | {expr_list}
        |   |     | {name b}: b: integer inferred_notnull variable was_set
        |   | {let_stmt}: x4: integer variable
        |   | | {name x4}: x4: integer variable
        |   | | {name a}: a: integer variable was_set
        |   | {let_stmt}: y4: integer variable
        |     | {name y4}: y4: integer variable
        |     | {name b}: b: integer variable was_set
        | {if_alt}: ok

The statement ending at line XXXX

CREATE TABLE tnull(
  xn INTEGER,
  yn INTEGER
);

  {create_table_stmt}: tnull: { xn: integer, yn: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name tnull}
  | {col_key_list}
    | {col_def}: xn: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name xn}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: yn: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name yn}
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC local_improvements_persist_until_fetch_into ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE x INTEGER;
  DECLARE c CURSOR FOR SELECT *
    FROM tnull;
  IF a IS NOT NULL AND b IS NOT NULL THEN
    LET x0 := a;
    LET y0 := b;
    FETCH c INTO x, b;
    LET x1 := a;
    LET y1 := b;
    FETCH c INTO a, x;
    LET x2 := a;
    LET y2 := b;
  END IF;
  IF a IS NOT NULL AND b IS NOT NULL THEN
    LET x3 := a;
    LET y3 := b;
    FETCH c INTO a, b;
    LET x4 := a;
    LET y4 := b;
  END IF;
END;

  {create_proc_stmt}: ok dml_proc
  | {name local_improvements_persist_until_fetch_into}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: x: integer variable was_set
      | | | {name x}: x: integer variable was_set
      | | {type_int}: integer
      | {declare_cursor}: c: select: { xn: integer, yn: integer } variable dml_proc
      | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
      | | {select_stmt}: select: { xn: integer, yn: integer }
      |   | {select_core_list}: select: { xn: integer, yn: integer }
      |   | | {select_core}: select: { xn: integer, yn: integer }
      |   |   | {select_expr_list_con}: select: { xn: integer, yn: integer }
      |   |     | {select_expr_list}: select: { xn: integer, yn: integer }
      |   |     | | {star}: select: { xn: integer, yn: integer }
      |   |     | {select_from_etc}: TABLE { tnull: tnull }
      |   |       | {table_or_subquery_list}: TABLE { tnull: tnull }
      |   |       | | {table_or_subquery}: TABLE { tnull: tnull }
      |   |       |   | {name tnull}: TABLE { tnull: tnull }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {and}: bool notnull
      | | | | {is_not}: bool notnull
      | | | | | {name a}: a: integer variable
      | | | | | {null}: null
      | | | | {is_not}: bool notnull
      | | |   | {name b}: b: integer variable
      | | |   | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y0: integer notnull variable
      | |   | | {name y0}: y0: integer notnull variable
      | |   | | {call}: b: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | {fetch_stmt}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
      | |   | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc
      | |   | | {name_list}
      | |   |   | {name x}: x: integer variable was_set
      | |   |   | {name_list}
      | |   |     | {name b}: b: integer variable was_set
      | |   | {let_stmt}: x1: integer notnull variable
      | |   | | {name x1}: x1: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y1: integer variable
      | |   | | {name y1}: y1: integer variable
      | |   | | {name b}: b: integer variable was_set
      | |   | {fetch_stmt}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
      | |   | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
      | |   | | {name_list}
      | |   |   | {name a}: a: integer variable was_set
      | |   |   | {name_list}
      | |   |     | {name x}: x: integer variable was_set
      | |   | {let_stmt}: x2: integer variable
      | |   | | {name x2}: x2: integer variable
      | |   | | {name a}: a: integer variable was_set
      | |   | {let_stmt}: y2: integer variable
      | |     | {name y2}: y2: integer variable
      | |     | {name b}: b: integer variable was_set
      | | {if_alt}: ok
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {name a}: a: integer variable was_set
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {name b}: b: integer variable was_set
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x3: integer notnull variable
        |   | | {name x3}: x3: integer notnull variable
        |   | | {call}: a: integer notnull variable was_set
        |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {name a}: a: integer inferred_notnull variable was_set
        |   | {let_stmt}: y3: integer notnull variable
        |   | | {name y3}: y3: integer notnull variable
        |   | | {call}: b: integer notnull variable was_set
        |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {name b}: b: integer inferred_notnull variable was_set
        |   | {fetch_stmt}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
        |   | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc fetch_into
        |   | | {name_list}
        |   |   | {name a}: a: integer variable was_set
        |   |   | {name_list}
        |   |     | {name b}: b: integer variable was_set
        |   | {let_stmt}: x4: integer variable
        |   | | {name x4}: x4: integer variable
        |   | | {name a}: a: integer variable was_set
        |   | {let_stmt}: y4: integer variable
        |     | {name y4}: y4: integer variable
        |     | {name b}: b: integer variable was_set
        | {if_alt}: ok

The statement ending at line XXXX

DECLARE c_global CURSOR LIKE tnull;

  {declare_cursor_like_name}: c_global: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
  | {name c_global}: c_global: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
  | {shape_def}: tnull: { xn: integer, yn: integer }
    | {like}: ok
      | {name tnull}

The statement ending at line XXXX

CREATE PROC improvements_work_for_auto_cursors ()
BEGIN
  DECLARE c CURSOR FOR SELECT *
    FROM tnull;
  FETCH c;
  LET x0 := c.xn;
  LET y0 := c.yn;
  IF c.xn IS NOT NULL AND c.yn IS NOT NULL THEN
    LET x1 := c.xn;
    LET y1 := c.yn;
    FETCH c;
    LET x2 := c.xn;
    LET y2 := c.yn;
  END IF;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_auto_cursors}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c: select: { xn: integer, yn: integer } variable dml_proc
      | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc shape_storage
      | | {select_stmt}: select: { xn: integer, yn: integer }
      |   | {select_core_list}: select: { xn: integer, yn: integer }
      |   | | {select_core}: select: { xn: integer, yn: integer }
      |   |   | {select_expr_list_con}: select: { xn: integer, yn: integer }
      |   |     | {select_expr_list}: select: { xn: integer, yn: integer }
      |   |     | | {star}: select: { xn: integer, yn: integer }
      |   |     | {select_from_etc}: TABLE { tnull: tnull }
      |   |       | {table_or_subquery_list}: TABLE { tnull: tnull }
      |   |       | | {table_or_subquery}: TABLE { tnull: tnull }
      |   |       |   | {name tnull}: TABLE { tnull: tnull }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c: select: { xn: integer, yn: integer } variable dml_proc shape_storage
      | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc shape_storage
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {dot}: c.xn: integer variable
      |   | {name c}
      |   | {name xn}
      | {let_stmt}: y0: integer variable
      | | {name y0}: y0: integer variable
      | | {dot}: c.yn: integer variable
      |   | {name c}
      |   | {name yn}
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: c.xn: integer variable
        | | | | | {name c}
        | | | | | {name xn}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: c.yn: integer variable
        | |   | | {name c}
        | |   | | {name yn}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.xn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name xn}
        |   | {let_stmt}: y1: integer notnull variable
        |   | | {name y1}: y1: integer notnull variable
        |   | | {call}: c.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.yn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name yn}
        |   | {fetch_stmt}: c: select: { xn: integer, yn: integer } variable dml_proc shape_storage
        |   | | {name c}: c: select: { xn: integer, yn: integer } variable dml_proc shape_storage
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: c.xn: integer variable
        |   |   | {name c}
        |   |   | {name xn}
        |   | {let_stmt}: y2: integer variable
        |     | {name y2}: y2: integer variable
        |     | {dot}: c.yn: integer variable
        |       | {name c}
        |       | {name yn}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_for_local_auto_cursors_that_do_not_shadow_a_global ()
BEGIN
  DECLARE c_local CURSOR LIKE tnull;
  FETCH c_local(xn, yn) FROM VALUES(0, 0);
  LET x0 := c_local.xn;
  LET y0 := c_local.yn;
  IF c_local.xn IS NOT NULL AND c_local.yn IS NOT NULL THEN
    LET x1 := c_local.xn;
    LET y1 := c_local.yn;
    FETCH c_local(xn, yn) FROM VALUES(0, 0);
    LET x2 := c_local.xn;
    LET y2 := c_local.yn;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_local_auto_cursors_that_do_not_shadow_a_global}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: c_local: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {name c_local}: c_local: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {shape_def}: tnull: { xn: integer, yn: integer }
      |   | {like}: ok
      |     | {name tnull}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c_local}: c_local: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name xn}: xn: integer
      |     |   | {name_list}
      |     |     | {name yn}: yn: integer
      |     | {insert_list}: ok
      |       | {int 0}: integer notnull
      |       | {insert_list}
      |         | {int 0}: integer notnull
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {dot}: c_local.xn: integer variable
      |   | {name c_local}
      |   | {name xn}
      | {let_stmt}: y0: integer variable
      | | {name y0}: y0: integer variable
      | | {dot}: c_local.yn: integer variable
      |   | {name c_local}
      |   | {name yn}
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: c_local.xn: integer variable
        | | | | | {name c_local}
        | | | | | {name xn}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: c_local.yn: integer variable
        | |   | | {name c_local}
        | |   | | {name yn}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c_local.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_local.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_local.xn: integer inferred_notnull variable
        |   |         | {name c_local}
        |   |         | {name xn}
        |   | {let_stmt}: y1: integer notnull variable
        |   | | {name y1}: y1: integer notnull variable
        |   | | {call}: c_local.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_local.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_local.yn: integer inferred_notnull variable
        |   |         | {name c_local}
        |   |         | {name yn}
        |   | {fetch_values_stmt}: ok
        |   | | {name_columns_values}
        |   |   | {name c_local}: c_local: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   |   | {columns_values}: ok
        |   |     | {column_spec}
        |   |     | | {name_list}
        |   |     |   | {name xn}: xn: integer
        |   |     |   | {name_list}
        |   |     |     | {name yn}: yn: integer
        |   |     | {insert_list}: ok
        |   |       | {int 0}: integer notnull
        |   |       | {insert_list}
        |   |         | {int 0}: integer notnull
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: c_local.xn: integer variable
        |   |   | {name c_local}
        |   |   | {name xn}
        |   | {let_stmt}: y2: integer variable
        |     | {name y2}: y2: integer variable
        |     | {dot}: c_local.yn: integer variable
        |       | {name c_local}
        |       | {name yn}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_for_auto_cursors_that_shadow_a_global ()
BEGIN
  DECLARE c_global CURSOR LIKE SELECT nullable(1) AS xn, nullable(2) AS yn;
  FETCH c_global(xn, yn) FROM VALUES(0, 0);
  LET x0 := c_global.xn;
  LET y0 := c_global.yn;
  IF c_global.xn IS NOT NULL AND c_global.yn IS NOT NULL THEN
    LET x1 := c_global.xn;
    LET y1 := c_global.yn;
    FETCH c_global(xn, yn) FROM VALUES(0, 0);
    LET x2 := c_global.xn;
    LET y2 := c_global.yn;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_auto_cursors_that_shadow_a_global}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: c_global: select: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {name c_global}: c_global: select: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {select_stmt}: select: { xn: integer, yn: integer }
      |   | {select_core_list}: select: { xn: integer, yn: integer }
      |   | | {select_core}: select: { xn: integer, yn: integer }
      |   |   | {select_expr_list_con}: select: { xn: integer, yn: integer }
      |   |     | {select_expr_list}: select: { xn: integer, yn: integer }
      |   |     | | {select_expr}: xn: integer
      |   |     | | | {call}: integer
      |   |     | | | | {name nullable}: integer
      |   |     | | | | {call_arg_list}
      |   |     | | |   | {call_filter_clause}
      |   |     | | |   | {arg_list}: ok
      |   |     | | |     | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name xn}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: yn: integer
      |   |     |     | {call}: integer
      |   |     |     | | {name nullable}: integer
      |   |     |     | | {call_arg_list}
      |   |     |     |   | {call_filter_clause}
      |   |     |     |   | {arg_list}: ok
      |   |     |     |     | {int 2}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name yn}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c_global}: c_global: select: { xn: integer, yn: integer } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name xn}: xn: integer
      |     |   | {name_list}
      |     |     | {name yn}: yn: integer
      |     | {insert_list}: ok
      |       | {int 0}: integer notnull
      |       | {insert_list}
      |         | {int 0}: integer notnull
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {dot}: c_global.xn: integer variable
      |   | {name c_global}
      |   | {name xn}
      | {let_stmt}: y0: integer variable
      | | {name y0}: y0: integer variable
      | | {dot}: c_global.yn: integer variable
      |   | {name c_global}
      |   | {name yn}
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: c_global.xn: integer variable
        | | | | | {name c_global}
        | | | | | {name xn}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: c_global.yn: integer variable
        | |   | | {name c_global}
        | |   | | {name yn}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c_global.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.xn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name xn}
        |   | {let_stmt}: y1: integer notnull variable
        |   | | {name y1}: y1: integer notnull variable
        |   | | {call}: c_global.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.yn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name yn}
        |   | {fetch_values_stmt}: ok
        |   | | {name_columns_values}
        |   |   | {name c_global}: c_global: select: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   |   | {columns_values}: ok
        |   |     | {column_spec}
        |   |     | | {name_list}
        |   |     |   | {name xn}: xn: integer
        |   |     |   | {name_list}
        |   |     |     | {name yn}: yn: integer
        |   |     | {insert_list}: ok
        |   |       | {int 0}: integer notnull
        |   |       | {insert_list}
        |   |         | {int 0}: integer notnull
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: c_global.xn: integer variable
        |   |   | {name c_global}
        |   |   | {name xn}
        |   | {let_stmt}: y2: integer variable
        |     | {name y2}: y2: integer variable
        |     | {dot}: c_global.yn: integer variable
        |       | {name c_global}
        |       | {name yn}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_for_global_auto_cursors ()
BEGIN
  FETCH c_global(xn, yn) FROM VALUES(0, 0);
  LET x0 := c_global.xn;
  LET y0 := c_global.yn;
  IF c_global.xn IS NOT NULL AND c_global.yn IS NOT NULL THEN
    LET x1 := c_global.xn;
    LET y1 := c_global.yn;
    FETCH c_global(xn, yn) FROM VALUES(0, 0);
    LET x2 := c_global.xn;
    LET y2 := c_global.yn;
    IF c_global.xn IS NULL OR c_global.yn IS NULL THEN
      RETURN;
    END IF;
    LET x3 := c_global.xn;
    LET y3 := c_global.yn;
    CALL proc1();
    LET x4 := c_global.xn;
    LET y4 := c_global.yn;
  END IF;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_global_auto_cursors}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c_global}: c_global: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name xn}: xn: integer
      |     |   | {name_list}
      |     |     | {name yn}: yn: integer
      |     | {insert_list}: ok
      |       | {int 0}: integer notnull
      |       | {insert_list}
      |         | {int 0}: integer notnull
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {dot}: c_global.xn: integer variable
      |   | {name c_global}
      |   | {name xn}
      | {let_stmt}: y0: integer variable
      | | {name y0}: y0: integer variable
      | | {dot}: c_global.yn: integer variable
      |   | {name c_global}
      |   | {name yn}
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: c_global.xn: integer variable
        | | | | | {name c_global}
        | | | | | {name xn}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: c_global.yn: integer variable
        | |   | | {name c_global}
        | |   | | {name yn}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c_global.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.xn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name xn}
        |   | {let_stmt}: y1: integer notnull variable
        |   | | {name y1}: y1: integer notnull variable
        |   | | {call}: c_global.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.yn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name yn}
        |   | {fetch_values_stmt}: ok
        |   | | {name_columns_values}
        |   |   | {name c_global}: c_global: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   |   | {columns_values}: ok
        |   |     | {column_spec}
        |   |     | | {name_list}
        |   |     |   | {name xn}: xn: integer
        |   |     |   | {name_list}
        |   |     |     | {name yn}: yn: integer
        |   |     | {insert_list}: ok
        |   |       | {int 0}: integer notnull
        |   |       | {insert_list}
        |   |         | {int 0}: integer notnull
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: c_global.xn: integer variable
        |   |   | {name c_global}
        |   |   | {name xn}
        |   | {let_stmt}: y2: integer variable
        |   | | {name y2}: y2: integer variable
        |   | | {dot}: c_global.yn: integer variable
        |   |   | {name c_global}
        |   |   | {name yn}
        |   | {if_stmt}: bool notnull
        |   | | {cond_action}: bool notnull
        |   | | | {or}: bool notnull
        |   | | | | {is}: bool notnull
        |   | | | | | {dot}: c_global.xn: integer variable
        |   | | | | | | {name c_global}
        |   | | | | | | {name xn}
        |   | | | | | {null}: null
        |   | | | | {is}: bool notnull
        |   | | |   | {dot}: c_global.yn: integer variable
        |   | | |   | | {name c_global}
        |   | | |   | | {name yn}
        |   | | |   | {null}: null
        |   | | | {stmt_list}: ok
        |   | |   | {return_stmt}: ok
        |   | | {if_alt}: ok
        |   | {let_stmt}: x3: integer notnull variable
        |   | | {name x3}: x3: integer notnull variable
        |   | | {call}: c_global.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.xn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name xn}
        |   | {let_stmt}: y3: integer notnull variable
        |   | | {name y3}: y3: integer notnull variable
        |   | | {call}: c_global.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c_global.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c_global.yn: integer inferred_notnull variable
        |   |         | {name c_global}
        |   |         | {name yn}
        |   | {call_stmt}: ok dml_proc
        |   | | {name proc1}: ok dml_proc
        |   | {let_stmt}: x4: integer variable
        |   | | {name x4}: x4: integer variable
        |   | | {dot}: c_global.xn: integer variable
        |   |   | {name c_global}
        |   |   | {name xn}
        |   | {let_stmt}: y4: integer variable
        |     | {name y4}: y4: integer variable
        |     | {dot}: c_global.yn: integer variable
        |       | {name c_global}
        |       | {name yn}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_for_in_args (a INTEGER)
BEGIN
  IF a IS NOT NULL THEN
    LET x := a;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_in_args}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {name a}: a: integer variable in
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x: integer notnull variable
        |     | {name x}: x: integer notnull variable
        |     | {call}: a: integer notnull variable in
        |       | {name cql_inferred_notnull}: a: integer notnull variable in
        |       | {call_arg_list}
        |         | {call_filter_clause}
        |         | {arg_list}: ok
        |           | {name a}: a: integer inferred_notnull variable in
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC requires_notnull_out (OUT a INTEGER NOT NULL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name requires_notnull_out}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable out
        | {out}
        | {param_detail}: a: integer notnull variable out
          | {name a}: a: integer notnull variable out
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_out ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    CALL requires_notnull_out(a);
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0210: proc out parameter: arg must be an exact type match (even nullability) (expected integer notnull; found integer) 'a'

  {create_proc_stmt}: err
  | {name improvements_do_not_work_for_out}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: err
        | {cond_action}: err
        | | {is_not}: bool notnull
        | | | {name a}: a: integer variable
        | | | {null}: null
        | | {stmt_list}: err
        |   | {call_stmt}: err
        |     | {name requires_notnull_out}: ok
        |     | {expr_list}: ok
        |       | {name a}: a: integer inferred_notnull variable
        | {if_alt}

The statement ending at line XXXX

CREATE PROC requires_notnull_inout (INOUT a INTEGER NOT NULL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name requires_notnull_inout}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable in out
        | {inout}
        | {param_detail}: a: integer notnull variable in out
          | {name a}: a: integer notnull variable in out
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_inout ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    CALL requires_notnull_inout(a);
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0013: cannot assign/copy possibly null expression to not null target 'a'

  {create_proc_stmt}: err
  | {name improvements_do_not_work_for_inout}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: err
        | {cond_action}: err
        | | {is_not}: bool notnull
        | | | {name a}: a: integer variable
        | | | {null}: null
        | | {stmt_list}: err
        |   | {call_stmt}: err
        |     | {name requires_notnull_inout}: ok
        |     | {expr_list}: ok
        |       | {name a}: a: integer inferred_notnull variable
        | {if_alt}

The statement ending at line XXXX

CREATE PROC improvements_work_in_sql ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    SELECT 1 + a AS b;
  END IF;
END;

  {create_proc_stmt}: improvements_work_in_sql: { b: integer notnull } dml_proc
  | {name improvements_work_in_sql}: improvements_work_in_sql: { b: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {name a}: a: integer variable
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {select_stmt}: select: { b: integer notnull }
        |     | {select_core_list}: select: { b: integer notnull }
        |     | | {select_core}: select: { b: integer notnull }
        |     |   | {select_expr_list_con}: select: { b: integer notnull }
        |     |     | {select_expr_list}: select: { b: integer notnull }
        |     |     | | {select_expr}: b: integer notnull
        |     |     |   | {add}: integer notnull
        |     |     |   | | {int 1}: integer notnull
        |     |     |   | | {call}: a: integer notnull variable
        |     |     |   |   | {name cql_inferred_notnull}: a: integer notnull variable
        |     |     |   |   | {call_arg_list}
        |     |     |   |     | {call_filter_clause}
        |     |     |   |     | {arg_list}: ok
        |     |     |   |       | {name a}: a: integer inferred_notnull variable
        |     |     |   | {opt_as_alias}
        |     |     |     | {name b}
        |     |     | {select_from_etc}: ok
        |     |       | {select_where}
        |     |         | {select_groupby}
        |     |           | {select_having}
        |     | {select_orderby}
        |       | {select_limit}
        |         | {select_offset}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_are_not_applied_if_not_an_id_or_dot ()
BEGIN
  DECLARE a INTEGER;
  IF a + 1 IS NOT NULL THEN
    LET b := a;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name improvements_are_not_applied_if_not_an_id_or_dot}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {add}: integer
        | | | | {name a}: a: integer variable
        | | | | {int 1}: integer notnull
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: b: integer variable
        |     | {name b}: b: integer variable
        |     | {name a}: a: integer variable
        | {if_alt}: ok

The statement ending at line XXXX

DECLARE some_global INTEGER;

  {declare_vars_type}: integer
  | {name_list}: some_global: integer variable
  | | {name some_global}: some_global: integer variable
  | {type_int}: integer

The statement ending at line XXXX

CREATE PROC requires_not_nulls (a INTEGER NOT NULL, b INTEGER NOT NULL, c INTEGER NOT NULL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name requires_not_nulls}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable in
      | | {param_detail}: a: integer notnull variable in
      |   | {name a}: a: integer notnull variable in
      |   | {notnull}: integer notnull
      |     | {type_int}: integer
      | {params}
        | {param}: b: integer notnull variable in
        | | {param_detail}: b: integer notnull variable in
        |   | {name b}: b: integer notnull variable in
        |   | {notnull}: integer notnull
        |     | {type_int}: integer
        | {params}
          | {param}: c: integer notnull variable in
            | {param_detail}: c: integer notnull variable in
              | {name c}: c: integer notnull variable in
              | {notnull}: integer notnull
                | {type_int}: integer

The statement ending at line XXXX

CREATE PROC returns_int_not_null (OUT a INTEGER NOT NULL)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name returns_int_not_null}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable out
        | {out}
        | {param_detail}: a: integer notnull variable out
          | {name a}: a: integer notnull variable out
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC improvements_work_for_globals ()
BEGIN
  IF some_global IS NOT NULL THEN
    LET x0 := some_global;
    LET x1 := CASE WHEN 0 THEN some_global
    ELSE some_global
    END;
    CALL some_external_thing();
    LET x2 := some_global;
    SELECT round(4.2) AS a;
    LET x3 := some_global;
    CALL proc1();
    LET x4 := some_global;
    IF some_global IS NULL THEN
      RETURN;
    END IF;
    LET x5 := some_global;
    CALL requires_not_nulls(some_global, some_global, some_global);
    LET x6 := some_global;
    IF some_global IS NULL THEN
      RETURN;
    END IF;
    LET x7 := some_global;
    LET x8 := returns_int_not_null() + some_global;
    IF some_global IS NULL THEN
      RETURN;
    END IF;
    LET x9 := some_global;
    LET x10 := CASE WHEN 0 THEN returns_int_not_null()
    ELSE some_global
    END;
    DECLARE c CURSOR FETCH FROM CALL out_cursor_proc();
    LET x11 := some_global;
    IF some_global IS NULL THEN
      RETURN;
    END IF;
    LET x12 := some_global;
  END IF;
  LET x13 := some_global;
END;

  {create_proc_stmt}: improvements_work_for_globals: { a: longint notnull } dml_proc
  | {name improvements_work_for_globals}: improvements_work_for_globals: { a: longint notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is_not}: bool notnull
      | | | | {name some_global}: some_global: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {let_stmt}: x1: integer notnull variable
      | |   | | {name x1}: x1: integer notnull variable
      | |   | | {case_expr}: integer notnull
      | |   |   | {connector}: integer notnull
      | |   |     | {case_list}: integer notnull variable
      | |   |     | | {when}: some_global: integer notnull variable
      | |   |     |   | {int 0}: integer notnull
      | |   |     |   | {call}: some_global: integer notnull variable
      | |   |     |     | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |     |     | {call_arg_list}
      | |   |     |       | {call_filter_clause}
      | |   |     |       | {arg_list}: ok
      | |   |     |         | {name some_global}: some_global: integer inferred_notnull variable
      | |   |     | {call}: some_global: integer notnull variable
      | |   |       | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |       | {call_arg_list}
      | |   |         | {call_filter_clause}
      | |   |         | {arg_list}: ok
      | |   |           | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {call_stmt}: ok
      | |   | | {name some_external_thing}: ok
      | |   | {let_stmt}: x2: integer notnull variable
      | |   | | {name x2}: x2: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {select_stmt}: select: { a: longint notnull }
      | |   | | {select_core_list}: select: { a: longint notnull }
      | |   | | | {select_core}: select: { a: longint notnull }
      | |   | |   | {select_expr_list_con}: select: { a: longint notnull }
      | |   | |     | {select_expr_list}: select: { a: longint notnull }
      | |   | |     | | {select_expr}: a: longint notnull
      | |   | |     |   | {call}: longint notnull
      | |   | |     |   | | {name round}: longint notnull
      | |   | |     |   | | {call_arg_list}
      | |   | |     |   |   | {call_filter_clause}
      | |   | |     |   |   | {arg_list}: ok
      | |   | |     |   |     | {dbl 4.2}: real notnull
      | |   | |     |   | {opt_as_alias}
      | |   | |     |     | {name a}
      | |   | |     | {select_from_etc}: ok
      | |   | |       | {select_where}
      | |   | |         | {select_groupby}
      | |   | |           | {select_having}
      | |   | | {select_orderby}
      | |   |   | {select_limit}
      | |   |     | {select_offset}
      | |   | {let_stmt}: x3: integer notnull variable
      | |   | | {name x3}: x3: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {call_stmt}: ok dml_proc
      | |   | | {name proc1}: ok dml_proc
      | |   | {let_stmt}: x4: integer variable
      | |   | | {name x4}: x4: integer variable
      | |   | | {name some_global}: some_global: integer variable
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name some_global}: some_global: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x5: integer notnull variable
      | |   | | {name x5}: x5: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {call_stmt}: ok
      | |   | | {name requires_not_nulls}: ok
      | |   | | {expr_list}: ok
      | |   |   | {call}: some_global: integer notnull variable
      | |   |   | | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | | {call_arg_list}
      | |   |   |   | {call_filter_clause}
      | |   |   |   | {arg_list}: ok
      | |   |   |     | {name some_global}: some_global: integer inferred_notnull variable
      | |   |   | {expr_list}
      | |   |     | {call}: some_global: integer notnull variable
      | |   |     | | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |     | | {call_arg_list}
      | |   |     |   | {call_filter_clause}
      | |   |     |   | {arg_list}: ok
      | |   |     |     | {name some_global}: some_global: integer inferred_notnull variable
      | |   |     | {expr_list}
      | |   |       | {call}: some_global: integer notnull variable
      | |   |         | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |         | {call_arg_list}
      | |   |           | {call_filter_clause}
      | |   |           | {arg_list}: ok
      | |   |             | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {let_stmt}: x6: integer variable
      | |   | | {name x6}: x6: integer variable
      | |   | | {name some_global}: some_global: integer variable
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name some_global}: some_global: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x7: integer notnull variable
      | |   | | {name x7}: x7: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {let_stmt}: x8: integer variable
      | |   | | {name x8}: x8: integer variable
      | |   | | {add}: integer
      | |   |   | {call}: integer notnull
      | |   |   | | {name returns_int_not_null}
      | |   |   | | {call_arg_list}
      | |   |   |   | {call_filter_clause}
      | |   |   | {name some_global}: some_global: integer variable
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name some_global}: some_global: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x9: integer notnull variable
      | |   | | {name x9}: x9: integer notnull variable
      | |   | | {call}: some_global: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {let_stmt}: x10: integer notnull variable
      | |   | | {name x10}: x10: integer notnull variable
      | |   | | {case_expr}: integer notnull
      | |   |   | {connector}: integer notnull
      | |   |     | {case_list}: integer notnull
      | |   |     | | {when}: integer notnull
      | |   |     |   | {int 0}: integer notnull
      | |   |     |   | {call}: integer notnull
      | |   |     |     | {name returns_int_not_null}
      | |   |     |     | {call_arg_list}
      | |   |     |       | {call_filter_clause}
      | |   |     | {call}: some_global: integer notnull variable
      | |   |       | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |   |       | {call_arg_list}
      | |   |         | {call_filter_clause}
      | |   |         | {arg_list}: ok
      | |   |           | {name some_global}: some_global: integer inferred_notnull variable
      | |   | {declare_value_cursor}: c: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | |   | | {name c}: c: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage value_cursor
      | |   | | {call_stmt}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | |   |   | {name out_cursor_proc}: C: out_cursor_proc: { A: integer notnull, B: integer notnull } variable dml_proc shape_storage uses_out
      | |   | {let_stmt}: x11: integer variable
      | |   | | {name x11}: x11: integer variable
      | |   | | {name some_global}: some_global: integer variable
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name some_global}: some_global: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x12: integer notnull variable
      | |     | {name x12}: x12: integer notnull variable
      | |     | {call}: some_global: integer notnull variable
      | |       | {name cql_inferred_notnull}: some_global: integer notnull variable
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name some_global}: some_global: integer inferred_notnull variable
      | | {if_alt}: ok
      | {let_stmt}: x13: integer variable
        | {name x13}: x13: integer variable
        | {name some_global}: some_global: integer variable

The statement ending at line XXXX

CREATE PROC improvements_work_for_select_star ()
BEGIN
  SELECT *
    FROM tnull
    WHERE yn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_work_for_select_star: { xn: integer, yn: integer notnull } dml_proc
  | {name improvements_work_for_select_star}: improvements_work_for_select_star: { xn: integer, yn: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn: integer, yn: integer notnull }
        | {select_core_list}: select: { xn: integer, yn: integer notnull }
        | | {select_core}: select: { xn: integer, yn: integer notnull }
        |   | {select_expr_list_con}: select: { xn: integer, yn: integer notnull }
        |     | {select_expr_list}: select: { xn: integer, yn: integer notnull }
        |     | | {star}: select: { xn: integer, yn: integer notnull }
        |     | {select_from_etc}: TABLE { tnull: tnull }
        |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       |   | {name tnull}: TABLE { tnull: tnull }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {is_not}: bool notnull
        |         |   | {name yn}: yn: integer
        |         |   | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE another_table_with_nullables(
  xn INTEGER,
  zn INTEGER
);

  {create_table_stmt}: another_table_with_nullables: { xn: integer, zn: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name another_table_with_nullables}
  | {col_key_list}
    | {col_def}: xn: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name xn}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: zn: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name zn}
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC improvements_work_for_select_table_star ()
BEGIN
  SELECT tnull.*, another_table_with_nullables.xn AS xn0, another_table_with_nullables.zn
    FROM tnull
    INNER JOIN another_table_with_nullables ON tnull.xn = another_table_with_nullables.xn
    WHERE tnull.xn IS NOT NULL AND yn IS NOT NULL AND zn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_work_for_select_table_star: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull } dml_proc
  | {name improvements_work_for_select_table_star}: improvements_work_for_select_table_star: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull }
        | {select_core_list}: select: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull }
        | | {select_core}: select: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull }
        |   | {select_expr_list_con}: select: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull }
        |     | {select_expr_list}: select: { xn: integer notnull, yn: integer notnull, xn0: integer, zn: integer notnull }
        |     | | {table_star}: tnull: tnull: { xn: integer, yn: integer }
        |     | | | {name tnull}
        |     | | {select_expr_list}
        |     |   | {select_expr}: xn0: integer
        |     |   | | {dot}: xn: integer
        |     |   | | | {name another_table_with_nullables}
        |     |   | | | {name xn}
        |     |   | | {opt_as_alias}
        |     |   |   | {name xn0}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: zn: integer notnull
        |     |       | {call}: zn: integer notnull
        |     |         | {name cql_inferred_notnull}: zn: integer notnull
        |     |         | {call_arg_list}
        |     |           | {call_filter_clause}
        |     |           | {arg_list}: ok
        |     |             | {dot}: zn: integer inferred_notnull
        |     |               | {name another_table_with_nullables}
        |     |               | {name zn}
        |     | {select_from_etc}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | {join_clause}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       | | | {name tnull}: TABLE { tnull: tnull }
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | | {name another_table_with_nullables}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | {join_cond}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |         | {on}: bool
        |       |         | {eq}: bool
        |       |           | {dot}: xn: integer
        |       |           | | {name tnull}
        |       |           | | {name xn}
        |       |           | {dot}: xn: integer
        |       |             | {name another_table_with_nullables}
        |       |             | {name xn}
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {and}: bool notnull
        |         |   | {and}: bool notnull
        |         |   | | {is_not}: bool notnull
        |         |   | | | {dot}: xn: integer
        |         |   | | | | {name tnull}
        |         |   | | | | {name xn}
        |         |   | | | {null}: null
        |         |   | | {is_not}: bool notnull
        |         |   |   | {name yn}: yn: integer
        |         |   |   | {null}: null
        |         |   | {is_not}: bool notnull
        |         |     | {name zn}: zn: integer
        |         |     | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC improvements_work_for_select_expressions ()
BEGIN
  SELECT xn, yn
    FROM tnull
    WHERE xn IS NOT NULL AND yn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_work_for_select_expressions: { xn: integer notnull, yn: integer notnull } dml_proc
  | {name improvements_work_for_select_expressions}: improvements_work_for_select_expressions: { xn: integer notnull, yn: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn: integer notnull, yn: integer notnull }
        | {select_core_list}: select: { xn: integer notnull, yn: integer notnull }
        | | {select_core}: select: { xn: integer notnull, yn: integer notnull }
        |   | {select_expr_list_con}: select: { xn: integer notnull, yn: integer notnull }
        |     | {select_expr_list}: select: { xn: integer notnull, yn: integer notnull }
        |     | | {select_expr}: xn: integer notnull
        |     | | | {call}: xn: integer notnull
        |     | |   | {name cql_inferred_notnull}: xn: integer notnull
        |     | |   | {call_arg_list}
        |     | |     | {call_filter_clause}
        |     | |     | {arg_list}: ok
        |     | |       | {name xn}: xn: integer inferred_notnull
        |     | | {select_expr_list}
        |     |   | {select_expr}: yn: integer notnull
        |     |     | {call}: yn: integer notnull
        |     |       | {name cql_inferred_notnull}: yn: integer notnull
        |     |       | {call_arg_list}
        |     |         | {call_filter_clause}
        |     |         | {arg_list}: ok
        |     |           | {name yn}: yn: integer inferred_notnull
        |     | {select_from_etc}: TABLE { tnull: tnull }
        |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       |   | {name tnull}: TABLE { tnull: tnull }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {and}: bool notnull
        |         |   | {is_not}: bool notnull
        |         |   | | {name xn}: xn: integer
        |         |   | | {null}: null
        |         |   | {is_not}: bool notnull
        |         |     | {name yn}: yn: integer
        |         |     | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC improvements_correctly_handle_nested_selects ()
BEGIN
  SELECT ( SELECT xn ), ( SELECT yn
    FROM tnull ), ( SELECT yn
    FROM tnull
    WHERE yn IS NOT NULL ) AS yn0, ( SELECT yn ) AS yn1
    FROM tnull
    WHERE xn IS NOT NULL AND yn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_correctly_handle_nested_selects: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull } dml_proc
  | {name improvements_correctly_handle_nested_selects}: improvements_correctly_handle_nested_selects: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull }
        | {select_core_list}: select: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull }
        | | {select_core}: select: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull }
        |   | {select_expr_list_con}: select: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull }
        |     | {select_expr_list}: select: { xn: integer notnull, yn: integer, yn0: integer, yn1: integer notnull }
        |     | | {select_expr}: xn: integer notnull
        |     | | | {select_stmt}: xn: integer notnull
        |     | |   | {select_core_list}: select: { xn: integer notnull }
        |     | |   | | {select_core}: select: { xn: integer notnull }
        |     | |   |   | {select_expr_list_con}: select: { xn: integer notnull }
        |     | |   |     | {select_expr_list}: select: { xn: integer notnull }
        |     | |   |     | | {select_expr}: xn: integer notnull
        |     | |   |     |   | {call}: xn: integer notnull
        |     | |   |     |     | {name cql_inferred_notnull}: xn: integer notnull
        |     | |   |     |     | {call_arg_list}
        |     | |   |     |       | {call_filter_clause}
        |     | |   |     |       | {arg_list}: ok
        |     | |   |     |         | {name xn}: xn: integer inferred_notnull
        |     | |   |     | {select_from_etc}: ok
        |     | |   |       | {select_where}
        |     | |   |         | {select_groupby}
        |     | |   |           | {select_having}
        |     | |   | {select_orderby}
        |     | |     | {select_limit}
        |     | |       | {select_offset}
        |     | | {select_expr_list}
        |     |   | {select_expr}: yn: integer
        |     |   | | {select_stmt}: yn: integer
        |     |   |   | {select_core_list}: select: { yn: integer }
        |     |   |   | | {select_core}: select: { yn: integer }
        |     |   |   |   | {select_expr_list_con}: select: { yn: integer }
        |     |   |   |     | {select_expr_list}: select: { yn: integer }
        |     |   |   |     | | {select_expr}: yn: integer
        |     |   |   |     |   | {name yn}: yn: integer
        |     |   |   |     | {select_from_etc}: TABLE { tnull: tnull }
        |     |   |   |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |     |   |   |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |     |   |   |       |   | {name tnull}: TABLE { tnull: tnull }
        |     |   |   |       | {select_where}
        |     |   |   |         | {select_groupby}
        |     |   |   |           | {select_having}
        |     |   |   | {select_orderby}
        |     |   |     | {select_limit}
        |     |   |       | {select_offset}
        |     |   | {select_expr_list}
        |     |     | {select_expr}: yn0: integer
        |     |     | | {select_stmt}: yn: integer
        |     |     | | | {select_core_list}: select: { yn: integer notnull }
        |     |     | | | | {select_core}: select: { yn: integer notnull }
        |     |     | | |   | {select_expr_list_con}: select: { yn: integer notnull }
        |     |     | | |     | {select_expr_list}: select: { yn: integer notnull }
        |     |     | | |     | | {select_expr}: yn: integer notnull
        |     |     | | |     |   | {call}: yn: integer notnull
        |     |     | | |     |     | {name cql_inferred_notnull}: yn: integer notnull
        |     |     | | |     |     | {call_arg_list}
        |     |     | | |     |       | {call_filter_clause}
        |     |     | | |     |       | {arg_list}: ok
        |     |     | | |     |         | {name yn}: yn: integer inferred_notnull
        |     |     | | |     | {select_from_etc}: TABLE { tnull: tnull }
        |     |     | | |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |     |     | | |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |     |     | | |       |   | {name tnull}: TABLE { tnull: tnull }
        |     |     | | |       | {select_where}
        |     |     | | |         | {opt_where}: bool notnull
        |     |     | | |         | | {is_not}: bool notnull
        |     |     | | |         |   | {name yn}: yn: integer
        |     |     | | |         |   | {null}: null
        |     |     | | |         | {select_groupby}
        |     |     | | |           | {select_having}
        |     |     | | | {select_orderby}
        |     |     | |   | {select_limit}
        |     |     | |     | {select_offset}
        |     |     | | {opt_as_alias}
        |     |     |   | {name yn0}
        |     |     | {select_expr_list}
        |     |       | {select_expr}: yn1: integer notnull
        |     |         | {select_stmt}: yn: integer notnull
        |     |         | | {select_core_list}: select: { yn: integer notnull }
        |     |         | | | {select_core}: select: { yn: integer notnull }
        |     |         | |   | {select_expr_list_con}: select: { yn: integer notnull }
        |     |         | |     | {select_expr_list}: select: { yn: integer notnull }
        |     |         | |     | | {select_expr}: yn: integer notnull
        |     |         | |     |   | {call}: yn: integer notnull
        |     |         | |     |     | {name cql_inferred_notnull}: yn: integer notnull
        |     |         | |     |     | {call_arg_list}
        |     |         | |     |       | {call_filter_clause}
        |     |         | |     |       | {arg_list}: ok
        |     |         | |     |         | {name yn}: yn: integer inferred_notnull
        |     |         | |     | {select_from_etc}: ok
        |     |         | |       | {select_where}
        |     |         | |         | {select_groupby}
        |     |         | |           | {select_having}
        |     |         | | {select_orderby}
        |     |         |   | {select_limit}
        |     |         |     | {select_offset}
        |     |         | {opt_as_alias}
        |     |           | {name yn1}
        |     | {select_from_etc}: TABLE { tnull: tnull }
        |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       |   | {name tnull}: TABLE { tnull: tnull }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {and}: bool notnull
        |         |   | {is_not}: bool notnull
        |         |   | | {name xn}: xn: integer
        |         |   | | {null}: null
        |         |   | {is_not}: bool notnull
        |         |     | {name yn}: yn: integer
        |         |     | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC improvements_apply_in_select_exprs ()
BEGIN
  SELECT xn + xn AS yn, yn AS yn0
    FROM tnull
    WHERE xn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_apply_in_select_exprs: { yn: integer notnull, yn0: integer } dml_proc
  | {name improvements_apply_in_select_exprs}: improvements_apply_in_select_exprs: { yn: integer notnull, yn0: integer } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { yn: integer notnull, yn0: integer }
        | {select_core_list}: select: { yn: integer notnull, yn0: integer }
        | | {select_core}: select: { yn: integer notnull, yn0: integer }
        |   | {select_expr_list_con}: select: { yn: integer notnull, yn0: integer }
        |     | {select_expr_list}: select: { yn: integer notnull, yn0: integer }
        |     | | {select_expr}: yn: integer notnull
        |     | | | {add}: integer notnull
        |     | | | | {call}: xn: integer notnull
        |     | | | | | {name cql_inferred_notnull}: xn: integer notnull
        |     | | | | | {call_arg_list}
        |     | | | |   | {call_filter_clause}
        |     | | | |   | {arg_list}: ok
        |     | | | |     | {name xn}: xn: integer inferred_notnull
        |     | | | | {call}: xn: integer notnull
        |     | | |   | {name cql_inferred_notnull}: xn: integer notnull
        |     | | |   | {call_arg_list}
        |     | | |     | {call_filter_clause}
        |     | | |     | {arg_list}: ok
        |     | | |       | {name xn}: xn: integer inferred_notnull
        |     | | | {opt_as_alias}
        |     | |   | {name yn}
        |     | | {select_expr_list}
        |     |   | {select_expr}: yn0: integer
        |     |     | {name yn}: yn: integer
        |     |     | {opt_as_alias}
        |     |       | {name yn0}
        |     | {select_from_etc}: TABLE { tnull: tnull }
        |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       |   | {name tnull}: TABLE { tnull: tnull }
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {is_not}: bool notnull
        |         |   | {name xn}: xn: integer
        |         |   | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC local_variable_improvements_do_not_affect_result_columns ()
BEGIN
  DECLARE xn INTEGER;
  IF xn IS NULL THEN
    RETURN;
  END IF;
  SELECT *
    FROM tnull;
END;

  {create_proc_stmt}: local_variable_improvements_do_not_affect_result_columns: { xn: integer, yn: integer } dml_proc
  | {name local_variable_improvements_do_not_affect_result_columns}: local_variable_improvements_do_not_affect_result_columns: { xn: integer, yn: integer } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: xn: integer variable
      | | | {name xn}: xn: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name xn}: xn: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {select_stmt}: select: { xn: integer, yn: integer }
        | {select_core_list}: select: { xn: integer, yn: integer }
        | | {select_core}: select: { xn: integer, yn: integer }
        |   | {select_expr_list_con}: select: { xn: integer, yn: integer }
        |     | {select_expr_list}: select: { xn: integer, yn: integer }
        |     | | {star}: select: { xn: integer, yn: integer }
        |     | {select_from_etc}: TABLE { tnull: tnull }
        |       | {table_or_subquery_list}: TABLE { tnull: tnull }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       |   | {name tnull}: TABLE { tnull: tnull }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC improvements_work_on_join_results ()
BEGIN
  SELECT tnull.xn AS xn0
    FROM tnull
    INNER JOIN another_table_with_nullables ON tnull.xn = another_table_with_nullables.xn
    WHERE tnull.xn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_work_on_join_results: { xn0: integer notnull } dml_proc
  | {name improvements_work_on_join_results}: improvements_work_on_join_results: { xn0: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn0: integer notnull }
        | {select_core_list}: select: { xn0: integer notnull }
        | | {select_core}: select: { xn0: integer notnull }
        |   | {select_expr_list_con}: select: { xn0: integer notnull }
        |     | {select_expr_list}: select: { xn0: integer notnull }
        |     | | {select_expr}: xn0: integer notnull
        |     |   | {call}: xn: integer notnull
        |     |   | | {name cql_inferred_notnull}: xn: integer notnull
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {dot}: xn: integer inferred_notnull
        |     |   |       | {name tnull}
        |     |   |       | {name xn}
        |     |   | {opt_as_alias}
        |     |     | {name xn0}
        |     | {select_from_etc}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | {join_clause}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       | | | {name tnull}: TABLE { tnull: tnull }
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | | {name another_table_with_nullables}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | {join_cond}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |         | {on}: bool
        |       |         | {eq}: bool
        |       |           | {dot}: xn: integer
        |       |           | | {name tnull}
        |       |           | | {name xn}
        |       |           | {dot}: xn: integer
        |       |             | {name another_table_with_nullables}
        |       |             | {name xn}
        |       | {select_where}
        |         | {opt_where}: bool notnull
        |         | | {is_not}: bool notnull
        |         |   | {dot}: xn: integer
        |         |   | | {name tnull}
        |         |   | | {name xn}
        |         |   | {null}: null
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_on_clauses ()
BEGIN
  SELECT tnull.xn AS xn0
    FROM tnull
    INNER JOIN another_table_with_nullables ON tnull.xn = another_table_with_nullables.xn AND tnull.xn IS NOT NULL;
END;

  {create_proc_stmt}: improvements_do_not_work_for_on_clauses: { xn0: integer } dml_proc
  | {name improvements_do_not_work_for_on_clauses}: improvements_do_not_work_for_on_clauses: { xn0: integer } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {select_stmt}: select: { xn0: integer }
        | {select_core_list}: select: { xn0: integer }
        | | {select_core}: select: { xn0: integer }
        |   | {select_expr_list_con}: select: { xn0: integer }
        |     | {select_expr_list}: select: { xn0: integer }
        |     | | {select_expr}: xn0: integer
        |     |   | {dot}: xn: integer
        |     |   | | {name tnull}
        |     |   | | {name xn}
        |     |   | {opt_as_alias}
        |     |     | {name xn0}
        |     | {select_from_etc}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | {join_clause}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       | | {table_or_subquery}: TABLE { tnull: tnull }
        |       | | | {name tnull}: TABLE { tnull: tnull }
        |       | | {join_target_list}
        |       |   | {join_target}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |     | {int 1} {join_inner}
        |       |     | {table_join}
        |       |       | {table_or_subquery}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | | {name another_table_with_nullables}: TABLE { another_table_with_nullables: another_table_with_nullables }
        |       |       | {join_cond}: JOIN { tnull: tnull, another_table_with_nullables: another_table_with_nullables }
        |       |         | {on}: bool
        |       |         | {and}: bool
        |       |           | {eq}: bool
        |       |           | | {dot}: xn: integer
        |       |           | | | {name tnull}
        |       |           | | | {name xn}
        |       |           | | {dot}: xn: integer
        |       |           |   | {name another_table_with_nullables}
        |       |           |   | {name xn}
        |       |           | {is_not}: bool notnull
        |       |             | {dot}: xn: integer
        |       |             | | {name tnull}
        |       |             | | {name xn}
        |       |             | {null}: null
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC notnull_inferred_does_not_get_copied_via_declare_cursor_like_cursor ()
BEGIN
  DECLARE c CURSOR LIKE tnull;
  FETCH c(xn, yn) FROM VALUES(1, 2);
  IF c.xn IS NOT NULL AND c.yn IS NOT NULL THEN
    LET x0 := c.xn;
    LET y0 := c.yn;
    DECLARE d CURSOR LIKE c;
    LET x1 := c.xn;
    LET y1 := c.yn;
    LET x2 := d.xn;
    LET y2 := d.yn;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name notnull_inferred_does_not_get_copied_via_declare_cursor_like_cursor}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: c: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {name c}: c: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      | | {shape_def}: tnull: { xn: integer, yn: integer }
      |   | {like}: ok
      |     | {name tnull}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c}: c: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name xn}: xn: integer
      |     |   | {name_list}
      |     |     | {name yn}: yn: integer
      |     | {insert_list}: ok
      |       | {int 1}: integer notnull
      |       | {insert_list}
      |         | {int 2}: integer notnull
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: c.xn: integer variable
        | | | | | {name c}
        | | | | | {name xn}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: c.yn: integer variable
        | |   | | {name c}
        | |   | | {name yn}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x0: integer notnull variable
        |   | | {name x0}: x0: integer notnull variable
        |   | | {call}: c.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.xn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name xn}
        |   | {let_stmt}: y0: integer notnull variable
        |   | | {name y0}: y0: integer notnull variable
        |   | | {call}: c.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.yn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name yn}
        |   | {declare_cursor_like_name}: d: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   | | {name d}: d: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   | | {shape_def}: c: tnull: { xn: integer, yn: integer } variable shape_storage value_cursor
        |   |   | {like}: ok
        |   |     | {name c}
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c.xn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.xn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.xn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name xn}
        |   | {let_stmt}: y1: integer notnull variable
        |   | | {name y1}: y1: integer notnull variable
        |   | | {call}: c.yn: integer notnull variable
        |   |   | {name cql_inferred_notnull}: c.yn: integer notnull variable
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.yn: integer inferred_notnull variable
        |   |         | {name c}
        |   |         | {name yn}
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: d.xn: integer variable
        |   |   | {name d}
        |   |   | {name xn}
        |   | {let_stmt}: y2: integer variable
        |     | {name y2}: y2: integer variable
        |     | {dot}: d.yn: integer variable
        |       | {name d}
        |       | {name yn}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC notnull_inferred_does_not_get_copied_via_declare_cursor_like_proc ()
BEGIN
  DECLARE c CURSOR LIKE improvements_work_for_in_args ARGUMENTS;
  FETCH c(a) FROM VALUES(0);
  IF c.a IS NOT NULL THEN
    LET x0 := c.a;
    DECLARE d CURSOR LIKE improvements_work_for_in_args ARGUMENTS;
    FETCH d(a) FROM VALUES(0);
    LET x1 := c.a;
    LET x2 := d.a;
    DECLARE e CURSOR LIKE improvements_work_for_in_args ARGUMENTS;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name notnull_inferred_does_not_get_copied_via_declare_cursor_like_proc}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_name}: c: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
      | | {name c}: c: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
      | | {shape_def}: improvements_work_for_in_args[arguments]: { a: integer in }
      |   | {like}
      |     | {name improvements_work_for_in_args}
      |     | {name improvements_work_for_in_args}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c}: c: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name a}: a: integer
      |     | {insert_list}: ok
      |       | {int 0}: integer notnull
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {dot}: c.a: integer variable in
        | | | | {name c}
        | | | | {name a}
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x0: integer notnull variable
        |   | | {name x0}: x0: integer notnull variable
        |   | | {call}: c.a: integer notnull variable in
        |   |   | {name cql_inferred_notnull}: c.a: integer notnull variable in
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.a: integer inferred_notnull variable in
        |   |         | {name c}
        |   |         | {name a}
        |   | {declare_cursor_like_name}: d: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
        |   | | {name d}: d: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
        |   | | {shape_def}: improvements_work_for_in_args[arguments]: { a: integer in }
        |   |   | {like}
        |   |     | {name improvements_work_for_in_args}
        |   |     | {name improvements_work_for_in_args}
        |   | {fetch_values_stmt}: ok
        |   | | {name_columns_values}
        |   |   | {name d}: d: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
        |   |   | {columns_values}: ok
        |   |     | {column_spec}
        |   |     | | {name_list}
        |   |     |   | {name a}: a: integer
        |   |     | {insert_list}: ok
        |   |       | {int 0}: integer notnull
        |   | {let_stmt}: x1: integer notnull variable
        |   | | {name x1}: x1: integer notnull variable
        |   | | {call}: c.a: integer notnull variable in
        |   |   | {name cql_inferred_notnull}: c.a: integer notnull variable in
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: c.a: integer inferred_notnull variable in
        |   |         | {name c}
        |   |         | {name a}
        |   | {let_stmt}: x2: integer variable
        |   | | {name x2}: x2: integer variable
        |   | | {dot}: d.a: integer variable in
        |   |   | {name d}
        |   |   | {name a}
        |   | {declare_cursor_like_name}: e: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
        |     | {name e}: e: improvements_work_for_in_args[arguments]: { a: integer in } variable shape_storage value_cursor
        |     | {shape_def}: improvements_work_for_in_args[arguments]: { a: integer in }
        |       | {like}
        |         | {name improvements_work_for_in_args}
        |         | {name improvements_work_for_in_args}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC returns_nullable_int ()
BEGIN
  DECLARE c CURSOR LIKE SELECT nullable(0) AS a;
  OUT c;
END;

  {create_proc_stmt}: c: returns_nullable_int: { a: integer } variable shape_storage uses_out value_cursor
  | {name returns_nullable_int}: c: returns_nullable_int: { a: integer } variable shape_storage uses_out value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor_like_select}: c: select: { a: integer } variable shape_storage value_cursor
      | | {name c}: c: select: { a: integer } variable shape_storage value_cursor
      | | {select_stmt}: select: { a: integer }
      |   | {select_core_list}: select: { a: integer }
      |   | | {select_core}: select: { a: integer }
      |   |   | {select_expr_list_con}: select: { a: integer }
      |   |     | {select_expr_list}: select: { a: integer }
      |   |     | | {select_expr}: a: integer
      |   |     |   | {call}: integer
      |   |     |   | | {name nullable}: integer
      |   |     |   | | {call_arg_list}
      |   |     |   |   | {call_filter_clause}
      |   |     |   |   | {arg_list}: ok
      |   |     |   |     | {int 0}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name a}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {out_stmt}: c: select: { a: integer } variable shape_storage value_cursor
        | {name c}: c: select: { a: integer } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC notnull_inferred_does_not_get_copied_via_arguments_like_proc (args_a INTEGER)
BEGIN
  IF args.a IS NOT NULL THEN
    LET x0 := args.a;
    DECLARE c CURSOR FETCH FROM CALL returns_nullable_int();
    LET x1 := c.a;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name notnull_inferred_does_not_get_copied_via_arguments_like_proc}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: args_a: integer variable in
    |   | {param_detail}: args_a: integer variable in
    |     | {name args_a}: args_a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {dot}: args_a: integer variable in
        | | | | {name args}
        | | | | {name a}
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x0: integer notnull variable
        |   | | {name x0}: x0: integer notnull variable
        |   | | {call}: args_a: integer notnull variable in
        |   |   | {name cql_inferred_notnull}: args_a: integer notnull variable in
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: args_a: integer inferred_notnull variable in
        |   |         | {name args}
        |   |         | {name a}
        |   | {declare_value_cursor}: c: returns_nullable_int: { a: integer } variable shape_storage value_cursor
        |   | | {name c}: c: returns_nullable_int: { a: integer } variable shape_storage value_cursor
        |   | | {call_stmt}: c: returns_nullable_int: { a: integer } variable shape_storage uses_out value_cursor
        |   |   | {name returns_nullable_int}: c: returns_nullable_int: { a: integer } variable shape_storage uses_out value_cursor
        |   | {let_stmt}: x1: integer variable
        |     | {name x1}: x1: integer variable
        |     | {dot}: c.a: integer variable
        |       | {name c}
        |       | {name a}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_within_ctes ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NOT NULL THEN
    WITH RECURSIVE
    some_cte (b) AS (SELECT a)
    SELECT b
      FROM some_cte;
  END IF;
END;

  {create_proc_stmt}: improvements_work_within_ctes: { b: integer notnull } dml_proc
  | {name improvements_work_within_ctes}: improvements_work_within_ctes: { b: integer notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {is_not}: bool notnull
        | | | {name a}: a: integer variable
        | | | {null}: null
        | | {stmt_list}: ok
        |   | {with_select_stmt}: select: { b: integer notnull }
        |     | {with_recursive}
        |     | | {cte_tables}: ok
        |     |   | {cte_table}: some_cte: { b: integer notnull variable }
        |     |     | {cte_decl}: some_cte: { b: integer notnull variable }
        |     |     | | {name some_cte}
        |     |     | | {name_list}
        |     |     |   | {name b}
        |     |     | {select_stmt}: select: { a: integer notnull variable }
        |     |       | {select_core_list}: select: { a: integer notnull variable }
        |     |       | | {select_core}: select: { a: integer notnull variable }
        |     |       |   | {select_expr_list_con}: select: { a: integer notnull variable }
        |     |       |     | {select_expr_list}: select: { a: integer notnull variable }
        |     |       |     | | {select_expr}: a: integer notnull variable
        |     |       |     |   | {call}: a: integer notnull variable
        |     |       |     |     | {name cql_inferred_notnull}: a: integer notnull variable
        |     |       |     |     | {call_arg_list}
        |     |       |     |       | {call_filter_clause}
        |     |       |     |       | {arg_list}: ok
        |     |       |     |         | {name a}: a: integer inferred_notnull variable
        |     |       |     | {select_from_etc}: ok
        |     |       |       | {select_where}
        |     |       |         | {select_groupby}
        |     |       |           | {select_having}
        |     |       | {select_orderby}
        |     |         | {select_limit}
        |     |           | {select_offset}
        |     | {select_stmt}: select: { b: integer notnull }
        |       | {select_core_list}: select: { b: integer notnull }
        |       | | {select_core}: select: { b: integer notnull }
        |       |   | {select_expr_list_con}: select: { b: integer notnull }
        |       |     | {select_expr_list}: select: { b: integer notnull }
        |       |     | | {select_expr}: b: integer notnull
        |       |     |   | {name b}: b: integer notnull
        |       |     | {select_from_etc}: TABLE { some_cte: some_cte }
        |       |       | {table_or_subquery_list}: TABLE { some_cte: some_cte }
        |       |       | | {table_or_subquery}: TABLE { some_cte: some_cte }
        |       |       |   | {name some_cte}: TABLE { some_cte: some_cte }
        |       |       | {select_where}
        |       |         | {select_groupby}
        |       |           | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {select_offset}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC improvements_work_for_commit_return_guards (a INTEGER)
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      IF a IS NULL THEN
        COMMIT RETURN;
      END IF;
      LET x0 := a;
    END IF;
    LET x1 := a;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_commit_return_guards}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {proc_savepoint_stmt}: ok
        | {stmt_list}: ok
          | {if_stmt}: integer notnull
          | | {cond_action}: integer notnull
          | | | {int 1}: integer notnull
          | | | {stmt_list}: ok
          | |   | {if_stmt}: bool notnull
          | |   | | {cond_action}: bool notnull
          | |   | | | {is}: bool notnull
          | |   | | | | {name a}: a: integer variable in
          | |   | | | | {null}: null
          | |   | | | {stmt_list}: ok
          | |   | |   | {commit_return_stmt}: ok
          | |   | | {if_alt}: ok
          | |   | {let_stmt}: x0: integer notnull variable
          | |     | {name x0}: x0: integer notnull variable
          | |     | {call}: a: integer notnull variable in
          | |       | {name cql_inferred_notnull}: a: integer notnull variable in
          | |       | {call_arg_list}
          | |         | {call_filter_clause}
          | |         | {arg_list}: ok
          | |           | {name a}: a: integer inferred_notnull variable in
          | | {if_alt}: ok
          | {let_stmt}: x1: integer variable
            | {name x1}: x1: integer variable
            | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC improvements_work_for_continue_guards (a INTEGER)
BEGIN
  WHILE 1
  BEGIN
    IF a IS NULL THEN
      CONTINUE;
    END IF;
    LET x0 := a;
  END;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_continue_guards}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {while_stmt}: ok
      | | {int 1}: integer notnull
      | | {stmt_list}: ok
      |   | {if_stmt}: bool notnull
      |   | | {cond_action}: bool notnull
      |   | | | {is}: bool notnull
      |   | | | | {name a}: a: integer variable in
      |   | | | | {null}: null
      |   | | | {stmt_list}: ok
      |   | |   | {continue_stmt}: ok
      |   | | {if_alt}: ok
      |   | {let_stmt}: x0: integer notnull variable
      |     | {name x0}: x0: integer notnull variable
      |     | {call}: a: integer notnull variable in
      |       | {name cql_inferred_notnull}: a: integer notnull variable in
      |       | {call_arg_list}
      |         | {call_filter_clause}
      |         | {arg_list}: ok
      |           | {name a}: a: integer inferred_notnull variable in
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC improvements_work_for_leave_guards (a INTEGER)
BEGIN
  WHILE 1
  BEGIN
    IF a IS NULL THEN
      LEAVE;
    END IF;
    LET x0 := a;
  END;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_leave_guards}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {while_stmt}: ok
      | | {int 1}: integer notnull
      | | {stmt_list}: ok
      |   | {if_stmt}: bool notnull
      |   | | {cond_action}: bool notnull
      |   | | | {is}: bool notnull
      |   | | | | {name a}: a: integer variable in
      |   | | | | {null}: null
      |   | | | {stmt_list}: ok
      |   | |   | {leave_stmt}: ok
      |   | | {if_alt}: ok
      |   | {let_stmt}: x0: integer notnull variable
      |     | {name x0}: x0: integer notnull variable
      |     | {call}: a: integer notnull variable in
      |       | {name cql_inferred_notnull}: a: integer notnull variable in
      |       | {call_arg_list}
      |         | {call_filter_clause}
      |         | {arg_list}: ok
      |           | {name a}: a: integer inferred_notnull variable in
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC improvements_work_for_return_guards (a INTEGER)
BEGIN
  IF 1 THEN
    IF a IS NULL THEN
      RETURN;
    END IF;
    LET x0 := a;
  END IF;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_return_guards}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name a}: a: integer variable in
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |     | {name x0}: x0: integer notnull variable
      | |     | {call}: a: integer notnull variable in
      | |       | {name cql_inferred_notnull}: a: integer notnull variable in
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name a}: a: integer inferred_notnull variable in
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC improvements_work_for_rollback_return_guards (a INTEGER)
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      IF a IS NULL THEN
        ROLLBACK RETURN;
      END IF;
      LET x0 := a;
    END IF;
    LET x1 := a;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_rollback_return_guards}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {proc_savepoint_stmt}: ok
        | {stmt_list}: ok
          | {if_stmt}: integer notnull
          | | {cond_action}: integer notnull
          | | | {int 1}: integer notnull
          | | | {stmt_list}: ok
          | |   | {if_stmt}: bool notnull
          | |   | | {cond_action}: bool notnull
          | |   | | | {is}: bool notnull
          | |   | | | | {name a}: a: integer variable in
          | |   | | | | {null}: null
          | |   | | | {stmt_list}: ok
          | |   | |   | {rollback_return_stmt}: ok
          | |   | | {if_alt}: ok
          | |   | {let_stmt}: x0: integer notnull variable
          | |     | {name x0}: x0: integer notnull variable
          | |     | {call}: a: integer notnull variable in
          | |       | {name cql_inferred_notnull}: a: integer notnull variable in
          | |       | {call_arg_list}
          | |         | {call_filter_clause}
          | |         | {arg_list}: ok
          | |           | {name a}: a: integer inferred_notnull variable in
          | | {if_alt}: ok
          | {let_stmt}: x1: integer variable
            | {name x1}: x1: integer variable
            | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC improvements_work_for_throw_guards (a INTEGER)
BEGIN
  PROC SAVEPOINT
  BEGIN
    IF 1 THEN
      IF a IS NULL THEN
        THROW;
      END IF;
      LET x0 := a;
    END IF;
    LET x1 := a;
  END;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_throw_guards}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {proc_savepoint_stmt}: ok
        | {stmt_list}: ok
          | {if_stmt}: integer notnull
          | | {cond_action}: integer notnull
          | | | {int 1}: integer notnull
          | | | {stmt_list}: ok
          | |   | {if_stmt}: bool notnull
          | |   | | {cond_action}: bool notnull
          | |   | | | {is}: bool notnull
          | |   | | | | {name a}: a: integer variable in
          | |   | | | | {null}: null
          | |   | | | {stmt_list}: ok
          | |   | |   | {throw_stmt}: ok
          | |   | | {if_alt}: ok
          | |   | {let_stmt}: x0: integer notnull variable
          | |     | {name x0}: x0: integer notnull variable
          | |     | {call}: a: integer notnull variable in
          | |       | {name cql_inferred_notnull}: a: integer notnull variable in
          | |       | {call_arg_list}
          | |         | {call_filter_clause}
          | |         | {arg_list}: ok
          | |           | {name a}: a: integer inferred_notnull variable in
          | | {if_alt}: ok
          | {let_stmt}: x1: integer variable
            | {name x1}: x1: integer variable
            | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC guard_improvements_work_for_cursor_fields ()
BEGIN
  DECLARE c CURSOR FOR SELECT nullable(1) AS a;
  FETCH c;
  IF 1 THEN
    IF c.a IS NULL THEN
      RETURN;
    END IF;
    LET x0 := c.a;
  END IF;
  LET x1 := c.a;
END;

  {create_proc_stmt}: ok dml_proc
  | {name guard_improvements_work_for_cursor_fields}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: c: select: { a: integer } variable dml_proc
      | | {name c}: c: select: { a: integer } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: integer }
      |   | {select_core_list}: select: { a: integer }
      |   | | {select_core}: select: { a: integer }
      |   |   | {select_expr_list_con}: select: { a: integer }
      |   |     | {select_expr_list}: select: { a: integer }
      |   |     | | {select_expr}: a: integer
      |   |     |   | {call}: integer
      |   |     |   | | {name nullable}: integer
      |   |     |   | | {call_arg_list}
      |   |     |   |   | {call_filter_clause}
      |   |     |   |   | {arg_list}: ok
      |   |     |   |     | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name a}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c: select: { a: integer } variable dml_proc shape_storage
      | | {name c}: c: select: { a: integer } variable dml_proc shape_storage
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {dot}: c.a: integer variable
      | |   | | | | | {name c}
      | |   | | | | | {name a}
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |     | {name x0}: x0: integer notnull variable
      | |     | {call}: c.a: integer notnull variable
      | |       | {name cql_inferred_notnull}: c.a: integer notnull variable
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {dot}: c.a: integer inferred_notnull variable
      | |             | {name c}
      | |             | {name a}
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {dot}: c.a: integer variable
          | {name c}
          | {name a}

The statement ending at line XXXX

CREATE PROC multiple_improvements_are_possible_via_one_guard (a INTEGER, b INTEGER, c INTEGER)
BEGIN
  IF 1 THEN
    IF a IS NULL OR b IS NULL OR c IS NULL THEN
      RETURN;
    END IF;
    LET x0 := a;
    LET y0 := b;
    LET z0 := c;
  END IF;
  LET x1 := a;
  LET y1 := b;
  LET z1 := c;
END;

  {create_proc_stmt}: ok
  | {name multiple_improvements_are_possible_via_one_guard}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    | | | {param_detail}: a: integer variable in
    | |   | {name a}: a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: b: integer variable in
    |   | | {param_detail}: b: integer variable in
    |   |   | {name b}: b: integer variable in
    |   |   | {type_int}: integer
    |   | {params}
    |     | {param}: c: integer variable in
    |       | {param_detail}: c: integer variable in
    |         | {name c}: c: integer variable in
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {or}: bool notnull
      | |   | | | | {or}: bool notnull
      | |   | | | | | {is}: bool notnull
      | |   | | | | | | {name a}: a: integer variable in
      | |   | | | | | | {null}: null
      | |   | | | | | {is}: bool notnull
      | |   | | | |   | {name b}: b: integer variable in
      | |   | | | |   | {null}: null
      | |   | | | | {is}: bool notnull
      | |   | | |   | {name c}: c: integer variable in
      | |   | | |   | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable in
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable in
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable in
      | |   | {let_stmt}: y0: integer notnull variable
      | |   | | {name y0}: y0: integer notnull variable
      | |   | | {call}: b: integer notnull variable in
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable in
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable in
      | |   | {let_stmt}: z0: integer notnull variable
      | |     | {name z0}: z0: integer notnull variable
      | |     | {call}: c: integer notnull variable in
      | |       | {name cql_inferred_notnull}: c: integer notnull variable in
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name c}: c: integer inferred_notnull variable in
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable in
      | {let_stmt}: y1: integer variable
      | | {name y1}: y1: integer variable
      | | {name b}: b: integer variable in
      | {let_stmt}: z1: integer variable
        | {name z1}: z1: integer variable
        | {name c}: c: integer variable in

The statement ending at line XXXX

CREATE PROC guard_improvements_only_work_for_outermost_ors (a INTEGER, b INTEGER, c INTEGER)
BEGIN
  IF a IS NULL AND (b IS NULL OR c IS NULL) THEN
    RETURN;
  END IF;
  LET x := a;
  LET y := b;
  LET z := c;
END;

  {create_proc_stmt}: ok
  | {name guard_improvements_only_work_for_outermost_ors}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    | | | {param_detail}: a: integer variable in
    | |   | {name a}: a: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: b: integer variable in
    |   | | {param_detail}: b: integer variable in
    |   |   | {name b}: b: integer variable in
    |   |   | {type_int}: integer
    |   | {params}
    |     | {param}: c: integer variable in
    |       | {param_detail}: c: integer variable in
    |         | {name c}: c: integer variable in
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {and}: bool notnull
      | | | | {is}: bool notnull
      | | | | | {name a}: a: integer variable in
      | | | | | {null}: null
      | | | | {or}: bool notnull
      | | |   | {is}: bool notnull
      | | |   | | {name b}: b: integer variable in
      | | |   | | {null}: null
      | | |   | {is}: bool notnull
      | | |     | {name c}: c: integer variable in
      | | |     | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x: integer variable
      | | {name x}: x: integer variable
      | | {name a}: a: integer variable in
      | {let_stmt}: y: integer variable
      | | {name y}: y: integer variable
      | | {name b}: b: integer variable in
      | {let_stmt}: z: integer variable
        | {name z}: z: integer variable
        | {name c}: c: integer variable in

The statement ending at line XXXX

CREATE PROC guard_improvements_only_work_for_is_null (a INTEGER)
BEGIN
  IF NOT a THEN
    RETURN;
  END IF;
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name guard_improvements_only_work_for_is_null}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: integer variable in
    |   | {param_detail}: a: integer variable in
    |     | {name a}: a: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {if_stmt}: bool
      | | {cond_action}: bool
      | | | {not}: bool
      | | | | {name a}: a: integer variable in
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x: integer variable
        | {name x}: x: integer variable
        | {name a}: a: integer variable in

The statement ending at line XXXX

CREATE PROC guard_improvements_handle_semantic_issues_like_if ()
BEGIN
  IF some_undefined_variable IS NULL THEN
    RETURN;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'some_undefined_variable'

  {create_proc_stmt}: err
  | {name guard_improvements_handle_semantic_issues_like_if}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {if_stmt}: err
        | {cond_action}: err
        | | {is}: err
        | | | {name some_undefined_variable}: err
        | | | {null}: null
        | | {stmt_list}
        |   | {return_stmt}
        | {if_alt}

The statement ending at line XXXX

CREATE PROC improvements_work_for_guard_pattern_ifs ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  IF 1 THEN
    IF a IS NULL OR b IS NULL OR c IS NULL THEN
      RETURN;
    END IF;
    LET x0 := a;
    LET y0 := b;
    LET z0 := c;
  END IF;
  LET x1 := a;
  LET y1 := b;
  LET z1 := c;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_guard_pattern_ifs}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable
      | | | {name c}: c: integer variable
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {or}: bool notnull
      | |   | | | | {or}: bool notnull
      | |   | | | | | {is}: bool notnull
      | |   | | | | | | {name a}: a: integer variable
      | |   | | | | | | {null}: null
      | |   | | | | | {is}: bool notnull
      | |   | | | |   | {name b}: b: integer variable
      | |   | | | |   | {null}: null
      | |   | | | | {is}: bool notnull
      | |   | | |   | {name c}: c: integer variable
      | |   | | |   | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y0: integer notnull variable
      | |   | | {name y0}: y0: integer notnull variable
      | |   | | {call}: b: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | {let_stmt}: z0: integer notnull variable
      | |     | {name z0}: z0: integer notnull variable
      | |     | {call}: c: integer notnull variable
      | |       | {name cql_inferred_notnull}: c: integer notnull variable
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name c}: c: integer inferred_notnull variable
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y1: integer variable
      | | {name y1}: y1: integer variable
      | | {name b}: b: integer variable
      | {let_stmt}: z1: integer variable
        | {name z1}: z1: integer variable
        | {name c}: c: integer variable

The statement ending at line XXXX

CREATE PROC improvements_work_for_guard_pattern_ifs_with_preceding_statements ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  IF 1 THEN
    IF a IS NULL OR b IS NULL OR c IS NULL THEN
      CALL printf("Hello, world!\n");
      RETURN;
    END IF;
    LET x0 := a;
    LET y0 := b;
    LET z0 := c;
  END IF;
  LET x1 := a;
  LET y1 := b;
  LET z1 := c;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_guard_pattern_ifs_with_preceding_statements}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable
      | | | {name c}: c: integer variable
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {or}: bool notnull
      | |   | | | | {or}: bool notnull
      | |   | | | | | {is}: bool notnull
      | |   | | | | | | {name a}: a: integer variable
      | |   | | | | | | {null}: null
      | |   | | | | | {is}: bool notnull
      | |   | | | |   | {name b}: b: integer variable
      | |   | | | |   | {null}: null
      | |   | | | | {is}: bool notnull
      | |   | | |   | {name c}: c: integer variable
      | |   | | |   | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {call_stmt}: ok
      | |   | |   | | {name printf}: ok
      | |   | |   | | {expr_list}: ok
      | |   | |   |   | {strlit 'Hello, world!
'}: text notnull
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |   | | {name x0}: x0: integer notnull variable
      | |   | | {call}: a: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | {let_stmt}: y0: integer notnull variable
      | |   | | {name y0}: y0: integer notnull variable
      | |   | | {call}: b: integer notnull variable
      | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   |   | {call_arg_list}
      | |   |     | {call_filter_clause}
      | |   |     | {arg_list}: ok
      | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | {let_stmt}: z0: integer notnull variable
      | |     | {name z0}: z0: integer notnull variable
      | |     | {call}: c: integer notnull variable
      | |       | {name cql_inferred_notnull}: c: integer notnull variable
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name c}: c: integer inferred_notnull variable
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y1: integer variable
      | | {name y1}: y1: integer variable
      | | {name b}: b: integer variable
      | {let_stmt}: z1: integer variable
        | {name z1}: z1: integer variable
        | {name c}: c: integer variable

The statement ending at line XXXX

CREATE PROC improvements_work_for_guard_pattern_ifs_that_set_the_id_to_null ()
BEGIN
  DECLARE a INTEGER;
  IF 1 THEN
    IF a IS NULL THEN
      SET a := NULL;
      RETURN;
    END IF;
    LET x0 := a;
  END IF;
  LET x1 := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_guard_pattern_ifs_that_set_the_id_to_null}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 1}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is}: bool notnull
      | |   | | | | {name a}: a: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {assign}: a: integer variable was_set
      | |   | |   | | {name a}: a: integer variable was_set
      | |   | |   | | {null}: null
      | |   | |   | {return_stmt}: ok
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x0: integer notnull variable
      | |     | {name x0}: x0: integer notnull variable
      | |     | {call}: a: integer notnull variable was_set
      | |       | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name a}: a: integer inferred_notnull variable was_set
      | | {if_alt}: ok
      | {let_stmt}: x1: integer variable
        | {name x1}: x1: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_guard_like_ifs_with_else ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NULL THEN
    RETURN;
  ELSE
  END IF;
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_do_not_work_for_guard_like_ifs_with_else}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      |   | {else}: ok
      | {let_stmt}: x: integer variable
        | {name x}: x: integer variable
        | {name a}: a: integer variable

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_guard_like_ifs_with_else_if ()
BEGIN
  DECLARE a INTEGER;
  IF a IS NULL THEN
    RETURN;
  ELSE IF 1 THEN
  END IF;
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_do_not_work_for_guard_like_ifs_with_else_if}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |     | {cond_action}: integer notnull
      |       | {int 1}: integer notnull
      | {let_stmt}: x: integer variable
        | {name x}: x: integer variable
        | {name a}: a: integer variable

The statement ending at line XXXX

CREATE PROC improvements_do_not_work_for_is_null_checks_in_else_ifs ()
BEGIN
  DECLARE a INTEGER;
  IF 0 THEN
    RETURN;
  ELSE IF a IS NULL THEN
    RETURN;
  END IF;
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name improvements_do_not_work_for_is_null_checks_in_else_ifs}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      |   | {elseif}: bool notnull
      |     | {cond_action}: bool notnull
      |       | {is}: bool notnull
      |       | | {name a}: a: integer variable
      |       | | {null}: null
      |       | {stmt_list}: ok
      |         | {return_stmt}: ok
      | {let_stmt}: x: integer variable
        | {name x}: x: integer variable
        | {name a}: a: integer variable

The statement ending at line XXXX

CREATE PROC false_conditions_of_earlier_branches_improve_later_branches ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  IF a IS NULL THEN
    LET x0 := a;
    LET y0 := b;
    LET z0 := c;
  ELSE IF 0 THEN
    LET x1 := a;
    LET y1 := b;
    LET z1 := c;
  ELSE IF b IS NULL OR c IS NULL THEN
    LET x2 := a;
    LET y2 := b;
    LET z2 := c;
  ELSE
    LET x3 := a;
    LET y3 := b;
    LET z3 := c;
  END IF;
  LET x4 := a;
  LET y4 := b;
  LET z4 := c;
END;

  {create_proc_stmt}: ok
  | {name false_conditions_of_earlier_branches_improve_later_branches}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable
      | | | {name c}: c: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x0: integer variable
      | |   | | {name x0}: x0: integer variable
      | |   | | {name a}: a: integer variable
      | |   | {let_stmt}: y0: integer variable
      | |   | | {name y0}: y0: integer variable
      | |   | | {name b}: b: integer variable
      | |   | {let_stmt}: z0: integer variable
      | |     | {name z0}: z0: integer variable
      | |     | {name c}: c: integer variable
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   | | | {int 0}: integer notnull
      |   | | | {stmt_list}: ok
      |   | |   | {let_stmt}: x1: integer notnull variable
      |   | |   | | {name x1}: x1: integer notnull variable
      |   | |   | | {call}: a: integer notnull variable
      |   | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      |   | |   |   | {call_arg_list}
      |   | |   |     | {call_filter_clause}
      |   | |   |     | {arg_list}: ok
      |   | |   |       | {name a}: a: integer inferred_notnull variable
      |   | |   | {let_stmt}: y1: integer variable
      |   | |   | | {name y1}: y1: integer variable
      |   | |   | | {name b}: b: integer variable
      |   | |   | {let_stmt}: z1: integer variable
      |   | |     | {name z1}: z1: integer variable
      |   | |     | {name c}: c: integer variable
      |   | | {elseif}: bool notnull
      |   |   | {cond_action}: bool notnull
      |   |     | {or}: bool notnull
      |   |     | | {is}: bool notnull
      |   |     | | | {name b}: b: integer variable
      |   |     | | | {null}: null
      |   |     | | {is}: bool notnull
      |   |     |   | {name c}: c: integer variable
      |   |     |   | {null}: null
      |   |     | {stmt_list}: ok
      |   |       | {let_stmt}: x2: integer notnull variable
      |   |       | | {name x2}: x2: integer notnull variable
      |   |       | | {call}: a: integer notnull variable
      |   |       |   | {name cql_inferred_notnull}: a: integer notnull variable
      |   |       |   | {call_arg_list}
      |   |       |     | {call_filter_clause}
      |   |       |     | {arg_list}: ok
      |   |       |       | {name a}: a: integer inferred_notnull variable
      |   |       | {let_stmt}: y2: integer variable
      |   |       | | {name y2}: y2: integer variable
      |   |       | | {name b}: b: integer variable
      |   |       | {let_stmt}: z2: integer variable
      |   |         | {name z2}: z2: integer variable
      |   |         | {name c}: c: integer variable
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {let_stmt}: x3: integer notnull variable
      |       | | {name x3}: x3: integer notnull variable
      |       | | {call}: a: integer notnull variable
      |       |   | {name cql_inferred_notnull}: a: integer notnull variable
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name a}: a: integer inferred_notnull variable
      |       | {let_stmt}: y3: integer notnull variable
      |       | | {name y3}: y3: integer notnull variable
      |       | | {call}: b: integer notnull variable
      |       |   | {name cql_inferred_notnull}: b: integer notnull variable
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name b}: b: integer inferred_notnull variable
      |       | {let_stmt}: z3: integer notnull variable
      |         | {name z3}: z3: integer notnull variable
      |         | {call}: c: integer notnull variable
      |           | {name cql_inferred_notnull}: c: integer notnull variable
      |           | {call_arg_list}
      |             | {call_filter_clause}
      |             | {arg_list}: ok
      |               | {name c}: c: integer inferred_notnull variable
      | {let_stmt}: x4: integer variable
      | | {name x4}: x4: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y4: integer variable
      | | {name y4}: y4: integer variable
      | | {name b}: b: integer variable
      | {let_stmt}: z4: integer variable
        | {name z4}: z4: integer variable
        | {name c}: c: integer variable

The statement ending at line XXXX

CREATE PROC unimprovements_do_not_negatively_affect_later_branches ()
BEGIN
  DECLARE a INTEGER;
  LET x0 := a;
  IF a IS NULL THEN
    RETURN;
  END IF;
  LET x1 := a;
  IF 0 THEN
    SET a := NULL;
    LET x2 := a;
  ELSE IF 0 THEN
    LET x3 := a;
    SET a := NULL;
    LET x4 := a;
  ELSE
    LET x5 := a;
  END IF;
  LET x6 := a;
END;

  {create_proc_stmt}: ok
  | {name unimprovements_do_not_negatively_affect_later_branches}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x1: integer notnull variable
      | | {name x1}: x1: integer notnull variable
      | | {call}: a: integer notnull variable
      |   | {name cql_inferred_notnull}: a: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |   | | {name a}: a: integer variable was_set
      | |   | | {null}: null
      | |   | {let_stmt}: x2: integer variable
      | |     | {name x2}: x2: integer variable
      | |     | {name a}: a: integer variable was_set
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   |   | {stmt_list}: ok
      |   |     | {let_stmt}: x3: integer notnull variable
      |   |     | | {name x3}: x3: integer notnull variable
      |   |     | | {call}: a: integer notnull variable was_set
      |   |     |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   |     |   | {call_arg_list}
      |   |     |     | {call_filter_clause}
      |   |     |     | {arg_list}: ok
      |   |     |       | {name a}: a: integer inferred_notnull variable was_set
      |   |     | {assign}: a: integer variable was_set
      |   |     | | {name a}: a: integer variable was_set
      |   |     | | {null}: null
      |   |     | {let_stmt}: x4: integer variable
      |   |       | {name x4}: x4: integer variable
      |   |       | {name a}: a: integer variable was_set
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {let_stmt}: x5: integer notnull variable
      |         | {name x5}: x5: integer notnull variable
      |         | {call}: a: integer notnull variable was_set
      |           | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |           | {call_arg_list}
      |             | {call_filter_clause}
      |             | {arg_list}: ok
      |               | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: x6: integer variable
        | {name x6}: x6: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC nested_unimprovements_do_not_negatively_affect_later_branches ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  IF a IS NULL OR b IS NULL OR c IS NULL THEN
    RETURN;
  END IF;
  LET x0 := a;
  LET y0 := b;
  LET z0 := c;
  IF 0 THEN
    IF 0 THEN
      SET a := NULL;
      IF 0 THEN
        SET b := NULL;
      ELSE
        SET a := 42;
        SET c := NULL;
        LET x1 := a;
        LET y1 := b;
        LET z1 := c;
        SET a := NULL;
        IF a IS NULL THEN
          SET a := NULL;
        ELSE IF c IS NULL THEN
          SET b := NULL;
          LET x2 := a;
          LET y2 := b;
          LET z2 := c;
        ELSE IF 0 THEN
          LET x3 := a;
          LET y3 := b;
          LET z3 := c;
          SET b := NULL;
          SET c := NULL;
        ELSE
          LET x4 := a;
          LET y4 := b;
          LET z4 := c;
        END IF;
        LET x5 := a;
        LET y5 := b;
        LET z5 := c;
        SET a := 42;
        SET b := 42;
        SET c := 42;
      END IF;
      LET x6 := a;
      LET y6 := b;
      LET z6 := c;
    ELSE
      LET x7 := a;
      LET y7 := b;
      LET z7 := c;
    END IF;
    LET x8 := a;
    LET y8 := b;
    LET z8 := c;
  ELSE
    LET x9 := a;
    LET y9 := b;
    LET z9 := c;
  END IF;
  LET x10 := a;
  LET y10 := b;
  LET z10 := c;
END;

  {create_proc_stmt}: ok
  | {name nested_unimprovements_do_not_negatively_affect_later_branches}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable was_set
      | | | {name c}: c: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {or}: bool notnull
      | | | | {or}: bool notnull
      | | | | | {is}: bool notnull
      | | | | | | {name a}: a: integer variable
      | | | | | | {null}: null
      | | | | | {is}: bool notnull
      | | | |   | {name b}: b: integer variable
      | | | |   | {null}: null
      | | | | {is}: bool notnull
      | | |   | {name c}: c: integer variable
      | | |   | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {call}: a: integer notnull variable
      |   | {name cql_inferred_notnull}: a: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {call}: b: integer notnull variable
      |   | {name cql_inferred_notnull}: b: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable
      | {let_stmt}: z0: integer notnull variable
      | | {name z0}: z0: integer notnull variable
      | | {call}: c: integer notnull variable
      |   | {name cql_inferred_notnull}: c: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name c}: c: integer inferred_notnull variable
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: integer notnull
      | |   | | {cond_action}: integer notnull
      | |   | | | {int 0}: integer notnull
      | |   | | | {stmt_list}: ok
      | |   | |   | {assign}: a: integer variable was_set
      | |   | |   | | {name a}: a: integer variable was_set
      | |   | |   | | {null}: null
      | |   | |   | {if_stmt}: integer notnull
      | |   | |   | | {cond_action}: integer notnull
      | |   | |   | | | {int 0}: integer notnull
      | |   | |   | | | {stmt_list}: ok
      | |   | |   | |   | {assign}: b: integer variable was_set
      | |   | |   | |     | {name b}: b: integer variable was_set
      | |   | |   | |     | {null}: null
      | |   | |   | | {if_alt}: ok
      | |   | |   |   | {else}: ok
      | |   | |   |     | {stmt_list}: ok
      | |   | |   |       | {assign}: a: integer variable was_set
      | |   | |   |       | | {name a}: a: integer variable was_set
      | |   | |   |       | | {int 42}: integer notnull
      | |   | |   |       | {assign}: c: integer variable was_set
      | |   | |   |       | | {name c}: c: integer variable was_set
      | |   | |   |       | | {null}: null
      | |   | |   |       | {let_stmt}: x1: integer notnull variable
      | |   | |   |       | | {name x1}: x1: integer notnull variable
      | |   | |   |       | | {call}: a: integer notnull variable was_set
      | |   | |   |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |   | |   |       |   | {call_arg_list}
      | |   | |   |       |     | {call_filter_clause}
      | |   | |   |       |     | {arg_list}: ok
      | |   | |   |       |       | {name a}: a: integer inferred_notnull variable was_set
      | |   | |   |       | {let_stmt}: y1: integer notnull variable
      | |   | |   |       | | {name y1}: y1: integer notnull variable
      | |   | |   |       | | {call}: b: integer notnull variable was_set
      | |   | |   |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   | |   |       |   | {call_arg_list}
      | |   | |   |       |     | {call_filter_clause}
      | |   | |   |       |     | {arg_list}: ok
      | |   | |   |       |       | {name b}: b: integer inferred_notnull variable was_set
      | |   | |   |       | {let_stmt}: z1: integer variable
      | |   | |   |       | | {name z1}: z1: integer variable
      | |   | |   |       | | {name c}: c: integer variable was_set
      | |   | |   |       | {assign}: a: integer variable was_set
      | |   | |   |       | | {name a}: a: integer variable was_set
      | |   | |   |       | | {null}: null
      | |   | |   |       | {if_stmt}: bool notnull
      | |   | |   |       | | {cond_action}: bool notnull
      | |   | |   |       | | | {is}: bool notnull
      | |   | |   |       | | | | {name a}: a: integer variable was_set
      | |   | |   |       | | | | {null}: null
      | |   | |   |       | | | {stmt_list}: ok
      | |   | |   |       | |   | {assign}: a: integer variable was_set
      | |   | |   |       | |     | {name a}: a: integer variable was_set
      | |   | |   |       | |     | {null}: null
      | |   | |   |       | | {if_alt}: ok
      | |   | |   |       |   | {elseif}: bool notnull
      | |   | |   |       |   | | {cond_action}: bool notnull
      | |   | |   |       |   | | | {is}: bool notnull
      | |   | |   |       |   | | | | {name c}: c: integer variable was_set
      | |   | |   |       |   | | | | {null}: null
      | |   | |   |       |   | | | {stmt_list}: ok
      | |   | |   |       |   | |   | {assign}: b: integer variable was_set
      | |   | |   |       |   | |   | | {name b}: b: integer variable was_set
      | |   | |   |       |   | |   | | {null}: null
      | |   | |   |       |   | |   | {let_stmt}: x2: integer notnull variable
      | |   | |   |       |   | |   | | {name x2}: x2: integer notnull variable
      | |   | |   |       |   | |   | | {call}: a: integer notnull variable was_set
      | |   | |   |       |   | |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |   | |   |       |   | |   |   | {call_arg_list}
      | |   | |   |       |   | |   |     | {call_filter_clause}
      | |   | |   |       |   | |   |     | {arg_list}: ok
      | |   | |   |       |   | |   |       | {name a}: a: integer inferred_notnull variable was_set
      | |   | |   |       |   | |   | {let_stmt}: y2: integer variable
      | |   | |   |       |   | |   | | {name y2}: y2: integer variable
      | |   | |   |       |   | |   | | {name b}: b: integer variable was_set
      | |   | |   |       |   | |   | {let_stmt}: z2: integer variable
      | |   | |   |       |   | |     | {name z2}: z2: integer variable
      | |   | |   |       |   | |     | {name c}: c: integer variable was_set
      | |   | |   |       |   | | {elseif}: integer notnull
      | |   | |   |       |   |   | {cond_action}: integer notnull
      | |   | |   |       |   |     | {int 0}: integer notnull
      | |   | |   |       |   |     | {stmt_list}: ok
      | |   | |   |       |   |       | {let_stmt}: x3: integer notnull variable
      | |   | |   |       |   |       | | {name x3}: x3: integer notnull variable
      | |   | |   |       |   |       | | {call}: a: integer notnull variable was_set
      | |   | |   |       |   |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |   | |   |       |   |       |   | {call_arg_list}
      | |   | |   |       |   |       |     | {call_filter_clause}
      | |   | |   |       |   |       |     | {arg_list}: ok
      | |   | |   |       |   |       |       | {name a}: a: integer inferred_notnull variable was_set
      | |   | |   |       |   |       | {let_stmt}: y3: integer notnull variable
      | |   | |   |       |   |       | | {name y3}: y3: integer notnull variable
      | |   | |   |       |   |       | | {call}: b: integer notnull variable was_set
      | |   | |   |       |   |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   | |   |       |   |       |   | {call_arg_list}
      | |   | |   |       |   |       |     | {call_filter_clause}
      | |   | |   |       |   |       |     | {arg_list}: ok
      | |   | |   |       |   |       |       | {name b}: b: integer inferred_notnull variable was_set
      | |   | |   |       |   |       | {let_stmt}: z3: integer notnull variable
      | |   | |   |       |   |       | | {name z3}: z3: integer notnull variable
      | |   | |   |       |   |       | | {call}: c: integer notnull variable was_set
      | |   | |   |       |   |       |   | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |   | |   |       |   |       |   | {call_arg_list}
      | |   | |   |       |   |       |     | {call_filter_clause}
      | |   | |   |       |   |       |     | {arg_list}: ok
      | |   | |   |       |   |       |       | {name c}: c: integer inferred_notnull variable was_set
      | |   | |   |       |   |       | {assign}: b: integer variable was_set
      | |   | |   |       |   |       | | {name b}: b: integer variable was_set
      | |   | |   |       |   |       | | {null}: null
      | |   | |   |       |   |       | {assign}: c: integer variable was_set
      | |   | |   |       |   |         | {name c}: c: integer variable was_set
      | |   | |   |       |   |         | {null}: null
      | |   | |   |       |   | {else}: ok
      | |   | |   |       |     | {stmt_list}: ok
      | |   | |   |       |       | {let_stmt}: x4: integer notnull variable
      | |   | |   |       |       | | {name x4}: x4: integer notnull variable
      | |   | |   |       |       | | {call}: a: integer notnull variable was_set
      | |   | |   |       |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |   | |   |       |       |   | {call_arg_list}
      | |   | |   |       |       |     | {call_filter_clause}
      | |   | |   |       |       |     | {arg_list}: ok
      | |   | |   |       |       |       | {name a}: a: integer inferred_notnull variable was_set
      | |   | |   |       |       | {let_stmt}: y4: integer notnull variable
      | |   | |   |       |       | | {name y4}: y4: integer notnull variable
      | |   | |   |       |       | | {call}: b: integer notnull variable was_set
      | |   | |   |       |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   | |   |       |       |   | {call_arg_list}
      | |   | |   |       |       |     | {call_filter_clause}
      | |   | |   |       |       |     | {arg_list}: ok
      | |   | |   |       |       |       | {name b}: b: integer inferred_notnull variable was_set
      | |   | |   |       |       | {let_stmt}: z4: integer notnull variable
      | |   | |   |       |         | {name z4}: z4: integer notnull variable
      | |   | |   |       |         | {call}: c: integer notnull variable was_set
      | |   | |   |       |           | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |   | |   |       |           | {call_arg_list}
      | |   | |   |       |             | {call_filter_clause}
      | |   | |   |       |             | {arg_list}: ok
      | |   | |   |       |               | {name c}: c: integer inferred_notnull variable was_set
      | |   | |   |       | {let_stmt}: x5: integer variable
      | |   | |   |       | | {name x5}: x5: integer variable
      | |   | |   |       | | {name a}: a: integer variable was_set
      | |   | |   |       | {let_stmt}: y5: integer variable
      | |   | |   |       | | {name y5}: y5: integer variable
      | |   | |   |       | | {name b}: b: integer variable was_set
      | |   | |   |       | {let_stmt}: z5: integer variable
      | |   | |   |       | | {name z5}: z5: integer variable
      | |   | |   |       | | {name c}: c: integer variable was_set
      | |   | |   |       | {assign}: a: integer variable was_set
      | |   | |   |       | | {name a}: a: integer variable was_set
      | |   | |   |       | | {int 42}: integer notnull
      | |   | |   |       | {assign}: b: integer variable was_set
      | |   | |   |       | | {name b}: b: integer variable was_set
      | |   | |   |       | | {int 42}: integer notnull
      | |   | |   |       | {assign}: c: integer variable was_set
      | |   | |   |         | {name c}: c: integer variable was_set
      | |   | |   |         | {int 42}: integer notnull
      | |   | |   | {let_stmt}: x6: integer variable
      | |   | |   | | {name x6}: x6: integer variable
      | |   | |   | | {name a}: a: integer variable was_set
      | |   | |   | {let_stmt}: y6: integer variable
      | |   | |   | | {name y6}: y6: integer variable
      | |   | |   | | {name b}: b: integer variable was_set
      | |   | |   | {let_stmt}: z6: integer notnull variable
      | |   | |     | {name z6}: z6: integer notnull variable
      | |   | |     | {call}: c: integer notnull variable was_set
      | |   | |       | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |   | |       | {call_arg_list}
      | |   | |         | {call_filter_clause}
      | |   | |         | {arg_list}: ok
      | |   | |           | {name c}: c: integer inferred_notnull variable was_set
      | |   | | {if_alt}: ok
      | |   |   | {else}: ok
      | |   |     | {stmt_list}: ok
      | |   |       | {let_stmt}: x7: integer notnull variable
      | |   |       | | {name x7}: x7: integer notnull variable
      | |   |       | | {call}: a: integer notnull variable was_set
      | |   |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |   |       |   | {call_arg_list}
      | |   |       |     | {call_filter_clause}
      | |   |       |     | {arg_list}: ok
      | |   |       |       | {name a}: a: integer inferred_notnull variable was_set
      | |   |       | {let_stmt}: y7: integer notnull variable
      | |   |       | | {name y7}: y7: integer notnull variable
      | |   |       | | {call}: b: integer notnull variable was_set
      | |   |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      | |   |       |   | {call_arg_list}
      | |   |       |     | {call_filter_clause}
      | |   |       |     | {arg_list}: ok
      | |   |       |       | {name b}: b: integer inferred_notnull variable was_set
      | |   |       | {let_stmt}: z7: integer notnull variable
      | |   |         | {name z7}: z7: integer notnull variable
      | |   |         | {call}: c: integer notnull variable was_set
      | |   |           | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |   |           | {call_arg_list}
      | |   |             | {call_filter_clause}
      | |   |             | {arg_list}: ok
      | |   |               | {name c}: c: integer inferred_notnull variable was_set
      | |   | {let_stmt}: x8: integer variable
      | |   | | {name x8}: x8: integer variable
      | |   | | {name a}: a: integer variable was_set
      | |   | {let_stmt}: y8: integer variable
      | |   | | {name y8}: y8: integer variable
      | |   | | {name b}: b: integer variable was_set
      | |   | {let_stmt}: z8: integer notnull variable
      | |     | {name z8}: z8: integer notnull variable
      | |     | {call}: c: integer notnull variable was_set
      | |       | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |       | {call_arg_list}
      | |         | {call_filter_clause}
      | |         | {arg_list}: ok
      | |           | {name c}: c: integer inferred_notnull variable was_set
      | | {if_alt}: ok
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {let_stmt}: x9: integer notnull variable
      |       | | {name x9}: x9: integer notnull variable
      |       | | {call}: a: integer notnull variable was_set
      |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name a}: a: integer inferred_notnull variable was_set
      |       | {let_stmt}: y9: integer notnull variable
      |       | | {name y9}: y9: integer notnull variable
      |       | | {call}: b: integer notnull variable was_set
      |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name b}: b: integer inferred_notnull variable was_set
      |       | {let_stmt}: z9: integer notnull variable
      |         | {name z9}: z9: integer notnull variable
      |         | {call}: c: integer notnull variable was_set
      |           | {name cql_inferred_notnull}: c: integer notnull variable was_set
      |           | {call_arg_list}
      |             | {call_filter_clause}
      |             | {arg_list}: ok
      |               | {name c}: c: integer inferred_notnull variable was_set
      | {let_stmt}: x10: integer variable
      | | {name x10}: x10: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y10: integer variable
      | | {name y10}: y10: integer variable
      | | {name b}: b: integer variable was_set
      | {let_stmt}: z10: integer notnull variable
        | {name z10}: z10: integer notnull variable
        | {call}: c: integer notnull variable was_set
          | {name cql_inferred_notnull}: c: integer notnull variable was_set
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c}: c: integer inferred_notnull variable was_set

The statement ending at line XXXX

CREATE PROC reverting_improvements_and_unimprovements_restores_original_state ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  DECLARE d INTEGER;
  IF b IS NULL THEN
    RETURN;
  END IF;
  SET c := 42;
  LET x0 := a;
  LET y0 := b;
  LET z0 := c;
  LET w0 := d;
  IF 0 THEN
    IF a IS NOT NULL THEN
      LET x1 := a;
      LET y1 := b;
      LET z1 := c;
      LET w1 := d;
      SET b := NULL;
      SET c := NULL;
      IF c IS NOT NULL THEN
        LET dummy := 0;
      END IF;
      SET d := 42;
      LET x2 := a;
      LET y2 := b;
      LET z2 := c;
      LET w2 := d;
    END IF;
    LET x3 := a;
    LET y3 := b;
    LET z3 := c;
    LET w3 := d;
    SET a := NULL;
  ELSE
    LET x4 := a;
    LET y4 := b;
    LET z4 := c;
    LET w4 := d;
  END IF;
  LET x5 := a;
  LET y5 := b;
  LET z5 := c;
  LET w5 := d;
END;

  {create_proc_stmt}: ok
  | {name reverting_improvements_and_unimprovements_restores_original_state}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable was_set
      | | | {name c}: c: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: d: integer variable was_set
      | | | {name d}: d: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name b}: b: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {assign}: c: integer variable was_set
      | | {name c}: c: integer variable was_set
      | | {int 42}: integer notnull
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {call}: b: integer notnull variable
      |   | {name cql_inferred_notnull}: b: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable
      | {let_stmt}: z0: integer notnull variable
      | | {name z0}: z0: integer notnull variable
      | | {call}: c: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: c: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name c}: c: integer inferred_notnull variable was_set
      | {let_stmt}: w0: integer variable
      | | {name w0}: w0: integer variable
      | | {name d}: d: integer variable
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: bool notnull
      | |   | | {cond_action}: bool notnull
      | |   | | | {is_not}: bool notnull
      | |   | | | | {name a}: a: integer variable
      | |   | | | | {null}: null
      | |   | | | {stmt_list}: ok
      | |   | |   | {let_stmt}: x1: integer notnull variable
      | |   | |   | | {name x1}: x1: integer notnull variable
      | |   | |   | | {call}: a: integer notnull variable
      | |   | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | |   | {let_stmt}: y1: integer notnull variable
      | |   | |   | | {name y1}: y1: integer notnull variable
      | |   | |   | | {call}: b: integer notnull variable
      | |   | |   |   | {name cql_inferred_notnull}: b: integer notnull variable
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name b}: b: integer inferred_notnull variable
      | |   | |   | {let_stmt}: z1: integer notnull variable
      | |   | |   | | {name z1}: z1: integer notnull variable
      | |   | |   | | {call}: c: integer notnull variable was_set
      | |   | |   |   | {name cql_inferred_notnull}: c: integer notnull variable was_set
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name c}: c: integer inferred_notnull variable was_set
      | |   | |   | {let_stmt}: w1: integer variable
      | |   | |   | | {name w1}: w1: integer variable
      | |   | |   | | {name d}: d: integer variable
      | |   | |   | {assign}: b: integer variable was_set
      | |   | |   | | {name b}: b: integer variable was_set
      | |   | |   | | {null}: null
      | |   | |   | {assign}: c: integer variable was_set
      | |   | |   | | {name c}: c: integer variable was_set
      | |   | |   | | {null}: null
      | |   | |   | {if_stmt}: bool notnull
      | |   | |   | | {cond_action}: bool notnull
      | |   | |   | | | {is_not}: bool notnull
      | |   | |   | | | | {name c}: c: integer variable was_set
      | |   | |   | | | | {null}: null
      | |   | |   | | | {stmt_list}: ok
      | |   | |   | |   | {let_stmt}: dummy: integer notnull variable
      | |   | |   | |     | {name dummy}: dummy: integer notnull variable
      | |   | |   | |     | {int 0}: integer notnull
      | |   | |   | | {if_alt}: ok
      | |   | |   | {assign}: d: integer variable was_set
      | |   | |   | | {name d}: d: integer variable was_set
      | |   | |   | | {int 42}: integer notnull
      | |   | |   | {let_stmt}: x2: integer notnull variable
      | |   | |   | | {name x2}: x2: integer notnull variable
      | |   | |   | | {call}: a: integer notnull variable
      | |   | |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      | |   | |   |   | {call_arg_list}
      | |   | |   |     | {call_filter_clause}
      | |   | |   |     | {arg_list}: ok
      | |   | |   |       | {name a}: a: integer inferred_notnull variable
      | |   | |   | {let_stmt}: y2: integer variable
      | |   | |   | | {name y2}: y2: integer variable
      | |   | |   | | {name b}: b: integer variable was_set
      | |   | |   | {let_stmt}: z2: integer variable
      | |   | |   | | {name z2}: z2: integer variable
      | |   | |   | | {name c}: c: integer variable was_set
      | |   | |   | {let_stmt}: w2: integer notnull variable
      | |   | |     | {name w2}: w2: integer notnull variable
      | |   | |     | {call}: d: integer notnull variable was_set
      | |   | |       | {name cql_inferred_notnull}: d: integer notnull variable was_set
      | |   | |       | {call_arg_list}
      | |   | |         | {call_filter_clause}
      | |   | |         | {arg_list}: ok
      | |   | |           | {name d}: d: integer inferred_notnull variable was_set
      | |   | | {if_alt}: ok
      | |   | {let_stmt}: x3: integer variable
      | |   | | {name x3}: x3: integer variable
      | |   | | {name a}: a: integer variable
      | |   | {let_stmt}: y3: integer variable
      | |   | | {name y3}: y3: integer variable
      | |   | | {name b}: b: integer variable was_set
      | |   | {let_stmt}: z3: integer variable
      | |   | | {name z3}: z3: integer variable
      | |   | | {name c}: c: integer variable was_set
      | |   | {let_stmt}: w3: integer variable
      | |   | | {name w3}: w3: integer variable
      | |   | | {name d}: d: integer variable was_set
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {null}: null
      | | {if_alt}: ok
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {let_stmt}: x4: integer variable
      |       | | {name x4}: x4: integer variable
      |       | | {name a}: a: integer variable was_set
      |       | {let_stmt}: y4: integer notnull variable
      |       | | {name y4}: y4: integer notnull variable
      |       | | {call}: b: integer notnull variable was_set
      |       |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name b}: b: integer inferred_notnull variable was_set
      |       | {let_stmt}: z4: integer notnull variable
      |       | | {name z4}: z4: integer notnull variable
      |       | | {call}: c: integer notnull variable was_set
      |       |   | {name cql_inferred_notnull}: c: integer notnull variable was_set
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name c}: c: integer inferred_notnull variable was_set
      |       | {let_stmt}: w4: integer variable
      |         | {name w4}: w4: integer variable
      |         | {name d}: d: integer variable was_set
      | {let_stmt}: x5: integer variable
      | | {name x5}: x5: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y5: integer variable
      | | {name y5}: y5: integer variable
      | | {name b}: b: integer variable was_set
      | {let_stmt}: z5: integer variable
      | | {name z5}: z5: integer variable
      | | {name c}: c: integer variable was_set
      | {let_stmt}: w5: integer variable
        | {name w5}: w5: integer variable
        | {name d}: d: integer variable was_set

The statement ending at line XXXX

CREATE PROC unimproving_and_reimproving_is_neutral ()
BEGIN
  DECLARE a INTEGER;
  SET a := 42;
  LET x0 := a;
  IF 0 THEN
    SET a := NULL;
    SET a := NULL;
    SET a := 100;
  ELSE IF 0 THEN
    SET a := NULL;
    SET a := 100;
    SET a := NULL;
    SET a := 100;
  ELSE
    SET a := 100;
  END IF;
  LET x1 := a;
  IF 0 THEN
    SET a := 100;
  ELSE IF 0 THEN
    SET a := NULL;
  ELSE
    SET a := 100;
  END IF;
  LET x2 := a;
END;

  {create_proc_stmt}: ok
  | {name unimproving_and_reimproving_is_neutral}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 42}: integer notnull
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |   | | {name a}: a: integer variable was_set
      | |   | | {null}: null
      | |   | {assign}: a: integer variable was_set
      | |   | | {name a}: a: integer variable was_set
      | |   | | {null}: null
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 100}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   |   | {stmt_list}: ok
      |   |     | {assign}: a: integer variable was_set
      |   |     | | {name a}: a: integer variable was_set
      |   |     | | {null}: null
      |   |     | {assign}: a: integer variable was_set
      |   |     | | {name a}: a: integer variable was_set
      |   |     | | {int 100}: integer notnull
      |   |     | {assign}: a: integer variable was_set
      |   |     | | {name a}: a: integer variable was_set
      |   |     | | {null}: null
      |   |     | {assign}: a: integer variable was_set
      |   |       | {name a}: a: integer variable was_set
      |   |       | {int 100}: integer notnull
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 100}: integer notnull
      | {let_stmt}: x1: integer notnull variable
      | | {name x1}: x1: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 100}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   |   | {stmt_list}: ok
      |   |     | {assign}: a: integer variable was_set
      |   |       | {name a}: a: integer variable was_set
      |   |       | {null}: null
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 100}: integer notnull
      | {let_stmt}: x2: integer variable
        | {name x2}: x2: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC all_branches_improving_including_else_results_in_an_improvement ()
BEGIN
  DECLARE a INTEGER;
  IF 0 THEN
    SET a := 42;
  ELSE IF 0 THEN
    SET a := NULL;
    IF 0 THEN
      SET a := 42;
    ELSE
      SET a := NULL;
      SET a := 42;
    END IF;
  ELSE IF 0 THEN
    SET a := 42;
  ELSE
    SET a := NULL;
    SET a := NULL;
    SET a := 42;
  END IF;
  LET x0 := a;
  SET a := NULL;
  LET x1 := a;
  IF 0 THEN
    SET a := 42;
  END IF;
  LET x2 := a;
  IF 0 THEN
    SET a := 42;
  ELSE IF 0 THEN
    SET a := 42;
  END IF;
  LET x3 := a;
END;

  {create_proc_stmt}: ok
  | {name all_branches_improving_including_else_results_in_an_improvement}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 42}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   | | | {int 0}: integer notnull
      |   | | | {stmt_list}: ok
      |   | |   | {assign}: a: integer variable was_set
      |   | |   | | {name a}: a: integer variable was_set
      |   | |   | | {null}: null
      |   | |   | {if_stmt}: integer notnull
      |   | |     | {cond_action}: integer notnull
      |   | |     | | {int 0}: integer notnull
      |   | |     | | {stmt_list}: ok
      |   | |     |   | {assign}: a: integer variable was_set
      |   | |     |     | {name a}: a: integer variable was_set
      |   | |     |     | {int 42}: integer notnull
      |   | |     | {if_alt}: ok
      |   | |       | {else}: ok
      |   | |         | {stmt_list}: ok
      |   | |           | {assign}: a: integer variable was_set
      |   | |           | | {name a}: a: integer variable was_set
      |   | |           | | {null}: null
      |   | |           | {assign}: a: integer variable was_set
      |   | |             | {name a}: a: integer variable was_set
      |   | |             | {int 42}: integer notnull
      |   | | {elseif}: integer notnull
      |   |   | {cond_action}: integer notnull
      |   |     | {int 0}: integer notnull
      |   |     | {stmt_list}: ok
      |   |       | {assign}: a: integer variable was_set
      |   |         | {name a}: a: integer variable was_set
      |   |         | {int 42}: integer notnull
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |       | | {name a}: a: integer variable was_set
      |       | | {null}: null
      |       | {assign}: a: integer variable was_set
      |       | | {name a}: a: integer variable was_set
      |       | | {null}: null
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 42}: integer notnull
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {null}: null
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 42}: integer notnull
      | | {if_alt}: ok
      | {let_stmt}: x2: integer variable
      | | {name x2}: x2: integer variable
      | | {name a}: a: integer variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 42}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |     | {cond_action}: integer notnull
      |       | {int 0}: integer notnull
      |       | {stmt_list}: ok
      |         | {assign}: a: integer variable was_set
      |           | {name a}: a: integer variable was_set
      |           | {int 42}: integer notnull
      | {let_stmt}: x3: integer variable
        | {name x3}: x3: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

DECLARE PROC requires_int_notnull (a INTEGER NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_int_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: integer notnull variable in
        | {param_detail}: a: integer notnull variable in
          | {name a}: a: integer notnull variable in
          | {notnull}: integer notnull
            | {type_int}: integer

The statement ending at line XXXX

CREATE PROC unimprovements_in_loops_affect_earlier_statements ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  SET a := 1;
  SET b := 1;
  LET x0 := a;
  LET y0 := b;
  WHILE 0
  BEGIN
    CALL requires_int_notnull(a);
    LET x1 := a;
    LET y1 := b;
    SET a := NULL;
    WHILE 0
    BEGIN
      SET a := 1;
      SET b := NULL;
      LET x2 := a;
      LET y2 := b;
    END;
  END;
  LET x3 := a;
  LET y3 := b;
  SET a := 1;
  SET b := 1;
  LET x4 := a;
  LET y4 := b;
  DECLARE foo CURSOR FOR SELECT 1 AS bar;
  LOOP FETCH foo
  BEGIN
    LET x5 := a;
    LET y5 := b;
    SET a := NULL;
  END;
  LET x6 := a;
  LET y6 := b;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0013: cannot assign/copy possibly null expression to not null target 'a'

  {create_proc_stmt}: err
  | {name unimprovements_in_loops_affect_earlier_statements}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {assign}: b: integer variable was_set
      | | {name b}: b: integer variable was_set
      | | {int 1}: integer notnull
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {call}: b: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable was_set
      | {while_stmt}: err
      | | {int 0}: integer notnull
      | | {stmt_list}: err
      |   | {call_stmt}: err
      |   | | {name requires_int_notnull}: ok
      |   | | {expr_list}: ok
      |   |   | {name a}: a: integer variable was_set
      |   | {let_stmt}: x1: integer variable
      |   | | {name x1}: x1: integer variable
      |   | | {name a}: a: integer variable was_set
      |   | {let_stmt}: y1: integer variable
      |   | | {name y1}: y1: integer variable
      |   | | {name b}: b: integer variable was_set
      |   | {assign}: a: integer variable was_set
      |   | | {name a}: a: integer variable was_set
      |   | | {null}: null
      |   | {while_stmt}: ok
      |     | {int 0}: integer notnull
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |       | | {name a}: a: integer variable was_set
      |       | | {int 1}: integer notnull
      |       | {assign}: b: integer variable was_set
      |       | | {name b}: b: integer variable was_set
      |       | | {null}: null
      |       | {let_stmt}: x2: integer notnull variable
      |       | | {name x2}: x2: integer notnull variable
      |       | | {call}: a: integer notnull variable was_set
      |       |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |       |   | {call_arg_list}
      |       |     | {call_filter_clause}
      |       |     | {arg_list}: ok
      |       |       | {name a}: a: integer inferred_notnull variable was_set
      |       | {let_stmt}: y2: integer variable
      |         | {name y2}: y2: integer variable
      |         | {name b}: b: integer variable was_set
      | {let_stmt}: x3: integer variable
      | | {name x3}: x3: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y3: integer variable
      | | {name y3}: y3: integer variable
      | | {name b}: b: integer variable was_set
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {assign}: b: integer variable was_set
      | | {name b}: b: integer variable was_set
      | | {int 1}: integer notnull
      | {let_stmt}: x4: integer notnull variable
      | | {name x4}: x4: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: y4: integer notnull variable
      | | {name y4}: y4: integer notnull variable
      | | {call}: b: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable was_set
      | {declare_cursor}: foo: select: { bar: integer notnull } variable dml_proc
      | | {name foo}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { bar: integer notnull }
      |   | {select_core_list}: select: { bar: integer notnull }
      |   | | {select_core}: select: { bar: integer notnull }
      |   |   | {select_expr_list_con}: select: { bar: integer notnull }
      |   |     | {select_expr_list}: select: { bar: integer notnull }
      |   |     | | {select_expr}: bar: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name bar}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {loop_stmt}: ok
      | | {fetch_stmt}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | | {name foo}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {let_stmt}: x5: integer variable
      |   | | {name x5}: x5: integer variable
      |   | | {name a}: a: integer variable was_set
      |   | {let_stmt}: y5: integer notnull variable
      |   | | {name y5}: y5: integer notnull variable
      |   | | {call}: b: integer notnull variable was_set
      |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name b}: b: integer inferred_notnull variable was_set
      |   | {assign}: a: integer variable was_set
      |     | {name a}: a: integer variable was_set
      |     | {null}: null
      | {let_stmt}: x6: integer variable
      | | {name x6}: x6: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y6: integer notnull variable
        | {name y6}: y6: integer notnull variable
        | {call}: b: integer notnull variable was_set
          | {name cql_inferred_notnull}: b: integer notnull variable was_set
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name b}: b: integer inferred_notnull variable was_set

The statement ending at line XXXX

CREATE PROC loops_keep_all_unsets_and_ignore_all_sets ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  SET a := 1;
  SET b := 1;
  WHILE 0
  BEGIN
    SET a := 1;
    SET b := 1;
    LET x0 := a;
    LET y0 := b;
    IF 0 THEN
      SET a := NULL;
      IF 0 THEN
        LEAVE;
      END IF;
      SET a := 1;
      WHILE 0
      BEGIN
        IF 0 THEN
          SET b := NULL;
          SET b := 1;
        ELSE
          SET b := 1;
        END IF;
      END;
    ELSE
      SET a := 1;
      SET b := 1;
    END IF;
    LET x1 := a;
    LET y1 := b;
  END;
  LET x2 := a;
  LET y2 := b;
  SET a := 1;
  SET b := 1;
  LET x3 := a;
  LET y3 := b;
  DECLARE foo CURSOR FOR SELECT 1 AS bar;
  LOOP FETCH foo
  BEGIN
    IF 0 THEN
      SET a := NULL;
      IF 0 THEN
        LEAVE;
      END IF;
      SET a := 1;
    ELSE
      SET b := 1;
    END IF;
  END;
  LET x4 := a;
  LET y4 := b;
  DECLARE c INTEGER;
  SET c := 1;
  PROC SAVEPOINT
  BEGIN
    IF 0 THEN
      SET c := NULL;
      IF 0 THEN
        ROLLBACK RETURN;
      END IF;
      SET c := 1;
    ELSE
    END IF;
  END;
  LET z := c;
END;

  {create_proc_stmt}: ok dml_proc
  | {name loops_keep_all_unsets_and_ignore_all_sets}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {assign}: b: integer variable was_set
      | | {name b}: b: integer variable was_set
      | | {int 1}: integer notnull
      | {while_stmt}: ok
      | | {int 0}: integer notnull
      | | {stmt_list}: ok
      |   | {assign}: a: integer variable was_set
      |   | | {name a}: a: integer variable was_set
      |   | | {int 1}: integer notnull
      |   | {assign}: b: integer variable was_set
      |   | | {name b}: b: integer variable was_set
      |   | | {int 1}: integer notnull
      |   | {let_stmt}: x0: integer notnull variable
      |   | | {name x0}: x0: integer notnull variable
      |   | | {call}: a: integer notnull variable was_set
      |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name a}: a: integer inferred_notnull variable was_set
      |   | {let_stmt}: y0: integer notnull variable
      |   | | {name y0}: y0: integer notnull variable
      |   | | {call}: b: integer notnull variable was_set
      |   |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name b}: b: integer inferred_notnull variable was_set
      |   | {if_stmt}: integer notnull
      |   | | {cond_action}: integer notnull
      |   | | | {int 0}: integer notnull
      |   | | | {stmt_list}: ok
      |   | |   | {assign}: a: integer variable was_set
      |   | |   | | {name a}: a: integer variable was_set
      |   | |   | | {null}: null
      |   | |   | {if_stmt}: integer notnull
      |   | |   | | {cond_action}: integer notnull
      |   | |   | | | {int 0}: integer notnull
      |   | |   | | | {stmt_list}: ok
      |   | |   | |   | {leave_stmt}: ok
      |   | |   | | {if_alt}: ok
      |   | |   | {assign}: a: integer variable was_set
      |   | |   | | {name a}: a: integer variable was_set
      |   | |   | | {int 1}: integer notnull
      |   | |   | {while_stmt}: ok
      |   | |     | {int 0}: integer notnull
      |   | |     | {stmt_list}: ok
      |   | |       | {if_stmt}: integer notnull
      |   | |         | {cond_action}: integer notnull
      |   | |         | | {int 0}: integer notnull
      |   | |         | | {stmt_list}: ok
      |   | |         |   | {assign}: b: integer variable was_set
      |   | |         |   | | {name b}: b: integer variable was_set
      |   | |         |   | | {null}: null
      |   | |         |   | {assign}: b: integer variable was_set
      |   | |         |     | {name b}: b: integer variable was_set
      |   | |         |     | {int 1}: integer notnull
      |   | |         | {if_alt}: ok
      |   | |           | {else}: ok
      |   | |             | {stmt_list}: ok
      |   | |               | {assign}: b: integer variable was_set
      |   | |                 | {name b}: b: integer variable was_set
      |   | |                 | {int 1}: integer notnull
      |   | | {if_alt}: ok
      |   |   | {else}: ok
      |   |     | {stmt_list}: ok
      |   |       | {assign}: a: integer variable was_set
      |   |       | | {name a}: a: integer variable was_set
      |   |       | | {int 1}: integer notnull
      |   |       | {assign}: b: integer variable was_set
      |   |         | {name b}: b: integer variable was_set
      |   |         | {int 1}: integer notnull
      |   | {let_stmt}: x1: integer notnull variable
      |   | | {name x1}: x1: integer notnull variable
      |   | | {call}: a: integer notnull variable was_set
      |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name a}: a: integer inferred_notnull variable was_set
      |   | {let_stmt}: y1: integer variable
      |     | {name y1}: y1: integer variable
      |     | {name b}: b: integer variable was_set
      | {let_stmt}: x2: integer variable
      | | {name x2}: x2: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y2: integer variable
      | | {name y2}: y2: integer variable
      | | {name b}: b: integer variable was_set
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {assign}: b: integer variable was_set
      | | {name b}: b: integer variable was_set
      | | {int 1}: integer notnull
      | {let_stmt}: x3: integer notnull variable
      | | {name x3}: x3: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: y3: integer notnull variable
      | | {name y3}: y3: integer notnull variable
      | | {call}: b: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable was_set
      | {declare_cursor}: foo: select: { bar: integer notnull } variable dml_proc
      | | {name foo}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { bar: integer notnull }
      |   | {select_core_list}: select: { bar: integer notnull }
      |   | | {select_core}: select: { bar: integer notnull }
      |   |   | {select_expr_list_con}: select: { bar: integer notnull }
      |   |     | {select_expr_list}: select: { bar: integer notnull }
      |   |     | | {select_expr}: bar: integer notnull
      |   |     |   | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name bar}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {loop_stmt}: ok
      | | {fetch_stmt}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | | {name foo}: foo: select: { bar: integer notnull } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {if_stmt}: integer notnull
      |     | {cond_action}: integer notnull
      |     | | {int 0}: integer notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: a: integer variable was_set
      |     |   | | {name a}: a: integer variable was_set
      |     |   | | {null}: null
      |     |   | {if_stmt}: integer notnull
      |     |   | | {cond_action}: integer notnull
      |     |   | | | {int 0}: integer notnull
      |     |   | | | {stmt_list}: ok
      |     |   | |   | {leave_stmt}: ok
      |     |   | | {if_alt}: ok
      |     |   | {assign}: a: integer variable was_set
      |     |     | {name a}: a: integer variable was_set
      |     |     | {int 1}: integer notnull
      |     | {if_alt}: ok
      |       | {else}: ok
      |         | {stmt_list}: ok
      |           | {assign}: b: integer variable was_set
      |             | {name b}: b: integer variable was_set
      |             | {int 1}: integer notnull
      | {let_stmt}: x4: integer variable
      | | {name x4}: x4: integer variable
      | | {name a}: a: integer variable was_set
      | {let_stmt}: y4: integer notnull variable
      | | {name y4}: y4: integer notnull variable
      | | {call}: b: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable was_set
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable was_set
      | | | {name c}: c: integer variable was_set
      | | {type_int}: integer
      | {assign}: c: integer variable was_set
      | | {name c}: c: integer variable was_set
      | | {int 1}: integer notnull
      | {proc_savepoint_stmt}: ok
      | | {stmt_list}: ok
      |   | {if_stmt}: integer notnull
      |     | {cond_action}: integer notnull
      |     | | {int 0}: integer notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: c: integer variable was_set
      |     |   | | {name c}: c: integer variable was_set
      |     |   | | {null}: null
      |     |   | {if_stmt}: integer notnull
      |     |   | | {cond_action}: integer notnull
      |     |   | | | {int 0}: integer notnull
      |     |   | | | {stmt_list}: ok
      |     |   | |   | {rollback_return_stmt}: ok
      |     |   | | {if_alt}: ok
      |     |   | {assign}: c: integer variable was_set
      |     |     | {name c}: c: integer variable was_set
      |     |     | {int 1}: integer notnull
      |     | {if_alt}: ok
      |       | {else}: ok
      | {let_stmt}: z: integer notnull variable
        | {name z}: z: integer notnull variable
        | {call}: c: integer notnull variable was_set
          | {name cql_inferred_notnull}: c: integer notnull variable was_set
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name c}: c: integer inferred_notnull variable was_set

The statement ending at line XXXX

CREATE PROC try_keeps_all_unsets_and_ignores_all_sets ()
BEGIN
  DECLARE a INTEGER;
  SET a := 1;
  BEGIN TRY
    IF 0 THEN
      SET a := NULL;
      IF 0 THEN
        THROW;
      END IF;
      SET a := 1;
    ELSE
    END IF;
    LET x0 := a;
  END TRY;
  BEGIN CATCH
    LET x1 := a;
    SET a := 1;
  END CATCH;
  LET x2 := a;
END;

  {create_proc_stmt}: ok dml_proc
  | {name try_keeps_all_unsets_and_ignores_all_sets}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {trycatch_stmt}: ok
      | | {stmt_list}: ok
      | | | {if_stmt}: integer notnull
      | | | | {cond_action}: integer notnull
      | | | | | {int 0}: integer notnull
      | | | | | {stmt_list}: ok
      | | | |   | {assign}: a: integer variable was_set
      | | | |   | | {name a}: a: integer variable was_set
      | | | |   | | {null}: null
      | | | |   | {if_stmt}: integer notnull
      | | | |   | | {cond_action}: integer notnull
      | | | |   | | | {int 0}: integer notnull
      | | | |   | | | {stmt_list}: ok
      | | | |   | |   | {throw_stmt}: ok
      | | | |   | | {if_alt}: ok
      | | | |   | {assign}: a: integer variable was_set
      | | | |     | {name a}: a: integer variable was_set
      | | | |     | {int 1}: integer notnull
      | | | | {if_alt}: ok
      | | |   | {else}: ok
      | | | {let_stmt}: x0: integer notnull variable
      | |   | {name x0}: x0: integer notnull variable
      | |   | {call}: a: integer notnull variable was_set
      | |     | {name cql_inferred_notnull}: a: integer notnull variable was_set
      | |     | {call_arg_list}
      | |       | {call_filter_clause}
      | |       | {arg_list}: ok
      | |         | {name a}: a: integer inferred_notnull variable was_set
      | | {stmt_list}: ok
      |   | {let_stmt}: x1: integer variable
      |   | | {name x1}: x1: integer variable
      |   | | {name a}: a: integer variable was_set
      |   | {assign}: a: integer variable was_set
      |     | {name a}: a: integer variable was_set
      |     | {int 1}: integer notnull
      | {let_stmt}: x2: integer variable
        | {name x2}: x2: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC proc_savepoint_improvements_persist ()
BEGIN
  DECLARE a INTEGER;
  PROC SAVEPOINT
  BEGIN
    SET a := 1;
    ROLLBACK RETURN;
  END;
  LET x := a;
END;

  {create_proc_stmt}: ok dml_proc
  | {name proc_savepoint_improvements_persist}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {proc_savepoint_stmt}: ok
      | | {stmt_list}: ok
      |   | {assign}: a: integer variable was_set
      |   | | {name a}: a: integer variable was_set
      |   | | {int 1}: integer notnull
      |   | {rollback_return_stmt}: ok
      | {let_stmt}: x: integer notnull variable
        | {name x}: x: integer notnull variable
        | {call}: a: integer notnull variable was_set
          | {name cql_inferred_notnull}: a: integer notnull variable was_set
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name a}: a: integer inferred_notnull variable was_set

The statement ending at line XXXX

CREATE PROC switch_branches_are_independent_for_improvements ()
BEGIN
  DECLARE a INTEGER;
  SET a := 1;
  SWITCH 0
    WHEN 1 THEN
      SET a := NULL;
    WHEN 2 THEN
      LET x0 := a;
      SET a := NULL;
    ELSE
      LET x1 := a;
  END;
  LET x2 := a;
END;

  {create_proc_stmt}: ok
  | {name switch_branches_are_independent_for_improvements}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {int 1}: integer notnull
      | {switch_stmt}: ok
      | | {int 0}
      | | {switch_body}
      |   | {int 0}: integer notnull
      |   | {switch_case}: ok
      |     | {connector}
      |     | | {expr_list}: ok
      |     | | | {int 1}: integer notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: a: integer variable was_set
      |     |     | {name a}: a: integer variable was_set
      |     |     | {null}: null
      |     | {switch_case}
      |       | {connector}
      |       | | {expr_list}: ok
      |       | | | {int 2}: integer notnull
      |       | | {stmt_list}: ok
      |       |   | {let_stmt}: x0: integer notnull variable
      |       |   | | {name x0}: x0: integer notnull variable
      |       |   | | {call}: a: integer notnull variable was_set
      |       |   |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |       |   |   | {call_arg_list}
      |       |   |     | {call_filter_clause}
      |       |   |     | {arg_list}: ok
      |       |   |       | {name a}: a: integer inferred_notnull variable was_set
      |       |   | {assign}: a: integer variable was_set
      |       |     | {name a}: a: integer variable was_set
      |       |     | {null}: null
      |       | {switch_case}
      |         | {connector}
      |           | {stmt_list}: ok
      |             | {let_stmt}: x1: integer notnull variable
      |               | {name x1}: x1: integer notnull variable
      |               | {call}: a: integer notnull variable was_set
      |                 | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |                 | {call_arg_list}
      |                   | {call_filter_clause}
      |                   | {arg_list}: ok
      |                     | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: x2: integer variable
        | {name x2}: x2: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC switch_improvements_can_persist ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  SWITCH 0
    WHEN 1 THEN
      SET a := 1;
    WHEN 2 THEN
      SET a := 1;
    ELSE
      SET a := 1;
  END;
  SWITCH 0 ALL VALUES
    WHEN 0 THEN
      SET b := 1;
    WHEN 1 THEN
      SET b := 1;
    WHEN 2 THEN
      SET b := 1;
  END;
  SWITCH 0
    WHEN 1 THEN
      SET c := 1;
    WHEN 2 THEN
      SET c := 1;
  END;
  LET x := a;
  LET y := b;
  LET z := c;
END;

  {create_proc_stmt}: ok
  | {name switch_improvements_can_persist}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable was_set
      | | | {name c}: c: integer variable was_set
      | | {type_int}: integer
      | {switch_stmt}: ok
      | | {int 0}
      | | {switch_body}
      |   | {int 0}: integer notnull
      |   | {switch_case}: ok
      |     | {connector}
      |     | | {expr_list}: ok
      |     | | | {int 1}: integer notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: a: integer variable was_set
      |     |     | {name a}: a: integer variable was_set
      |     |     | {int 1}: integer notnull
      |     | {switch_case}
      |       | {connector}
      |       | | {expr_list}: ok
      |       | | | {int 2}: integer notnull
      |       | | {stmt_list}: ok
      |       |   | {assign}: a: integer variable was_set
      |       |     | {name a}: a: integer variable was_set
      |       |     | {int 1}: integer notnull
      |       | {switch_case}
      |         | {connector}
      |           | {stmt_list}: ok
      |             | {assign}: a: integer variable was_set
      |               | {name a}: a: integer variable was_set
      |               | {int 1}: integer notnull
      | {switch_stmt}: ok
      | | {int 1}
      | | {switch_body}
      |   | {int 0}: integer<three_things> notnull
      |   | {switch_case}: ok
      |     | {connector}
      |     | | {expr_list}: ok
      |     | | | {int 0}: integer<three_things> notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: b: integer variable was_set
      |     |     | {name b}: b: integer variable was_set
      |     |     | {int 1}: integer notnull
      |     | {switch_case}
      |       | {connector}
      |       | | {expr_list}: ok
      |       | | | {int 1}: integer<three_things> notnull
      |       | | {stmt_list}: ok
      |       |   | {assign}: b: integer variable was_set
      |       |     | {name b}: b: integer variable was_set
      |       |     | {int 1}: integer notnull
      |       | {switch_case}
      |         | {connector}
      |           | {expr_list}: ok
      |           | | {int 2}: integer<three_things> notnull
      |           | {stmt_list}: ok
      |             | {assign}: b: integer variable was_set
      |               | {name b}: b: integer variable was_set
      |               | {int 1}: integer notnull
      | {switch_stmt}: ok
      | | {int 0}
      | | {switch_body}
      |   | {int 0}: integer notnull
      |   | {switch_case}: ok
      |     | {connector}
      |     | | {expr_list}: ok
      |     | | | {int 1}: integer notnull
      |     | | {stmt_list}: ok
      |     |   | {assign}: c: integer variable was_set
      |     |     | {name c}: c: integer variable was_set
      |     |     | {int 1}: integer notnull
      |     | {switch_case}
      |       | {connector}
      |         | {expr_list}: ok
      |         | | {int 2}: integer notnull
      |         | {stmt_list}: ok
      |           | {assign}: c: integer variable was_set
      |             | {name c}: c: integer variable was_set
      |             | {int 1}: integer notnull
      | {let_stmt}: x: integer notnull variable
      | | {name x}: x: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: y: integer notnull variable
      | | {name y}: y: integer notnull variable
      | | {call}: b: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: b: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable was_set
      | {let_stmt}: z: integer variable
        | {name z}: z: integer variable
        | {name c}: c: integer variable was_set

The statement ending at line XXXX

CREATE PROC empty_branches_prevent_persisting_improvements ()
BEGIN
  DECLARE a INTEGER;
  IF 0 THEN
  ELSE IF 0 THEN
    SET a := 1;
  ELSE
    SET a := 1;
  END IF;
  LET x0 := a;
  IF 0 THEN
    SET a := 1;
  ELSE IF 0 THEN
  ELSE
    SET a := 1;
  END IF;
  LET x1 := a;
  IF 0 THEN
    SET a := 1;
  ELSE IF 0 THEN
    SET a := 1;
  ELSE
  END IF;
  LET x2 := a;
END;

  {create_proc_stmt}: ok
  | {name empty_branches_prevent_persisting_improvements}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   |   | {stmt_list}: ok
      |   |     | {assign}: a: integer variable was_set
      |   |       | {name a}: a: integer variable was_set
      |   |       | {int 1}: integer notnull
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 1}: integer notnull
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 1}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 1}: integer notnull
      | {let_stmt}: x1: integer variable
      | | {name x1}: x1: integer variable
      | | {name a}: a: integer variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 1}: integer notnull
      | | {if_alt}: ok
      |   | {elseif}: integer notnull
      |   | | {cond_action}: integer notnull
      |   |   | {int 0}: integer notnull
      |   |   | {stmt_list}: ok
      |   |     | {assign}: a: integer variable was_set
      |   |       | {name a}: a: integer variable was_set
      |   |       | {int 1}: integer notnull
      |   | {else}: ok
      | {let_stmt}: x2: integer variable
        | {name x2}: x2: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_account_for_control_statements ()
BEGIN
  DECLARE a INTEGER;
  IF 0 THEN
    SET a := 1;
  ELSE
    THROW;
  END IF;
  LET x0 := a;
  SET a := NULL;
  WHILE 0
  BEGIN
    IF 0 THEN
      IF 0 THEN
        SET a := NULL;
        SET a := 1;
      ELSE IF 0 THEN
        THROW;
      ELSE IF 0 THEN
        RETURN;
      ELSE
        SET a := 1;
      END IF;
    ELSE IF 0 THEN
      LEAVE;
    ELSE IF 0 THEN
      IF 0 THEN
        CONTINUE;
      ELSE
        SET a := NULL;
        SET a := NULL;
        SET a := 1;
      END IF;
    ELSE
      SET a := NULL;
      CONTINUE;
    END IF;
    LET x1 := a;
  END;
  LET x2 := a;
  IF 0 THEN
    IF 0 THEN
      THROW;
    ELSE
      RETURN;
    END IF;
  ELSE
    SET a := 1;
  END IF;
  LET x3 := a;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_account_for_control_statements}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable was_set
      | | | {name a}: a: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {assign}: a: integer variable was_set
      | |     | {name a}: a: integer variable was_set
      | |     | {int 1}: integer notnull
      | | {if_alt}: ok
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {throw_stmt}: ok
      | {let_stmt}: x0: integer notnull variable
      | | {name x0}: x0: integer notnull variable
      | | {call}: a: integer notnull variable was_set
      |   | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name a}: a: integer inferred_notnull variable was_set
      | {assign}: a: integer variable was_set
      | | {name a}: a: integer variable was_set
      | | {null}: null
      | {while_stmt}: ok
      | | {int 0}: integer notnull
      | | {stmt_list}: ok
      |   | {if_stmt}: integer notnull
      |   | | {cond_action}: integer notnull
      |   | | | {int 0}: integer notnull
      |   | | | {stmt_list}: ok
      |   | |   | {if_stmt}: integer notnull
      |   | |     | {cond_action}: integer notnull
      |   | |     | | {int 0}: integer notnull
      |   | |     | | {stmt_list}: ok
      |   | |     |   | {assign}: a: integer variable was_set
      |   | |     |   | | {name a}: a: integer variable was_set
      |   | |     |   | | {null}: null
      |   | |     |   | {assign}: a: integer variable was_set
      |   | |     |     | {name a}: a: integer variable was_set
      |   | |     |     | {int 1}: integer notnull
      |   | |     | {if_alt}: ok
      |   | |       | {elseif}: integer notnull
      |   | |       | | {cond_action}: integer notnull
      |   | |       | | | {int 0}: integer notnull
      |   | |       | | | {stmt_list}: ok
      |   | |       | |   | {throw_stmt}: ok
      |   | |       | | {elseif}: integer notnull
      |   | |       |   | {cond_action}: integer notnull
      |   | |       |     | {int 0}: integer notnull
      |   | |       |     | {stmt_list}: ok
      |   | |       |       | {return_stmt}: ok
      |   | |       | {else}: ok
      |   | |         | {stmt_list}: ok
      |   | |           | {assign}: a: integer variable was_set
      |   | |             | {name a}: a: integer variable was_set
      |   | |             | {int 1}: integer notnull
      |   | | {if_alt}: ok
      |   |   | {elseif}: integer notnull
      |   |   | | {cond_action}: integer notnull
      |   |   | | | {int 0}: integer notnull
      |   |   | | | {stmt_list}: ok
      |   |   | |   | {leave_stmt}: ok
      |   |   | | {elseif}: integer notnull
      |   |   |   | {cond_action}: integer notnull
      |   |   |     | {int 0}: integer notnull
      |   |   |     | {stmt_list}: ok
      |   |   |       | {if_stmt}: integer notnull
      |   |   |         | {cond_action}: integer notnull
      |   |   |         | | {int 0}: integer notnull
      |   |   |         | | {stmt_list}: ok
      |   |   |         |   | {continue_stmt}: ok
      |   |   |         | {if_alt}: ok
      |   |   |           | {else}: ok
      |   |   |             | {stmt_list}: ok
      |   |   |               | {assign}: a: integer variable was_set
      |   |   |               | | {name a}: a: integer variable was_set
      |   |   |               | | {null}: null
      |   |   |               | {assign}: a: integer variable was_set
      |   |   |               | | {name a}: a: integer variable was_set
      |   |   |               | | {null}: null
      |   |   |               | {assign}: a: integer variable was_set
      |   |   |                 | {name a}: a: integer variable was_set
      |   |   |                 | {int 1}: integer notnull
      |   |   | {else}: ok
      |   |     | {stmt_list}: ok
      |   |       | {assign}: a: integer variable was_set
      |   |       | | {name a}: a: integer variable was_set
      |   |       | | {null}: null
      |   |       | {continue_stmt}: ok
      |   | {let_stmt}: x1: integer notnull variable
      |     | {name x1}: x1: integer notnull variable
      |     | {call}: a: integer notnull variable was_set
      |       | {name cql_inferred_notnull}: a: integer notnull variable was_set
      |       | {call_arg_list}
      |         | {call_filter_clause}
      |         | {arg_list}: ok
      |           | {name a}: a: integer inferred_notnull variable was_set
      | {let_stmt}: x2: integer variable
      | | {name x2}: x2: integer variable
      | | {name a}: a: integer variable was_set
      | {if_stmt}: integer notnull
      | | {cond_action}: integer notnull
      | | | {int 0}: integer notnull
      | | | {stmt_list}: ok
      | |   | {if_stmt}: integer notnull
      | |     | {cond_action}: integer notnull
      | |     | | {int 0}: integer notnull
      | |     | | {stmt_list}: ok
      | |     |   | {throw_stmt}: ok
      | |     | {if_alt}: ok
      | |       | {else}: ok
      | |         | {stmt_list}: ok
      | |           | {return_stmt}: ok
      | | {if_alt}: ok
      |   | {else}: ok
      |     | {stmt_list}: ok
      |       | {assign}: a: integer variable was_set
      |         | {name a}: a: integer variable was_set
      |         | {int 1}: integer notnull
      | {let_stmt}: x3: integer variable
        | {name x3}: x3: integer variable
        | {name a}: a: integer variable was_set

The statement ending at line XXXX

CREATE PROC improvements_work_for_while_conditions ()
BEGIN
  DECLARE a INTEGER;
  DECLARE b INTEGER;
  DECLARE c INTEGER;
  IF b IS NULL THEN
    RETURN;
  END IF;
  LET x0 := a;
  LET y0 := b;
  LET z0 := b;
  WHILE a IS NOT NULL AND c IS NOT NULL
  BEGIN
    LET x1 := a;
    LET y1 := b;
    LET z1 := c;
    SET b := NULL;
    SET c := NULL;
  END;
  LET x2 := a;
  LET y2 := b;
  LET z2 := c;
END;

  {create_proc_stmt}: ok
  | {name improvements_work_for_while_conditions}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: a: integer variable
      | | | {name a}: a: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable was_set
      | | | {name b}: b: integer variable was_set
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c: integer variable was_set
      | | | {name c}: c: integer variable was_set
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {is}: bool notnull
      | | | | {name b}: b: integer variable
      | | | | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x0: integer variable
      | | {name x0}: x0: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y0: integer notnull variable
      | | {name y0}: y0: integer notnull variable
      | | {call}: b: integer notnull variable
      |   | {name cql_inferred_notnull}: b: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable
      | {let_stmt}: z0: integer notnull variable
      | | {name z0}: z0: integer notnull variable
      | | {call}: b: integer notnull variable
      |   | {name cql_inferred_notnull}: b: integer notnull variable
      |   | {call_arg_list}
      |     | {call_filter_clause}
      |     | {arg_list}: ok
      |       | {name b}: b: integer inferred_notnull variable
      | {while_stmt}: ok
      | | {and}: bool notnull
      | | | {is_not}: bool notnull
      | | | | {name a}: a: integer variable
      | | | | {null}: null
      | | | {is_not}: bool notnull
      | |   | {name c}: c: integer variable
      | |   | {null}: null
      | | {stmt_list}: ok
      |   | {let_stmt}: x1: integer notnull variable
      |   | | {name x1}: x1: integer notnull variable
      |   | | {call}: a: integer notnull variable
      |   |   | {name cql_inferred_notnull}: a: integer notnull variable
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name a}: a: integer inferred_notnull variable
      |   | {let_stmt}: y1: integer variable
      |   | | {name y1}: y1: integer variable
      |   | | {name b}: b: integer variable was_set
      |   | {let_stmt}: z1: integer notnull variable
      |   | | {name z1}: z1: integer notnull variable
      |   | | {call}: c: integer notnull variable was_set
      |   |   | {name cql_inferred_notnull}: c: integer notnull variable was_set
      |   |   | {call_arg_list}
      |   |     | {call_filter_clause}
      |   |     | {arg_list}: ok
      |   |       | {name c}: c: integer inferred_notnull variable was_set
      |   | {assign}: b: integer variable was_set
      |   | | {name b}: b: integer variable was_set
      |   | | {null}: null
      |   | {assign}: c: integer variable was_set
      |     | {name c}: c: integer variable was_set
      |     | {null}: null
      | {let_stmt}: x2: integer variable
      | | {name x2}: x2: integer variable
      | | {name a}: a: integer variable
      | {let_stmt}: y2: integer variable
      | | {name y2}: y2: integer variable
      | | {name b}: b: integer variable was_set
      | {let_stmt}: z2: integer variable
        | {name z2}: z2: integer variable
        | {name c}: c: integer variable was_set

The statement ending at line XXXX

DECLARE PROC requires_inout_text_notnull (INOUT t TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_inout_text_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: t: text notnull variable in out
        | {inout}
        | {param_detail}: t: text notnull variable in out
          | {name t}: t: text notnull variable in out
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

DECLARE PROC requires_inout_blob_notnull (INOUT t BLOB NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_inout_blob_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: t: blob notnull variable in out
        | {inout}
        | {param_detail}: t: blob notnull variable in out
          | {name t}: t: blob notnull variable in out
          | {notnull}: blob notnull
            | {type_blob}: blob

The statement ending at line XXXX

DECLARE PROC requires_inout_object_notnull (INOUT t OBJECT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_inout_object_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: t: object notnull variable in out
        | {inout}
        | {param_detail}: t: object notnull variable in out
          | {name t}: t: object notnull variable in out
          | {notnull}: object notnull
            | {type_object}: object

The statement ending at line XXXX

CREATE PROC initialization_is_required_for_nonnull_reference_types ()
BEGIN
  DECLARE a TEXT NOT NULL;
  DECLARE b BLOB NOT NULL;
  DECLARE c OBJECT NOT NULL;
  LET dummy := a;
  LET dummy := b;
  LET dummy := c;
  CALL requires_inout_text_notnull(a);
  CALL requires_inout_blob_notnull(b);
  CALL requires_inout_object_notnull(c);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'a'
test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'b'
test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'c'
test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'a'
test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'b'
test/sem_test.sql:XXXX:1: error: in str : CQL0438: variable possibly used before initialization 'c'

  {create_proc_stmt}: err
  | {name initialization_is_required_for_nonnull_reference_types}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: text notnull
      | | {name_list}: a: text notnull variable init_required
      | | | {name a}: a: text notnull variable init_required
      | | {notnull}: text notnull
      |   | {type_text}: text
      | {declare_vars_type}: blob notnull
      | | {name_list}: b: blob notnull variable init_required
      | | | {name b}: b: blob notnull variable init_required
      | | {notnull}: blob notnull
      |   | {type_blob}: blob
      | {declare_vars_type}: object notnull
      | | {name_list}: c: object notnull variable init_required
      | | | {name c}: c: object notnull variable init_required
      | | {notnull}: object notnull
      |   | {type_object}: object
      | {let_stmt}: err
      | | {name dummy}
      | | {name a}: err
      | {let_stmt}: err
      | | {name dummy}
      | | {name b}: err
      | {let_stmt}: err
      | | {name dummy}
      | | {name c}: err
      | {call_stmt}: err
      | | {name requires_inout_text_notnull}: ok
      | | {expr_list}: ok
      |   | {name a}: err
      | {call_stmt}: err
      | | {name requires_inout_blob_notnull}: ok
      | | {expr_list}: ok
      |   | {name b}: err
      | {call_stmt}: err
        | {name requires_inout_object_notnull}: ok
        | {expr_list}: ok
          | {name c}: err

The statement ending at line XXXX

CREATE PROC initialization_is_not_required_for_nullable_reference_types ()
BEGIN
  DECLARE a TEXT;
  DECLARE b BLOB;
  DECLARE c OBJECT;
  LET x := a;
  LET y := b;
  LET z := c;
END;

  {create_proc_stmt}: ok
  | {name initialization_is_not_required_for_nullable_reference_types}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text
      | | {name_list}: a: text variable
      | | | {name a}: a: text variable
      | | {type_text}: text
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {declare_vars_type}: object
      | | {name_list}: c: object variable
      | | | {name c}: c: object variable
      | | {type_object}: object
      | {let_stmt}: x: text variable
      | | {name x}: x: text variable
      | | {name a}: a: text variable
      | {let_stmt}: y: blob variable
      | | {name y}: y: blob variable
      | | {name b}: b: blob variable
      | {let_stmt}: z: object variable
        | {name z}: z: object variable
        | {name c}: c: object variable

The statement ending at line XXXX

CREATE PROC initialization_is_not_required_for_non_reference_types ()
BEGIN
  DECLARE a BOOL NOT NULL;
  DECLARE b INTEGER NOT NULL;
  DECLARE c LONG_INT NOT NULL;
  LET x := a;
  LET y := b;
  LET z := c;
END;

  {create_proc_stmt}: ok
  | {name initialization_is_not_required_for_non_reference_types}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: bool notnull
      | | {name_list}: a: bool notnull variable
      | | | {name a}: a: bool notnull variable
      | | {notnull}: bool notnull
      |   | {type_bool}: bool
      | {declare_vars_type}: integer notnull
      | | {name_list}: b: integer notnull variable
      | | | {name b}: b: integer notnull variable
      | | {notnull}: integer notnull
      |   | {type_int}: integer
      | {declare_vars_type}: longint notnull
      | | {name_list}: c: longint notnull variable
      | | | {name c}: c: longint notnull variable
      | | {notnull}: longint notnull
      |   | {type_long}: longint
      | {let_stmt}: x: bool notnull variable
      | | {name x}: x: bool notnull variable
      | | {name a}: a: bool notnull variable
      | {let_stmt}: y: integer notnull variable
      | | {name y}: y: integer notnull variable
      | | {name b}: b: integer notnull variable
      | {let_stmt}: z: longint notnull variable
        | {name z}: z: longint notnull variable
        | {name c}: c: longint notnull variable

The statement ending at line XXXX

CREATE PROC set_can_initialize ()
BEGIN
  DECLARE a TEXT NOT NULL;
  SET a := "text";
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name set_can_initialize}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text notnull
      | | {name_list}: a: text notnull variable init_required was_set
      | | | {name a}: a: text notnull variable init_required was_set
      | | {notnull}: text notnull
      |   | {type_text}: text
      | {assign}: a: text notnull variable init_required was_set
      | | {name a}: a: text notnull variable init_required was_set
      | | {strlit 'text'}: text notnull
      | {let_stmt}: x: text notnull variable
        | {name x}: x: text notnull variable
        | {name a}: a: text notnull variable was_set

The statement ending at line XXXX

CREATE PROC string_chain ()
BEGIN
  LET z := "abc\n123\r\n\x02lmnop''";
END;

  {create_proc_stmt}: ok
  | {name string_chain}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {let_stmt}: z: text notnull variable
        | {name z}: z: text notnull variable
        | {strlit 'abc
123
lmnop'''''}: text notnull

The statement ending at line XXXX

DECLARE PROC requires_out_text_notnull (OUT t TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_out_text_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: t: text notnull variable init_required out
        | {out}
        | {param_detail}: t: text notnull variable init_required out
          | {name t}: t: text notnull variable init_required out
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC out_arg_uses_can_initialize ()
BEGIN
  DECLARE a TEXT NOT NULL;
  CALL requires_out_text_notnull(a);
  LET x := a;
END;

  {create_proc_stmt}: ok
  | {name out_arg_uses_can_initialize}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text notnull
      | | {name_list}: a: text notnull variable init_required was_set
      | | | {name a}: a: text notnull variable init_required was_set
      | | {notnull}: text notnull
      |   | {type_text}: text
      | {call_stmt}: ok
      | | {name requires_out_text_notnull}: ok
      | | {expr_list}: ok
      |   | {name a}: a: text notnull variable init_required
      | {let_stmt}: x: text notnull variable
        | {name x}: x: text notnull variable
        | {name a}: a: text notnull variable was_set

The statement ending at line XXXX

CREATE PROC fetch_into_initializes ()
BEGIN
  DECLARE a TEXT NOT NULL;
  DECLARE foo CURSOR FOR SELECT "text" AS bar;
  FETCH foo INTO a;
  LET x := a;
END;

  {create_proc_stmt}: ok dml_proc
  | {name fetch_into_initializes}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: text notnull
      | | {name_list}: a: text notnull variable init_required was_set
      | | | {name a}: a: text notnull variable init_required was_set
      | | {notnull}: text notnull
      |   | {type_text}: text
      | {declare_cursor}: foo: select: { bar: text notnull } variable dml_proc
      | | {name foo}: foo: select: { bar: text notnull } variable dml_proc fetch_into
      | | {select_stmt}: select: { bar: text notnull }
      |   | {select_core_list}: select: { bar: text notnull }
      |   | | {select_core}: select: { bar: text notnull }
      |   |   | {select_expr_list_con}: select: { bar: text notnull }
      |   |     | {select_expr_list}: select: { bar: text notnull }
      |   |     | | {select_expr}: bar: text notnull
      |   |     |   | {strlit 'text'}: text notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name bar}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: foo: select: { bar: text notnull } variable dml_proc fetch_into
      | | {name foo}: foo: select: { bar: text notnull } variable dml_proc
      | | {name_list}
      |   | {name a}: a: text notnull variable init_required was_set
      | {let_stmt}: x: text notnull variable
        | {name x}: x: text notnull variable
        | {name a}: a: text notnull variable was_set

The statement ending at line XXXX

CREATE PROC nonnull_reference_out_args_require_initialization (OUT a TEXT NOT NULL)
BEGIN
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0439: nonnull reference OUT parameter possibly not always initialized 'a'

  {create_proc_stmt}: err
  | {name nonnull_reference_out_args_require_initialization}: err
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: text notnull variable init_required out
        | {out}
        | {param_detail}: a: text notnull variable init_required out
          | {name a}: a: text notnull variable init_required out
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC out_arg_initialization_directly_in_proc_works (OUT a TEXT NOT NULL)
BEGIN
  SET a := "text";
END;

  {create_proc_stmt}: ok
  | {name out_arg_initialization_directly_in_proc_works}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: a: text notnull variable init_required out was_set
    |     | {name a}: a: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {assign}: a: text notnull variable init_required out was_set
        | {name a}: a: text notnull variable init_required out was_set
        | {strlit 'text'}: text notnull

The statement ending at line XXXX

CREATE PROC out_args_must_be_initialized_before_return (OUT a TEXT NOT NULL)
BEGIN
  IF 0 THEN
    RETURN;
  END IF;
  SET a := "text";
END;

test/sem_test.sql:XXXX:1: error: in return_stmt : CQL0439: nonnull reference OUT parameter possibly not always initialized 'a'

  {create_proc_stmt}: err
  | {name out_args_must_be_initialized_before_return}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: a: text notnull variable init_required out was_set
    |     | {name a}: a: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: err
      | {if_stmt}: err
      | | {cond_action}: err
      | | | {int 0}: integer notnull
      | | | {stmt_list}: err
      | |   | {return_stmt}: err
      | | {if_alt}
      | {assign}: a: text notnull variable init_required out was_set
        | {name a}: a: text notnull variable init_required out was_set
        | {strlit 'text'}: text notnull

The statement ending at line XXXX

CREATE PROC out_args_can_be_initialized_in_branches (OUT a TEXT NOT NULL)
BEGIN
  IF 0 THEN
    SET a := "text";
  ELSE IF 0 THEN
    SET a := "text";
  ELSE
    IF 0 THEN
      IF 0 THEN
        SET a := "text";
      ELSE
        IF 0 THEN
          SET a := "text";
        ELSE
          SWITCH 0
            WHEN 0 THEN
              SET a := "text";
            WHEN 1 THEN
              IF 0 THEN
                SET a := "text";
              ELSE
                SET a := "text";
              END IF;
            ELSE
              SET a := "text";
          END;
        END IF;
      END IF;
    ELSE
      SET a := "text";
    END IF;
  END IF;
END;

  {create_proc_stmt}: ok
  | {name out_args_can_be_initialized_in_branches}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: a: text notnull variable init_required out was_set
    |     | {name a}: a: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 0}: integer notnull
        | | {stmt_list}: ok
        |   | {assign}: a: text notnull variable init_required out was_set
        |     | {name a}: a: text notnull variable init_required out was_set
        |     | {strlit 'text'}: text notnull
        | {if_alt}: ok
          | {elseif}: integer notnull
          | | {cond_action}: integer notnull
          |   | {int 0}: integer notnull
          |   | {stmt_list}: ok
          |     | {assign}: a: text notnull variable init_required out was_set
          |       | {name a}: a: text notnull variable init_required out was_set
          |       | {strlit 'text'}: text notnull
          | {else}: ok
            | {stmt_list}: ok
              | {if_stmt}: integer notnull
                | {cond_action}: integer notnull
                | | {int 0}: integer notnull
                | | {stmt_list}: ok
                |   | {if_stmt}: integer notnull
                |     | {cond_action}: integer notnull
                |     | | {int 0}: integer notnull
                |     | | {stmt_list}: ok
                |     |   | {assign}: a: text notnull variable init_required out was_set
                |     |     | {name a}: a: text notnull variable init_required out was_set
                |     |     | {strlit 'text'}: text notnull
                |     | {if_alt}: ok
                |       | {else}: ok
                |         | {stmt_list}: ok
                |           | {if_stmt}: integer notnull
                |             | {cond_action}: integer notnull
                |             | | {int 0}: integer notnull
                |             | | {stmt_list}: ok
                |             |   | {assign}: a: text notnull variable init_required out was_set
                |             |     | {name a}: a: text notnull variable init_required out was_set
                |             |     | {strlit 'text'}: text notnull
                |             | {if_alt}: ok
                |               | {else}: ok
                |                 | {stmt_list}: ok
                |                   | {switch_stmt}: ok
                |                     | {int 0}
                |                     | {switch_body}
                |                       | {int 0}: integer notnull
                |                       | {switch_case}: ok
                |                         | {connector}
                |                         | | {expr_list}: ok
                |                         | | | {int 0}: integer notnull
                |                         | | {stmt_list}: ok
                |                         |   | {assign}: a: text notnull variable init_required out was_set
                |                         |     | {name a}: a: text notnull variable init_required out was_set
                |                         |     | {strlit 'text'}: text notnull
                |                         | {switch_case}
                |                           | {connector}
                |                           | | {expr_list}: ok
                |                           | | | {int 1}: integer notnull
                |                           | | {stmt_list}: ok
                |                           |   | {if_stmt}: integer notnull
                |                           |     | {cond_action}: integer notnull
                |                           |     | | {int 0}: integer notnull
                |                           |     | | {stmt_list}: ok
                |                           |     |   | {assign}: a: text notnull variable init_required out was_set
                |                           |     |     | {name a}: a: text notnull variable init_required out was_set
                |                           |     |     | {strlit 'text'}: text notnull
                |                           |     | {if_alt}: ok
                |                           |       | {else}: ok
                |                           |         | {stmt_list}: ok
                |                           |           | {assign}: a: text notnull variable init_required out was_set
                |                           |             | {name a}: a: text notnull variable init_required out was_set
                |                           |             | {strlit 'text'}: text notnull
                |                           | {switch_case}
                |                             | {connector}
                |                               | {stmt_list}: ok
                |                                 | {assign}: a: text notnull variable init_required out was_set
                |                                   | {name a}: a: text notnull variable init_required out was_set
                |                                   | {strlit 'text'}: text notnull
                | {if_alt}: ok
                  | {else}: ok
                    | {stmt_list}: ok
                      | {assign}: a: text notnull variable init_required out was_set
                        | {name a}: a: text notnull variable init_required out was_set
                        | {strlit 'text'}: text notnull

The statement ending at line XXXX

CREATE PROC out_arg_initialization_in_branches_must_cover_all_cases (OUT a TEXT NOT NULL)
BEGIN
  IF 0 THEN
    SET a := "text";
  ELSE IF 0 THEN
    SET a := "text";
  ELSE
    IF 0 THEN
      IF 0 THEN
        SET a := "text";
      ELSE
        IF 0 THEN
          SET a := "text";
        ELSE
          SWITCH 0
            WHEN 0 THEN
              SET a := "text";
            WHEN 1 THEN
              IF 0 THEN
              ELSE
                SET a := "text";
              END IF;
            ELSE
              SET a := "text";
          END;
        END IF;
      END IF;
    ELSE
      SET a := "text";
    END IF;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0439: nonnull reference OUT parameter possibly not always initialized 'a'

  {create_proc_stmt}: err
  | {name out_arg_initialization_in_branches_must_cover_all_cases}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: a: text notnull variable init_required out was_set
    |     | {name a}: a: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {if_stmt}: integer notnull
        | {cond_action}: integer notnull
        | | {int 0}: integer notnull
        | | {stmt_list}: ok
        |   | {assign}: a: text notnull variable init_required out was_set
        |     | {name a}: a: text notnull variable init_required out was_set
        |     | {strlit 'text'}: text notnull
        | {if_alt}: ok
          | {elseif}: integer notnull
          | | {cond_action}: integer notnull
          |   | {int 0}: integer notnull
          |   | {stmt_list}: ok
          |     | {assign}: a: text notnull variable init_required out was_set
          |       | {name a}: a: text notnull variable init_required out was_set
          |       | {strlit 'text'}: text notnull
          | {else}: ok
            | {stmt_list}: ok
              | {if_stmt}: integer notnull
                | {cond_action}: integer notnull
                | | {int 0}: integer notnull
                | | {stmt_list}: ok
                |   | {if_stmt}: integer notnull
                |     | {cond_action}: integer notnull
                |     | | {int 0}: integer notnull
                |     | | {stmt_list}: ok
                |     |   | {assign}: a: text notnull variable init_required out was_set
                |     |     | {name a}: a: text notnull variable init_required out was_set
                |     |     | {strlit 'text'}: text notnull
                |     | {if_alt}: ok
                |       | {else}: ok
                |         | {stmt_list}: ok
                |           | {if_stmt}: integer notnull
                |             | {cond_action}: integer notnull
                |             | | {int 0}: integer notnull
                |             | | {stmt_list}: ok
                |             |   | {assign}: a: text notnull variable init_required out was_set
                |             |     | {name a}: a: text notnull variable init_required out was_set
                |             |     | {strlit 'text'}: text notnull
                |             | {if_alt}: ok
                |               | {else}: ok
                |                 | {stmt_list}: ok
                |                   | {switch_stmt}: ok
                |                     | {int 0}
                |                     | {switch_body}
                |                       | {int 0}: integer notnull
                |                       | {switch_case}: ok
                |                         | {connector}
                |                         | | {expr_list}: ok
                |                         | | | {int 0}: integer notnull
                |                         | | {stmt_list}: ok
                |                         |   | {assign}: a: text notnull variable init_required out was_set
                |                         |     | {name a}: a: text notnull variable init_required out was_set
                |                         |     | {strlit 'text'}: text notnull
                |                         | {switch_case}
                |                           | {connector}
                |                           | | {expr_list}: ok
                |                           | | | {int 1}: integer notnull
                |                           | | {stmt_list}: ok
                |                           |   | {if_stmt}: integer notnull
                |                           |     | {cond_action}: integer notnull
                |                           |     | | {int 0}: integer notnull
                |                           |     | {if_alt}: ok
                |                           |       | {else}: ok
                |                           |         | {stmt_list}: ok
                |                           |           | {assign}: a: text notnull variable init_required out was_set
                |                           |             | {name a}: a: text notnull variable init_required out was_set
                |                           |             | {strlit 'text'}: text notnull
                |                           | {switch_case}
                |                             | {connector}
                |                               | {stmt_list}: ok
                |                                 | {assign}: a: text notnull variable init_required out was_set
                |                                   | {name a}: a: text notnull variable init_required out was_set
                |                                   | {strlit 'text'}: text notnull
                | {if_alt}: ok
                  | {else}: ok
                    | {stmt_list}: ok
                      | {assign}: a: text notnull variable init_required out was_set
                        | {name a}: a: text notnull variable init_required out was_set
                        | {strlit 'text'}: text notnull

The statement ending at line XXXX

CREATE PROC forwarding_procs_handle_initialization (OUT t TEXT NOT NULL)
BEGIN
  CALL requires_out_text_notnull(t);
END;

  {create_proc_stmt}: ok
  | {name forwarding_procs_handle_initialization}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: t: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: t: text notnull variable init_required out was_set
    |     | {name t}: t: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name requires_out_text_notnull}: ok
        | {expr_list}: ok
          | {dot}: t: text notnull variable init_required out was_set
            | {name ARGUMENTS}
            | {name t}

The statement ending at line XXXX

CREATE PROC forwarding_procs_handle_initialization_named (OUT bundle_t TEXT NOT NULL)
BEGIN
  CALL requires_out_text_notnull(bundle.t);
END;

  {create_proc_stmt}: ok
  | {name forwarding_procs_handle_initialization_named}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: bundle_t: text notnull variable init_required out was_set
    |   | {out}
    |   | {param_detail}: bundle_t: text notnull variable init_required out was_set
    |     | {name bundle_t}: bundle_t: text notnull variable init_required out was_set
    |     | {notnull}: text notnull
    |       | {type_text}: text
    | {stmt_list}: ok
      | {call_stmt}: ok
        | {name requires_out_text_notnull}: ok
        | {expr_list}: ok
          | {dot}: bundle_t: text notnull variable init_required out
            | {name bundle}
            | {name t}

The statement ending at line XXXX

CREATE PROC try_blocks_can_successfully_verify_initialization (OUT a TEXT NOT NULL, OUT rc INTEGER NOT NULL)
BEGIN
  SET rc := 0;
  @ATTRIBUTE(cql:try_is_proc_body)
  @ATTRIBUTE(some_other_attribute)
  BEGIN TRY
    SET a := "text";
  END TRY;
  BEGIN CATCH
    SET rc := 1;
  END CATCH;
END;

  {create_proc_stmt}: ok dml_proc
  | {name try_blocks_can_successfully_verify_initialization}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    | | | {out}
    | | | {param_detail}: a: text notnull variable init_required out was_set
    | |   | {name a}: a: text notnull variable init_required out was_set
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: rc: integer notnull variable out was_set
    |     | {out}
    |     | {param_detail}: rc: integer notnull variable out was_set
    |       | {name rc}: rc: integer notnull variable out was_set
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: ok
      | {assign}: rc: integer notnull variable out was_set
      | | {name rc}: rc: integer notnull variable out was_set
      | | {int 0}: integer notnull
      | {stmt_and_attr}: ok
        | {misc_attrs}: ok
        | | {misc_attr}
        | | | {dot}
        | |   | {name cql}
        | |   | {name try_is_proc_body}
        | | {misc_attrs}
        |   | {misc_attr}
        |     | {name some_other_attribute}
        | {trycatch_stmt}: ok
          | {stmt_list}: ok
          | | {assign}: a: text notnull variable init_required out was_set
          |   | {name a}: a: text notnull variable init_required out was_set
          |   | {strlit 'text'}: text notnull
          | {stmt_list}: ok
            | {assign}: rc: integer notnull variable out was_set
              | {name rc}: rc: integer notnull variable out was_set
              | {int 1}: integer notnull

The statement ending at line XXXX

CREATE PROC try_blocks_can_fail_to_verify_initialization (OUT a TEXT NOT NULL, OUT rc INTEGER NOT NULL)
BEGIN
  SET rc := 0;
  @ATTRIBUTE(some_other_attribute)
  @ATTRIBUTE(cql:try_is_proc_body)
  BEGIN TRY
  END TRY;
  BEGIN CATCH
    SET rc := 1;
  END CATCH;
  SET a := "text";
END;

test/sem_test.sql:XXXX:1: error: in trycatch_stmt : CQL0439: nonnull reference OUT parameter possibly not always initialized 'a'

  {create_proc_stmt}: err
  | {name try_blocks_can_fail_to_verify_initialization}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text notnull variable init_required out was_set
    | | | {out}
    | | | {param_detail}: a: text notnull variable init_required out was_set
    | |   | {name a}: a: text notnull variable init_required out was_set
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: rc: integer notnull variable out was_set
    |     | {out}
    |     | {param_detail}: rc: integer notnull variable out was_set
    |       | {name rc}: rc: integer notnull variable out was_set
    |       | {notnull}: integer notnull
    |         | {type_int}: integer
    | {stmt_list}: err
      | {assign}: rc: integer notnull variable out was_set
      | | {name rc}: rc: integer notnull variable out was_set
      | | {int 0}: integer notnull
      | {stmt_and_attr}: err
      | | {misc_attrs}: ok
      | | | {misc_attr}
      | | | | {name some_other_attribute}
      | | | {misc_attrs}
      | |   | {misc_attr}
      | |     | {dot}
      | |       | {name cql}
      | |       | {name try_is_proc_body}
      | | {trycatch_stmt}: err
      |   | {stmt_list}
      |     | {assign}
      |       | {name rc}
      |       | {int 1}
      | {assign}: a: text notnull variable init_required out was_set
        | {name a}: a: text notnull variable init_required out was_set
        | {strlit 'text'}: text notnull

The statement ending at line XXXX

CREATE PROC try_is_proc_body_may_only_appear_once ()
BEGIN
  @ATTRIBUTE(cql:try_is_proc_body)
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
  @ATTRIBUTE(cql:try_is_proc_body)
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
END;

test/sem_test.sql:XXXX:1: error: in trycatch_stmt : CQL0446: @attribute(cql:try_is_proc_body) cannot be used more than once per procedure

  {create_proc_stmt}: err
  | {name try_is_proc_body_may_only_appear_once}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {stmt_and_attr}: ok
      | | {misc_attrs}: ok
      | | | {misc_attr}
      | |   | {dot}
      | |     | {name cql}
      | |     | {name try_is_proc_body}
      | | {trycatch_stmt}: ok
      | {stmt_and_attr}: err
        | {misc_attrs}: ok
        | | {misc_attr}
        |   | {dot}
        |     | {name cql}
        |     | {name try_is_proc_body}
        | {trycatch_stmt}: err

The statement ending at line XXXX

CREATE PROC try_is_proc_body_accepts_no_values ()
BEGIN
  @ATTRIBUTE(cql:try_is_proc_body=(foo))
  BEGIN TRY
  END TRY;
  BEGIN CATCH
  END CATCH;
END;

test/sem_test.sql:XXXX:1: error: in misc_attr_value_list : CQL0445: @attribute(cql:try_is_proc_body) accepts no values

  {create_proc_stmt}: err
  | {name try_is_proc_body_accepts_no_values}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {stmt_and_attr}: err
        | {misc_attrs}: ok
        | | {misc_attr}
        |   | {dot}
        |   | | {name cql}
        |   | | {name try_is_proc_body}
        |   | {misc_attr_value_list}: ok
        |     | {name foo}: ok
        | {trycatch_stmt}: err

The statement ending at line XXXX

CREATE PROC improvements_work_for_dots_that_shadow_globals (X_id INTEGER, X_t TEXT, X_t1 TEXT NOT NULL, X_b BLOB, OUT X_x INTEGER NOT NULL)
BEGIN
  DECLARE Y CURSOR FOR SELECT nullable(1) AS id;
  FETCH Y;
  IF X.id IS NOT NULL AND Y.id IS NOT NULL THEN
    LET x_ := X.id;
    LET y_ := Y.id;
  END IF;
END;

  {create_proc_stmt}: ok dml_proc
  | {name improvements_work_for_dots_that_shadow_globals}: ok dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: X_id: integer variable in
    | | | {param_detail}: X_id: integer variable in
    | |   | {name X_id}: X_id: integer variable in
    | |   | {type_int}: integer
    | | {params}
    |   | {param}: X_t: text variable in
    |   | | {param_detail}: X_t: text variable in
    |   |   | {name X_t}: X_t: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: X_t1: text notnull variable in
    |     | | {param_detail}: X_t1: text notnull variable in
    |     |   | {name X_t1}: X_t1: text notnull variable in
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: X_b: blob variable in
    |       | | {param_detail}: X_b: blob variable in
    |       |   | {name X_b}: X_b: blob variable in
    |       |   | {type_blob}: blob
    |       | {params}
    |         | {param}: X_x: integer notnull variable out
    |           | {out}
    |           | {param_detail}: X_x: integer notnull variable out
    |             | {name X_x}: X_x: integer notnull variable out
    |             | {notnull}: integer notnull
    |               | {type_int}: integer
    | {stmt_list}: ok
      | {declare_cursor}: Y: select: { id: integer } variable dml_proc
      | | {name Y}: Y: select: { id: integer } variable dml_proc shape_storage
      | | {select_stmt}: select: { id: integer }
      |   | {select_core_list}: select: { id: integer }
      |   | | {select_core}: select: { id: integer }
      |   |   | {select_expr_list_con}: select: { id: integer }
      |   |     | {select_expr_list}: select: { id: integer }
      |   |     | | {select_expr}: id: integer
      |   |     |   | {call}: integer
      |   |     |   | | {name nullable}: integer
      |   |     |   | | {call_arg_list}
      |   |     |   |   | {call_filter_clause}
      |   |     |   |   | {arg_list}: ok
      |   |     |   |     | {int 1}: integer notnull
      |   |     |   | {opt_as_alias}
      |   |     |     | {name id}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: Y: select: { id: integer } variable dml_proc shape_storage
      | | {name Y}: Y: select: { id: integer } variable dml_proc shape_storage
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: X_id: integer variable in
        | | | | | {name X}
        | | | | | {name id}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {dot}: Y.id: integer variable
        | |   | | {name Y}
        | |   | | {name id}
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {let_stmt}: x_: integer notnull variable
        |   | | {name x_}: x_: integer notnull variable
        |   | | {call}: X_id: integer notnull variable in
        |   |   | {name cql_inferred_notnull}: X_id: integer notnull variable in
        |   |   | {call_arg_list}
        |   |     | {call_filter_clause}
        |   |     | {arg_list}: ok
        |   |       | {dot}: X_id: integer inferred_notnull variable in
        |   |         | {name X}
        |   |         | {name id}
        |   | {let_stmt}: y_: integer notnull variable
        |     | {name y_}: y_: integer notnull variable
        |     | {call}: Y.id: integer notnull variable
        |       | {name cql_inferred_notnull}: Y.id: integer notnull variable
        |       | {call_arg_list}
        |         | {call_filter_clause}
        |         | {arg_list}: ok
        |           | {dot}: Y.id: integer inferred_notnull variable
        |             | {name Y}
        |             | {name id}
        | {if_alt}: ok

The statement ending at line XXXX

DECLARE PROC requires_out_text_notnull_and_int (OUT a TEXT NOT NULL, b INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_out_text_notnull_and_int}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: text notnull variable init_required out
      | | {out}
      | | {param_detail}: a: text notnull variable init_required out
      |   | {name a}: a: text notnull variable init_required out
      |   | {notnull}: text notnull
      |     | {type_text}: text
      | {params}
        | {param}: b: integer variable in
          | {param_detail}: b: integer variable in
            | {name b}: b: integer variable in
            | {type_int}: integer

The statement ending at line XXXX

DECLARE PROC requires_text_notnull (a TEXT NOT NULL);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name requires_text_notnull}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: text notnull variable in
        | {param_detail}: a: text notnull variable in
          | {name a}: a: text notnull variable in
          | {notnull}: text notnull
            | {type_text}: text

The statement ending at line XXXX

CREATE PROC dot_form_and_underscore_form_are_equivalent (OUT b0_a TEXT NOT NULL, b0_b INTEGER, OUT b1_a TEXT NOT NULL, b1_b INTEGER)
BEGIN
  CALL requires_out_text_notnull_and_int(b0.a, b0.b);
  SET b1_a := "text";
  CALL requires_text_notnull(b0.a);
  CALL requires_text_notnull(b0_a);
  CALL requires_text_notnull(b1.a);
  CALL requires_text_notnull(b1_a);
  IF b0.b IS NOT NULL AND b1_b IS NOT NULL THEN
    CALL requires_int_notnull(b0.b);
    CALL requires_int_notnull(b0_b);
    CALL requires_int_notnull(b1.b);
    CALL requires_int_notnull(b1_b);
  END IF;
END;

  {create_proc_stmt}: ok
  | {name dot_form_and_underscore_form_are_equivalent}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: b0_a: text notnull variable init_required out was_set
    | | | {out}
    | | | {param_detail}: b0_a: text notnull variable init_required out was_set
    | |   | {name b0_a}: b0_a: text notnull variable init_required out was_set
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: b0_b: integer variable in
    |   | | {param_detail}: b0_b: integer variable in
    |   |   | {name b0_b}: b0_b: integer variable in
    |   |   | {type_int}: integer
    |   | {params}
    |     | {param}: b1_a: text notnull variable init_required out was_set
    |     | | {out}
    |     | | {param_detail}: b1_a: text notnull variable init_required out was_set
    |     |   | {name b1_a}: b1_a: text notnull variable init_required out was_set
    |     |   | {notnull}: text notnull
    |     |     | {type_text}: text
    |     | {params}
    |       | {param}: b1_b: integer variable in
    |         | {param_detail}: b1_b: integer variable in
    |           | {name b1_b}: b1_b: integer variable in
    |           | {type_int}: integer
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name requires_out_text_notnull_and_int}: ok
      | | {expr_list}: ok
      |   | {dot}: b0_a: text notnull variable init_required out
      |   | | {name b0}
      |   | | {name a}
      |   | {expr_list}
      |     | {dot}: b0_b: integer variable in
      |       | {name b0}
      |       | {name b}
      | {assign}: b1_a: text notnull variable init_required out was_set
      | | {name b1_a}: b1_a: text notnull variable init_required out was_set
      | | {strlit 'text'}: text notnull
      | {call_stmt}: ok
      | | {name requires_text_notnull}: ok
      | | {expr_list}: ok
      |   | {dot}: b0_a: text notnull variable out was_set
      |     | {name b0}
      |     | {name a}
      | {call_stmt}: ok
      | | {name requires_text_notnull}: ok
      | | {expr_list}: ok
      |   | {name b0_a}: b0_a: text notnull variable out was_set
      | {call_stmt}: ok
      | | {name requires_text_notnull}: ok
      | | {expr_list}: ok
      |   | {dot}: b1_a: text notnull variable out was_set
      |     | {name b1}
      |     | {name a}
      | {call_stmt}: ok
      | | {name requires_text_notnull}: ok
      | | {expr_list}: ok
      |   | {name b1_a}: b1_a: text notnull variable out was_set
      | {if_stmt}: bool notnull
        | {cond_action}: bool notnull
        | | {and}: bool notnull
        | | | {is_not}: bool notnull
        | | | | {dot}: b0_b: integer variable in
        | | | | | {name b0}
        | | | | | {name b}
        | | | | {null}: null
        | | | {is_not}: bool notnull
        | |   | {name b1_b}: b1_b: integer variable in
        | |   | {null}: null
        | | {stmt_list}: ok
        |   | {call_stmt}: ok
        |   | | {name requires_int_notnull}: ok
        |   | | {expr_list}: ok
        |   |   | {call}: b0_b: integer notnull variable in
        |   |     | {name cql_inferred_notnull}: b0_b: integer notnull variable in
        |   |     | {call_arg_list}
        |   |       | {call_filter_clause}
        |   |       | {arg_list}: ok
        |   |         | {dot}: b0_b: integer inferred_notnull variable in
        |   |           | {name b0}
        |   |           | {name b}
        |   | {call_stmt}: ok
        |   | | {name requires_int_notnull}: ok
        |   | | {expr_list}: ok
        |   |   | {call}: b0_b: integer notnull variable in
        |   |     | {name cql_inferred_notnull}: b0_b: integer notnull variable in
        |   |     | {call_arg_list}
        |   |       | {call_filter_clause}
        |   |       | {arg_list}: ok
        |   |         | {name b0_b}: b0_b: integer inferred_notnull variable in
        |   | {call_stmt}: ok
        |   | | {name requires_int_notnull}: ok
        |   | | {expr_list}: ok
        |   |   | {call}: b1_b: integer notnull variable in
        |   |     | {name cql_inferred_notnull}: b1_b: integer notnull variable in
        |   |     | {call_arg_list}
        |   |       | {call_filter_clause}
        |   |       | {arg_list}: ok
        |   |         | {dot}: b1_b: integer inferred_notnull variable in
        |   |           | {name b1}
        |   |           | {name b}
        |   | {call_stmt}: ok
        |     | {name requires_int_notnull}: ok
        |     | {expr_list}: ok
        |       | {call}: b1_b: integer notnull variable in
        |         | {name cql_inferred_notnull}: b1_b: integer notnull variable in
        |         | {call_arg_list}
        |           | {call_filter_clause}
        |           | {arg_list}: ok
        |             | {name b1_b}: b1_b: integer inferred_notnull variable in
        | {if_alt}: ok

The statement ending at line XXXX

SELECT 1 + (NOT 2 IS NULL);

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {int 1}: integer notnull
  |     |     | {not}: err
  |     |       | {is}: err
  |     |         | {int 2}: integer notnull
  |     |         | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 1) + (NOT 2 IS NULL);

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {add}: err
  |     |     | {not}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | {not}: err
  |     |       | {is}: err
  |     |         | {int 2}: integer notnull
  |     |         | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1 + (2 IS NULL);

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {add}: err
  |     |       | {int 1}: integer notnull
  |     |       | {is}: err
  |     |         | {int 2}: integer notnull
  |     |         | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1 + 2 IS NULL;

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '1 + 2'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not}: err
  |     |     | {is}: err
  |     |       | {add}: integer notnull
  |     |       | | {int 1}: integer notnull
  |     |       | | {int 2}: integer notnull
  |     |       | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 + (NOT 2) IS NULL;

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '1 + (NOT 2)'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {add}: integer notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {not}: bool notnull
  |     |     |   | {int 2}: integer notnull
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IS NOT NULL AND 2 + (NOT 3) IS NULL;

test/sem_test.sql:XXXX:1: error: in is_not : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '1'
test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '2 + (NOT 3)'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {and}: err
  |     |     | {is_not}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {null}: null
  |     |     | {is}: err
  |     |       | {add}: integer notnull
  |     |       | | {int 2}: integer notnull
  |     |       | | {not}: bool notnull
  |     |       |   | {int 3}: integer notnull
  |     |       | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 IS NOT NULL AND 2 + (NOT 3 IS NULL);

test/sem_test.sql:XXXX:1: error: in is_not : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '1'
test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '3'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {and}: err
  |     |     | {is_not}: err
  |     |     | | {int 1}: integer notnull
  |     |     | | {null}: null
  |     |     | {add}: err
  |     |       | {int 2}: integer notnull
  |     |       | {not}: err
  |     |         | {is}: err
  |     |           | {int 3}: integer notnull
  |     |           | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 0 BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {between}: bool notnull
  |     |       | {int 0}: integer notnull
  |     |       | {range}
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 0) BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {not}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {uminus}: integer notnull
  |     |       | | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 0 BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {between}: bool notnull
  |     |       | {int 0}: integer notnull
  |     |       | {range}
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = 2 BETWEEN 2 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = (2 BETWEEN 2 AND 2);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {between}: bool notnull
  |     |       | {int 2}: integer notnull
  |     |       | {range}
  |     |         | {int 2}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = 2 BETWEEN 2 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN -2 AND -1 = 4;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {uminus}: integer notnull
  |     |     |   | | {int 2}: integer notnull
  |     |     |   | {uminus}: integer notnull
  |     |     |     | {int 1}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN -2 AND -1 = 4;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {uminus}: integer notnull
  |     |     |   | | {int 2}: integer notnull
  |     |     |   | {uminus}: integer notnull
  |     |     |     | {int 1}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN -2 AND (-1 = 4);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {uminus}: integer notnull
  |     |       | | {int 2}: integer notnull
  |     |       | {eq}: bool notnull
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN 0 AND 3 BETWEEN 2 AND 3;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {int 0}: integer notnull
  |     |     |   | {int 3}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN 0 AND 3 BETWEEN 2 AND 3;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {int 0}: integer notnull
  |     |     |   | {int 3}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN 0 AND (3 BETWEEN 2 AND 3);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {between}: bool notnull
  |     |         | {int 3}: integer notnull
  |     |         | {range}
  |     |           | {int 2}: integer notnull
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 BETWEEN 1 BETWEEN 3 AND 4 AND (3 BETWEEN 2 AND 3);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {between}: bool notnull
  |     |       | | {int 1}: integer notnull
  |     |       | | {range}
  |     |       |   | {int 3}: integer notnull
  |     |       |   | {int 4}: integer notnull
  |     |       | {between}: bool notnull
  |     |         | {int 3}: integer notnull
  |     |         | {range}
  |     |           | {int 2}: integer notnull
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ~1 || 2;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {tilde}: integer notnull
  |     |     | | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ~1 || 2;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {tilde}: integer notnull
  |     |     | | {int 1}: integer notnull
  |     |     | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ~(1 || 2);

test/sem_test.sql:XXXX:1: error: in concat : CQL0047: string operand not allowed in '~'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {tilde}: err
  |     |     | {concat}: text notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -0 || 1;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {uminus}: integer notnull
  |     |     | | {int 0}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -0 || 1;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {uminus}: integer notnull
  |     |     | | {int 0}: integer notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT -(0 || 1);

test/sem_test.sql:XXXX:1: error: in concat : CQL0047: string operand not allowed in '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {uminus}: err
  |     |     | {concat}: text notnull
  |     |       | {int 0}: integer notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' || 'y' COLLATE foo;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {collate}: text notnull
  |     |       | {strlit 'y'}: text notnull
  |     |       | {name foo}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' || 'y' COLLATE foo;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {concat}: text notnull
  |     |     | {strlit 'x'}: text notnull
  |     |     | {collate}: text notnull
  |     |       | {strlit 'y'}: text notnull
  |     |       | {name foo}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT ('x' || 'y') COLLATE foo;

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {collate}: text notnull
  |     |     | {concat}: text notnull
  |     |     | | {strlit 'x'}: text notnull
  |     |     | | {strlit 'y'}: text notnull
  |     |     | {name foo}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 0 NOT BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |       | {int 0}: integer notnull
  |     |       | {range}
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 0) NOT BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {not}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {uminus}: integer notnull
  |     |       | | {int 1}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 0 NOT BETWEEN -1 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |       | {int 0}: integer notnull
  |     |       | {range}
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = 2 NOT BETWEEN 2 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = (2 NOT BETWEEN 2 AND 2);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {not_between}: bool notnull
  |     |       | {int 2}: integer notnull
  |     |       | {range}
  |     |         | {int 2}: integer notnull
  |     |         | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 = 2 NOT BETWEEN 2 AND 2;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {eq}: bool notnull
  |     |     | | {int 1}: integer notnull
  |     |     | | {int 2}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN -2 AND -1 = 4;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {uminus}: integer notnull
  |     |     |   | | {int 2}: integer notnull
  |     |     |   | {uminus}: integer notnull
  |     |     |     | {int 1}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN -2 AND -1 = 4;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {uminus}: integer notnull
  |     |     |   | | {int 2}: integer notnull
  |     |     |   | {uminus}: integer notnull
  |     |     |     | {int 1}: integer notnull
  |     |     | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN -2 AND (-1 = 4);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {uminus}: integer notnull
  |     |       | | {int 2}: integer notnull
  |     |       | {eq}: bool notnull
  |     |         | {uminus}: integer notnull
  |     |         | | {int 1}: integer notnull
  |     |         | {int 4}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN 0 AND 3 NOT BETWEEN 2 AND 3;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {int 0}: integer notnull
  |     |     |   | {int 3}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN 0 AND 3 NOT BETWEEN 2 AND 3;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {not_between}: bool notnull
  |     |     | | {int 0}: integer notnull
  |     |     | | {range}
  |     |     |   | {int 0}: integer notnull
  |     |     |   | {int 3}: integer notnull
  |     |     | {range}
  |     |       | {int 2}: integer notnull
  |     |       | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN 0 AND (3 NOT BETWEEN 2 AND 3);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {int 0}: integer notnull
  |     |       | {not_between}: bool notnull
  |     |         | {int 3}: integer notnull
  |     |         | {range}
  |     |           | {int 2}: integer notnull
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 0 NOT BETWEEN 1 NOT BETWEEN 3 AND 4 AND (3 NOT BETWEEN 2 AND 3);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not_between}: bool notnull
  |     |     | {int 0}: integer notnull
  |     |     | {range}
  |     |       | {not_between}: bool notnull
  |     |       | | {int 1}: integer notnull
  |     |       | | {range}
  |     |       |   | {int 3}: integer notnull
  |     |       |   | {int 4}: integer notnull
  |     |       | {not_between}: bool notnull
  |     |         | {int 3}: integer notnull
  |     |         | {range}
  |     |           | {int 2}: integer notnull
  |     |           | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT LIKE 'y' = 1;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {not_like}: bool notnull
  |     |     | | {strlit 'x'}: text notnull
  |     |     | | {strlit 'y'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT LIKE 'y' = 1;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {eq}: bool notnull
  |     |     | {not_like}: bool notnull
  |     |     | | {strlit 'x'}: text notnull
  |     |     | | {strlit 'y'}: text notnull
  |     |     | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 'x' NOT LIKE ('y' = 1);

test/sem_test.sql:XXXX:1: error: in eq : CQL0009: incompatible types in expression '='

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {not_like}: err
  |     |     | {strlit 'x'}: text notnull
  |     |     | {eq}: err
  |     |       | {strlit 'y'}: text notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (nullable(5) IS NULL) + 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {is}: bool notnull
  |     |     | | {call}: integer
  |     |     | | | {name nullable}: integer
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {int 5}: integer notnull
  |     |     | | {null}: null
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 5 IS NULL IS NULL;

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '5'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {is}: err
  |     |     | | {int 5}: integer notnull
  |     |     | | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (nullable(5) IS NOT NULL) + 3;

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {add}: integer notnull
  |     |     | {is_not}: bool notnull
  |     |     | | {call}: integer
  |     |     | | | {name nullable}: integer
  |     |     | | | {call_arg_list}
  |     |     | |   | {call_filter_clause}
  |     |     | |   | {arg_list}: ok
  |     |     | |     | {int 5}: integer notnull
  |     |     | | {null}: null
  |     |     | {int 3}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 5 IS NOT NULL IS NULL;

test/sem_test.sql:XXXX:1: error: in is_not : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type '5'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {is}: err
  |     |     | {is_not}: err
  |     |     | | {int 5}: integer notnull
  |     |     | | {null}: null
  |     |     | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1 IS TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {is_true}: bool notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT NOT 1 IS TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {not}: bool notnull
  |     |     | {is_true}: bool notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT (NOT 1) IS TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is_true}: bool notnull
  |     |     | {not}: bool notnull
  |     |       | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 < 5 IS TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is_true}: bool notnull
  |     |     | {lt}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 < 5 IS TRUE;

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {is_true}: bool notnull
  |     |     | {lt}: bool notnull
  |     |       | {int 1}: integer notnull
  |     |       | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 < (5 IS TRUE);

  {select_stmt}: select: { _anon: bool notnull }
  | {select_core_list}: select: { _anon: bool notnull }
  | | {select_core}: select: { _anon: bool notnull }
  |   | {select_expr_list_con}: select: { _anon: bool notnull }
  |     | {select_expr_list}: select: { _anon: bool notnull }
  |     | | {select_expr}: bool notnull
  |     |   | {lt}: bool notnull
  |     |     | {int 1}: integer notnull
  |     |     | {is_true}: bool notnull
  |     |       | {int 5}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SET fal := 'x' IS TRUE;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'IS TRUE'

  {assign}: err
  | {name fal}: fal: bool notnull variable was_set
  | {is_true}: err
    | {strlit 'x'}: text notnull

The statement ending at line XXXX

SET fal := (NOT 'x') IS FALSE;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {assign}: err
  | {name fal}: fal: bool notnull variable was_set
  | {is_false}: err
    | {not}: err
      | {strlit 'x'}: text notnull

The statement ending at line XXXX

SELECT printf();

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'printf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}: err
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf(a_string);

test/sem_test.sql:XXXX:1: error: in call : CQL0421: first argument must be a string literal 'printf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {name a_string}: a_string: text variable was_set
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%d %f", 0, 0.0, "str");

test/sem_test.sql:XXXX:1: error: in arg_list : CQL0422: more arguments provided than expected by format string 'printf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%d %f'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 0.0}: real notnull
  |     |             | {arg_list}
  |     |               | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%d %f %s", 0, 0.0);

test/sem_test.sql:XXXX:1: error: in arg_list : CQL0423: fewer arguments provided than expected by format string 'printf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%d %f %s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {dbl 0.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf('Hello!\n');

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'Hello!\n'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("Hello %% there %%!\n");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit 'Hello %% there %%!
'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%s %s", "hello", 42);

test/sem_test.sql:XXXX:1: error: in num : CQL0009: incompatible types in expression 'printf'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s %s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     |           | {arg_list}
  |     |             | {int 42}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%d", 0L);

test/sem_test.sql:XXXX:1: error: in num : CQL0242: lossy conversion from type 'LONG_INT' in 0L

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%d'}: text notnull
  |     |         | {arg_list}
  |     |           | {longint 0}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%s %d", NULL, NULL);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%s %d'}: text notnull
  |     |         | {arg_list}
  |     |           | {null}: null
  |     |           | {arg_list}
  |     |             | {null}: null
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%d %i %u %f %e %E %g %G %x %X %o %s", 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%d %i %u %f %e %E %g %G %x %X %o %s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {dbl 0.0}: real notnull
  |     |                     | {arg_list}
  |     |                       | {dbl 0.0}: real notnull
  |     |                       | {arg_list}
  |     |                         | {dbl 0.0}: real notnull
  |     |                         | {arg_list}
  |     |                           | {int 0}: integer notnull
  |     |                           | {arg_list}
  |     |                             | {int 0}: integer notnull
  |     |                             | {arg_list}
  |     |                               | {int 0}: integer notnull
  |     |                               | {arg_list}
  |     |                                 | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%c", "x");

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'c'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%c'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'x'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%p", 0x123456789L);

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'p'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%p'}: err
  |     |         | {arg_list}
  |     |           | {longint 0x123456789}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%n", 0x123456789L);

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'n'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%n'}: err
  |     |         | {arg_list}
  |     |           | {longint 0x123456789}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%q", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'q'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%q'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%Q", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'Q'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%Q'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%w", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0416: type specifier not allowed in CQL 'w'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%w'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%lld %lli %llu %llx %llX %llo", 0L, 0L, 0L, 0L, 0L, 0L);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%lld %lli %llu %llx %llX %llo'}: text notnull
  |     |         | {arg_list}
  |     |           | {longint 0}: longint notnull
  |     |           | {arg_list}
  |     |             | {longint 0}: longint notnull
  |     |             | {arg_list}
  |     |               | {longint 0}: longint notnull
  |     |               | {arg_list}
  |     |                 | {longint 0}: longint notnull
  |     |                 | {arg_list}
  |     |                   | {longint 0}: longint notnull
  |     |                   | {arg_list}
  |     |                     | {longint 0}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%ld", 0L);

test/sem_test.sql:XXXX:1: error: in str : CQL0414: 'l' length specifier has no effect; consider 'll' instead

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%ld'}: err
  |     |         | {arg_list}
  |     |           | {longint 0}: longint notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%lls", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0419: type specifier cannot be combined with length specifier 's'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%lls'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%12d %12i %12u %12f %12e %12E %12g %12G %12x %12X %12o %12s", 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%12d %12i %12u %12f %12e %12E %12g %12G %12x %12X %12o %12s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {dbl 0.0}: real notnull
  |     |                     | {arg_list}
  |     |                       | {dbl 0.0}: real notnull
  |     |                       | {arg_list}
  |     |                         | {dbl 0.0}: real notnull
  |     |                         | {arg_list}
  |     |                           | {int 0}: integer notnull
  |     |                           | {arg_list}
  |     |                             | {int 0}: integer notnull
  |     |                             | {arg_list}
  |     |                               | {int 0}: integer notnull
  |     |                               | {arg_list}
  |     |                                 | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%*s %*f", 10, "hello", 20, 3.14);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%*s %*f'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 10}: integer notnull
  |     |           | {arg_list}
  |     |             | {strlit 'hello'}: text notnull
  |     |             | {arg_list}
  |     |               | {int 20}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 3.14}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%10*s", 10, "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0417: unrecognized type specifier '*'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%10*s'}: err
  |     |         | {arg_list}
  |     |           | {int 10}: integer notnull
  |     |           | {arg_list}
  |     |             | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%*10s", 10, "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0417: unrecognized type specifier '1'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%*10s'}: err
  |     |         | {arg_list}
  |     |           | {int 10}: integer notnull
  |     |           | {arg_list}
  |     |             | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%*", 10);

test/sem_test.sql:XXXX:1: error: in str : CQL0420: incomplete substitution in format string

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%*'}: err
  |     |         | {arg_list}
  |     |           | {int 10}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%.12d %.12i %.12u %.12f %.12e %.12E %.12g %.12G %.12x %.12X %.12o %.12s", 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%.12d %.12i %.12u %.12f %.12e %.12E %.12g %.12G %.12x %.12X %.12o %.12s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {dbl 0.0}: real notnull
  |     |                     | {arg_list}
  |     |                       | {dbl 0.0}: real notnull
  |     |                       | {arg_list}
  |     |                         | {dbl 0.0}: real notnull
  |     |                         | {arg_list}
  |     |                           | {int 0}: integer notnull
  |     |                           | {arg_list}
  |     |                             | {int 0}: integer notnull
  |     |                             | {arg_list}
  |     |                               | {int 0}: integer notnull
  |     |                               | {arg_list}
  |     |                                 | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%9.12d %9.12i %9.12u %9.12f %9.12e %9.12E %9.12g %9.12G %9.12x %9.12X %9.12o %9.12s", 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%9.12d %9.12i %9.12u %9.12f %9.12e %9.12E %9.12g %9.12G %9.12x %9.12X %9.12o %9.12s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {dbl 0.0}: real notnull
  |     |                     | {arg_list}
  |     |                       | {dbl 0.0}: real notnull
  |     |                       | {arg_list}
  |     |                         | {dbl 0.0}: real notnull
  |     |                         | {arg_list}
  |     |                           | {int 0}: integer notnull
  |     |                           | {arg_list}
  |     |                             | {int 0}: integer notnull
  |     |                             | {arg_list}
  |     |                               | {int 0}: integer notnull
  |     |                               | {arg_list}
  |     |                                 | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%-16d %-16i %-16u %-16f %-16e %-16E %-16g %-16G %-16x %-16X %-16o %-16s", 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%-16d %-16i %-16u %-16f %-16e %-16E %-16g %-16G %-16x %-16X %-16o %-16s'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0}: integer notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {dbl 0.0}: real notnull
  |     |                     | {arg_list}
  |     |                       | {dbl 0.0}: real notnull
  |     |                       | {arg_list}
  |     |                         | {dbl 0.0}: real notnull
  |     |                         | {arg_list}
  |     |                           | {int 0}: integer notnull
  |     |                           | {arg_list}
  |     |                             | {int 0}: integer notnull
  |     |                             | {arg_list}
  |     |                               | {int 0}: integer notnull
  |     |                               | {arg_list}
  |     |                                 | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%-s", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0413: width required when using flag in substitution '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%-s'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%--10s", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0411: duplicate flag in substitution '-'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%--10s'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%+d %+i", 42, -100);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%+d %+i'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     |           | {arg_list}
  |     |             | {uminus}: integer notnull
  |     |               | {int 100}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%+u", 42);

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 'u'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%+u'}: err
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("% d % i", 42, -100);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '% d % i'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     |           | {arg_list}
  |     |             | {uminus}: integer notnull
  |     |               | {int 100}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("% u", 42);

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 'u'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '% u'}: err
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%+ u", 42);

test/sem_test.sql:XXXX:1: error: in str : CQL0412: cannot combine '+' flag with space flag

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%+ u'}: err
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%!lld", 0);

test/sem_test.sql:XXXX:1: error: in str : CQL0415: length specifier cannot be combined with '!' flag

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%!lld'}: err
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%09d", 42);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%09d'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%09s", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 's'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%09s'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%0d", 42);

test/sem_test.sql:XXXX:1: error: in str : CQL0413: width required when using flag in substitution '0'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%0d'}: err
  |     |         | {arg_list}
  |     |           | {int 42}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%#g %#G %#o %#x %#X", 0.0, 0.0, 00, 0x0, 0x0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%#g %#G %#o %#x %#X'}: text notnull
  |     |         | {arg_list}
  |     |           | {dbl 0.0}: real notnull
  |     |           | {arg_list}
  |     |             | {dbl 0.0}: real notnull
  |     |             | {arg_list}
  |     |               | {int 00}: integer notnull
  |     |               | {arg_list}
  |     |                 | {int 0x0}: integer notnull
  |     |                 | {arg_list}
  |     |                   | {int 0x0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%#s", "hello");

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 's'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%#s'}: err
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%,d %,i", 0, 0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%,d %,i'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%,u", 0);

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 'u'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%,u'}: err
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%!f %!e %!E %!g %!G %!s", 0.0, 0.0, 0.0, 0.0, 0.0, "str");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%!f %!e %!E %!g %!G %!s'}: text notnull
  |     |         | {arg_list}
  |     |           | {dbl 0.0}: real notnull
  |     |           | {arg_list}
  |     |             | {dbl 0.0}: real notnull
  |     |             | {arg_list}
  |     |               | {dbl 0.0}: real notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     |                   | {arg_list}
  |     |                     | {strlit 'str'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%!d", 0);

test/sem_test.sql:XXXX:1: error: in str : CQL0418: type specifier combined with inappropriate flags 'd'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name printf}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%!d'}: err
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%-+0,10d %, 0-7lli", 0, 0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%-+0,10d %, 0-7lli'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%0-7llu %-042u", 0, 0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%0-7llu %-042u'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%-0#!8f %!#-016e %0!#-12E %!0#-24g %-0!#100G", 0.0, 0.0, 0.0, 0.0, 0.0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%-0#!8f %!#-016e %0!#-12E %!0#-24g %-0!#100G'}: text notnull
  |     |         | {arg_list}
  |     |           | {dbl 0.0}: real notnull
  |     |           | {arg_list}
  |     |             | {dbl 0.0}: real notnull
  |     |             | {arg_list}
  |     |               | {dbl 0.0}: real notnull
  |     |               | {arg_list}
  |     |                 | {dbl 0.0}: real notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%#0-32o %-#016x %0-#24X", 00, 0x0, 0x0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%#0-32o %-#016x %0-#24X'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 00}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 0x0}: integer notnull
  |     |             | {arg_list}
  |     |               | {int 0x0}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%-!8s %!-16s", "hello", "world");

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%-!8s %!-16s'}: text notnull
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     |           | {arg_list}
  |     |             | {strlit 'world'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT printf("%%s%%%-#123.0194llX%%%.241o.%!.32s% -0,14.234llds%#-!1.000E", 0x0, 00, "str", 0, 0.0);

  {select_stmt}: select: { _anon: text notnull }
  | {select_core_list}: select: { _anon: text notnull }
  | | {select_core}: select: { _anon: text notnull }
  |   | {select_expr_list_con}: select: { _anon: text notnull }
  |     | {select_expr_list}: select: { _anon: text notnull }
  |     | | {select_expr}: text notnull
  |     |   | {call}: text notnull
  |     |     | {name printf}: text notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '%%s%%%-#123.0194llX%%%.241o.%!.32s% -0,14.234llds%#-!1.000E'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0x0}: integer notnull
  |     |           | {arg_list}
  |     |             | {int 00}: integer notnull
  |     |             | {arg_list}
  |     |               | {strlit 'str'}: text notnull
  |     |               | {arg_list}
  |     |                 | {int 0}: integer notnull
  |     |                 | {arg_list}
  |     |                   | {dbl 0.0}: real notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT substr("123", 0, 2);

test/sem_test.sql:XXXX:1: error: in num : CQL0406: substr uses 1 based indices, the 2nd argument of substr may not be zero

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name substr}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {strlit '123'}: text notnull
  |     |         | {arg_list}
  |     |           | {int 0}: err
  |     |           | {arg_list}
  |     |             | {int 2}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET not_null_object_is_null := not_null_object IS NULL;

test/sem_test.sql:XXXX:1: error: in is : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type 'not_null_object'

  {let_stmt}: err
  | {name not_null_object_is_null}
  | {is}: err
    | {name not_null_object}: not_null_object: object notnull variable was_set
    | {null}: null

The statement ending at line XXXX

LET not_null_object_is_not_null := not_null_object IS NOT NULL;

test/sem_test.sql:XXXX:1: error: in is_not : CQL0409: cannot use IS NULL or IS NOT NULL on a value of a NOT NULL type 'not_null_object'

  {let_stmt}: err
  | {name not_null_object_is_not_null}
  | {is_not}: err
    | {name not_null_object}: not_null_object: object notnull variable was_set
    | {null}: null

The statement ending at line XXXX

CREATE PROC proc_inout_text (INOUT a TEXT)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name proc_inout_text}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: a: text variable in out
        | {inout}
        | {param_detail}: a: text variable in out
          | {name a}: a: text variable in out
          | {type_text}: text

The statement ending at line XXXX

LET dummy := proc_inout_text();

test/sem_test.sql:XXXX:1: error: in param : CQL0211: procedure without trailing OUT parameter used as function 'proc_inout_text'

  {let_stmt}: err
  | {name dummy}
  | {call}: err
    | {name proc_inout_text}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

CALL proc_inout_text(a_string);

  {call_stmt}: ok
  | {name proc_inout_text}: ok
  | {expr_list}: ok
    | {name a_string}: a_string: text variable was_set

The statement ending at line XXXX

CREATE PROC proc_inout_text_out_text (INOUT a TEXT, OUT b TEXT)
BEGIN
  SET b := NULL;
END;

  {create_proc_stmt}: ok
  | {name proc_inout_text_out_text}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text variable in out
    | | | {inout}
    | | | {param_detail}: a: text variable in out
    | |   | {name a}: a: text variable in out
    | |   | {type_text}: text
    | | {params}
    |   | {param}: b: text variable out was_set
    |     | {out}
    |     | {param_detail}: b: text variable out was_set
    |       | {name b}: b: text variable out was_set
    |       | {type_text}: text
    | {stmt_list}: ok
      | {assign}: b: text variable out was_set
        | {name b}: b: text variable out was_set
        | {null}: null

The statement ending at line XXXX

LET dummy := proc_inout_text_out_text(a_string);

test/sem_test.sql:XXXX:1: error: in call : CQL0424: procedure with INOUT parameter used as function 'proc_inout_text_out_text'

  {let_stmt}: err
  | {name dummy}
  | {call}: err
    | {name proc_inout_text_out_text}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name a_string}: a_string: text variable was_set

The statement ending at line XXXX

CALL proc_inout_text_out_text(a_string, a_string2);

  {call_stmt}: ok
  | {name proc_inout_text_out_text}: ok
  | {expr_list}: ok
    | {name a_string}: a_string: text variable was_set
    | {expr_list}
      | {name a_string2}: a_string2: text variable

The statement ending at line XXXX

CREATE PROC proc_out_text_out_text (OUT a TEXT, OUT b TEXT)
BEGIN
  SET a := NULL;
  SET b := NULL;
END;

  {create_proc_stmt}: ok
  | {name proc_out_text_out_text}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text variable out was_set
    | | | {out}
    | | | {param_detail}: a: text variable out was_set
    | |   | {name a}: a: text variable out was_set
    | |   | {type_text}: text
    | | {params}
    |   | {param}: b: text variable out was_set
    |     | {out}
    |     | {param_detail}: b: text variable out was_set
    |       | {name b}: b: text variable out was_set
    |       | {type_text}: text
    | {stmt_list}: ok
      | {assign}: a: text variable out was_set
      | | {name a}: a: text variable out was_set
      | | {null}: null
      | {assign}: b: text variable out was_set
        | {name b}: b: text variable out was_set
        | {null}: null

The statement ending at line XXXX

LET dummy := proc_out_text_out_text(a_string);

test/sem_test.sql:XXXX:1: error: in call : CQL0425: procedure with non-trailing OUT parameter used as function 'proc_out_text_out_text'

  {let_stmt}: err
  | {name dummy}
  | {call}: err
    | {name proc_out_text_out_text}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name a_string}: a_string: text variable was_set

The statement ending at line XXXX

CALL proc_out_text_out_text(a_string, a_string2);

  {call_stmt}: ok
  | {name proc_out_text_out_text}: ok
  | {expr_list}: ok
    | {name a_string}: a_string: text variable was_set
    | {expr_list}
      | {name a_string2}: a_string2: text variable was_set

The statement ending at line XXXX

CREATE PROC proc_out_text (OUT a TEXT)
BEGIN
  SET a := NULL;
END;

  {create_proc_stmt}: ok
  | {name proc_out_text}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text variable out was_set
    |   | {out}
    |   | {param_detail}: a: text variable out was_set
    |     | {name a}: a: text variable out was_set
    |     | {type_text}: text
    | {stmt_list}: ok
      | {assign}: a: text variable out was_set
        | {name a}: a: text variable out was_set
        | {null}: null

The statement ending at line XXXX

LET proc_out_text_result := proc_out_text();

  {let_stmt}: proc_out_text_result: text variable
  | {name proc_out_text_result}: proc_out_text_result: text variable
  | {call}: text
    | {name proc_out_text}
    | {call_arg_list}
      | {call_filter_clause}

The statement ending at line XXXX

CREATE PROC proc_in_text_in_text_out_text (a TEXT, b TEXT, OUT c TEXT)
BEGIN
  SET c := NULL;
END;

  {create_proc_stmt}: ok
  | {name proc_in_text_in_text_out_text}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a: text variable in
    | | | {param_detail}: a: text variable in
    | |   | {name a}: a: text variable in
    | |   | {type_text}: text
    | | {params}
    |   | {param}: b: text variable in
    |   | | {param_detail}: b: text variable in
    |   |   | {name b}: b: text variable in
    |   |   | {type_text}: text
    |   | {params}
    |     | {param}: c: text variable out was_set
    |       | {out}
    |       | {param_detail}: c: text variable out was_set
    |         | {name c}: c: text variable out was_set
    |         | {type_text}: text
    | {stmt_list}: ok
      | {assign}: c: text variable out was_set
        | {name c}: c: text variable out was_set
        | {null}: null

The statement ending at line XXXX

LET proc_in_text_in_text_out_text_result := proc_in_text_in_text_out_text("a", "b");

  {let_stmt}: proc_in_text_in_text_out_text_result: text variable
  | {name proc_in_text_in_text_out_text_result}: proc_in_text_in_text_out_text_result: text variable
  | {call}: text
    | {name proc_in_text_in_text_out_text}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'a'}: text notnull
        | {arg_list}
          | {strlit 'b'}: text notnull

The statement ending at line XXXX

DECLARE CONST GROUP foo (
  const_v = FALSE,
  const_w = 3.5,
  const_x = 1L,
  const_y = 2 + 3,
  const_z = "hello, world\n"
);

  {declare_const_stmt}: ok
  | {name foo}
  | {const_values}
    | {const_value}: bool = 0 notnull
    | | {name const_v}: bool = 0 notnull
    | | {bool 0}: bool = 0 notnull
    | {const_values}
      | {const_value}: real = 3.500000e+00 notnull
      | | {name const_w}: real = 3.500000e+00 notnull
      | | {dbl 3.5}: real = 3.500000e+00 notnull
      | {const_values}
        | {const_value}: longint = 1 notnull
        | | {name const_x}: longint = 1 notnull
        | | {longint 1}: longint = 1 notnull
        | {const_values}
          | {const_value}: integer = 5 notnull
          | | {name const_y}: integer = 5 notnull
          | | {add}: integer = 5 notnull
          |   | {int 2}: integer notnull
          |   | {int 3}: integer notnull
          | {const_values}
            | {const_value}: text notnull
              | {name const_z}: text notnull
              | {strlit 'hello, world
'}: text notnull

The statement ending at line XXXX

CREATE PROC use_global_constants ()
BEGIN
  LET v := FALSE;
  LET w := 3.500000e+00;
  LET x := 1L;
  LET y := 5;
  LET z := "hello, world\n";
END;

  {create_proc_stmt}: ok
  | {name use_global_constants}: ok
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {let_stmt}: v: bool notnull variable
      | | {name v}: v: bool notnull variable
      | | {bool 0}: bool notnull
      | {let_stmt}: w: real notnull variable
      | | {name w}: w: real notnull variable
      | | {dbl 3.500000e+00}: real notnull
      | {let_stmt}: x: longint notnull variable
      | | {name x}: x: longint notnull variable
      | | {longint 1}: longint notnull
      | {let_stmt}: y: integer notnull variable
      | | {name y}: y: integer notnull variable
      | | {int 5}: integer notnull
      | {let_stmt}: z: text notnull variable
        | {name z}: z: text notnull variable
        | {strlit 'hello, world
'}: text notnull

The statement ending at line XXXX

DECLARE CONST GROUP err1 (
  const_err1 = NOT 'x'
);

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {declare_const_stmt}: err
  | {name err1}
  | {const_values}
    | {const_value}
      | {name const_err1}
      | {not}: err
        | {strlit 'x'}: text notnull

The statement ending at line XXXX

DECLARE CONST GROUP err2 (
  const_err2 = 1 / 0
);

test/sem_test.sql:XXXX:1: error: in div : CQL0177: global constants must be either constant numeric expressions or string literals 'const_err2 = 1 / 0'

  {declare_const_stmt}: err
  | {name err2}
  | {const_values}
    | {const_value}
      | {name const_err2}
      | {div}: err
        | {int 1}: integer notnull
        | {int 0}: integer notnull

The statement ending at line XXXX

DECLARE CONST GROUP err3 (
  const_err3 = printf("bar")
);

test/sem_test.sql:XXXX:1: error: in call : CQL0177: global constants must be either constant numeric expressions or string literals 'const_err3 = printf("bar")'

  {declare_const_stmt}: err
  | {name err3}
  | {const_values}
    | {const_value}
      | {name const_err3}
      | {call}: err
        | {name printf}: text notnull
        | {call_arg_list}
          | {call_filter_clause}
          | {arg_list}: ok
            | {strlit 'bar'}: text notnull

The statement ending at line XXXX

DECLARE CONST GROUP err4 (
  const_v = FALSE
);

test/sem_test.sql:XXXX:1: error: in const_value : CQL0354: duplicate constant name 'const_v'

  {declare_const_stmt}: err
  | {name err4}
  | {const_values}
    | {const_value}
      | {name const_v}
      | {bool 0}

The statement ending at line XXXX

DECLARE CONST GROUP foo (
  const_v = FALSE
);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_const_stmt : DECLARE CONST GROUP foo (
  const_v = FALSE
)
test/sem_test.sql:XXXX:1: error: in declare_const_stmt : DECLARE CONST GROUP foo (
  const_v = FALSE,
  const_w = 3.5,
  const_x = 1L,
  const_y = 2 + 3,
  const_z = "hello, world\n"
)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_const_stmt : CQL0356: const definitions do not match 'foo'

  {declare_const_stmt}: err
  | {name foo}
  | {const_values}
    | {const_value}: bool = 0 notnull
      | {name const_v}: bool = 0 notnull
      | {bool 0}: bool = 0 notnull

The statement ending at line XXXX

CREATE PROC try_to_nest_constants ()
BEGIN
  DECLARE CONST GROUP err5 (
    err5 = 1
  );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0358: declared constants must be top level 'err5'

  {create_proc_stmt}: err
  | {name try_to_nest_constants}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_const_stmt}: err
        | {name err5}
        | {const_values}
          | {const_value}
            | {name err5}
            | {int 1}

The statement ending at line XXXX

@EMIT_CONSTANTS foo;

  {emit_constants_stmt}: ok
  | {name_list}
    | {name foo}

The statement ending at line XXXX

@EMIT_CONSTANTS not_found;

test/sem_test.sql:XXXX:1: error: in str : CQL0169: constant group not found 'not_found'

  {emit_constants_stmt}: err
  | {name_list}
    | {name not_found}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC conditional_frag (bb INTEGER NOT NULL)
BEGIN
  IF bb = 1 THEN
    WITH
    source (id) LIKE foo
    SELECT *
      FROM source;
  ELSE IF bb = 2 THEN
    WITH
    source2 (id) LIKE foo
    SELECT *
      FROM source2
      WHERE x <> bb;
  ELSE
    WITH
    source (id) LIKE foo
    SELECT *
      FROM source
      WHERE x = bb;
  END IF;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: conditional_frag: { id: integer notnull } dml_proc
    | {name conditional_frag}: conditional_frag: { id: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: bb: integer notnull variable in
      |   | {param_detail}: bb: integer notnull variable in
      |     | {name bb}: bb: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {if_stmt}: bool notnull
          | {cond_action}: bool notnull
          | | {eq}: bool notnull
          | | | {name bb}: bb: integer notnull variable in
          | | | {int 1}: integer notnull
          | | {stmt_list}: ok
          |   | {with_select_stmt}: select: { id: integer notnull }
          |     | {with}
          |     | | {cte_tables}: ok
          |     |   | {cte_table}: source: { id: integer notnull }
          |     |     | {cte_decl}: source: { id: integer notnull }
          |     |     | | {name source}
          |     |     | | {name_list}
          |     |     |   | {name id}
          |     |     | {like}: ok
          |     |       | {name foo}
          |     | {select_stmt}: select: { id: integer notnull }
          |       | {select_core_list}: select: { id: integer notnull }
          |       | | {select_core}: select: { id: integer notnull }
          |       |   | {select_expr_list_con}: select: { id: integer notnull }
          |       |     | {select_expr_list}: select: { id: integer notnull }
          |       |     | | {star}: select: { id: integer notnull }
          |       |     | {select_from_etc}: TABLE { source: source }
          |       |       | {table_or_subquery_list}: TABLE { source: source }
          |       |       | | {table_or_subquery}: TABLE { source: source }
          |       |       |   | {name source}: TABLE { source: source }
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {if_alt}: ok
            | {elseif}: bool notnull
            | | {cond_action}: bool notnull
            |   | {eq}: bool notnull
            |   | | {name bb}: bb: integer notnull variable in
            |   | | {int 2}: integer notnull
            |   | {stmt_list}: ok
            |     | {with_select_stmt}: select: { id: integer notnull }
            |       | {with}
            |       | | {cte_tables}: ok
            |       |   | {cte_table}: source2: { id: integer notnull }
            |       |     | {cte_decl}: source2: { id: integer notnull }
            |       |     | | {name source2}
            |       |     | | {name_list}
            |       |     |   | {name id}
            |       |     | {like}: ok
            |       |       | {name foo}
            |       | {select_stmt}: select: { id: integer notnull }
            |         | {select_core_list}: select: { id: integer notnull }
            |         | | {select_core}: select: { id: integer notnull }
            |         |   | {select_expr_list_con}: select: { id: integer notnull }
            |         |     | {select_expr_list}: select: { id: integer notnull }
            |         |     | | {star}: select: { id: integer notnull }
            |         |     | {select_from_etc}: TABLE { source2: source2 }
            |         |       | {table_or_subquery_list}: TABLE { source2: source2 }
            |         |       | | {table_or_subquery}: TABLE { source2: source2 }
            |         |       |   | {name source2}: TABLE { source2: source2 }
            |         |       | {select_where}
            |         |         | {opt_where}: bool
            |         |         | | {ne}: bool
            |         |         |   | {name x}: X: integer variable was_set
            |         |         |   | {name bb}: bb: integer notnull variable in
            |         |         | {select_groupby}
            |         |           | {select_having}
            |         | {select_orderby}
            |           | {select_limit}
            |             | {select_offset}
            | {else}: ok
              | {stmt_list}: ok
                | {with_select_stmt}: select: { id: integer notnull }
                  | {with}
                  | | {cte_tables}: ok
                  |   | {cte_table}: source: { id: integer notnull }
                  |     | {cte_decl}: source: { id: integer notnull }
                  |     | | {name source}
                  |     | | {name_list}
                  |     |   | {name id}
                  |     | {like}: ok
                  |       | {name foo}
                  | {select_stmt}: select: { id: integer notnull }
                    | {select_core_list}: select: { id: integer notnull }
                    | | {select_core}: select: { id: integer notnull }
                    |   | {select_expr_list_con}: select: { id: integer notnull }
                    |     | {select_expr_list}: select: { id: integer notnull }
                    |     | | {star}: select: { id: integer notnull }
                    |     | {select_from_etc}: TABLE { source: source }
                    |       | {table_or_subquery_list}: TABLE { source: source }
                    |       | | {table_or_subquery}: TABLE { source: source }
                    |       |   | {name source}: TABLE { source: source }
                    |       | {select_where}
                    |         | {opt_where}: bool
                    |         | | {eq}: bool
                    |         |   | {name x}: X: integer variable was_set
                    |         |   | {name bb}: bb: integer notnull variable in
                    |         | {select_groupby}
                    |           | {select_having}
                    | {select_orderby}
                      | {select_limit}
                        | {select_offset}

The statement ending at line XXXX

CREATE PROC conditional_user (xx INTEGER NOT NULL)
BEGIN
  WITH
  D (id) AS (CALL conditional_frag(1) USING foo AS source, foo AS source2)
  SELECT *
    FROM D;
END;

  {create_proc_stmt}: conditional_user: { id: integer notnull } dml_proc
  | {name conditional_user}: conditional_user: { id: integer notnull } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: xx: integer notnull variable in
    |   | {param_detail}: xx: integer notnull variable in
    |     | {name xx}: xx: integer notnull variable in
    |     | {notnull}: integer notnull
    |       | {type_int}: integer
    | {stmt_list}: ok
      | {with_select_stmt}: select: { id: integer notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: D: { id: integer notnull }
        |     | {cte_decl}: D: { id: integer notnull }
        |     | | {name D}
        |     | | {name_list}
        |     |   | {name id}
        |     | {shared_cte}: conditional_frag: { id: integer notnull } dml_proc
        |       | {call_stmt}: conditional_frag: { id: integer notnull } dml_proc
        |       | | {name conditional_frag}: conditional_frag: { id: integer notnull } dml_proc
        |       | | {expr_list}: ok
        |       |   | {int 1}: integer notnull
        |       | {cte_binding_list}
        |         | {cte_binding}
        |         | | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |         | | {name source}: source: { id: integer notnull }
        |         | {cte_binding_list}
        |           | {cte_binding}
        |             | {name foo}: foo: { id: integer notnull primary_key autoinc }
        |             | {name source2}: source2: { id: integer notnull }
        | {select_stmt}: select: { id: integer notnull }
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {star}: select: { id: integer notnull }
          |     | {select_from_etc}: TABLE { D: D }
          |       | {table_or_subquery_list}: TABLE { D: D }
          |       | | {table_or_subquery}: TABLE { D: D }
          |       |   | {name D}: TABLE { D: D }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_0_0 ()
BEGIN
  WITH
  source (x) LIKE (SELECT 1 AS x),
  possible_conflict (x) AS (SELECT *
    FROM source)
  SELECT *
    FROM possible_conflict;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_0_0: { x: integer notnull } dml_proc
    | {name fragtest_0_0}: fragtest_0_0: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull }
          |   | | {cte_decl}: source: { x: integer notnull }
          |   | | | {name source}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {like}
          |   |   | {select_stmt}: select: { x: integer notnull }
          |   |     | {select_core_list}: select: { x: integer notnull }
          |   |     | | {select_core}: select: { x: integer notnull }
          |   |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |     |     | {select_expr_list}: select: { x: integer notnull }
          |   |     |     | | {select_expr}: x: integer notnull
          |   |     |     |   | {int 1}: integer notnull
          |   |     |     |   | {opt_as_alias}
          |   |     |     |     | {name x}
          |   |     |     | {select_from_etc}: ok
          |   |     |       | {select_where}
          |   |     |         | {select_groupby}
          |   |     |           | {select_having}
          |   |     | {select_orderby}
          |   |       | {select_limit}
          |   |         | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: possible_conflict: { x: integer notnull }
          |       | {cte_decl}: possible_conflict: { x: integer notnull }
          |       | | {name possible_conflict}
          |       | | {name_list}
          |       |   | {name x}
          |       | {select_stmt}: select: { x: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull }
          |         | | {select_core}: select: { x: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull }
          |         |     | | {star}: select: { x: integer notnull }
          |         |     | {select_from_etc}: TABLE { source: source }
          |         |       | {table_or_subquery_list}: TABLE { source: source }
          |         |       | | {table_or_subquery}: TABLE { source: source }
          |         |       |   | {name source}: TABLE { source: source }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { possible_conflict: possible_conflict }
            |       | {table_or_subquery_list}: TABLE { possible_conflict: possible_conflict }
            |       | | {table_or_subquery}: TABLE { possible_conflict: possible_conflict }
            |       |   | {name possible_conflict}: TABLE { possible_conflict: possible_conflict }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_0_1 ()
BEGIN
  WITH
  source (x) LIKE (SELECT 1 AS x),
  fragtest_0_0 (x) AS (CALL fragtest_0_0() USING source AS source)
  SELECT *
    FROM fragtest_0_0;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_0_1: { x: integer notnull } dml_proc
    | {name fragtest_0_1}: fragtest_0_1: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull }
          |   | | {cte_decl}: source: { x: integer notnull }
          |   | | | {name source}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {like}
          |   |   | {select_stmt}: select: { x: integer notnull }
          |   |     | {select_core_list}: select: { x: integer notnull }
          |   |     | | {select_core}: select: { x: integer notnull }
          |   |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |     |     | {select_expr_list}: select: { x: integer notnull }
          |   |     |     | | {select_expr}: x: integer notnull
          |   |     |     |   | {int 1}: integer notnull
          |   |     |     |   | {opt_as_alias}
          |   |     |     |     | {name x}
          |   |     |     | {select_from_etc}: ok
          |   |     |       | {select_where}
          |   |     |         | {select_groupby}
          |   |     |           | {select_having}
          |   |     | {select_orderby}
          |   |       | {select_limit}
          |   |         | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: fragtest_0_0: { x: integer notnull }
          |       | {cte_decl}: fragtest_0_0: { x: integer notnull }
          |       | | {name fragtest_0_0}: fragtest_0_0: { x: integer notnull } dml_proc
          |       | | {name_list}
          |       |   | {name x}
          |       | {shared_cte}: fragtest_0_0: { x: integer notnull } dml_proc
          |         | {call_stmt}: fragtest_0_0: { x: integer notnull } dml_proc
          |         | | {name fragtest_0_0}: fragtest_0_0: { x: integer notnull } dml_proc
          |         | {cte_binding_list}
          |           | {cte_binding}
          |             | {name source}: source: { x: integer notnull }
          |             | {name source}: source: { x: integer notnull }
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { fragtest_0_0: fragtest_0_0 }
            |       | {table_or_subquery_list}: TABLE { fragtest_0_0: fragtest_0_0 }
            |       | | {table_or_subquery}: TABLE { fragtest_0_0: fragtest_0_0 }
            |       |   | {name fragtest_0_0}: TABLE { fragtest_0_0: fragtest_0_0 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_0_2 ()
BEGIN
  WITH
  source (x) LIKE (SELECT 1 AS x),
  fragtest_0_1 (x) AS (CALL fragtest_0_1() USING source AS source)
  SELECT *
    FROM fragtest_0_1;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_0_2: { x: integer notnull } dml_proc
    | {name fragtest_0_2}: fragtest_0_2: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull }
          |   | | {cte_decl}: source: { x: integer notnull }
          |   | | | {name source}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {like}
          |   |   | {select_stmt}: select: { x: integer notnull }
          |   |     | {select_core_list}: select: { x: integer notnull }
          |   |     | | {select_core}: select: { x: integer notnull }
          |   |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |     |     | {select_expr_list}: select: { x: integer notnull }
          |   |     |     | | {select_expr}: x: integer notnull
          |   |     |     |   | {int 1}: integer notnull
          |   |     |     |   | {opt_as_alias}
          |   |     |     |     | {name x}
          |   |     |     | {select_from_etc}: ok
          |   |     |       | {select_where}
          |   |     |         | {select_groupby}
          |   |     |           | {select_having}
          |   |     | {select_orderby}
          |   |       | {select_limit}
          |   |         | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: fragtest_0_1: { x: integer notnull }
          |       | {cte_decl}: fragtest_0_1: { x: integer notnull }
          |       | | {name fragtest_0_1}: fragtest_0_1: { x: integer notnull } dml_proc
          |       | | {name_list}
          |       |   | {name x}
          |       | {shared_cte}: fragtest_0_1: { x: integer notnull } dml_proc
          |         | {call_stmt}: fragtest_0_1: { x: integer notnull } dml_proc
          |         | | {name fragtest_0_1}: fragtest_0_1: { x: integer notnull } dml_proc
          |         | {cte_binding_list}
          |           | {cte_binding}
          |             | {name source}: source: { x: integer notnull }
          |             | {name source}: source: { x: integer notnull }
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { fragtest_0_1: fragtest_0_1 }
            |       | {table_or_subquery_list}: TABLE { fragtest_0_1: fragtest_0_1 }
            |       | | {table_or_subquery}: TABLE { fragtest_0_1: fragtest_0_1 }
            |       |   | {name fragtest_0_1}: TABLE { fragtest_0_1: fragtest_0_1 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

WITH
possible_conflict (x) AS (SELECT 1 AS x)
SELECT *
  FROM (CALL fragtest_0_2() USING possible_conflict AS source);

test/sem_test.sql:XXXX:1: error: in cte_binding : CQL0444: this use of the named shared fragment is not legal because of a name conflict 'fragtest_0_2'
Procedure 'fragtest_0_0' has a different CTE that is also named 'possible_conflict'
The above originated from CALL fragtest_0_0 USING possible_conflict AS source
The above originated from CALL fragtest_0_1 USING possible_conflict AS source
The above originated from CALL fragtest_0_2 USING possible_conflict AS source


  {with_select_stmt}: err
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: possible_conflict: { x: integer notnull }
  |     | {cte_decl}: possible_conflict: { x: integer notnull }
  |     | | {name possible_conflict}
  |     | | {name_list}
  |     |   | {name x}
  |     | {select_stmt}: select: { x: integer notnull }
  |       | {select_core_list}: select: { x: integer notnull }
  |       | | {select_core}: select: { x: integer notnull }
  |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |       |     | {select_expr_list}: select: { x: integer notnull }
  |       |     | | {select_expr}: x: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     |   | {opt_as_alias}
  |       |     |     | {name x}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {star}
    |     | {select_from_etc}: err
    |       | {table_or_subquery_list}: err
    |       | | {table_or_subquery}: err
    |       |   | {shared_cte}: err
    |       |     | {call_stmt}: err
    |       |     | | {name fragtest_0_2}: fragtest_0_2: { x: integer notnull } dml_proc
    |       |     | {cte_binding_list}
    |       |       | {cte_binding}
    |       |         | {name possible_conflict}: possible_conflict: { x: integer notnull }
    |       |         | {name source}: source: { x: integer notnull }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

WITH
source (x) AS (SELECT 1 AS x)
SELECT *
  FROM (CALL fragtest_0_2() USING source AS source);

  {with_select_stmt}: select: { x: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: source: { x: integer notnull }
  |     | {cte_decl}: source: { x: integer notnull }
  |     | | {name source}
  |     | | {name_list}
  |     |   | {name x}
  |     | {select_stmt}: select: { x: integer notnull }
  |       | {select_core_list}: select: { x: integer notnull }
  |       | | {select_core}: select: { x: integer notnull }
  |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |       |     | {select_expr_list}: select: { x: integer notnull }
  |       |     | | {select_expr}: x: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     |   | {opt_as_alias}
  |       |     |     | {name x}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { x: integer notnull }
    | {select_core_list}: select: { x: integer notnull }
    | | {select_core}: select: { x: integer notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull }
    |     | {select_expr_list}: select: { x: integer notnull }
    |     | | {star}: select: { x: integer notnull }
    |     | {select_from_etc}: TABLE { fragtest_0_2: fragtest_0_2 }
    |       | {table_or_subquery_list}: TABLE { fragtest_0_2: fragtest_0_2 }
    |       | | {table_or_subquery}: TABLE { fragtest_0_2: fragtest_0_2 }
    |       |   | {shared_cte}: fragtest_0_2: { x: integer notnull } dml_proc
    |       |     | {call_stmt}: fragtest_0_2: { x: integer notnull } dml_proc
    |       |     | | {name fragtest_0_2}: fragtest_0_2: { x: integer notnull } dml_proc
    |       |     | {cte_binding_list}
    |       |       | {cte_binding}
    |       |         | {name source}: source: { x: integer notnull }
    |       |         | {name source}: source: { x: integer notnull }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_1_0 ()
BEGIN
  WITH
  source (x) LIKE (SELECT 1 AS x),
  possible_conflict (x) AS (SELECT *
    FROM source)
  SELECT *
    FROM possible_conflict;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_1_0: { x: integer notnull } dml_proc
    | {name fragtest_1_0}: fragtest_1_0: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull }
          |   | | {cte_decl}: source: { x: integer notnull }
          |   | | | {name source}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {like}
          |   |   | {select_stmt}: select: { x: integer notnull }
          |   |     | {select_core_list}: select: { x: integer notnull }
          |   |     | | {select_core}: select: { x: integer notnull }
          |   |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |     |     | {select_expr_list}: select: { x: integer notnull }
          |   |     |     | | {select_expr}: x: integer notnull
          |   |     |     |   | {int 1}: integer notnull
          |   |     |     |   | {opt_as_alias}
          |   |     |     |     | {name x}
          |   |     |     | {select_from_etc}: ok
          |   |     |       | {select_where}
          |   |     |         | {select_groupby}
          |   |     |           | {select_having}
          |   |     | {select_orderby}
          |   |       | {select_limit}
          |   |         | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: possible_conflict: { x: integer notnull }
          |       | {cte_decl}: possible_conflict: { x: integer notnull }
          |       | | {name possible_conflict}
          |       | | {name_list}
          |       |   | {name x}
          |       | {select_stmt}: select: { x: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull }
          |         | | {select_core}: select: { x: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull }
          |         |     | | {star}: select: { x: integer notnull }
          |         |     | {select_from_etc}: TABLE { source: source }
          |         |       | {table_or_subquery_list}: TABLE { source: source }
          |         |       | | {table_or_subquery}: TABLE { source: source }
          |         |       |   | {name source}: TABLE { source: source }
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { possible_conflict: possible_conflict }
            |       | {table_or_subquery_list}: TABLE { possible_conflict: possible_conflict }
            |       | | {table_or_subquery}: TABLE { possible_conflict: possible_conflict }
            |       |   | {name possible_conflict}: TABLE { possible_conflict: possible_conflict }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_1_1 ()
BEGIN
  WITH
  possible_conflict (x) AS (SELECT 1 AS x),
  fragtest_1_0 (*) AS (CALL fragtest_1_0() USING possible_conflict AS source)
  SELECT *
    FROM fragtest_1_0;
END;

test/sem_test.sql:XXXX:1: error: in cte_binding : CQL0444: this use of the named shared fragment is not legal because of a name conflict 'fragtest_1_0'
Procedure 'fragtest_1_0' has a different CTE that is also named 'possible_conflict'
The above originated from CALL fragtest_1_0 USING possible_conflict AS source


  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name fragtest_1_1}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {with_select_stmt}: err
          | {with}
          | | {cte_tables}: err
          |   | {cte_table}: possible_conflict: { x: integer notnull }
          |   | | {cte_decl}: possible_conflict: { x: integer notnull }
          |   | | | {name possible_conflict}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {select_stmt}: select: { x: integer notnull }
          |   |   | {select_core_list}: select: { x: integer notnull }
          |   |   | | {select_core}: select: { x: integer notnull }
          |   |   |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |   |     | {select_expr_list}: select: { x: integer notnull }
          |   |   |     | | {select_expr}: x: integer notnull
          |   |   |     |   | {int 1}: integer notnull
          |   |   |     |   | {opt_as_alias}
          |   |   |     |     | {name x}
          |   |   |     | {select_from_etc}: ok
          |   |   |       | {select_where}
          |   |   |         | {select_groupby}
          |   |   |           | {select_having}
          |   |   | {select_orderby}
          |   |     | {select_limit}
          |   |       | {select_offset}
          |   | {cte_tables}: err
          |     | {cte_table}: err
          |       | {cte_decl}
          |       | | {name fragtest_1_0}: fragtest_1_0: { x: integer notnull } dml_proc
          |       | | {star}
          |       | {shared_cte}: err
          |         | {call_stmt}: err
          |         | | {name fragtest_1_0}: fragtest_1_0: { x: integer notnull } dml_proc
          |         | {cte_binding_list}
          |           | {cte_binding}
          |             | {name possible_conflict}: possible_conflict: { x: integer notnull }
          |             | {name source}: source: { x: integer notnull }
          | {select_stmt}
            | {select_core_list}
            | | {select_core}
            |   | {select_expr_list_con}
            |     | {select_expr_list}
            |     | | {star}
            |     | {select_from_etc}
            |       | {table_or_subquery_list}
            |       | | {table_or_subquery}
            |       |   | {name fragtest_1_0}
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_2_0 ()
BEGIN
  WITH
  possible_conflict (x) AS (SELECT 1 AS x)
  SELECT *
    FROM possible_conflict;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_2_0: { x: integer notnull } dml_proc
    | {name fragtest_2_0}: fragtest_2_0: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: possible_conflict: { x: integer notnull }
          |     | {cte_decl}: possible_conflict: { x: integer notnull }
          |     | | {name possible_conflict}
          |     | | {name_list}
          |     |   | {name x}
          |     | {select_stmt}: select: { x: integer notnull }
          |       | {select_core_list}: select: { x: integer notnull }
          |       | | {select_core}: select: { x: integer notnull }
          |       |   | {select_expr_list_con}: select: { x: integer notnull }
          |       |     | {select_expr_list}: select: { x: integer notnull }
          |       |     | | {select_expr}: x: integer notnull
          |       |     |   | {int 1}: integer notnull
          |       |     |   | {opt_as_alias}
          |       |     |     | {name x}
          |       |     | {select_from_etc}: ok
          |       |       | {select_where}
          |       |         | {select_groupby}
          |       |           | {select_having}
          |       | {select_orderby}
          |         | {select_limit}
          |           | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { possible_conflict: possible_conflict }
            |       | {table_or_subquery_list}: TABLE { possible_conflict: possible_conflict }
            |       | | {table_or_subquery}: TABLE { possible_conflict: possible_conflict }
            |       |   | {name possible_conflict}: TABLE { possible_conflict: possible_conflict }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC fragtest_2_1 ()
BEGIN
  WITH
  source (x) LIKE (SELECT 1 AS x),
  fragtest_2_0 (x) AS (CALL fragtest_2_0())
  SELECT source.x
    FROM source
    INNER JOIN fragtest_2_0;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: fragtest_2_1: { x: integer notnull } dml_proc
    | {name fragtest_2_1}: fragtest_2_1: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: source: { x: integer notnull }
          |   | | {cte_decl}: source: { x: integer notnull }
          |   | | | {name source}
          |   | | | {name_list}
          |   | |   | {name x}
          |   | | {like}
          |   |   | {select_stmt}: select: { x: integer notnull }
          |   |     | {select_core_list}: select: { x: integer notnull }
          |   |     | | {select_core}: select: { x: integer notnull }
          |   |     |   | {select_expr_list_con}: select: { x: integer notnull }
          |   |     |     | {select_expr_list}: select: { x: integer notnull }
          |   |     |     | | {select_expr}: x: integer notnull
          |   |     |     |   | {int 1}: integer notnull
          |   |     |     |   | {opt_as_alias}
          |   |     |     |     | {name x}
          |   |     |     | {select_from_etc}: ok
          |   |     |       | {select_where}
          |   |     |         | {select_groupby}
          |   |     |           | {select_having}
          |   |     | {select_orderby}
          |   |       | {select_limit}
          |   |         | {select_offset}
          |   | {cte_tables}
          |     | {cte_table}: fragtest_2_0: { x: integer notnull }
          |       | {cte_decl}: fragtest_2_0: { x: integer notnull }
          |       | | {name fragtest_2_0}: fragtest_2_0: { x: integer notnull } dml_proc
          |       | | {name_list}
          |       |   | {name x}
          |       | {shared_cte}: fragtest_2_0: { x: integer notnull } dml_proc
          |         | {call_stmt}: fragtest_2_0: { x: integer notnull } dml_proc
          |           | {name fragtest_2_0}: fragtest_2_0: { x: integer notnull } dml_proc
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {select_expr}: x: integer notnull
            |     |   | {dot}: x: integer notnull
            |     |     | {name source}
            |     |     | {name x}
            |     | {select_from_etc}: JOIN { source: source, fragtest_2_0: fragtest_2_0 }
            |       | {join_clause}: JOIN { source: source, fragtest_2_0: fragtest_2_0 }
            |       | | {table_or_subquery}: TABLE { source: source }
            |       | | | {name source}: TABLE { source: source }
            |       | | {join_target_list}
            |       |   | {join_target}: JOIN { source: source, fragtest_2_0: fragtest_2_0 }
            |       |     | {int 1} {join_inner}
            |       |     | {table_join}
            |       |       | {table_or_subquery}: TABLE { fragtest_2_0: fragtest_2_0 }
            |       |         | {name fragtest_2_0}: TABLE { fragtest_2_0: fragtest_2_0 }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

WITH
possible_conflict (x) AS (SELECT 1 AS x)
SELECT *
  FROM (CALL fragtest_2_1() USING possible_conflict AS source);

  {with_select_stmt}: select: { x: integer notnull }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: possible_conflict: { x: integer notnull }
  |     | {cte_decl}: possible_conflict: { x: integer notnull }
  |     | | {name possible_conflict}
  |     | | {name_list}
  |     |   | {name x}
  |     | {select_stmt}: select: { x: integer notnull }
  |       | {select_core_list}: select: { x: integer notnull }
  |       | | {select_core}: select: { x: integer notnull }
  |       |   | {select_expr_list_con}: select: { x: integer notnull }
  |       |     | {select_expr_list}: select: { x: integer notnull }
  |       |     | | {select_expr}: x: integer notnull
  |       |     |   | {int 1}: integer notnull
  |       |     |   | {opt_as_alias}
  |       |     |     | {name x}
  |       |     | {select_from_etc}: ok
  |       |       | {select_where}
  |       |         | {select_groupby}
  |       |           | {select_having}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {select_stmt}: select: { x: integer notnull }
    | {select_core_list}: select: { x: integer notnull }
    | | {select_core}: select: { x: integer notnull }
    |   | {select_expr_list_con}: select: { x: integer notnull }
    |     | {select_expr_list}: select: { x: integer notnull }
    |     | | {star}: select: { x: integer notnull }
    |     | {select_from_etc}: TABLE { fragtest_2_1: fragtest_2_1 }
    |       | {table_or_subquery_list}: TABLE { fragtest_2_1: fragtest_2_1 }
    |       | | {table_or_subquery}: TABLE { fragtest_2_1: fragtest_2_1 }
    |       |   | {shared_cte}: fragtest_2_1: { x: integer notnull } dml_proc
    |       |     | {call_stmt}: fragtest_2_1: { x: integer notnull } dml_proc
    |       |     | | {name fragtest_2_1}: fragtest_2_1: { x: integer notnull } dml_proc
    |       |     | {cte_binding_list}
    |       |       | {cte_binding}
    |       |         | {name possible_conflict}: possible_conflict: { x: integer notnull }
    |       |         | {name source}: source: { x: integer notnull }
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC frag_not_really_a_conflict ()
BEGIN
  WITH
  possible_conflict (x) LIKE (SELECT 1 AS x)
  SELECT *
    FROM (CALL fragtest_1_0() USING possible_conflict AS source);
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: frag_not_really_a_conflict: { x: integer notnull } dml_proc
    | {name frag_not_really_a_conflict}: frag_not_really_a_conflict: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {with_select_stmt}: select: { x: integer notnull }
          | {with}
          | | {cte_tables}: ok
          |   | {cte_table}: possible_conflict: { x: integer notnull }
          |     | {cte_decl}: possible_conflict: { x: integer notnull }
          |     | | {name possible_conflict}
          |     | | {name_list}
          |     |   | {name x}
          |     | {like}
          |       | {select_stmt}: select: { x: integer notnull }
          |         | {select_core_list}: select: { x: integer notnull }
          |         | | {select_core}: select: { x: integer notnull }
          |         |   | {select_expr_list_con}: select: { x: integer notnull }
          |         |     | {select_expr_list}: select: { x: integer notnull }
          |         |     | | {select_expr}: x: integer notnull
          |         |     |   | {int 1}: integer notnull
          |         |     |   | {opt_as_alias}
          |         |     |     | {name x}
          |         |     | {select_from_etc}: ok
          |         |       | {select_where}
          |         |         | {select_groupby}
          |         |           | {select_having}
          |         | {select_orderby}
          |           | {select_limit}
          |             | {select_offset}
          | {select_stmt}: select: { x: integer notnull }
            | {select_core_list}: select: { x: integer notnull }
            | | {select_core}: select: { x: integer notnull }
            |   | {select_expr_list_con}: select: { x: integer notnull }
            |     | {select_expr_list}: select: { x: integer notnull }
            |     | | {star}: select: { x: integer notnull }
            |     | {select_from_etc}: TABLE { fragtest_1_0: fragtest_1_0 }
            |       | {table_or_subquery_list}: TABLE { fragtest_1_0: fragtest_1_0 }
            |       | | {table_or_subquery}: TABLE { fragtest_1_0: fragtest_1_0 }
            |       |   | {shared_cte}: fragtest_1_0: { x: integer notnull } dml_proc
            |       |     | {call_stmt}: fragtest_1_0: { x: integer notnull } dml_proc
            |       |     | | {name fragtest_1_0}: fragtest_1_0: { x: integer notnull } dml_proc
            |       |     | {cte_binding_list}
            |       |       | {cte_binding}
            |       |         | {name possible_conflict}: possible_conflict: { x: integer notnull }
            |       |         | {name source}: source: { x: integer notnull }
            |       | {select_where}
            |         | {select_groupby}
            |           | {select_having}
            | {select_orderby}
              | {select_limit}
                | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:doc_comment="/** This is a doc comment */")
CREATE PROC doc_comment_proc ()
BEGIN
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name doc_comment}
  |   | {strlit '/** This is a doc comment */'}: ok
  | {create_proc_stmt}: ok
    | {name doc_comment_proc}: ok
    | {proc_params_stmts}

The statement ending at line XXXX

CREATE VIRTUAL TABLE @EPONYMOUS epon USING epon AS (
  id INTEGER @SENSITIVE,
  t TEXT
);

  {create_virtual_table_stmt}: epon: { id: integer sensitive, t: text } virtual @recreate
  | {module_info}
  | | {name epon}
  | {create_table_stmt}: epon: { id: integer sensitive, t: text } virtual @recreate
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 4}
    | | | {recreate_attr}
    | | {name epon}
    | {col_key_list}
      | {col_def}: id: integer sensitive
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {sensitive_attr}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

CREATE VIRTUAL TABLE @EPONYMOUS epony USING epono AS (
  id INTEGER @SENSITIVE,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_virtual_table_stmt : CQL0447: virtual table 'epony' claims to be eponymous but its module name 'epono' differs from its table name

  {create_virtual_table_stmt}: err
  | {module_info}
  | | {name epono}
  | {create_table_stmt}
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 4}
    | | | {recreate_attr}
    | | {name epony}
    | {col_key_list}
      | {col_def}
      | | {col_def_type_attrs}
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}
      |   | {sensitive_attr}
      | {col_key_list}
        | {col_def}
          | {col_def_type_attrs}
            | {col_def_name_type}
              | {name t}
              | {type_text}

The statement ending at line XXXX

CREATE TABLE simple_shape(
  id INTEGER,
  t TEXT
);

  {create_table_stmt}: simple_shape: { id: integer, t: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_shape}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: t: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name t}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE simple_shape2(
  id INTEGER,
  t TEXT,
  u TEXT
);

  {create_table_stmt}: simple_shape2: { id: integer, t: text, u: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name simple_shape2}
  | {col_key_list}
    | {col_def}: id: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: t: text
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name t}
      |     | {type_text}: text
      | {col_key_list}
        | {col_def}: u: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name u}
              | {type_text}: text

The statement ending at line XXXX

SELECT simple_shape2.id, simple_shape2.t, simple_shape2.u
  FROM simple_shape2;

  {select_stmt}: select: { id: integer, t: text, u: text }
  | {select_core_list}: select: { id: integer, t: text, u: text }
  | | {select_core}: select: { id: integer, t: text, u: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text, u: text }
  |     | {select_expr_list}: select: { id: integer, t: text, u: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name simple_shape2}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |   | | {dot}: t: text
  |     |   |   | {name simple_shape2}
  |     |   |   | {name t}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: u: text
  |     |       | {dot}: u: text
  |     |         | {name simple_shape2}
  |     |         | {name u}
  |     | {select_from_etc}: TABLE { simple_shape2: simple_shape2 }
  |       | {table_or_subquery_list}: TABLE { simple_shape2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { simple_shape2: simple_shape2 }
  |       |   | {name simple_shape2}: TABLE { simple_shape2: simple_shape2 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT simple_shape2.id, simple_shape2.t, simple_shape2.u
  FROM simple_shape2;

  {select_stmt}: select: { id: integer, t: text, u: text }
  | {select_core_list}: select: { id: integer, t: text, u: text }
  | | {select_core}: select: { id: integer, t: text, u: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text, u: text }
  |     | {select_expr_list}: select: { id: integer, t: text, u: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name simple_shape2}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |   | | {dot}: t: text
  |     |   |   | {name simple_shape2}
  |     |   |   | {name t}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: u: text
  |     |       | {dot}: u: text
  |     |         | {name simple_shape2}
  |     |         | {name u}
  |     | {select_from_etc}: TABLE { simple_shape2: simple_shape2 }
  |       | {table_or_subquery_list}: TABLE { simple_shape2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { simple_shape2: simple_shape2 }
  |       |   | {name simple_shape2}: TABLE { simple_shape2: simple_shape2 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT simple_shape2.id, simple_shape2.t
  FROM simple_shape2;

  {select_stmt}: select: { id: integer, t: text }
  | {select_core_list}: select: { id: integer, t: text }
  | | {select_core}: select: { id: integer, t: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text }
  |     | {select_expr_list}: select: { id: integer, t: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name simple_shape2}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |     | {dot}: t: text
  |     |       | {name simple_shape2}
  |     |       | {name t}
  |     | {select_from_etc}: TABLE { simple_shape2: simple_shape2 }
  |       | {table_or_subquery_list}: TABLE { simple_shape2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { simple_shape2: simple_shape2 }
  |       |   | {name simple_shape2}: TABLE { simple_shape2: simple_shape2 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT id, t
  FROM simple_shape2;

  {select_stmt}: select: { id: integer, t: text }
  | {select_core_list}: select: { id: integer, t: text }
  | | {select_core}: select: { id: integer, t: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text }
  |     | {select_expr_list}: select: { id: integer, t: text }
  |     | | {select_expr}: id: integer
  |     | | | {name id}: id: integer
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |     | {name t}: t: text
  |     | {select_from_etc}: TABLE { simple_shape2: simple_shape2 }
  |       | {table_or_subquery_list}: TABLE { simple_shape2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { simple_shape2: simple_shape2 }
  |       |   | {name simple_shape2}: TABLE { simple_shape2: simple_shape2 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id, T1.t
  FROM simple_shape2 AS T1
  INNER JOIN simple_shape2 AS T2;

  {select_stmt}: select: { id: integer, t: text }
  | {select_core_list}: select: { id: integer, t: text }
  | | {select_core}: select: { id: integer, t: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text }
  |     | {select_expr_list}: select: { id: integer, t: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name T1}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |     | {dot}: t: text
  |     |       | {name T1}
  |     |       | {name t}
  |     | {select_from_etc}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | {join_clause}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { T1: simple_shape2 }
  |       | | | {name simple_shape2}: TABLE { T1: simple_shape2 }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: simple_shape2 }
  |       |         | {name simple_shape2}: TABLE { T2: simple_shape2 }
  |       |         | {opt_as_alias}
  |       |           | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id, T1.t, T1.u
  FROM simple_shape2 AS T1
  INNER JOIN simple_shape2 AS T2;

  {select_stmt}: select: { id: integer, t: text, u: text }
  | {select_core_list}: select: { id: integer, t: text, u: text }
  | | {select_core}: select: { id: integer, t: text, u: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text, u: text }
  |     | {select_expr_list}: select: { id: integer, t: text, u: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name T1}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |   | | {dot}: t: text
  |     |   |   | {name T1}
  |     |   |   | {name t}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: u: text
  |     |       | {dot}: u: text
  |     |         | {name T1}
  |     |         | {name u}
  |     | {select_from_etc}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | {join_clause}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { T1: simple_shape2 }
  |       | | | {name simple_shape2}: TABLE { T1: simple_shape2 }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: simple_shape2 }
  |       |         | {name simple_shape2}: TABLE { T2: simple_shape2 }
  |       |         | {opt_as_alias}
  |       |           | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT T1.id, T1.t, T1.u
  FROM simple_shape2 AS T1
  INNER JOIN simple_shape2 AS T2;

  {select_stmt}: select: { id: integer, t: text, u: text }
  | {select_core_list}: select: { id: integer, t: text, u: text }
  | | {select_core}: select: { id: integer, t: text, u: text }
  |   | {select_expr_list_con}: select: { id: integer, t: text, u: text }
  |     | {select_expr_list}: select: { id: integer, t: text, u: text }
  |     | | {select_expr}: id: integer
  |     | | | {dot}: id: integer
  |     | |   | {name T1}
  |     | |   | {name id}
  |     | | {select_expr_list}
  |     |   | {select_expr}: t: text
  |     |   | | {dot}: t: text
  |     |   |   | {name T1}
  |     |   |   | {name t}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: u: text
  |     |       | {dot}: u: text
  |     |         | {name T1}
  |     |         | {name u}
  |     | {select_from_etc}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | {join_clause}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { T1: simple_shape2 }
  |       | | | {name simple_shape2}: TABLE { T1: simple_shape2 }
  |       | | | {opt_as_alias}
  |       | |   | {name T1}
  |       | | {join_target_list}
  |       |   | {join_target}: JOIN { T1: simple_shape2, T2: simple_shape2 }
  |       |     | {int 1} {join_inner}
  |       |     | {table_join}
  |       |       | {table_or_subquery}: TABLE { T2: simple_shape2 }
  |       |         | {name simple_shape2}: TABLE { T2: simple_shape2 }
  |       |         | {opt_as_alias}
  |       |           | {name T2}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(not_correct)
  FROM simple_shape;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_correct'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {name not_correct}
  |     | {select_from_etc}: TABLE { simple_shape: simple_shape }
  |       | {table_or_subquery_list}: TABLE { simple_shape: simple_shape }
  |       | | {table_or_subquery}: TABLE { simple_shape: simple_shape }
  |       |   | {name simple_shape}: TABLE { simple_shape: simple_shape }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(simple_shape LIKE this_is_not_a_shape)
  FROM simple_shape;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'this_is_not_a_shape'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {name simple_shape}
  |     |       | {shape_def}: err
  |     |         | {like}: err
  |     |           | {name this_is_not_a_shape}: err
  |     | {select_from_etc}: TABLE { simple_shape: simple_shape }
  |       | {table_or_subquery_list}: TABLE { simple_shape: simple_shape }
  |       | | {table_or_subquery}: TABLE { simple_shape: simple_shape }
  |       |   | {name simple_shape}: TABLE { simple_shape: simple_shape }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(LIKE this_is_not_a_shape)
  FROM simple_shape;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'this_is_not_a_shape'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {shape_def}: err
  |     |         | {like}: err
  |     |           | {name this_is_not_a_shape}: err
  |     | {select_from_etc}: TABLE { simple_shape: simple_shape }
  |       | {table_or_subquery_list}: TABLE { simple_shape: simple_shape }
  |       | | {table_or_subquery}: TABLE { simple_shape: simple_shape }
  |       |   | {name simple_shape}: TABLE { simple_shape: simple_shape }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(LIKE with_kind)
  FROM simple_shape;

test/sem_test.sql:XXXX:1: error: in shape_def : CQL0069: name not found 'cost'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name with_kind}
  |     | {select_from_etc}: TABLE { simple_shape: simple_shape }
  |       | {table_or_subquery_list}: TABLE { simple_shape: simple_shape }
  |       | | {table_or_subquery}: TABLE { simple_shape: simple_shape }
  |       |   | {name simple_shape}: TABLE { simple_shape: simple_shape }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(simple_shape LIKE with_kind)
  FROM simple_shape;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0069: name not found 'simple_shape.cost'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {name simple_shape}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name with_kind}
  |     | {select_from_etc}: TABLE { simple_shape: simple_shape }
  |       | {table_or_subquery_list}: TABLE { simple_shape: simple_shape }
  |       | | {table_or_subquery}: TABLE { simple_shape: simple_shape }
  |       |   | {name simple_shape}: TABLE { simple_shape: simple_shape }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(LIKE foo);

test/sem_test.sql:XXXX:1: error: in select_expr_list_con : CQL0053: select columns(...) cannot be used with no FROM clause

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {shape_def}
  |     |         | {like}
  |     |           | {name foo}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT 1 AS y, T.id, T.t, T.u, 1 AS x
  FROM simple_shape2 AS T;

  {select_stmt}: select: { y: integer notnull, id: integer, t: text, u: text, x: integer notnull }
  | {select_core_list}: select: { y: integer notnull, id: integer, t: text, u: text, x: integer notnull }
  | | {select_core}: select: { y: integer notnull, id: integer, t: text, u: text, x: integer notnull }
  |   | {select_expr_list_con}: select: { y: integer notnull, id: integer, t: text, u: text, x: integer notnull }
  |     | {select_expr_list}: select: { y: integer notnull, id: integer, t: text, u: text, x: integer notnull }
  |     | | {select_expr}: y: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name y}
  |     | | {select_expr_list}
  |     |   | {select_expr}: id: integer
  |     |   | | {dot}: id: integer
  |     |   |   | {name T}
  |     |   |   | {name id}
  |     |   | {select_expr_list}
  |     |     | {select_expr}: t: text
  |     |     | | {dot}: t: text
  |     |     |   | {name T}
  |     |     |   | {name t}
  |     |     | {select_expr_list}
  |     |       | {select_expr}: u: text
  |     |       | | {dot}: u: text
  |     |       |   | {name T}
  |     |       |   | {name u}
  |     |       | {select_expr_list}
  |     |         | {select_expr}: x: integer notnull
  |     |           | {int 1}: integer notnull
  |     |           | {opt_as_alias}
  |     |             | {name x}
  |     | {select_from_etc}: TABLE { T: simple_shape2 }
  |       | {table_or_subquery_list}: TABLE { T: simple_shape2 }
  |       | | {table_or_subquery}: TABLE { T: simple_shape2 }
  |       |   | {name simple_shape2}: TABLE { T: simple_shape2 }
  |       |   | {opt_as_alias}
  |       |     | {name T}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

CREATE TABLE two_col_v1(
  x INTEGER,
  r REAL
);

  {create_table_stmt}: two_col_v1: { x: integer, r: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_col_v1}
  | {col_key_list}
    | {col_def}: x: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: r: real
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name r}
            | {type_real}: real

The statement ending at line XXXX

CREATE TABLE two_col_v2(
  x INTEGER,
  t REAL
);

  {create_table_stmt}: two_col_v2: { x: integer, t: real }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_col_v2}
  | {col_key_list}
    | {col_def}: x: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: t: real
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name t}
            | {type_real}: real

The statement ending at line XXXX

CREATE TABLE two_col_v3(
  x INTEGER,
  r TEXT
);

  {create_table_stmt}: two_col_v3: { x: integer, r: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name two_col_v3}
  | {col_key_list}
    | {col_def}: x: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: r: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name r}
            | {type_text}: text

The statement ending at line XXXX

SELECT COLUMNS(two_col_v3 LIKE two_col_v1)
  FROM two_col_v3;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0012: incompatible types in expression 'two_col_v3.r'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {name two_col_v3}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name two_col_v1}
  |     | {select_from_etc}: TABLE { two_col_v3: two_col_v3 }
  |       | {table_or_subquery_list}: TABLE { two_col_v3: two_col_v3 }
  |       | | {table_or_subquery}: TABLE { two_col_v3: two_col_v3 }
  |       |   | {name two_col_v3}: TABLE { two_col_v3: two_col_v3 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(two_col_v3 LIKE two_col_v2)
  FROM two_col_v3;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0069: name not found 'two_col_v3.t'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {name two_col_v3}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name two_col_v2}
  |     | {select_from_etc}: TABLE { two_col_v3: two_col_v3 }
  |       | {table_or_subquery_list}: TABLE { two_col_v3: two_col_v3 }
  |       | | {table_or_subquery}: TABLE { two_col_v3: two_col_v3 }
  |       |   | {name two_col_v3}: TABLE { two_col_v3: two_col_v3 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(LIKE two_col_v1)
  FROM two_col_v3;

test/sem_test.sql:XXXX:1: error: in select_expr_list : CQL0012: incompatible types in expression 'two_col_v3.r'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name two_col_v1}
  |     | {select_from_etc}: TABLE { two_col_v3: two_col_v3 }
  |       | {table_or_subquery_list}: TABLE { two_col_v3: two_col_v3 }
  |       | | {table_or_subquery}: TABLE { two_col_v3: two_col_v3 }
  |       |   | {name two_col_v3}: TABLE { two_col_v3: two_col_v3 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT COLUMNS(LIKE two_col_v2)
  FROM two_col_v3;

test/sem_test.sql:XXXX:1: error: in shape_def : CQL0069: name not found 't'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {column_calculation}: err
  |     |   | {col_calcs}
  |     |     | {col_calc}
  |     |       | {shape_def}
  |     |         | {like}: ok
  |     |           | {name two_col_v2}
  |     | {select_from_etc}: TABLE { two_col_v3: two_col_v3 }
  |       | {table_or_subquery_list}: TABLE { two_col_v3: two_col_v3 }
  |       | | {table_or_subquery}: TABLE { two_col_v3: two_col_v3 }
  |       |   | {name two_col_v3}: TABLE { two_col_v3: two_col_v3 }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE PROC arg_shape (xyzzy INTEGER);

  {declare_proc_stmt}: ok
  | {proc_name_type}
  | | {name arg_shape}: ok
  | | {int 0}
  | {proc_params_stmts}
    | {params}: ok
      | {param}: xyzzy: integer variable in
        | {param_detail}: xyzzy: integer variable in
          | {name xyzzy}: xyzzy: integer variable in
          | {type_int}: integer

The statement ending at line XXXX

SELECT xyzzy
  FROM (SELECT 1 AS xyzzy);

  {select_stmt}: select: { xyzzy: integer notnull }
  | {select_core_list}: select: { xyzzy: integer notnull }
  | | {select_core}: select: { xyzzy: integer notnull }
  |   | {select_expr_list_con}: select: { xyzzy: integer notnull }
  |     | {select_expr_list}: select: { xyzzy: integer notnull }
  |     | | {select_expr}: xyzzy: integer notnull
  |     |   | {name xyzzy}: xyzzy: integer notnull
  |     | {select_from_etc}: TABLE { select: select }
  |       | {table_or_subquery_list}: TABLE { select: select }
  |       | | {table_or_subquery}: TABLE { select: select }
  |       |   | {select_stmt}: select: { xyzzy: integer notnull }
  |       |     | {select_core_list}: select: { xyzzy: integer notnull }
  |       |     | | {select_core}: select: { xyzzy: integer notnull }
  |       |     |   | {select_expr_list_con}: select: { xyzzy: integer notnull }
  |       |     |     | {select_expr_list}: select: { xyzzy: integer notnull }
  |       |     |     | | {select_expr}: xyzzy: integer notnull
  |       |     |     |   | {int 1}: integer notnull
  |       |     |     |   | {opt_as_alias}
  |       |     |     |     | {name xyzzy}
  |       |     |     | {select_from_etc}: ok
  |       |     |       | {select_where}
  |       |     |         | {select_groupby}
  |       |     |           | {select_having}
  |       |     | {select_orderby}
  |       |       | {select_limit}
  |       |         | {select_offset}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_math (x_ INTEGER, y_ INTEGER)
BEGIN
  SELECT x_ + y_ AS result;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: inline_math: { result: integer } dml_proc
    | {name inline_math}: inline_math: { result: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x_: integer variable in
      | | | {param_detail}: x_: integer variable in
      | |   | {name x_}: x_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: y_: integer variable in
      |     | {param_detail}: y_: integer variable in
      |       | {name y_}: y_: integer variable in
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { result: integer }
          | {select_core_list}: select: { result: integer }
          | | {select_core}: select: { result: integer }
          |   | {select_expr_list_con}: select: { result: integer }
          |     | {select_expr_list}: select: { result: integer }
          |     | | {select_expr}: result: integer
          |     |   | {add}: integer
          |     |   | | {name x_}: x_: integer variable in
          |     |   | | {name y_}: y_: integer variable in
          |     |   | {opt_as_alias}
          |     |     | {name result}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math ()
BEGIN
  WITH
  N (i) AS (SELECT 1 AS i
  UNION ALL
  SELECT i + 1 AS i
    FROM N
  LIMIT 20)
  SELECT inline_math(i, i + 3) AS result
    FROM N;
END;

  {create_proc_stmt}: do_inline_math: { result: integer } dml_proc
  | {name do_inline_math}: do_inline_math: { result: integer } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { result: integer }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: N: { i: integer notnull }
        |     | {cte_decl}: N: { i: integer notnull }
        |     | | {name N}
        |     | | {name_list}
        |     |   | {name i}
        |     | {select_stmt}: UNION ALL: { i: integer notnull }
        |       | {select_core_list}: UNION ALL: { i: integer notnull }
        |       | | {select_core}: select: { i: integer notnull }
        |       | | | {select_expr_list_con}: select: { i: integer notnull }
        |       | |   | {select_expr_list}: select: { i: integer notnull }
        |       | |   | | {select_expr}: i: integer notnull
        |       | |   |   | {int 1}: integer notnull
        |       | |   |   | {opt_as_alias}
        |       | |   |     | {name i}
        |       | |   | {select_from_etc}: ok
        |       | |     | {select_where}
        |       | |       | {select_groupby}
        |       | |         | {select_having}
        |       | | {select_core_compound}
        |       |   | {int 2}
        |       |   | {select_core_list}: select: { i: integer notnull }
        |       |     | {select_core}: select: { i: integer notnull }
        |       |       | {select_expr_list_con}: select: { i: integer notnull }
        |       |         | {select_expr_list}: select: { i: integer notnull }
        |       |         | | {select_expr}: i: integer notnull
        |       |         |   | {add}: integer notnull
        |       |         |   | | {name i}: i: integer notnull
        |       |         |   | | {int 1}: integer notnull
        |       |         |   | {opt_as_alias}
        |       |         |     | {name i}
        |       |         | {select_from_etc}: TABLE { N: N }
        |       |           | {table_or_subquery_list}: TABLE { N: N }
        |       |           | | {table_or_subquery}: TABLE { N: N }
        |       |           |   | {name N}: TABLE { N: N }
        |       |           | {select_where}
        |       |             | {select_groupby}
        |       |               | {select_having}
        |       | {select_orderby}
        |         | {select_limit}
        |           | {opt_limit}: integer notnull
        |           | | {int 20}: integer notnull
        |           | {select_offset}
        | {select_stmt}: select: { result: integer }
          | {select_core_list}: select: { result: integer }
          | | {select_core}: select: { result: integer }
          |   | {select_expr_list_con}: select: { result: integer }
          |     | {select_expr_list}: select: { result: integer }
          |     | | {select_expr}: result: integer
          |     |   | {call}: integer
          |     |   | | {name inline_math}: integer inline_call
          |     |   | | {call_arg_list}
          |     |   |   | {call_filter_clause}
          |     |   |   | {arg_list}: ok
          |     |   |     | {name i}: i: integer notnull
          |     |   |     | {arg_list}
          |     |   |       | {add}: integer notnull
          |     |   |         | {name i}: i: integer notnull
          |     |   |         | {int 3}: integer notnull
          |     |   | {opt_as_alias}
          |     |     | {name result}
          |     | {select_from_etc}: TABLE { N: N }
          |       | {table_or_subquery_list}: TABLE { N: N }
          |       | | {table_or_subquery}: TABLE { N: N }
          |       |   | {name N}: TABLE { N: N }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_math_bad (x INTEGER, y INTEGER)
BEGIN
  SELECT x + y AS sum
    FROM (SELECT 1 AS z);
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: inline_math_bad: { sum: integer } dml_proc
    | {name inline_math_bad}: inline_math_bad: { sum: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x: integer variable in
      | | | {param_detail}: x: integer variable in
      | |   | {name x}: x: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: y: integer variable in
      |     | {param_detail}: y: integer variable in
      |       | {name y}: y: integer variable in
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { sum: integer }
          | {select_core_list}: select: { sum: integer }
          | | {select_core}: select: { sum: integer }
          |   | {select_expr_list_con}: select: { sum: integer }
          |     | {select_expr_list}: select: { sum: integer }
          |     | | {select_expr}: sum: integer
          |     |   | {add}: integer
          |     |   | | {name x}: x: integer variable in
          |     |   | | {name y}: y: integer variable in
          |     |   | {opt_as_alias}
          |     |     | {name sum}
          |     | {select_from_etc}: TABLE { select: select }
          |       | {table_or_subquery_list}: TABLE { select: select }
          |       | | {table_or_subquery}: TABLE { select: select }
          |       |   | {select_stmt}: select: { z: integer notnull }
          |       |     | {select_core_list}: select: { z: integer notnull }
          |       |     | | {select_core}: select: { z: integer notnull }
          |       |     |   | {select_expr_list_con}: select: { z: integer notnull }
          |       |     |     | {select_expr_list}: select: { z: integer notnull }
          |       |     |     | | {select_expr}: z: integer notnull
          |       |     |     |   | {int 1}: integer notnull
          |       |     |     |   | {opt_as_alias}
          |       |     |     |     | {name z}
          |       |     |     | {select_from_etc}: ok
          |       |     |       | {select_where}
          |       |     |         | {select_groupby}
          |       |     |           | {select_having}
          |       |     | {select_orderby}
          |       |       | {select_limit}
          |       |         | {select_offset}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad ()
BEGIN
  SELECT inline_math_bad(1, 2) AS bad;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0450: a shared fragment used like a function must be a simple SELECT with no FROM clause 'inline_math_bad'

  {create_proc_stmt}: err
  | {name do_inline_math_bad}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name inline_math_bad}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   |   | {arg_list}: ok
        |     |   |     | {int 1}
        |     |   |     | {arg_list}
        |     |   |       | {int 2}
        |     |   | {opt_as_alias}
        |     |     | {name bad}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_math_bad2 ()
BEGIN
  SELECT 1 AS x
  UNION ALL
  SELECT 2 AS x;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: inline_math_bad2: { x: integer notnull } dml_proc
    | {name inline_math_bad2}: inline_math_bad2: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: UNION ALL: { x: integer notnull }
          | {select_core_list}: UNION ALL: { x: integer notnull }
          | | {select_core}: select: { x: integer notnull }
          | | | {select_expr_list_con}: select: { x: integer notnull }
          | |   | {select_expr_list}: select: { x: integer notnull }
          | |   | | {select_expr}: x: integer notnull
          | |   |   | {int 1}: integer notnull
          | |   |   | {opt_as_alias}
          | |   |     | {name x}
          | |   | {select_from_etc}: ok
          | |     | {select_where}
          | |       | {select_groupby}
          | |         | {select_having}
          | | {select_core_compound}
          |   | {int 2}
          |   | {select_core_list}: select: { x: integer notnull }
          |     | {select_core}: select: { x: integer notnull }
          |       | {select_expr_list_con}: select: { x: integer notnull }
          |         | {select_expr_list}: select: { x: integer notnull }
          |         | | {select_expr}: x: integer notnull
          |         |   | {int 2}: integer notnull
          |         |   | {opt_as_alias}
          |         |     | {name x}
          |         | {select_from_etc}: ok
          |           | {select_where}
          |             | {select_groupby}
          |               | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad2 ()
BEGIN
  SELECT inline_math_bad2() AS bad;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0450: a shared fragment used like a function must be a simple SELECT with no FROM clause 'inline_math_bad2'

  {create_proc_stmt}: err
  | {name do_inline_math_bad2}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name inline_math_bad2}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   | {opt_as_alias}
        |     |     | {name bad}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_math_bad3 ()
BEGIN
  SELECT NOT 'x' AS y;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: err
    | {name inline_math_bad3}: err
    | {proc_params_stmts}
      | {stmt_list}: err
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {not}: err
          |     |   | | {strlit 'x'}: text notnull
          |     |   | {opt_as_alias}
          |     |     | {name y}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad3 ()
BEGIN
  SELECT inline_math_bad3() AS bad;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0213: procedure had errors, can't call 'inline_math_bad3'

  {create_proc_stmt}: err
  | {name do_inline_math_bad3}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name inline_math_bad3}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   | {opt_as_alias}
        |     |     | {name bad}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_math_bad4 ()
BEGIN
  SELECT 1 AS x, 2 AS y;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: inline_math_bad4: { x: integer notnull, y: integer notnull } dml_proc
    | {name inline_math_bad4}: inline_math_bad4: { x: integer notnull, y: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { x: integer notnull, y: integer notnull }
          | {select_core_list}: select: { x: integer notnull, y: integer notnull }
          | | {select_core}: select: { x: integer notnull, y: integer notnull }
          |   | {select_expr_list_con}: select: { x: integer notnull, y: integer notnull }
          |     | {select_expr_list}: select: { x: integer notnull, y: integer notnull }
          |     | | {select_expr}: x: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name x}
          |     | | {select_expr_list}
          |     |   | {select_expr}: y: integer notnull
          |     |     | {int 2}: integer notnull
          |     |     | {opt_as_alias}
          |     |       | {name y}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad4 ()
BEGIN
  SELECT inline_math_bad4() AS bad;
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0232: nested select expression must return exactly one column 'inline_math_bad4'

  {create_proc_stmt}: err
  | {name do_inline_math_bad4}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}: err
        |     |   | {call}: err
        |     |   | | {name inline_math_bad4}
        |     |   | | {call_arg_list}
        |     |   |   | {call_filter_clause}
        |     |   | {opt_as_alias}
        |     |     | {name bad}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad5 ()
BEGIN
  SELECT 1
    WHERE inline_math(2);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0212: too few arguments provided to procedure 'inline_math'

  {create_proc_stmt}: err
  | {name do_inline_math_bad5}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}: err
        |       | {select_where}
        |         | {opt_where}: err
        |         | | {call}: err
        |         |   | {name inline_math}
        |         |   | {call_arg_list}
        |         |     | {call_filter_clause}
        |         |     | {arg_list}: ok
        |         |       | {int 2}: integer notnull
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
CREATE PROC inline_frag (x INTEGER)
BEGIN
  SELECT 1 AS x;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {create_proc_stmt}: inline_frag: { x: integer notnull } dml_proc
    | {name inline_frag}: inline_frag: { x: integer notnull } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: x: integer variable in
      |   | {param_detail}: x: integer variable in
      |     | {name x}: x: integer variable in
      |     | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { x: integer notnull }
          | {select_core_list}: select: { x: integer notnull }
          | | {select_core}: select: { x: integer notnull }
          |   | {select_expr_list_con}: select: { x: integer notnull }
          |     | {select_expr_list}: select: { x: integer notnull }
          |     | | {select_expr}: x: integer notnull
          |     |   | {int 1}: integer notnull
          |     |   | {opt_as_alias}
          |     |     | {name x}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad6 ()
BEGIN
  SELECT 1
    WHERE inline_frag(DISTINCT 2);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0451: procedure as function call is not compatible with DISTINCT or filter clauses 'inline_frag'

  {create_proc_stmt}: err
  | {name do_inline_math_bad6}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}: err
        |       | {select_where}
        |         | {opt_where}: err
        |         | | {call}: err
        |         |   | {name inline_frag}
        |         |   | {call_arg_list}
        |         |     | {call_filter_clause}
        |         |     | | {distinct}
        |         |     | {arg_list}: ok
        |         |       | {int 2}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:shared_fragment)
DECLARE PROC declared_shared_fragment () (x INTEGER);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name shared_fragment}
  | {declare_proc_stmt}: declared_shared_fragment: { x: integer } dml_proc
    | {proc_name_type}
    | | {name declared_shared_fragment}: declared_shared_fragment: { x: integer } dml_proc
    | | {int 3}
    | {proc_params_stmts}
      | {typed_names}: declared_shared_fragment: { x: integer }
        | {typed_name}: x: integer
          | {name x}
          | {type_int}: x: integer

The statement ending at line XXXX

CREATE PROC uses_declared_shared_fragment ()
BEGIN
  WITH
  x (*) AS (CALL declared_shared_fragment())
  SELECT *
    FROM x;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0468: @attribute(cql:shared_fragment) may only be placed on a CREATE PROC statement 'declared_shared_fragment'

  {create_proc_stmt}: err
  | {name uses_declared_shared_fragment}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {with_select_stmt}: err
        | {with}
        | | {cte_tables}: err
        |   | {cte_table}: err
        |     | {cte_decl}
        |     | | {name x}
        |     | | {star}
        |     | {shared_cte}: err
        |       | {call_stmt}: declared_shared_fragment: { x: integer } dml_proc
        |         | {name declared_shared_fragment}: declared_shared_fragment: { x: integer } dml_proc
        | {select_stmt}
          | {select_core_list}
          | | {select_core}
          |   | {select_expr_list_con}
          |     | {select_expr_list}
          |     | | {star}
          |     | {select_from_etc}
          |       | {table_or_subquery_list}
          |       | | {table_or_subquery}
          |       |   | {name x}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC do_inline_math_bad7 ()
BEGIN
  SELECT 1
    WHERE inline_frag(2) FILTER (WHERE 1);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0451: procedure as function call is not compatible with DISTINCT or filter clauses 'inline_frag'

  {create_proc_stmt}: err
  | {name do_inline_math_bad7}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {select_stmt}: err
        | {select_core_list}: err
        | | {select_core}: err
        |   | {select_expr_list_con}: err
        |     | {select_expr_list}: err
        |     | | {select_expr}
        |     |   | {int 1}
        |     | {select_from_etc}: err
        |       | {select_where}
        |         | {opt_where}: err
        |         | | {call}: err
        |         |   | {name inline_frag}
        |         |   | {call_arg_list}
        |         |     | {call_filter_clause}
        |         |     | | {opt_filter_clause}: integer notnull
        |         |     |   | {opt_where}: integer notnull
        |         |     |     | {int 1}: integer notnull
        |         |     | {arg_list}: ok
        |         |       | {int 2}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE Shape_xy(
  x INTEGER,
  y INTEGER
);

  {create_table_stmt}: Shape_xy: { x: integer, y: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name Shape_xy}
  | {col_key_list}
    | {col_def}: x: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: y: integer
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name y}
            | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE Shape_uv(
  u TEXT,
  v TEXT
);

  {create_table_stmt}: Shape_uv: { u: text, v: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name Shape_uv}
  | {col_key_list}
    | {col_def}: u: text
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name u}
    |     | {type_text}: text
    | {col_key_list}
      | {col_def}: v: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name v}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE Shape_uvxy(
  x INTEGER,
  y INTEGER,
  u TEXT,
  v TEXT
);

  {create_table_stmt}: Shape_uvxy: { x: integer, y: integer, u: text, v: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name Shape_uvxy}
  | {col_key_list}
    | {col_def}: x: integer
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name x}
    |     | {type_int}: integer
    | {col_key_list}
      | {col_def}: y: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name y}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: u: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name u}
        |     | {type_text}: text
        | {col_key_list}
          | {col_def}: v: text
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
                | {name v}
                | {type_text}: text

The statement ending at line XXXX

CREATE PROC ShapeTrix ()
BEGIN
  DECLARE C CURSOR FOR SELECT Shape_xy.*, 1 AS u, 2 AS v
    FROM Shape_xy;
  FETCH C;
  INSERT INTO Shape_xy(x, y) VALUES(C.x, C.y);
  INSERT INTO Shape_xy(x, y) VALUES(1, 2), (3, 4), (C.x, C.y);
  DECLARE D CURSOR FOR SELECT *
    FROM Shape_uv;
  FETCH D;
  DECLARE R CURSOR LIKE Shape_uvxy;
  FETCH R(x, y, u, v) FROM VALUES(C.x, C.y, D.u, D.v);
  UPDATE CURSOR R(x, y, u, v) FROM VALUES(C.x, C.y, D.u, D.v);
  DECLARE S CURSOR FOR WITH
  cte1 (l, m, n, o) AS (VALUES(C.x, C.y, D.u, D.v))
  SELECT *
    FROM cte1;
  FETCH S;
  DECLARE T CURSOR FOR WITH
  cte2 (l, m, n, o) AS (VALUES(1, 2, '3', '4'), (C.x, C.y, D.u, D.v))
  SELECT *
    FROM cte2;
  FETCH S;
END;

  {create_proc_stmt}: ok dml_proc
  | {name ShapeTrix}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { x: integer, y: integer, u: integer notnull, v: integer notnull } variable dml_proc
      | | {name C}: C: select: { x: integer, y: integer, u: integer notnull, v: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { x: integer, y: integer, u: integer notnull, v: integer notnull }
      |   | {select_core_list}: select: { x: integer, y: integer, u: integer notnull, v: integer notnull }
      |   | | {select_core}: select: { x: integer, y: integer, u: integer notnull, v: integer notnull }
      |   |   | {select_expr_list_con}: select: { x: integer, y: integer, u: integer notnull, v: integer notnull }
      |   |     | {select_expr_list}: select: { x: integer, y: integer, u: integer notnull, v: integer notnull }
      |   |     | | {table_star}: Shape_xy: Shape_xy: { x: integer, y: integer }
      |   |     | | | {name Shape_xy}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: u: integer notnull
      |   |     |   | | {int 1}: integer notnull
      |   |     |   | | {opt_as_alias}
      |   |     |   |   | {name u}
      |   |     |   | {select_expr_list}
      |   |     |     | {select_expr}: v: integer notnull
      |   |     |       | {int 2}: integer notnull
      |   |     |       | {opt_as_alias}
      |   |     |         | {name v}
      |   |     | {select_from_etc}: TABLE { Shape_xy: Shape_xy }
      |   |       | {table_or_subquery_list}: TABLE { Shape_xy: Shape_xy }
      |   |       | | {table_or_subquery}: TABLE { Shape_xy: Shape_xy }
      |   |       |   | {name Shape_xy}: TABLE { Shape_xy: Shape_xy }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { x: integer, y: integer, u: integer notnull, v: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { x: integer, y: integer, u: integer notnull, v: integer notnull } variable dml_proc shape_storage
      | {insert_stmt}: ok
      | | {insert_normal}
      | | {name_columns_values}
      |   | {name Shape_xy}: Shape_xy: { x: integer, y: integer }
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer
      |     |   | {name_list}
      |     |     | {name y}: y: integer
      |     | {select_stmt}: values: { column1: integer variable, column2: integer variable }
      |       | {select_core_list}: values: { column1: integer variable, column2: integer variable }
      |       | | {select_core}: values: { column1: integer variable, column2: integer variable }
      |       |   | {select_values}
      |       |   | {values}: values: { column1: integer variable, column2: integer variable }
      |       |     | {insert_list}: ok
      |       |       | {dot}: C.x: integer variable
      |       |       | | {name C}
      |       |       | | {name x}
      |       |       | {insert_list}
      |       |         | {dot}: C.y: integer variable
      |       |           | {name C}
      |       |           | {name y}
      |       | {select_orderby}
      |         | {select_limit}
      |           | {select_offset}
      | {insert_stmt}: ok
      | | {insert_normal}
      | | {name_columns_values}
      |   | {name Shape_xy}: Shape_xy: { x: integer, y: integer }
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer
      |     |   | {name_list}
      |     |     | {name y}: y: integer
      |     | {select_stmt}: values: { column1: integer, column2: integer }
      |       | {select_core_list}: values: { column1: integer, column2: integer }
      |       | | {select_core}: values: { column1: integer, column2: integer }
      |       |   | {select_values}
      |       |   | {values}: values: { column1: integer, column2: integer }
      |       |     | {insert_list}: ok
      |       |     | | {int 1}: integer notnull
      |       |     | | {insert_list}
      |       |     |   | {int 2}: integer notnull
      |       |     | {values}
      |       |       | {insert_list}: ok
      |       |       | | {int 3}: integer notnull
      |       |       | | {insert_list}
      |       |       |   | {int 4}: integer notnull
      |       |       | {values}
      |       |         | {insert_list}: ok
      |       |           | {dot}: C.x: integer variable
      |       |           | | {name C}
      |       |           | | {name x}
      |       |           | {insert_list}
      |       |             | {dot}: C.y: integer variable
      |       |               | {name C}
      |       |               | {name y}
      |       | {select_orderby}
      |         | {select_limit}
      |           | {select_offset}
      | {declare_cursor}: D: select: { u: text, v: text } variable dml_proc
      | | {name D}: D: select: { u: text, v: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { u: text, v: text }
      |   | {select_core_list}: select: { u: text, v: text }
      |   | | {select_core}: select: { u: text, v: text }
      |   |   | {select_expr_list_con}: select: { u: text, v: text }
      |   |     | {select_expr_list}: select: { u: text, v: text }
      |   |     | | {star}: select: { u: text, v: text }
      |   |     | {select_from_etc}: TABLE { Shape_uv: Shape_uv }
      |   |       | {table_or_subquery_list}: TABLE { Shape_uv: Shape_uv }
      |   |       | | {table_or_subquery}: TABLE { Shape_uv: Shape_uv }
      |   |       |   | {name Shape_uv}: TABLE { Shape_uv: Shape_uv }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: D: select: { u: text, v: text } variable dml_proc shape_storage
      | | {name D}: D: select: { u: text, v: text } variable dml_proc shape_storage
      | {declare_cursor_like_name}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {shape_def}: Shape_uvxy: { x: integer, y: integer, u: text, v: text }
      |   | {like}: ok
      |     | {name Shape_uvxy}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer
      |     |   | {name_list}
      |     |     | {name y}: y: integer
      |     |     | {name_list}
      |     |       | {name u}: u: text
      |     |       | {name_list}
      |     |         | {name v}: v: text
      |     | {insert_list}: ok
      |       | {dot}: C.x: integer variable
      |       | | {name C}
      |       | | {name x}
      |       | {insert_list}
      |         | {dot}: C.y: integer variable
      |         | | {name C}
      |         | | {name y}
      |         | {insert_list}
      |           | {dot}: D.u: text variable
      |           | | {name D}
      |           | | {name u}
      |           | {insert_list}
      |             | {dot}: D.v: text variable
      |               | {name D}
      |               | {name v}
      | {update_cursor_stmt}: ok
      | | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {columns_values}: ok
      |   | {column_spec}
      |   | | {name_list}
      |   |   | {name x}: x: integer
      |   |   | {name_list}
      |   |     | {name y}: y: integer
      |   |     | {name_list}
      |   |       | {name u}: u: text
      |   |       | {name_list}
      |   |         | {name v}: v: text
      |   | {insert_list}: ok
      |     | {dot}: C.x: integer variable
      |     | | {name C}
      |     | | {name x}
      |     | {insert_list}
      |       | {dot}: C.y: integer variable
      |       | | {name C}
      |       | | {name y}
      |       | {insert_list}
      |         | {dot}: D.u: text variable
      |         | | {name D}
      |         | | {name u}
      |         | {insert_list}
      |           | {dot}: D.v: text variable
      |             | {name D}
      |             | {name v}
      | {declare_cursor}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc
      | | {name S}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc shape_storage
      | | {with_select_stmt}: select: { l: integer, m: integer, n: text, o: text }
      |   | {with}
      |   | | {cte_tables}: ok
      |   |   | {cte_table}: cte1: { l: integer variable, m: integer variable, n: text variable, o: text variable }
      |   |     | {cte_decl}: cte1: { l: integer variable, m: integer variable, n: text variable, o: text variable }
      |   |     | | {name cte1}
      |   |     | | {name_list}
      |   |     |   | {name l}
      |   |     |   | {name_list}
      |   |     |     | {name m}
      |   |     |     | {name_list}
      |   |     |       | {name n}
      |   |     |       | {name_list}
      |   |     |         | {name o}
      |   |     | {select_stmt}: values: { column1: integer variable, column2: integer variable, column3: text variable, column4: text variable }
      |   |       | {select_core_list}: values: { column1: integer variable, column2: integer variable, column3: text variable, column4: text variable }
      |   |       | | {select_core}: values: { column1: integer variable, column2: integer variable, column3: text variable, column4: text variable }
      |   |       |   | {select_values}
      |   |       |   | {values}: values: { column1: integer variable, column2: integer variable, column3: text variable, column4: text variable }
      |   |       |     | {insert_list}: ok
      |   |       |       | {dot}: C.x: integer variable
      |   |       |       | | {name C}
      |   |       |       | | {name x}
      |   |       |       | {insert_list}
      |   |       |         | {dot}: C.y: integer variable
      |   |       |         | | {name C}
      |   |       |         | | {name y}
      |   |       |         | {insert_list}
      |   |       |           | {dot}: D.u: text variable
      |   |       |           | | {name D}
      |   |       |           | | {name u}
      |   |       |           | {insert_list}
      |   |       |             | {dot}: D.v: text variable
      |   |       |               | {name D}
      |   |       |               | {name v}
      |   |       | {select_orderby}
      |   |         | {select_limit}
      |   |           | {select_offset}
      |   | {select_stmt}: select: { l: integer, m: integer, n: text, o: text }
      |     | {select_core_list}: select: { l: integer, m: integer, n: text, o: text }
      |     | | {select_core}: select: { l: integer, m: integer, n: text, o: text }
      |     |   | {select_expr_list_con}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | {select_expr_list}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | | {star}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | {select_from_etc}: TABLE { cte1: cte1 }
      |     |       | {table_or_subquery_list}: TABLE { cte1: cte1 }
      |     |       | | {table_or_subquery}: TABLE { cte1: cte1 }
      |     |       |   | {name cte1}: TABLE { cte1: cte1 }
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {fetch_stmt}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc shape_storage
      | | {name S}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc shape_storage
      | {declare_cursor}: T: select: { l: integer, m: integer, n: text, o: text } variable dml_proc
      | | {name T}: T: select: { l: integer, m: integer, n: text, o: text } variable dml_proc
      | | {with_select_stmt}: select: { l: integer, m: integer, n: text, o: text }
      |   | {with}
      |   | | {cte_tables}: ok
      |   |   | {cte_table}: cte2: { l: integer, m: integer, n: text, o: text }
      |   |     | {cte_decl}: cte2: { l: integer, m: integer, n: text, o: text }
      |   |     | | {name cte2}
      |   |     | | {name_list}
      |   |     |   | {name l}
      |   |     |   | {name_list}
      |   |     |     | {name m}
      |   |     |     | {name_list}
      |   |     |       | {name n}
      |   |     |       | {name_list}
      |   |     |         | {name o}
      |   |     | {select_stmt}: values: { column1: integer, column2: integer, column3: text, column4: text }
      |   |       | {select_core_list}: values: { column1: integer, column2: integer, column3: text, column4: text }
      |   |       | | {select_core}: values: { column1: integer, column2: integer, column3: text, column4: text }
      |   |       |   | {select_values}
      |   |       |   | {values}: values: { column1: integer, column2: integer, column3: text, column4: text }
      |   |       |     | {insert_list}: ok
      |   |       |     | | {int 1}: integer notnull
      |   |       |     | | {insert_list}
      |   |       |     |   | {int 2}: integer notnull
      |   |       |     |   | {insert_list}
      |   |       |     |     | {strlit '3'}: text notnull
      |   |       |     |     | {insert_list}
      |   |       |     |       | {strlit '4'}: text notnull
      |   |       |     | {values}
      |   |       |       | {insert_list}: ok
      |   |       |         | {dot}: C.x: integer variable
      |   |       |         | | {name C}
      |   |       |         | | {name x}
      |   |       |         | {insert_list}
      |   |       |           | {dot}: C.y: integer variable
      |   |       |           | | {name C}
      |   |       |           | | {name y}
      |   |       |           | {insert_list}
      |   |       |             | {dot}: D.u: text variable
      |   |       |             | | {name D}
      |   |       |             | | {name u}
      |   |       |             | {insert_list}
      |   |       |               | {dot}: D.v: text variable
      |   |       |                 | {name D}
      |   |       |                 | {name v}
      |   |       | {select_orderby}
      |   |         | {select_limit}
      |   |           | {select_offset}
      |   | {select_stmt}: select: { l: integer, m: integer, n: text, o: text }
      |     | {select_core_list}: select: { l: integer, m: integer, n: text, o: text }
      |     | | {select_core}: select: { l: integer, m: integer, n: text, o: text }
      |     |   | {select_expr_list_con}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | {select_expr_list}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | | {star}: select: { l: integer, m: integer, n: text, o: text }
      |     |     | {select_from_etc}: TABLE { cte2: cte2 }
      |     |       | {table_or_subquery_list}: TABLE { cte2: cte2 }
      |     |       | | {table_or_subquery}: TABLE { cte2: cte2 }
      |     |       |   | {name cte2}: TABLE { cte2: cte2 }
      |     |       | {select_where}
      |     |         | {select_groupby}
      |     |           | {select_having}
      |     | {select_orderby}
      |       | {select_limit}
      |         | {select_offset}
      | {fetch_stmt}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc shape_storage
        | {name S}: S: select: { l: integer, m: integer, n: text, o: text } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC ShapeTrixError1 ()
BEGIN
  INSERT INTO Shape_xy(x, y) VALUES(FROM not_a_cursor LIKE Shape_xy);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name ShapeTrixError1}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name Shape_xy}: Shape_xy: { x: integer, y: integer }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name x}
            |   | {name_list}
            |     | {name y}
            | {select_stmt}: err
              | {select_core_list}: err
              | | {select_core}: err
              |   | {select_values}
              |   | {values}: err
              |     | {insert_list}: err
              |       | {from_shape}
              |         | {name not_a_cursor}: err
              |         | {shape_def}
              |           | {like}
              |             | {name Shape_xy}
              | {select_orderby}
                | {select_limit}
                  | {select_offset}

The statement ending at line XXXX

CREATE PROC ShapeTrixError2 ()
BEGIN
  DECLARE R CURSOR LIKE Shape_uvxy;
  FETCH R(x, y, u, v) FROM VALUES(FROM not_a_cursor);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name ShapeTrixError2}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {shape_def}: Shape_uvxy: { x: integer, y: integer, u: text, v: text }
      |   | {like}: ok
      |     | {name Shape_uvxy}
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name x}
            |   | {name_list}
            |     | {name y}
            |     | {name_list}
            |       | {name u}
            |       | {name_list}
            |         | {name v}
            | {insert_list}: err
              | {from_shape}
                | {name not_a_cursor}: err

The statement ending at line XXXX

CREATE PROC ShapeTrixError3 ()
BEGIN
  DECLARE R CURSOR LIKE Shape_uvxy;
  FETCH R(x, y, u, v) FROM VALUES(NULL, NULL, NULL, NULL) @DUMMY_SEED(1);
  UPDATE CURSOR R(x, y, u, v) FROM VALUES(FROM not_a_cursor);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name ShapeTrixError3}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      | | {shape_def}: Shape_uvxy: { x: integer, y: integer, u: text, v: text }
      |   | {like}: ok
      |     | {name Shape_uvxy}
      | {fetch_values_stmt}: ok
      | | {insert_dummy_spec}: integer notnull
      | | | {int 1}: integer notnull
      | | | {int 0}
      | | {name_columns_values}
      |   | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name x}: x: integer
      |     |   | {name_list}
      |     |     | {name y}: y: integer
      |     |     | {name_list}
      |     |       | {name u}: u: text
      |     |       | {name_list}
      |     |         | {name v}: v: text
      |     | {insert_list}
      |       | {null}: null
      |       | {insert_list}
      |         | {null}: null
      |         | {insert_list}
      |           | {null}: null
      |           | {insert_list}
      |             | {null}: null
      | {update_cursor_stmt}: err
        | {name R}: R: Shape_uvxy: { x: integer, y: integer, u: text, v: text } variable shape_storage value_cursor
        | {columns_values}: ok
          | {column_spec}
          | | {name_list}
          |   | {name x}
          |   | {name_list}
          |     | {name y}
          |     | {name_list}
          |       | {name u}
          |       | {name_list}
          |         | {name v}
          | {insert_list}: err
            | {from_shape}
              | {name not_a_cursor}: err

The statement ending at line XXXX

CREATE PROC ShapeTrixError4 ()
BEGIN
  INSERT INTO Shape_xy(x, y) VALUES(1, 2), (FROM not_a_cursor LIKE Shape_xy);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name ShapeTrixError4}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {insert_stmt}: err
        | {insert_normal}
        | {name_columns_values}
          | {name Shape_xy}: Shape_xy: { x: integer, y: integer }
          | {columns_values}: ok
            | {column_spec}
            | | {name_list}
            |   | {name x}
            |   | {name_list}
            |     | {name y}
            | {select_stmt}: err
              | {select_core_list}: err
              | | {select_core}: err
              |   | {select_values}
              |   | {values}: err
              |     | {insert_list}: ok
              |     | | {int 1}: integer notnull
              |     | | {insert_list}
              |     |   | {int 2}: integer notnull
              |     | {values}
              |       | {insert_list}: err
              |         | {from_shape}
              |           | {name not_a_cursor}: err
              |           | {shape_def}
              |             | {like}
              |               | {name Shape_xy}
              | {select_orderby}
                | {select_limit}
                  | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT SIGN FUNCTION;

  {enforce_strict_stmt}: ok
  | {int 12}

The statement ending at line XXXX

SELECT sign(-1);

test/sem_test.sql:XXXX:1: error: in call : CQL0452: function may not be used in SQL because it is not supported on old versions of SQLite 'sign'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name sign}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {uminus}: integer notnull
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

LET sign_of_some_value := sign(-42);

  {let_stmt}: sign_of_some_value: integer notnull variable
  | {name sign_of_some_value}: sign_of_some_value: integer notnull variable
  | {call}: integer notnull
    | {name sign}: integer notnull
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {uminus}: integer notnull
          | {int 42}: integer notnull

The statement ending at line XXXX

@ENFORCE_NORMAL SIGN FUNCTION;

  {enforce_normal_stmt}: ok
  | {int 12}

The statement ending at line XXXX

SELECT sign(-1);

  {select_stmt}: select: { _anon: integer notnull }
  | {select_core_list}: select: { _anon: integer notnull }
  | | {select_core}: select: { _anon: integer notnull }
  |   | {select_expr_list_con}: select: { _anon: integer notnull }
  |     | {select_expr_list}: select: { _anon: integer notnull }
  |     | | {select_expr}: integer notnull
  |     |   | {call}: integer notnull
  |     |     | {name sign}: integer notnull
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {uminus}: integer notnull
  |     |           | {int 1}: integer notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE simple_backing_table(
  k BLOB PRIMARY KEY,
  v BLOB NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backing_table}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE simple_backing_table_missing_pk(
  k BLOB NOT NULL,
  v BLOB NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it does not have a primary key 'simple_backing_table_missing_pk'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backing_table_missing_pk}
    | {col_key_list}
      | {col_def}: k: blob notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE simple_backing_table_only_pk(
  k BLOB NOT NULL,
  v BLOB NOT NULL,
  PRIMARY KEY (k, v)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it has only primary key columns 'simple_backing_table_only_pk'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backing_table_only_pk}
    | {col_key_list}
      | {col_def}: k: blob notnull partial_pk
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: v: blob notnull partial_pk
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name v}
        |   | | {type_blob}: blob
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {pk_def}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                | | {name k}: k: blob notnull
                | {indexed_columns}
                  | {indexed_column}
                    | {name v}: v: blob notnull

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE simple_backing_table_expr_key(
  k BLOB,
  v BLOB,
  CONSTRAINT pk1 PRIMARY KEY (length(k))
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it has an expression in its primary key 'length(k)'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backing_table_expr_key}
    | {col_key_list}
      | {col_def}: k: blob
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name k}
      |     | {type_blob}: blob
      | {col_key_list}
        | {col_def}: v: blob
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name v}
        |     | {type_blob}: blob
        | {col_key_list}
          | {pk_def}
            | {name pk1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {call}: integer
                    | {name length}: integer
                    | {call_arg_list}
                      | {call_filter_clause}
                      | {arg_list}: ok
                        | {name k}: k: blob

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE simple_backing_table_with_versions(
  k BLOB NOT NULL,
  v BLOB NOT NULL,
  CONSTRAINT pk_1 PRIMARY KEY (k)
) @CREATE(1) @DELETE(22);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: simple_backing_table_with_versions: { k: blob notnull partial_pk, v: blob notnull } deleted backing @create(1) @delete(22)
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {create_attr}
    | |   | {version_annotation}
    | |   | | {int 1}
    | |   | {delete_attr}
    | |     | {version_annotation}
    | |       | {int 22}
    | | {name simple_backing_table_with_versions}
    | {col_key_list}
      | {col_def}: k: blob notnull partial_pk
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: v: blob notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name v}
        |   | | {type_blob}: blob
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {pk_def}
            | {name pk_1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name k}: k: blob notnull

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE simple_backed_table(
  id INTEGER PRIMARY KEY,
  name TEXT<cool_text> NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: simple_backed_table: { id: integer notnull primary_key, name: text<cool_text> notnull } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backed_table}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: name: text<cool_text> notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name name}
            | | {type_text}: text<cool_text>
            |   | {name cool_text}
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE backed(
  status_id INTEGER PRIMARY KEY,
  global_connection_state LONG_INT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: backed: { status_id: integer notnull primary_key, global_connection_state: longint } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name backed}
    | {col_key_list}
      | {col_def}: status_id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name status_id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: global_connection_state: longint
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name global_connection_state}
              | {type_long}: longint

The statement ending at line XXXX

DECLARE ENUM an_enum INTEGER (
  ONE = 1,
  TWO = 2
);

  {declare_enum_stmt}: an_enum: integer<an_enum> notnull
  | {typed_name}: an_enum: integer<an_enum> notnull
  | | {name an_enum}
  | | {type_int}: an_enum: integer<an_enum> notnull
  | {enum_values}
    | {enum_value}
    | | {name ONE}: integer = 1 notnull
    | | {int 1}: integer notnull
    | {enum_values}
      | {enum_value}
        | {name TWO}: integer = 2 notnull
        | {int 2}: integer notnull

The statement ending at line XXXX

CREATE PROC use_enum_and_backing ()
BEGIN
  WITH
  backed (rowid, status_id, global_connection_state) AS (CALL _backed())
  SELECT 1 AS x
    FROM backed;
END;

  {create_proc_stmt}: use_enum_and_backing: { x: integer<an_enum> notnull } dml_proc
  | {name use_enum_and_backing}: use_enum_and_backing: { x: integer<an_enum> notnull } dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {with_select_stmt}: select: { x: integer<an_enum> notnull }
        | {with}
        | | {cte_tables}: ok
        |   | {cte_table}: backed: { rowid: longint notnull, status_id: integer notnull, global_connection_state: longint }
        |     | {cte_decl}: backed: { rowid: longint notnull, status_id: integer notnull, global_connection_state: longint }
        |     | | {name backed}
        |     | | {name_list}
        |     |   | {name rowid}
        |     |   | {name_list}
        |     |     | {name status_id}
        |     |     | {name_list}
        |     |       | {name global_connection_state}
        |     | {shared_cte}: _backed: { rowid: longint notnull, status_id: integer notnull, global_connection_state: longint } dml_proc
        |       | {call_stmt}: _backed: { rowid: longint notnull, status_id: integer notnull, global_connection_state: longint } dml_proc
        |         | {name _backed}: _backed: { rowid: longint notnull, status_id: integer notnull, global_connection_state: longint } dml_proc
        | {select_stmt}: select: { x: integer<an_enum> notnull }
          | {select_core_list}: select: { x: integer<an_enum> notnull }
          | | {select_core}: select: { x: integer<an_enum> notnull }
          |   | {select_expr_list_con}: select: { x: integer<an_enum> notnull }
          |     | {select_expr_list}: select: { x: integer<an_enum> notnull }
          |     | | {select_expr}: x: integer<an_enum> notnull
          |     |   | {int 1}: integer<an_enum> notnull
          |     |   | {opt_as_alias}
          |     |     | {name x}
          |     | {select_from_etc}: TABLE { backed: backed }
          |       | {table_or_subquery_list}: TABLE { backed: backed }
          |       | | {table_or_subquery}: TABLE { backed: backed }
          |       |   | {name backed}: TABLE { backed: backed }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER bogus_backed_trigger
  BEFORE DELETE ON simple_backed_table
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0493: backed storage tables may not be used in indexes/triggers/drop 'simple_backed_table'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name bogus_backed_trigger}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name simple_backed_table}
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

DROP TABLE simple_backed_table;

test/sem_test.sql:XXXX:1: error: in drop_table_stmt : CQL0493: backed storage tables may not be used in indexes/triggers/drop 'simple_backed_table'

  {drop_table_stmt}: err
  | {name simple_backed_table}

The statement ending at line XXXX

CREATE INDEX oh_no_you_dont ON simple_backed_table (id);

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0493: backed storage tables may not be used in indexes/triggers/drop 'simple_backed_table'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name oh_no_you_dont}
  | | {name simple_backed_table}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE no_pk_backed_table(
  id INTEGER,
  name TEXT NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it does not have a primary key 'no_pk_backed_table'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name no_pk_backed_table}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: name: text notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name name}
            | | {type_text}: text
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE only_pk_backed_table(
  id INTEGER PRIMARY KEY
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it has only primary key columns 'only_pk_backed_table'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name only_pk_backed_table}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id}
          | | {type_int}: integer
          | {col_attrs_pk}: ok
            | {autoinc_and_conflict_clause}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE simple_backed_table_2(
  id INTEGER,
  name TEXT NOT NULL,
  CONSTRAINT pk1 PRIMARY KEY (id)
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: simple_backed_table_2: { id: integer notnull partial_pk, name: text notnull } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backed_table_2}
    | {col_key_list}
      | {col_def}: id: integer notnull partial_pk
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: name: text notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name name}
        |   | | {type_text}: text
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {pk_def}
            | {name pk1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE simple_backed_table_expr_key(
  id INTEGER,
  name TEXT NOT NULL,
  CONSTRAINT pk1 PRIMARY KEY (id / 2)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it has an expression in its primary key 'id / 2'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name simple_backed_table_expr_key}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: name: text notnull
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name name}
        |   | | {type_text}: text
        |   | {col_attrs_not_null}: ok
        | {col_key_list}
          | {pk_def}
            | {name pk1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {div}: integer
                    | {name id}: id: integer
                    | {int 2}: integer notnull

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE simple_backed_table_with_versions(
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
) @CREATE(2) @DELETE(12);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it is declared using schema directives (@create or @delete 'simple_backed_table_with_versions'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {create_attr}
    | |   | {version_annotation}
    | |   | | {int 2}
    | |   | {delete_attr}
    | |     | {version_annotation}
    | |       | {int 12}
    | | {name simple_backed_table_with_versions}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: name: text notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name name}
            | | {type_text}: text
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE has_non_blob_columns(
  id INTEGER PRIMARY KEY,
  v BLOB NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' has a column that is not a blob in 'has_non_blob_columns'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name has_non_blob_columns}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE VIRTUAL TABLE virtual_backing_illegal USING module_name (args) AS (
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_virtual_table_stmt : CQL0483: table is not suitable for use as backing storage: it is a virtual table 'virtual_backing_illegal'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_virtual_table_stmt}: err
    | {module_info}
    | | {name module_name}
    | | {misc_attr_value_list}
    |   | {name args}
    | {create_table_stmt}
      | {create_table_name_flags}
      | | {table_flags_attrs}
      | | | {int 0}
      | | | {recreate_attr}
      | | {name virtual_backing_illegal}
      | {col_key_list}
        | {col_def}
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name id}
        |     | {type_int}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name t}
                | {type_text}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TEMP TABLE temp_backing(
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it is redundantly marked TEMP 'temp_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 1}
    | | {name temp_backing}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE norowid_backing(
  k BLOB,
  v BLOB
) WITHOUT ROWID;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it is redundantly marked WITHOUT ROWID 'norowid_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 4}
    | | {name norowid_backing}
    | {col_key_list}
      | {col_def}: k: blob
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name k}
      |     | {type_blob}: blob
      | {col_key_list}
        | {col_def}: v: blob
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name v}
              | {type_blob}: blob

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE constraint_backing(
  k BLOB PRIMARY KEY,
  v BLOB,
  CONSTRAINT ak1 UNIQUE (v)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it has at least one invalid constraint 'constraint_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name constraint_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name v}
        |     | {type_blob}: blob
        | {col_key_list}
          | {unq_def}
            | {name ak1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name v}: v: blob

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE pk_col_backing(
  k BLOB PRIMARY KEY,
  v BLOB
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: pk_col_backing: { k: blob notnull primary_key, v: blob } backing
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name pk_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name v}
              | {type_blob}: blob

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE fk_col_backing(
  id INTEGER REFERENCES foo (id),
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' has a foreign key in 'fk_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name fk_col_backing}
    | {col_key_list}
      | {col_def}: id: integer foreign_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_fk}: ok
      |     | {fk_target_options}
      |       | {fk_target}
      |       | | {name foo}
      |       | | {name_list}
      |       |   | {name id}: id: integer notnull
      |       | {int 0}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE uk_col_backing(
  id INTEGER UNIQUE,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' has a unique key in 'uk_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name uk_col_backing}
    | {col_key_list}
      | {col_def}: id: integer unique_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_unique}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE hidden_col_backing(
  k BLOB PRIMARY KEY,
  v BLOB HIDDEN NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'v' is a hidden column in 'hidden_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name hidden_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_hidden}: ok
              | {col_attrs_not_null}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE autoinc_col_backing(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  v BLOB NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' specifies auto increment in 'autoinc_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name autoinc_col_backing}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key autoinc
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      |       | {col_attrs_autoinc}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE conflict_clause_col_backing(
  k BLOB PRIMARY KEY ON CONFLICT ABORT,
  v BLOB NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: conflict_clause_col_backing: { k: blob notnull primary_key, v: blob notnull } backing
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name conflict_clause_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      |       | {int 1}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE check_col_backing(
  k BLOB PRIMARY KEY,
  id INTEGER CHECK(id = 5) 
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' has a check expression in 'check_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name check_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: id: integer has_check
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name id}
            | | {type_int}: integer
            | {col_attrs_check}: ok
              | {eq}: bool
                | {name id}: id: integer has_check
                | {int 5}: integer notnull

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE collate_col_backing(
  k BLOB PRIMARY KEY,
  t TEXT COLLATE nocase
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 't' specifies collation order in 'collate_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name collate_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: t: text has_collate
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {col_attrs_collate}: ok
              | {name nocase}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE default_value_col_backing(
  id INTEGER DEFAULT 5,
  v BLOB NOT NULL
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'id' has a default value in 'default_value_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name default_value_col_backing}
    | {col_key_list}
      | {col_def}: id: integer has_default
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_default}: ok
      |     | {int 5}: integer notnull
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE deleted_col_backing(
  k BLOB PRIMARY KEY,
  v BLOB @DELETE(11)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'v' has delete attribute in 'deleted_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name deleted_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob deleted @delete(11)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {delete_attr}: ok
              | {version_annotation}
                | {int 11}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE created_col_backing(
  k BLOB PRIMARY KEY,
  v BLOB @CREATE(11)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: column 'v' has create attribute in 'created_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name created_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob @create(11)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {create_attr}: ok
              | {version_annotation}
                | {int 11}

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE recreate_backing(
  k BLOB PRIMARY KEY,
  v BLOB NOT NULL
) @RECREATE;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: recreate_backing: { k: blob notnull primary_key, v: blob notnull } backing @recreate
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name recreate_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name k}
      |   | | {type_blob}: blob
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: v: blob notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name v}
            | | {type_blob}: blob
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backing_table)
CREATE TABLE one_col_backing(
  k BLOB PRIMARY KEY
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0483: table is not suitable for use as backing storage: it does not have exactly two blob columns 'one_col_backing'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name backing_table}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name one_col_backing}
    | {col_key_list}
      | {col_def}: k: blob notnull primary_key
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name k}
          | | {type_blob}: blob
          | {col_attrs_pk}: ok
            | {autoinc_and_conflict_clause}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE simple_backed_table_versions(
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
) @CREATE(2) @DELETE(12);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it is declared using schema directives (@create or @delete 'simple_backed_table_versions'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {create_attr}
    | |   | {version_annotation}
    | |   | | {int 2}
    | |   | {delete_attr}
    | |     | {version_annotation}
    | |       | {int 12}
    | | {name simple_backed_table_versions}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: name: text notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name name}
            | | {type_text}: text
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE VIRTUAL TABLE virtual_backed_illegal USING module_name (args) AS (
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_virtual_table_stmt : CQL0487: table is not suitable for use as backed storage: it is a virtual table 'virtual_backed_illegal'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_virtual_table_stmt}: err
    | {module_info}
    | | {name module_name}
    | | {misc_attr_value_list}
    |   | {name args}
    | {create_table_stmt}
      | {create_table_name_flags}
      | | {table_flags_attrs}
      | | | {int 0}
      | | | {recreate_attr}
      | | {name virtual_backed_illegal}
      | {col_key_list}
        | {col_def}
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name id}
        |     | {type_int}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name t}
                | {type_text}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TEMP TABLE temp_backed(
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it is redundantly marked TEMP 'temp_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 1}
    | | {name temp_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=not_exists_table)
CREATE TABLE backed_by_not_exists(
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: backing table does not exist 'not_exists_table'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name not_exists_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name backed_by_not_exists}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=foo)
CREATE TABLE backed_by_non_backing(
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: table exists but is not a valid backing table 'foo'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name foo}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name backed_by_non_backing}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE norowid_backed(
  id INTEGER,
  t TEXT
) WITHOUT ROWID;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it is redundantly marked WITHOUT ROWID 'norowid_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 4}
    | | {name norowid_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE constraint_backed(
  id INTEGER,
  t TEXT,
  CONSTRAINT ak1 UNIQUE (id)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: it has at least one invalid constraint 'constraint_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name constraint_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name t}
        |     | {type_text}: text
        | {col_key_list}
          | {unq_def}
            | {name ak1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE pk_col_backed(
  id INTEGER PRIMARY KEY,
  t TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: pk_col_backed: { id: integer notnull primary_key, t: text } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name pk_col_backed}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE fk_col_backed(
  id INTEGER REFERENCES foo (id),
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 'id' has a foreign key in 'fk_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name fk_col_backed}
    | {col_key_list}
      | {col_def}: id: integer foreign_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_fk}: ok
      |     | {fk_target_options}
      |       | {fk_target}
      |       | | {name foo}
      |       | | {name_list}
      |       |   | {name id}: id: integer notnull
      |       | {int 0}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE uk_col_backed(
  id INTEGER UNIQUE,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 'id' has a unique key in 'uk_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name uk_col_backed}
    | {col_key_list}
      | {col_def}: id: integer unique_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_unique}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE hidden_col_backed(
  id INTEGER HIDDEN,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 'id' is a hidden column in 'hidden_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name hidden_col_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_hidden}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE autoinc_col_backed(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 'id' specifies auto increment in 'autoinc_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name autoinc_col_backed}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key autoinc
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      |       | {col_attrs_autoinc}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE conflict_clause_col_backed(
  id INTEGER PRIMARY KEY ON CONFLICT ABORT,
  t TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: conflict_clause_col_backed: { id: integer notnull primary_key, t: text } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name conflict_clause_col_backed}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      |       | {int 1}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE check_col_backed(
  id INTEGER CHECK(id = 5) ,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 'id' has a check expression in 'check_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name check_col_backed}
    | {col_key_list}
      | {col_def}: id: integer has_check
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: ok
      |     | {eq}: bool
      |       | {name id}: id: integer has_check
      |       | {int 5}: integer notnull
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE collate_col_backed(
  id INTEGER,
  t TEXT COLLATE nocase
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 't' specifies collation order in 'collate_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name collate_col_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text has_collate
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {col_attrs_collate}: ok
              | {name nocase}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE default_value_col_backed(
  id INTEGER PRIMARY KEY,
  x INTEGER NOT NULL DEFAULT 7,
  t TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: default_value_col_backed: { id: integer notnull primary_key, x: integer notnull has_default, t: text } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name default_value_col_backed}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: x: integer notnull has_default
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name x}
        |   | | {type_int}: integer
        |   | {col_attrs_not_null}: ok
        |     | {col_attrs_default}
        |       | {int 7}: integer notnull
        | {col_key_list}
          | {col_def}: t: text
            | {col_def_type_attrs}: ok
              | {col_def_name_type}
                | {name t}
                | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE deleted_col_backed(
  id INTEGER,
  t TEXT @DELETE(7)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 't' has delete attribute in 'deleted_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name deleted_col_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text deleted @delete(7)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {delete_attr}: ok
              | {version_annotation}
                | {int 7}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE created_col_backed(
  id INTEGER,
  t TEXT @CREATE(7)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: column 't' has create attribute in 'created_col_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name created_col_backed}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text @create(7)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {create_attr}: ok
              | {version_annotation}
                | {int 7}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE recreate_backed(
  id INTEGER PRIMARY KEY,
  t TEXT
) @RECREATE;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: @recreate attribute doesn't match the backing table 'recreate_backed'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name recreate_backed}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=recreate_backing)
CREATE TABLE recreate_backed_wrong_group(
  id INTEGER PRIMARY KEY,
  t TEXT
) @RECREATE(wrong_group_name);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0487: table is not suitable for use as backed storage: @recreate group doesn't match the backing table 'recreate_backed_wrong_group'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name recreate_backing}: ok
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | |   | {name wrong_group_name}
    | | {name recreate_backed_wrong_group}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE structured_storage(
  id INTEGER NOT NULL,
  name TEXT NOT NULL
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: structured_storage: { id: integer notnull, name: text notnull }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name structured_storage}
    | {col_key_list}
      | {col_def}: id: integer notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: name: text notnull
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name name}
            | | {type_text}: text
            | {col_attrs_not_null}: ok

The statement ending at line XXXX

CREATE PROC blob_serialization_test ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 'foo' AS name;
  FETCH C;
  DECLARE B BLOB<structured_storage>;
  SET B FROM CURSOR C;
  DECLARE D CURSOR LIKE C;
  FETCH D FROM BLOB B;
END;

  {create_proc_stmt}: ok dml_proc
  | {name blob_serialization_test}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_cursor}: C: select: { id: integer notnull, name: text notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage serialize
      | | {select_stmt}: select: { id: integer notnull, name: text notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: text notnull }
      |   | | {select_core}: select: { id: integer notnull, name: text notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: text notnull
      |   |     |     | {strlit 'foo'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | {declare_vars_type}: blob<structured_storage>
      | | {name_list}: B: blob<structured_storage> variable
      | | | {name B}: B: blob<structured_storage> variable
      | | {type_blob}: blob<structured_storage>
      |   | {name structured_storage}
      | {set_blob_from_cursor_stmt}: ok
      | | {name B}: B: blob<structured_storage> variable
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | {declare_cursor_like_name}: D: select: { id: integer notnull, name: text notnull } variable shape_storage value_cursor serialize
      | | {name D}: D: select: { id: integer notnull, name: text notnull } variable shape_storage value_cursor serialize
      | | {shape_def}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage serialize
      |   | {like}: ok
      |     | {name C}
      | {fetch_cursor_from_blob_stmt}: ok
        | {name D}: D: select: { id: integer notnull, name: text notnull } variable shape_storage value_cursor
        | {name B}: B: blob<structured_storage> variable

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE basic_table(
  id INTEGER PRIMARY KEY,
  name TEXT<cool_text>
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: basic_table: { id: integer notnull primary_key, name: text<cool_text> } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name basic_table}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: name: text<cool_text>
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name name}
              | {type_text}: text<cool_text>
                | {name cool_text}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE basic_table2(
  id INTEGER PRIMARY KEY,
  name TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: basic_table2: { id: integer notnull primary_key, name: text } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name basic_table2}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: name: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name name}
              | {type_text}: text

The statement ending at line XXXX

CREATE PROC blob_get_type ()
BEGIN
  DECLARE x BLOB @SENSITIVE;
  LET z := ( SELECT cql_blob_get_type(x) );
END;

  {create_proc_stmt}: ok dml_proc
  | {name blob_get_type}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: blob sensitive
      | | {name_list}: x: blob variable sensitive
      | | | {name x}: x: blob variable sensitive
      | | {sensitive_attr}: blob sensitive
      |   | {type_blob}: blob
      | {let_stmt}: z: longint variable sensitive
        | {name z}: z: longint variable sensitive
        | {select_stmt}: _anon: longint sensitive
          | {select_core_list}: select: { _anon: longint sensitive }
          | | {select_core}: select: { _anon: longint sensitive }
          |   | {select_expr_list_con}: select: { _anon: longint sensitive }
          |     | {select_expr_list}: select: { _anon: longint sensitive }
          |     | | {select_expr}: longint sensitive
          |     |   | {call}: longint sensitive
          |     |     | {name cql_blob_get_type}: longint sensitive
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable sensitive
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_type_wrong_arg_count ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get_type() );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_blob_get_type'

  {create_proc_stmt}: err
  | {name blob_get_type_wrong_arg_count}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get_type}: err
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_type_wrong_arg_type ()
BEGIN
  LET z := ( SELECT cql_blob_get_type(1) );
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0012: incompatible types in expression 'cql_blob_get_type'

  {create_proc_stmt}: err
  | {name blob_get_type_wrong_arg_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get_type}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {int 1}: err
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_type_bad_expr ()
BEGIN
  LET z := ( SELECT cql_blob_get_type(NOT "x") );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_get_type_bad_expr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get_type}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {not}: err
          |     |           | {strlit 'x'}: text notnull
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_type_context_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := cql_blob_get_type(x);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_blob_get_type'

  {create_proc_stmt}: err
  | {name blob_get_type_context_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {call}: err
          | {name cql_blob_get_type}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name x}

The statement ending at line XXXX

CREATE PROC blob_get ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x, basic_table.id) );
END;

  {create_proc_stmt}: ok dml_proc
  | {name blob_get}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: z: integer notnull variable
        | {name z}: z: integer notnull variable
        | {select_stmt}: _anon: integer notnull primary_key
          | {select_core_list}: select: { _anon: integer notnull primary_key }
          | | {select_core}: select: { _anon: integer notnull primary_key }
          |   | {select_expr_list_con}: select: { _anon: integer notnull primary_key }
          |     | {select_expr_list}: select: { _anon: integer notnull primary_key }
          |     | | {select_expr}: integer notnull primary_key
          |     |   | {call}: integer notnull primary_key
          |     |     | {name cql_blob_get}: integer notnull primary_key
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable
          |     |         | {arg_list}
          |     |           | {dot}: integer notnull primary_key
          |     |             | {name basic_table}
          |     |             | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_not_dot_operator ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x, 1 + 2) );
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0490: argument must be table.column where table is a backed table 'cql_blob_get'

  {create_proc_stmt}: err
  | {name blob_get_not_dot_operator}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable
          |     |         | {arg_list}
          |     |           | {add}
          |     |             | {int 1}
          |     |             | {int 2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_table_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x, table_not_exists.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'table_not_exists'

  {create_proc_stmt}: err
  | {name blob_get_table_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable
          |     |         | {arg_list}
          |     |           | {dot}
          |     |             | {name table_not_exists}
          |     |             | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_column_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x, basic_table.col_not_exists) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0489: the indicated column is not present in the named backed storage 'basic_table.col_not_exists'

  {create_proc_stmt}: err
  | {name blob_get_column_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable
          |     |         | {arg_list}
          |     |           | {dot}
          |     |             | {name basic_table}
          |     |             | {name col_not_exists}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_column_wrong_arg_count ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_blob_get'

  {create_proc_stmt}: err
  | {name blob_get_column_wrong_arg_count}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}: err
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_column_context_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := cql_blob_get(x);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_blob_get'

  {create_proc_stmt}: err
  | {name blob_get_column_context_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {call}: err
          | {name cql_blob_get}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name x}

The statement ending at line XXXX

CREATE PROC blob_get_column_wrong_arg_type ()
BEGIN
  LET z := ( SELECT cql_blob_get(1, basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0012: incompatible types in expression 'cql_blob_get'

  {create_proc_stmt}: err
  | {name blob_get_column_wrong_arg_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {int 1}: err
          |     |         | {arg_list}
          |     |           | {dot}
          |     |             | {name basic_table}
          |     |             | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_column_bad_expr ()
BEGIN
  LET z := ( SELECT cql_blob_get(NOT "x", basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_get_column_bad_expr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {not}: err
          |     |         | | {strlit 'x'}: text notnull
          |     |         | {arg_list}
          |     |           | {dot}
          |     |             | {name basic_table}
          |     |             | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_get_not_backed_table ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_get(x, simple_backing_table.k) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0488: the indicated table is not declared for backed storage 'simple_backing_table'

  {create_proc_stmt}: err
  | {name blob_get_not_backed_table}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_get}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name x}: x: blob variable
          |     |         | {arg_list}
          |     |           | {dot}
          |     |             | {name simple_backing_table}
          |     |             | {name k}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, basic_table.id) );
END;

  {create_proc_stmt}: ok dml_proc
  | {name blob_update}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: z: blob notnull variable
        | {name z}: z: blob notnull variable
        | {select_stmt}: _anon: blob notnull
          | {select_core_list}: select: { _anon: blob notnull }
          | | {select_core}: select: { _anon: blob notnull }
          |   | {select_expr_list_con}: select: { _anon: blob notnull }
          |     | {select_expr_list}: select: { _anon: blob notnull }
          |     | | {select_expr}: blob notnull
          |     |   | {call}: blob notnull
          |     |     | {name cql_blob_update}: blob notnull
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_bogus_arg1 ()
BEGIN
  LET z := ( SELECT cql_blob_update(NOT 'x', 1, basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_update_bogus_arg1}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {not}: err
          |     |         | | {strlit 'x'}: text notnull
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_different_tables ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, basic_table.id, 2, basic_table2.id) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0488: the indicated table is not consistently used through all of cql_blob_update 'basic_table2'

  {create_proc_stmt}: err
  | {name blob_update_different_tables}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |             | | {name basic_table}
          |     |             | | {name id}
          |     |             | {arg_list}
          |     |               | {int 2}: integer notnull
          |     |               | {arg_list}
          |     |                 | {dot}
          |     |                   | {name basic_table2}
          |     |                   | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_arg_one_error ()
BEGIN
  DECLARE not_a_blob INTEGER;
  LET z := ( SELECT cql_blob_update(not_a_blob, 1, basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0012: incompatible types in expression 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_arg_one_error}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: integer
      | | {name_list}: not_a_blob: integer variable
      | | | {name not_a_blob}: not_a_blob: integer variable
      | | {type_int}: integer
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name not_a_blob}: err
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_not_dot_operator ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, 1 + 2) );
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0490: argument must be table.column where table is a backed table 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_not_dot_operator}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {add}
          |     |               | {int 1}
          |     |               | {int 2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_not_dot_operator_later_arg ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, basic_table.id, 2, 1 + 2) );
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0257: argument must be table.column where table is a backed table 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_not_dot_operator_later_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |             | | {name basic_table}
          |     |             | | {name id}
          |     |             | {arg_list}
          |     |               | {int 2}: integer notnull
          |     |               | {arg_list}
          |     |                 | {add}
          |     |                   | {int 1}
          |     |                   | {int 2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_table_wrong ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, table_not_exists.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'table_not_exists'

  {create_proc_stmt}: err
  | {name blob_update_table_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name table_not_exists}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_table_wrong_later_arg ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, basic_table.id, 2, table_not_exists.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'table_not_exists'

  {create_proc_stmt}: err
  | {name blob_update_table_wrong_later_arg}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |             | | {name basic_table}
          |     |             | | {name id}
          |     |             | {arg_list}
          |     |               | {int 2}: integer notnull
          |     |               | {arg_list}
          |     |                 | {dot}
          |     |                   | {name table_not_exists}
          |     |                   | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_column_wrong ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, 1, basic_table.col_not_exists) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0489: the indicated column is not present in the named backed storage 'basic_table.col_not_exists'

  {create_proc_stmt}: err
  | {name blob_update_column_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name col_not_exists}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_column_wrong_arg_count ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_column_wrong_arg_count}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}: err
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_column_context_wrong ()
BEGIN
  DECLARE b BLOB;
  LET z := cql_blob_update(x);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_column_context_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {call}: err
          | {name cql_blob_update}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name x}

The statement ending at line XXXX

CREATE PROC blob_update_column_wrong_arg_type ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, "x", basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'cql_blob_update'

  {create_proc_stmt}: err
  | {name blob_update_column_wrong_arg_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {strlit 'x'}: err
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_column_bad_expr ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, NOT "x", basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_update_column_bad_expr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {not}: err
          |     |           | | {strlit 'x'}: text notnull
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_update_not_backed_table ()
BEGIN
  DECLARE b BLOB;
  LET z := ( SELECT cql_blob_update(b, x, simple_backing_table.k) );
END;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0488: the indicated table is not declared for backed storage 'simple_backing_table'

  {create_proc_stmt}: err
  | {name blob_update_not_backed_table}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: b: blob variable
      | | | {name b}: b: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_update}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name b}: b: blob variable
          |     |         | {arg_list}
          |     |           | {name x}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name simple_backing_table}
          |     |               | {name k}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:backed_by=simple_backing_table)
CREATE TABLE bt_default(
  pk1 INTEGER DEFAULT 2222,
  pk2 INTEGER DEFAULT 99,
  x INTEGER DEFAULT 1111,
  y INTEGER DEFAULT 42,
  CONSTRAINT pk PRIMARY KEY (pk1, pk2)
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name backed_by}
  |   | {name simple_backing_table}: ok
  | {create_table_stmt}: bt_default: { pk1: integer notnull has_default partial_pk, pk2: integer notnull has_default partial_pk, x: integer has_default, y: integer has_default } backed
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name bt_default}
    | {col_key_list}
      | {col_def}: pk1: integer notnull has_default partial_pk
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name pk1}
      |   | | {type_int}: integer
      |   | {col_attrs_default}: ok
      |     | {int 2222}: integer notnull
      | {col_key_list}
        | {col_def}: pk2: integer notnull has_default partial_pk
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |   | | {name pk2}
        |   | | {type_int}: integer
        |   | {col_attrs_default}: ok
        |     | {int 99}: integer notnull
        | {col_key_list}
          | {col_def}: x: integer has_default
          | | {col_def_type_attrs}: ok
          |   | {col_def_name_type}
          |   | | {name x}
          |   | | {type_int}: integer
          |   | {col_attrs_default}: ok
          |     | {int 1111}: integer notnull
          | {col_key_list}
            | {col_def}: y: integer has_default
            | | {col_def_type_attrs}: ok
            |   | {col_def_name_type}
            |   | | {name y}
            |   | | {type_int}: integer
            |   | {col_attrs_default}: ok
            |     | {int 42}: integer notnull
            | {col_key_list}
              | {pk_def}
                | {name pk}
                | {indexed_columns_conflict_clause}
                  | {indexed_columns}
                    | {indexed_column}
                    | | {name pk1}: pk1: integer
                    | {indexed_columns}
                      | {indexed_column}
                        | {name pk2}: pk2: integer

The statement ending at line XXXX

WITH
_vals (pk1, x) AS (VALUES(1, 2))
INSERT INTO simple_backing_table(k, v) SELECT cql_blob_create(bt_default, V.pk1, bt_default.pk1, 99, bt_default.pk2), cql_blob_create(bt_default, V.x, bt_default.x, 42, bt_default.y)
  FROM _vals AS V;

  {with_insert_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: _vals: { pk1: integer notnull, x: integer notnull }
  |     | {cte_decl}: _vals: { pk1: integer notnull, x: integer notnull }
  |     | | {name _vals}
  |     | | {name_list}
  |     |   | {name pk1}: pk1: integer notnull partial_pk
  |     |   | {name_list}
  |     |     | {name x}: x: integer
  |     | {select_stmt}: values: { column1: integer notnull, column2: integer notnull }
  |       | {select_core_list}: values: { column1: integer notnull, column2: integer notnull }
  |       | | {select_core}: values: { column1: integer notnull, column2: integer notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull, column2: integer notnull }
  |       |     | {insert_list}: ok
  |       |       | {int 1}: integer notnull
  |       |       | {insert_list}
  |       |         | {int 2}: integer notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {insert_stmt}: ok
    | {insert_normal}
    | {name_columns_values}
      | {name simple_backing_table}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
      | {columns_values}: ok
        | {column_spec}
        | | {name_list}
        |   | {name k}: k: blob notnull
        |   | {name_list}
        |     | {name v}: v: blob notnull
        | {select_stmt}: select: { _anon: blob notnull, _anon: blob notnull }
          | {select_core_list}: select: { _anon: blob notnull, _anon: blob notnull }
          | | {select_core}: select: { _anon: blob notnull, _anon: blob notnull }
          |   | {select_expr_list_con}: select: { _anon: blob notnull, _anon: blob notnull }
          |     | {select_expr_list}: select: { _anon: blob notnull, _anon: blob notnull }
          |     | | {select_expr}: blob notnull
          |     | | | {call}: blob notnull
          |     | |   | {name cql_blob_create}: blob notnull
          |     | |   | {call_arg_list}
          |     | |     | {call_filter_clause}
          |     | |     | {arg_list}: ok
          |     | |       | {name bt_default}
          |     | |       | {arg_list}
          |     | |         | {dot}: pk1: integer notnull
          |     | |         | | {name V}
          |     | |         | | {name pk1}
          |     | |         | {arg_list}
          |     | |           | {dot}: integer notnull has_default partial_pk
          |     | |           | | {name bt_default}
          |     | |           | | {name pk1}
          |     | |           | {arg_list}
          |     | |             | {int 99}: integer notnull
          |     | |             | {arg_list}
          |     | |               | {dot}: integer notnull has_default partial_pk
          |     | |                 | {name bt_default}
          |     | |                 | {name pk2}
          |     | | {select_expr_list}
          |     |   | {select_expr}: blob notnull
          |     |     | {call}: blob notnull
          |     |       | {name cql_blob_create}: blob notnull
          |     |       | {call_arg_list}
          |     |         | {call_filter_clause}
          |     |         | {arg_list}: ok
          |     |           | {name bt_default}
          |     |           | {arg_list}
          |     |             | {dot}: x: integer notnull
          |     |             | | {name V}
          |     |             | | {name x}
          |     |             | {arg_list}
          |     |               | {dot}: integer has_default
          |     |               | | {name bt_default}
          |     |               | | {name x}
          |     |               | {arg_list}
          |     |                 | {int 42}: integer notnull
          |     |                 | {arg_list}
          |     |                   | {dot}: integer has_default
          |     |                     | {name bt_default}
          |     |                     | {name y}
          |     | {select_from_etc}: TABLE { V: _vals }
          |       | {table_or_subquery_list}: TABLE { V: _vals }
          |       | | {table_or_subquery}: TABLE { V: _vals }
          |       |   | {name _vals}: TABLE { V: _vals }
          |       |   | {opt_as_alias}
          |       |     | {name V}
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

WITH
_vals (id, name) AS (VALUES(1, 'foo'))
INSERT INTO simple_backing_table(k, v) SELECT cql_blob_create(basic_table, V.id, basic_table.id), cql_blob_create(basic_table, V.name, basic_table.name)
  FROM _vals AS V
ON CONFLICT (k) DO NOTHING;

  {with_upsert_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: _vals: { id: integer notnull, name: text notnull }
  |     | {cte_decl}: _vals: { id: integer notnull, name: text notnull }
  |     | | {name _vals}
  |     | | {name_list}
  |     |   | {name id}: id: integer notnull
  |     |   | {name_list}
  |     |     | {name name}: name: text<cool_text>
  |     | {select_stmt}: values: { column1: integer notnull, column2: text notnull }
  |       | {select_core_list}: values: { column1: integer notnull, column2: text notnull }
  |       | | {select_core}: values: { column1: integer notnull, column2: text notnull }
  |       |   | {select_values}
  |       |   | {values}: values: { column1: integer notnull, column2: text notnull }
  |       |     | {insert_list}: ok
  |       |       | {int 1}: integer notnull
  |       |       | {insert_list}
  |       |         | {strlit 'foo'}: text notnull
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_stmt}: ok
    | {insert_stmt}: ok
    | | {insert_normal}
    | | {name_columns_values}
    |   | {name simple_backing_table}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
    |   | {columns_values}: ok
    |     | {column_spec}
    |     | | {name_list}
    |     |   | {name k}: k: blob notnull
    |     |   | {name_list}
    |     |     | {name v}: v: blob notnull
    |     | {select_stmt}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | {select_core_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | | {select_core}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |   | {select_expr_list_con}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | {select_expr_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | | {select_expr}: blob notnull
    |       |     | | | {call}: blob notnull
    |       |     | |   | {name cql_blob_create}: blob notnull
    |       |     | |   | {call_arg_list}
    |       |     | |     | {call_filter_clause}
    |       |     | |     | {arg_list}: ok
    |       |     | |       | {name basic_table}
    |       |     | |       | {arg_list}
    |       |     | |         | {dot}: id: integer notnull
    |       |     | |         | | {name V}
    |       |     | |         | | {name id}
    |       |     | |         | {arg_list}
    |       |     | |           | {dot}: integer notnull primary_key
    |       |     | |             | {name basic_table}
    |       |     | |             | {name id}
    |       |     | | {select_expr_list}
    |       |     |   | {select_expr}: blob notnull
    |       |     |     | {call}: blob notnull
    |       |     |       | {name cql_blob_create}: blob notnull
    |       |     |       | {call_arg_list}
    |       |     |         | {call_filter_clause}
    |       |     |         | {arg_list}: ok
    |       |     |           | {name basic_table}
    |       |     |           | {arg_list}
    |       |     |             | {dot}: name: text notnull
    |       |     |             | | {name V}
    |       |     |             | | {name name}
    |       |     |             | {arg_list}
    |       |     |               | {dot}: text
    |       |     |                 | {name basic_table}
    |       |     |                 | {name name}
    |       |     | {select_from_etc}: TABLE { V: _vals }
    |       |       | {table_or_subquery_list}: TABLE { V: _vals }
    |       |       | | {table_or_subquery}: TABLE { V: _vals }
    |       |       |   | {name _vals}: TABLE { V: _vals }
    |       |       |   | {opt_as_alias}
    |       |       |     | {name V}
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {upsert_update}: ok
      | {conflict_target}: excluded: { k: blob notnull, v: blob notnull }
        | {indexed_columns}
          | {indexed_column}
            | {name k}: k: blob notnull

The statement ending at line XXXX

WITH
basic_table (rowid, id, name) AS (CALL _basic_table()),
_vals (id, name) AS (SELECT id + 3, name
  FROM basic_table
  WHERE id < 100)
INSERT INTO simple_backing_table(k, v) SELECT cql_blob_create(basic_table, V.id, basic_table.id), cql_blob_create(basic_table, V.name, basic_table.name)
  FROM _vals AS V
ON CONFLICT (k) DO UPDATE
SET k = cql_blob_update(k, cql_blob_get(k, basic_table.id) + 1, basic_table.id)
  WHERE rowid IN (SELECT rowid
  FROM basic_table
  WHERE id < 100);

  {with_upsert_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> }
  |   | | {cte_decl}: basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> }
  |   | | | {name basic_table}
  |   | | | {name_list}
  |   | |   | {name rowid}
  |   | |   | {name_list}
  |   | |     | {name id}
  |   | |     | {name_list}
  |   | |       | {name name}
  |   | | {shared_cte}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   |   | {call_stmt}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   |     | {name _basic_table}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   | {cte_tables}
  |     | {cte_table}: _vals: { id: integer notnull, name: text<cool_text> }
  |       | {cte_decl}: _vals: { id: integer notnull, name: text<cool_text> }
  |       | | {name _vals}
  |       | | {name_list}
  |       |   | {name id}: id: integer notnull
  |       |   | {name_list}
  |       |     | {name name}: name: text<cool_text>
  |       | {select_stmt}: select: { _anon: integer notnull, name: text<cool_text> }
  |         | {select_core_list}: select: { _anon: integer notnull, name: text<cool_text> }
  |         | | {select_core}: select: { _anon: integer notnull, name: text<cool_text> }
  |         |   | {select_expr_list_con}: select: { _anon: integer notnull, name: text<cool_text> }
  |         |     | {select_expr_list}: select: { _anon: integer notnull, name: text<cool_text> }
  |         |     | | {select_expr}: integer notnull
  |         |     | | | {add}: integer notnull
  |         |     | |   | {name id}: id: integer notnull
  |         |     | |   | {int 3}: integer notnull
  |         |     | | {select_expr_list}
  |         |     |   | {select_expr}: name: text<cool_text>
  |         |     |     | {name name}: name: text<cool_text>
  |         |     | {select_from_etc}: TABLE { basic_table: basic_table }
  |         |       | {table_or_subquery_list}: TABLE { basic_table: basic_table }
  |         |       | | {table_or_subquery}: TABLE { basic_table: basic_table }
  |         |       |   | {name basic_table}: TABLE { basic_table: basic_table }
  |         |       | {select_where}
  |         |         | {opt_where}: bool notnull
  |         |         | | {lt}: bool notnull
  |         |         |   | {name id}: id: integer notnull
  |         |         |   | {int 100}: integer notnull
  |         |         | {select_groupby}
  |         |           | {select_having}
  |         | {select_orderby}
  |           | {select_limit}
  |             | {select_offset}
  | {upsert_stmt}: ok
    | {insert_stmt}: ok
    | | {insert_normal}
    | | {name_columns_values}
    |   | {name simple_backing_table}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
    |   | {columns_values}: ok
    |     | {column_spec}
    |     | | {name_list}
    |     |   | {name k}: k: blob notnull
    |     |   | {name_list}
    |     |     | {name v}: v: blob notnull
    |     | {select_stmt}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | {select_core_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | | {select_core}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |   | {select_expr_list_con}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | {select_expr_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | | {select_expr}: blob notnull
    |       |     | | | {call}: blob notnull
    |       |     | |   | {name cql_blob_create}: blob notnull
    |       |     | |   | {call_arg_list}
    |       |     | |     | {call_filter_clause}
    |       |     | |     | {arg_list}: ok
    |       |     | |       | {name basic_table}
    |       |     | |       | {arg_list}
    |       |     | |         | {dot}: id: integer notnull
    |       |     | |         | | {name V}
    |       |     | |         | | {name id}
    |       |     | |         | {arg_list}
    |       |     | |           | {dot}: integer notnull primary_key
    |       |     | |             | {name basic_table}
    |       |     | |             | {name id}
    |       |     | | {select_expr_list}
    |       |     |   | {select_expr}: blob notnull
    |       |     |     | {call}: blob notnull
    |       |     |       | {name cql_blob_create}: blob notnull
    |       |     |       | {call_arg_list}
    |       |     |         | {call_filter_clause}
    |       |     |         | {arg_list}: ok
    |       |     |           | {name basic_table}
    |       |     |           | {arg_list}
    |       |     |             | {dot}: name: text<cool_text>
    |       |     |             | | {name V}
    |       |     |             | | {name name}
    |       |     |             | {arg_list}
    |       |     |               | {dot}: text
    |       |     |                 | {name basic_table}
    |       |     |                 | {name name}
    |       |     | {select_from_etc}: TABLE { V: _vals }
    |       |       | {table_or_subquery_list}: TABLE { V: _vals }
    |       |       | | {table_or_subquery}: TABLE { V: _vals }
    |       |       |   | {name _vals}: TABLE { V: _vals }
    |       |       |   | {opt_as_alias}
    |       |       |     | {name V}
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {upsert_update}: ok
      | {conflict_target}: excluded: { k: blob notnull, v: blob notnull }
      | | {indexed_columns}
      |   | {indexed_column}
      |     | {name k}: k: blob notnull
      | {update_stmt}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
        | {update_set}
          | {update_list}: ok
          | | {update_entry}: k: blob notnull
          |   | {name k}: k: blob notnull
          |   | {call}: blob notnull
          |     | {name cql_blob_update}: blob notnull
          |     | {call_arg_list}
          |       | {call_filter_clause}
          |       | {arg_list}: ok
          |         | {name k}: k: blob notnull
          |         | {arg_list}
          |           | {add}: integer notnull
          |           | | {call}: integer notnull primary_key
          |           | | | {name cql_blob_get}: integer notnull primary_key
          |           | | | {call_arg_list}
          |           | |   | {call_filter_clause}
          |           | |   | {arg_list}: ok
          |           | |     | {name k}: k: blob notnull
          |           | |     | {arg_list}
          |           | |       | {dot}: integer notnull primary_key
          |           | |         | {name basic_table}
          |           | |         | {name id}
          |           | | {int 1}: integer notnull
          |           | {arg_list}
          |             | {dot}: integer notnull primary_key
          |               | {name basic_table}
          |               | {name id}
          | {update_from}
            | {update_where}
              | {opt_where}: bool notnull
              | | {in_pred}: bool notnull
              |   | {name rowid}: rowid: longint notnull
              |   | {select_stmt}: rowid: longint
              |     | {select_core_list}: select: { rowid: longint notnull }
              |     | | {select_core}: select: { rowid: longint notnull }
              |     |   | {select_expr_list_con}: select: { rowid: longint notnull }
              |     |     | {select_expr_list}: select: { rowid: longint notnull }
              |     |     | | {select_expr}: rowid: longint notnull
              |     |     |   | {name rowid}: rowid: longint notnull
              |     |     | {select_from_etc}: TABLE { basic_table: basic_table }
              |     |       | {table_or_subquery_list}: TABLE { basic_table: basic_table }
              |     |       | | {table_or_subquery}: TABLE { basic_table: basic_table }
              |     |       |   | {name basic_table}: TABLE { basic_table: basic_table }
              |     |       | {select_where}
              |     |         | {opt_where}: bool notnull
              |     |         | | {lt}: bool notnull
              |     |         |   | {name id}: id: integer notnull
              |     |         |   | {int 100}: integer notnull
              |     |         | {select_groupby}
              |     |           | {select_having}
              |     | {select_orderby}
              |       | {select_limit}
              |         | {select_offset}
              | {update_orderby}

The statement ending at line XXXX

INSERT INTO bogus_table_not_present VALUES(1, 2)
ON CONFLICT (id) DO NOTHING;

test/sem_test.sql:XXXX:1: error: in str : CQL0160: table in insert statement does not exist 'bogus_table_not_present'

  {upsert_stmt}: err
  | {insert_stmt}
  | | {insert_normal}
  | | {name_columns_values}
  |   | {name bogus_table_not_present}
  |   | {columns_values}
  |     | {select_stmt}
  |       | {select_core_list}
  |       | | {select_core}
  |       |   | {select_values}
  |       |   | {values}
  |       |     | {insert_list}
  |       |       | {int 1}
  |       |       | {insert_list}
  |       |         | {int 2}
  |       | {select_orderby}
  |         | {select_limit}
  |           | {select_offset}
  | {upsert_update}
    | {conflict_target}
      | {indexed_columns}
        | {indexed_column}
          | {name id}

The statement ending at line XXXX

WITH
basic_table (rowid, id, name) AS (CALL _basic_table()),
a_useless_cte (x, y) AS (SELECT 1, 2),
_vals (id, name) AS (SELECT id + 3, name
  FROM basic_table
  WHERE id < 100)
INSERT INTO simple_backing_table(k, v) SELECT cql_blob_create(basic_table, V.id, basic_table.id), cql_blob_create(basic_table, V.name, basic_table.name)
  FROM _vals AS V
ON CONFLICT (k) DO UPDATE
SET k = cql_blob_update(k, cql_blob_get(k, basic_table.id) + 1, basic_table.id)
  WHERE rowid IN (SELECT rowid
  FROM basic_table
  WHERE id < 100);

  {with_upsert_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> }
  |   | | {cte_decl}: basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> }
  |   | | | {name basic_table}
  |   | | | {name_list}
  |   | |   | {name rowid}
  |   | |   | {name_list}
  |   | |     | {name id}
  |   | |     | {name_list}
  |   | |       | {name name}
  |   | | {shared_cte}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   |   | {call_stmt}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   |     | {name _basic_table}: _basic_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> } dml_proc
  |   | {cte_tables}: ok
  |     | {cte_table}: a_useless_cte: { x: integer notnull, y: integer notnull }
  |     | | {cte_decl}: a_useless_cte: { x: integer notnull, y: integer notnull }
  |     | | | {name a_useless_cte}
  |     | | | {name_list}
  |     | |   | {name x}
  |     | |   | {name_list}
  |     | |     | {name y}
  |     | | {select_stmt}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |   | {select_core_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |   | | {select_core}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |   |   | {select_expr_list_con}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |   |     | {select_expr_list}: select: { _anon: integer notnull, _anon: integer notnull }
  |     |   |     | | {select_expr}: integer notnull
  |     |   |     | | | {int 1}: integer notnull
  |     |   |     | | {select_expr_list}
  |     |   |     |   | {select_expr}: integer notnull
  |     |   |     |     | {int 2}: integer notnull
  |     |   |     | {select_from_etc}: ok
  |     |   |       | {select_where}
  |     |   |         | {select_groupby}
  |     |   |           | {select_having}
  |     |   | {select_orderby}
  |     |     | {select_limit}
  |     |       | {select_offset}
  |     | {cte_tables}
  |       | {cte_table}: _vals: { id: integer notnull, name: text<cool_text> }
  |         | {cte_decl}: _vals: { id: integer notnull, name: text<cool_text> }
  |         | | {name _vals}
  |         | | {name_list}
  |         |   | {name id}: id: integer notnull
  |         |   | {name_list}
  |         |     | {name name}: name: text<cool_text>
  |         | {select_stmt}: select: { _anon: integer notnull, name: text<cool_text> }
  |           | {select_core_list}: select: { _anon: integer notnull, name: text<cool_text> }
  |           | | {select_core}: select: { _anon: integer notnull, name: text<cool_text> }
  |           |   | {select_expr_list_con}: select: { _anon: integer notnull, name: text<cool_text> }
  |           |     | {select_expr_list}: select: { _anon: integer notnull, name: text<cool_text> }
  |           |     | | {select_expr}: integer notnull
  |           |     | | | {add}: integer notnull
  |           |     | |   | {name id}: id: integer notnull
  |           |     | |   | {int 3}: integer notnull
  |           |     | | {select_expr_list}
  |           |     |   | {select_expr}: name: text<cool_text>
  |           |     |     | {name name}: name: text<cool_text>
  |           |     | {select_from_etc}: TABLE { basic_table: basic_table }
  |           |       | {table_or_subquery_list}: TABLE { basic_table: basic_table }
  |           |       | | {table_or_subquery}: TABLE { basic_table: basic_table }
  |           |       |   | {name basic_table}: TABLE { basic_table: basic_table }
  |           |       | {select_where}
  |           |         | {opt_where}: bool notnull
  |           |         | | {lt}: bool notnull
  |           |         |   | {name id}: id: integer notnull
  |           |         |   | {int 100}: integer notnull
  |           |         | {select_groupby}
  |           |           | {select_having}
  |           | {select_orderby}
  |             | {select_limit}
  |               | {select_offset}
  | {upsert_stmt}: ok
    | {insert_stmt}: ok
    | | {insert_normal}
    | | {name_columns_values}
    |   | {name simple_backing_table}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
    |   | {columns_values}: ok
    |     | {column_spec}
    |     | | {name_list}
    |     |   | {name k}: k: blob notnull
    |     |   | {name_list}
    |     |     | {name v}: v: blob notnull
    |     | {select_stmt}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | {select_core_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       | | {select_core}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |   | {select_expr_list_con}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | {select_expr_list}: select: { _anon: blob notnull, _anon: blob notnull }
    |       |     | | {select_expr}: blob notnull
    |       |     | | | {call}: blob notnull
    |       |     | |   | {name cql_blob_create}: blob notnull
    |       |     | |   | {call_arg_list}
    |       |     | |     | {call_filter_clause}
    |       |     | |     | {arg_list}: ok
    |       |     | |       | {name basic_table}
    |       |     | |       | {arg_list}
    |       |     | |         | {dot}: id: integer notnull
    |       |     | |         | | {name V}
    |       |     | |         | | {name id}
    |       |     | |         | {arg_list}
    |       |     | |           | {dot}: integer notnull primary_key
    |       |     | |             | {name basic_table}
    |       |     | |             | {name id}
    |       |     | | {select_expr_list}
    |       |     |   | {select_expr}: blob notnull
    |       |     |     | {call}: blob notnull
    |       |     |       | {name cql_blob_create}: blob notnull
    |       |     |       | {call_arg_list}
    |       |     |         | {call_filter_clause}
    |       |     |         | {arg_list}: ok
    |       |     |           | {name basic_table}
    |       |     |           | {arg_list}
    |       |     |             | {dot}: name: text<cool_text>
    |       |     |             | | {name V}
    |       |     |             | | {name name}
    |       |     |             | {arg_list}
    |       |     |               | {dot}: text
    |       |     |                 | {name basic_table}
    |       |     |                 | {name name}
    |       |     | {select_from_etc}: TABLE { V: _vals }
    |       |       | {table_or_subquery_list}: TABLE { V: _vals }
    |       |       | | {table_or_subquery}: TABLE { V: _vals }
    |       |       |   | {name _vals}: TABLE { V: _vals }
    |       |       |   | {opt_as_alias}
    |       |       |     | {name V}
    |       |       | {select_where}
    |       |         | {select_groupby}
    |       |           | {select_having}
    |       | {select_orderby}
    |         | {select_limit}
    |           | {select_offset}
    | {upsert_update}: ok
      | {conflict_target}: excluded: { k: blob notnull, v: blob notnull }
      | | {indexed_columns}
      |   | {indexed_column}
      |     | {name k}: k: blob notnull
      | {update_stmt}: simple_backing_table: { k: blob notnull primary_key, v: blob notnull } backing
        | {update_set}
          | {update_list}: ok
          | | {update_entry}: k: blob notnull
          |   | {name k}: k: blob notnull
          |   | {call}: blob notnull
          |     | {name cql_blob_update}: blob notnull
          |     | {call_arg_list}
          |       | {call_filter_clause}
          |       | {arg_list}: ok
          |         | {name k}: k: blob notnull
          |         | {arg_list}
          |           | {add}: integer notnull
          |           | | {call}: integer notnull primary_key
          |           | | | {name cql_blob_get}: integer notnull primary_key
          |           | | | {call_arg_list}
          |           | |   | {call_filter_clause}
          |           | |   | {arg_list}: ok
          |           | |     | {name k}: k: blob notnull
          |           | |     | {arg_list}
          |           | |       | {dot}: integer notnull primary_key
          |           | |         | {name basic_table}
          |           | |         | {name id}
          |           | | {int 1}: integer notnull
          |           | {arg_list}
          |             | {dot}: integer notnull primary_key
          |               | {name basic_table}
          |               | {name id}
          | {update_from}
            | {update_where}
              | {opt_where}: bool notnull
              | | {in_pred}: bool notnull
              |   | {name rowid}: rowid: longint notnull
              |   | {select_stmt}: rowid: longint
              |     | {select_core_list}: select: { rowid: longint notnull }
              |     | | {select_core}: select: { rowid: longint notnull }
              |     |   | {select_expr_list_con}: select: { rowid: longint notnull }
              |     |     | {select_expr_list}: select: { rowid: longint notnull }
              |     |     | | {select_expr}: rowid: longint notnull
              |     |     |   | {name rowid}: rowid: longint notnull
              |     |     | {select_from_etc}: TABLE { basic_table: basic_table }
              |     |       | {table_or_subquery_list}: TABLE { basic_table: basic_table }
              |     |       | | {table_or_subquery}: TABLE { basic_table: basic_table }
              |     |       |   | {name basic_table}: TABLE { basic_table: basic_table }
              |     |       | {select_where}
              |     |         | {opt_where}: bool notnull
              |     |         | | {lt}: bool notnull
              |     |         |   | {name id}: id: integer notnull
              |     |         |   | {int 100}: integer notnull
              |     |         | {select_groupby}
              |     |           | {select_having}
              |     | {select_orderby}
              |       | {select_limit}
              |         | {select_offset}
              | {update_orderby}

The statement ending at line XXXX

CREATE PROC blob_create ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, 1, basic_table.id) );
END;

  {create_proc_stmt}: ok dml_proc
  | {name blob_create}: ok dml_proc
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {let_stmt}: z: blob notnull variable
        | {name z}: z: blob notnull variable
        | {select_stmt}: _anon: blob notnull
          | {select_core_list}: select: { _anon: blob notnull }
          | | {select_core}: select: { _anon: blob notnull }
          |   | {select_expr_list_con}: select: { _anon: blob notnull }
          |     | {select_expr_list}: select: { _anon: blob notnull }
          |     | | {select_expr}: blob notnull
          |     |   | {call}: blob notnull
          |     |     | {name cql_blob_create}: blob notnull
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_not_a_string ()
BEGIN
  LET z := ( SELECT cql_blob_create(1, 1, basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0491: argument 1 must be a table name that is a backed table 'cql_blob_create'

  {create_proc_stmt}: err
  | {name blob_create_not_a_string}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {int 1}
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_different_tables ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, 1, basic_table.id, 2, basic_table2.id) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0488: the indicated table is not consistently used through all of cql_blob_create 'basic_table2'

  {create_proc_stmt}: err
  | {name blob_create_different_tables}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}: integer notnull primary_key
          |     |             | | {name basic_table}
          |     |             | | {name id}
          |     |             | {arg_list}
          |     |               | {int 2}: integer notnull
          |     |               | {arg_list}
          |     |                 | {dot}
          |     |                   | {name basic_table2}
          |     |                   | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_arg_one_error ()
BEGIN
  LET z := ( SELECT cql_blob_create(not_a_table, 1, basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'not_a_table'

  {create_proc_stmt}: err
  | {name blob_create_arg_one_error}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name not_a_table}
          |     |         | {arg_list}
          |     |           | {int 1}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_not_dot_operator ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, 1, 1 + 2) );
END;

test/sem_test.sql:XXXX:1: error: in add : CQL0490: argument must be table.column where table is a backed table 'cql_blob_create'

  {create_proc_stmt}: err
  | {name blob_create_not_dot_operator}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {add}
          |     |               | {int 1}
          |     |               | {int 2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_table_wrong ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, 1, table_not_exists.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0095: table/view not defined 'table_not_exists'

  {create_proc_stmt}: err
  | {name blob_create_table_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name table_not_exists}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_column_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_create(basic_table, 1, basic_table.col_not_exists) );
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0489: the indicated column is not present in the named backed storage 'basic_table.col_not_exists'

  {create_proc_stmt}: err
  | {name blob_create_column_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {int 1}: integer notnull
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name col_not_exists}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_column_wrong_arg_count ()
BEGIN
  DECLARE x BLOB;
  LET z := ( SELECT cql_blob_create() );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_blob_create'

  {create_proc_stmt}: err
  | {name blob_create_column_wrong_arg_count}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}: err
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_column_context_wrong ()
BEGIN
  DECLARE x BLOB;
  LET z := cql_blob_create(x);
END;

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_blob_create'

  {create_proc_stmt}: err
  | {name blob_create_column_context_wrong}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob
      | | {name_list}: x: blob variable
      | | | {name x}: x: blob variable
      | | {type_blob}: blob
      | {let_stmt}: err
        | {name z}
        | {call}: err
          | {name cql_blob_create}
          | {call_arg_list}
            | {call_filter_clause}
            | {arg_list}: ok
              | {name x}

The statement ending at line XXXX

CREATE PROC blob_create_column_wrong_arg_type ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, "x", basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0009: incompatible types in expression 'cql_blob_create'

  {create_proc_stmt}: err
  | {name blob_create_column_wrong_arg_type}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {strlit 'x'}: err
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_column_bad_expr ()
BEGIN
  LET z := ( SELECT cql_blob_create(basic_table, NOT "x", basic_table.id) );
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_create_column_bad_expr}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name basic_table}
          |     |         | {arg_list}
          |     |           | {not}: err
          |     |           | | {strlit 'x'}: text notnull
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name basic_table}
          |     |               | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

CREATE PROC blob_create_not_backed_table ()
BEGIN
  LET z := ( SELECT cql_blob_create(simple_backing_table, x, simple_backing_table.k) );
END;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0488: the indicated table is not declared for backed storage 'simple_backing_table'

  {create_proc_stmt}: err
  | {name blob_create_not_backed_table}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {let_stmt}: err
        | {name z}
        | {select_stmt}: err
          | {select_core_list}: err
          | | {select_core}: err
          |   | {select_expr_list_con}: err
          |     | {select_expr_list}: err
          |     | | {select_expr}: err
          |     |   | {call}: err
          |     |     | {name cql_blob_create}
          |     |     | {call_arg_list}
          |     |       | {call_filter_clause}
          |     |       | {arg_list}: ok
          |     |         | {name simple_backing_table}
          |     |         | {arg_list}
          |     |           | {name x}
          |     |           | {arg_list}
          |     |             | {dot}
          |     |               | {name simple_backing_table}
          |     |               | {name k}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@BLOB_GET_KEY_TYPE BGETKEY_TYPE;

  {blob_get_key_type_stmt}: ok
  | {name BGETKEY_TYPE}

The statement ending at line XXXX

@BLOB_GET_VAL_TYPE BGETVAL_TYPE;

  {blob_get_val_type_stmt}: ok
  | {name BGETVAL_TYPE}

The statement ending at line XXXX

@BLOB_GET_KEY BGETKEY;

  {blob_get_key_stmt}: ok
  | {name BGETKEY}
  | {int 0}

The statement ending at line XXXX

@BLOB_GET_VAL BGETVAL;

  {blob_get_val_stmt}: ok
  | {name BGETVAL}
  | {int 0}

The statement ending at line XXXX

@BLOB_CREATE_KEY BCREATEKEY;

  {blob_create_key_stmt}: ok
  | {name BCREATEKEY}
  | {int 0}

The statement ending at line XXXX

@BLOB_CREATE_VAL BCREATEVAL;

  {blob_create_val_stmt}: ok
  | {name BCREATEVAL}
  | {int 0}

The statement ending at line XXXX

@BLOB_UPDATE_KEY BUPDATEKEY;

  {blob_update_key_stmt}: ok
  | {name BUPDATEKEY}
  | {int 0}

The statement ending at line XXXX

@BLOB_UPDATE_VAL BUPDATEVAL;

  {blob_update_val_stmt}: ok
  | {name BUPDATEVAL}
  | {int 0}

The statement ending at line XXXX

CREATE PROC blob_serialization_test_type_mismatch ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 5 AS name;
  FETCH C;
  DECLARE B BLOB<structured_storage>;
  SET B FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0061: in the cursor and the blob type, all columns must be an exact type match (expected text notnull; found integer notnull) 'name'

  {create_proc_stmt}: err
  | {name blob_serialization_test_type_mismatch}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { id: integer notnull, name: integer notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: integer notnull }
      |   | | {select_core}: select: { id: integer notnull, name: integer notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: integer notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: integer notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: integer notnull
      |   |     |     | {int 5}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc shape_storage
      | {declare_vars_type}: blob<structured_storage>
      | | {name_list}: B: blob<structured_storage> variable
      | | | {name B}: B: blob<structured_storage> variable
      | | {type_blob}: blob<structured_storage>
      |   | {name structured_storage}
      | {set_from_cursor}: err
        | {name B}: B: blob<structured_storage> variable
        | {name C}: err

The statement ending at line XXXX

CREATE PROC blob_serialization_test_type_not_a_table ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 'name' AS name;
  FETCH C;
  DECLARE B BLOB<not_a_table>;
  SET B FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0453: blob type is not a valid table 'not_a_table'

  {create_proc_stmt}: err
  | {name blob_serialization_test_type_not_a_table}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { id: integer notnull, name: text notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: text notnull }
      |   | | {select_core}: select: { id: integer notnull, name: text notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: text notnull
      |   |     |     | {strlit 'name'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | {declare_vars_type}: blob<not_a_table>
      | | {name_list}: B: blob<not_a_table> variable
      | | | {name B}: B: blob<not_a_table> variable
      | | {type_blob}: blob<not_a_table>
      |   | {name not_a_table}
      | {set_from_cursor}: err
        | {name B}: B: blob<not_a_table> variable
        | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC blob_serialization_test_type_is_a_view ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 'name' AS name;
  FETCH C;
  DECLARE B BLOB<MyView>;
  SET B FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0456: blob type is a view, not a table 'MyView'

  {create_proc_stmt}: err
  | {name blob_serialization_test_type_is_a_view}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { id: integer notnull, name: text notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: text notnull }
      |   | | {select_core}: select: { id: integer notnull, name: text notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: text notnull
      |   |     |     | {strlit 'name'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | {declare_vars_type}: blob<MyView>
      | | {name_list}: B: blob<MyView> variable
      | | | {name B}: B: blob<MyView> variable
      | | {type_blob}: blob<MyView>
      |   | {name MyView}
      | {set_from_cursor}: err
        | {name B}: B: blob<MyView> variable
        | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC blob_serialization_test_type_has_no_kind ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 'name' AS name;
  FETCH C;
  DECLARE B BLOB;
  SET B FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0455: blob variable must have a type-kind for type safety 'B'

  {create_proc_stmt}: err
  | {name blob_serialization_test_type_has_no_kind}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: text notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {select_stmt}: select: { id: integer notnull, name: text notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: text notnull }
      |   | | {select_core}: select: { id: integer notnull, name: text notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: text notnull
      |   |     |     | {strlit 'name'}: text notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage
      | {declare_vars_type}: blob
      | | {name_list}: B: blob variable
      | | | {name B}: B: blob variable
      | | {type_blob}: blob
      | {set_from_cursor}: err
        | {name B}: B: blob variable
        | {name C}: C: select: { id: integer notnull, name: text notnull } variable dml_proc shape_storage

The statement ending at line XXXX

CREATE PROC blob_serialization_test_no_storage ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 5 AS name;
  DECLARE B BLOB<structured_storage>;
  SET B FROM CURSOR C;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0454: cursor was not declared for storage 'C'

  {create_proc_stmt}: err
  | {name blob_serialization_test_no_storage}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, name: integer notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: integer notnull }
      |   | | {select_core}: select: { id: integer notnull, name: integer notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: integer notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: integer notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: integer notnull
      |   |     |     | {int 5}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_vars_type}: blob<structured_storage>
      | | {name_list}: B: blob<structured_storage> variable
      | | | {name B}: B: blob<structured_storage> variable
      | | {type_blob}: blob<structured_storage>
      |   | {name structured_storage}
      | {set_from_cursor}: err
        | {name B}: B: blob<structured_storage> variable
        | {name C}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc

The statement ending at line XXXX

CREATE PROC blob_serialization_test_valid_cursor ()
BEGIN
  DECLARE C CURSOR FOR SELECT 1 AS id, 5 AS name;
  DECLARE B BLOB<structured_storage>;
  SET B FROM CURSOR not_a_cursor;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'not_a_cursor'

  {create_proc_stmt}: err
  | {name blob_serialization_test_valid_cursor}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc
      | | {name C}: C: select: { id: integer notnull, name: integer notnull } variable dml_proc
      | | {select_stmt}: select: { id: integer notnull, name: integer notnull }
      |   | {select_core_list}: select: { id: integer notnull, name: integer notnull }
      |   | | {select_core}: select: { id: integer notnull, name: integer notnull }
      |   |   | {select_expr_list_con}: select: { id: integer notnull, name: integer notnull }
      |   |     | {select_expr_list}: select: { id: integer notnull, name: integer notnull }
      |   |     | | {select_expr}: id: integer notnull
      |   |     | | | {int 1}: integer notnull
      |   |     | | | {opt_as_alias}
      |   |     | |   | {name id}
      |   |     | | {select_expr_list}
      |   |     |   | {select_expr}: name: integer notnull
      |   |     |     | {int 5}: integer notnull
      |   |     |     | {opt_as_alias}
      |   |     |       | {name name}
      |   |     | {select_from_etc}: ok
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_vars_type}: blob<structured_storage>
      | | {name_list}: B: blob<structured_storage> variable
      | | | {name B}: B: blob<structured_storage> variable
      | | {type_blob}: blob<structured_storage>
      |   | {name structured_storage}
      | {set_from_cursor}: err
        | {name B}: B: blob<structured_storage> variable
        | {name not_a_cursor}: err

The statement ending at line XXXX

CREATE PROC blob_serialization_not_storage_table ()
BEGIN
  DECLARE b BLOB<foo>;
  DECLARE C CURSOR LIKE foo;
  FETCH C FROM b;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0457: the indicated table is not marked with @attribute(cql:blob_storage) 'foo'

  {create_proc_stmt}: err
  | {name blob_serialization_not_storage_table}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_vars_type}: blob<foo>
      | | {name_list}: b: blob<foo> variable
      | | | {name b}: b: blob<foo> variable
      | | {type_blob}: blob<foo>
      |   | {name foo}
      | {declare_cursor_like_name}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {shape_def}: foo: { id: integer notnull primary_key autoinc }
      |   | {like}: ok
      |     | {name foo}
      | {fetch_values_stmt}: err
        | {name_columns_values}
          | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
          | {columns_values}
            | {from_shape}
              | {name b}: b: blob<foo> variable

The statement ending at line XXXX

CREATE PROC blob_deseralized_from_err ()
BEGIN
  DECLARE C CURSOR LIKE foo;
  FETCH C FROM BLOB NOT 'x';
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0047: string operand not allowed in 'NOT'

  {create_proc_stmt}: err
  | {name blob_deseralized_from_err}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {shape_def}: foo: { id: integer notnull primary_key autoinc }
      |   | {like}: ok
      |     | {name foo}
      | {fetch_cursor_from_blob_stmt}: err
        | {name C}
        | {not}: err
          | {strlit 'x'}: text notnull

The statement ending at line XXXX

CREATE PROC blob_deseralized_from_not_a_blob ()
BEGIN
  DECLARE C CURSOR LIKE foo;
  FETCH C FROM BLOB 1;
END;

test/sem_test.sql:XXXX:1: error: in num : CQL0461: fetch from blob operand is not a blob

  {create_proc_stmt}: err
  | {name blob_deseralized_from_not_a_blob}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_name}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {name C}: C: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
      | | {shape_def}: foo: { id: integer notnull primary_key autoinc }
      |   | {like}: ok
      |     | {name foo}
      | {fetch_cursor_from_blob_stmt}: err
        | {name C}
        | {int 1}: integer notnull

The statement ending at line XXXX

CREATE TRIGGER storage_trigger
  BEFORE DELETE ON structured_storage
BEGIN
  DELETE FROM bar WHERE rate > id;
END;

test/sem_test.sql:XXXX:1: error: in create_trigger_stmt : CQL0458: the indicated table may only be used for blob storage 'structured_storage'

  {create_trigger_stmt}: err
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name storage_trigger}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name structured_storage}
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}
                  | {delete_stmt}
                    | {name bar}
                    | {opt_where}
                      | {gt}
                        | {name rate}
                        | {name id}

The statement ending at line XXXX

DROP TABLE structured_storage;

test/sem_test.sql:XXXX:1: error: in drop_table_stmt : CQL0458: the indicated table may only be used for blob storage 'structured_storage'

  {drop_table_stmt}: err
  | {name structured_storage}

The statement ending at line XXXX

DELETE FROM structured_storage WHERE 1;

test/sem_test.sql:XXXX:1: error: in delete_stmt : CQL0458: the indicated table may only be used for blob storage 'structured_storage'

  {delete_stmt}: err
  | {name structured_storage}
  | {opt_where}
    | {int 1}

The statement ending at line XXXX

CREATE INDEX oh_no_you_dont ON structured_storage (id);

test/sem_test.sql:XXXX:1: error: in create_index_stmt : CQL0458: the indicated table may only be used for blob storage 'structured_storage'

  {create_index_stmt}: err
  | {create_index_on_list}
  | | {name oh_no_you_dont}
  | | {name structured_storage}
  | {flags_names_attrs}
    | {int 0}
    | {connector}
      | {index_names_and_attrs}
        | {indexed_columns}
          | {indexed_column}
            | {name id}

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE VIRTUAL TABLE virtual_blob_storage_illegal USING module_name (args) AS (
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_virtual_table_stmt : CQL0459: table is not suitable for use as blob storage: it is a virtual table 'virtual_blob_storage_illegal'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_virtual_table_stmt}: err
    | {module_info}
    | | {name module_name}
    | | {misc_attr_value_list}
    |   | {name args}
    | {create_table_stmt}
      | {create_table_name_flags}
      | | {table_flags_attrs}
      | | | {int 0}
      | | | {recreate_attr}
      | | {name virtual_blob_storage_illegal}
      | {col_key_list}
        | {col_def}
        | | {col_def_type_attrs}
        |   | {col_def_name_type}
        |     | {name id}
        |     | {type_int}
        | {col_key_list}
          | {col_def}
            | {col_def_type_attrs}
              | {col_def_name_type}
                | {name t}
                | {type_text}

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TEMP TABLE temp_blob_storage(
  id INTEGER,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: it is redundantly marked TEMP 'temp_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 1}
    | | {name temp_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE norowid_blob_storage(
  id INTEGER,
  t TEXT
) WITHOUT ROWID;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: it is redundantly marked WITHOUT ROWID 'norowid_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 4}
    | | {name norowid_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE constraint_blob_storage(
  id INTEGER,
  t TEXT,
  CONSTRAINT ak1 UNIQUE (id)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: it has at least one constraint 'constraint_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name constraint_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
        | | {col_def_type_attrs}: ok
        |   | {col_def_name_type}
        |     | {name t}
        |     | {type_text}: text
        | {col_key_list}
          | {unq_def}
            | {name ak1}
            | {indexed_columns_conflict_clause}
              | {indexed_columns}
                | {indexed_column}
                  | {name id}: id: integer

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE pk_col_blob_storage(
  id INTEGER PRIMARY KEY,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' has a primary key in 'pk_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name pk_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer notnull primary_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_pk}: ok
      |     | {autoinc_and_conflict_clause}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE fk_col_blob_storage(
  id INTEGER REFERENCES foo (id),
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' has a foreign key in 'fk_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name fk_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer foreign_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_fk}: ok
      |     | {fk_target_options}
      |       | {fk_target}
      |       | | {name foo}
      |       | | {name_list}
      |       |   | {name id}: id: integer notnull
      |       | {int 0}
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE uk_col_blob_storage(
  id INTEGER UNIQUE,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' has a unique key in 'uk_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name uk_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer unique_key
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_unique}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE hidden_col_blob_storage(
  id INTEGER HIDDEN,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' is a hidden column in 'hidden_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name hidden_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_hidden}: ok
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE check_col_blob_storage(
  id INTEGER CHECK(id = 5) ,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' has a check expression in 'check_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name check_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer has_check
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_check}: ok
      |     | {eq}: bool
      |       | {name id}: id: integer has_check
      |       | {int 5}: integer notnull
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE collate_col_blob_storage(
  id INTEGER,
  t TEXT COLLATE nocase
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 't' specifies collation order in 'collate_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name collate_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text has_collate
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {col_attrs_collate}: ok
              | {name nocase}

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE default_value_col_blob_storage(
  id INTEGER DEFAULT 5,
  t TEXT
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 'id' has a default value in 'default_value_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name default_value_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer has_default
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name id}
      |   | | {type_int}: integer
      |   | {col_attrs_default}: ok
      |     | {int 5}: integer notnull
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE deleted_col_blob_storage(
  id INTEGER,
  t TEXT @DELETE(7)
);

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: column 't' has been deleted in 'deleted_col_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name deleted_col_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text deleted @delete(7)
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
            | | {name t}
            | | {type_text}: text
            | {delete_attr}: ok
              | {version_annotation}
                | {int 7}

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE recreate_blob_storage(
  id INTEGER,
  t TEXT
) @RECREATE;

test/sem_test.sql:XXXX:1: error: in create_table_stmt : CQL0459: table is not suitable for use as blob storage: it is declared using @recreate 'recreate_blob_storage'

  {stmt_and_attr}: err
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: err
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | | {recreate_attr}
    | | {name recreate_blob_storage}
    | {col_key_list}
      | {col_def}: id: integer
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name id}
      |     | {type_int}: integer
      | {col_key_list}
        | {col_def}: t: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name t}
              | {type_text}: text

The statement ending at line XXXX

SELECT *
  FROM structured_storage;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0458: the indicated table may only be used for blob storage 'structured_storage'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name structured_storage}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@ENFORCE_STRICT CURSOR HAS ROW;

  {enforce_strict_stmt}: ok
  | {int 21}

The statement ending at line XXXX

CREATE TABLE has_row_check_table(
  a TEXT NOT NULL,
  b TEXT
);

  {create_table_stmt}: has_row_check_table: { a: text notnull, b: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name has_row_check_table}
  | {col_key_list}
    | {col_def}: a: text notnull
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name a}
    |   | | {type_text}: text
    |   | {col_attrs_not_null}: ok
    | {col_key_list}
      | {col_def}: b: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name b}
            | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:blob_storage)
CREATE TABLE has_row_check_blob(
  a TEXT NOT NULL,
  b TEXT
);

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |     | {name cql}
  |     | {name blob_storage}
  | {create_table_stmt}: has_row_check_blob: { a: text notnull, b: text }
    | {create_table_name_flags}
    | | {table_flags_attrs}
    | | | {int 0}
    | | {name has_row_check_blob}
    | {col_key_list}
      | {col_def}: a: text notnull
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |   | | {name a}
      |   | | {type_text}: text
      |   | {col_attrs_not_null}: ok
      | {col_key_list}
        | {col_def}: b: text
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name b}
              | {type_text}: text

The statement ending at line XXXX

CREATE PROC has_row_check_required_before_using_nonnull_reference_field ()
BEGIN
  DECLARE c CURSOR FOR SELECT *
    FROM has_row_check_table;
  FETCH c;
  LET x := c.a;
  LET y := c.b;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c.a'

  {create_proc_stmt}: err
  | {name has_row_check_required_before_using_nonnull_reference_field}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { a: text notnull, b: text } variable dml_proc
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {let_stmt}: err
      | | {name x}
      | | {dot}: err
      |   | {name c}
      |   | {name a}
      | {let_stmt}: y: text variable
        | {name y}: y: text variable
        | {dot}: c.b: text variable
          | {name c}
          | {name b}

The statement ending at line XXXX

CREATE PROC has_row_checks_can_be_positive_or_negative ()
BEGIN
  DECLARE c CURSOR FOR SELECT *
    FROM has_row_check_table;
  FETCH c;
  LET x0 := c.a;
  IF c THEN
    LET x1 := c.a;
  END IF;
  LET x2 := c.a;
  IF NOT c THEN
    LET dummy := "hello";
    RETURN;
  END IF;
  LET x3 := c.a;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c.a'
test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c.a'

  {create_proc_stmt}: err
  | {name has_row_checks_can_be_positive_or_negative}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { a: text notnull, b: text } variable dml_proc
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {let_stmt}: err
      | | {name x0}
      | | {dot}: err
      |   | {name c}
      |   | {name a}
      | {if_stmt}: c._has_row_: bool notnull variable
      | | {cond_action}: c._has_row_: bool notnull variable
      | | | {name c}: c._has_row_: bool notnull variable
      | | | {stmt_list}: ok
      | |   | {let_stmt}: x1: text notnull variable
      | |     | {name x1}: x1: text notnull variable
      | |     | {dot}: c.a: text notnull variable
      | |       | {name c}
      | |       | {name a}
      | | {if_alt}: ok
      | {let_stmt}: err
      | | {name x2}
      | | {dot}: err
      |   | {name c}
      |   | {name a}
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {not}: bool notnull
      | | | | {name c}: c._has_row_: bool notnull variable
      | | | {stmt_list}: ok
      | |   | {let_stmt}: dummy: text notnull variable
      | |   | | {name dummy}: dummy: text notnull variable
      | |   | | {strlit 'hello'}: text notnull
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x3: text notnull variable
        | {name x3}: x3: text notnull variable
        | {dot}: c.a: text notnull variable
          | {name c}
          | {name a}

The statement ending at line XXXX

CREATE PROC fetch_values_requires_no_has_row_check (a_ TEXT NOT NULL, b_ TEXT)
BEGIN
  DECLARE c0 CURSOR LIKE has_row_check_table;
  FETCH c0(a, b) FROM VALUES("text", NULL);
  LET x0 := c0.a;
  DECLARE c1 CURSOR LIKE has_row_check_table;
  FETCH c1(a, b) FROM VALUES(a_, b_);
  LET x1 := c1.a;
  DECLARE b BLOB<has_row_check_blob>;
  DECLARE c2 CURSOR LIKE has_row_check_blob;
  FETCH c2 FROM BLOB b;
  LET x2 := c2.a;
  DECLARE c3 CURSOR FOR SELECT *
    FROM has_row_check_table;
  FETCH c3;
  LET x3 := c3.a;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c3.a'

  {create_proc_stmt}: err
  | {name fetch_values_requires_no_has_row_check}: err
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_: text notnull variable in
    | | | {param_detail}: a_: text notnull variable in
    | |   | {name a_}: a_: text notnull variable in
    | |   | {notnull}: text notnull
    | |     | {type_text}: text
    | | {params}
    |   | {param}: b_: text variable in
    |     | {param_detail}: b_: text variable in
    |       | {name b_}: b_: text variable in
    |       | {type_text}: text
    | {stmt_list}: err
      | {declare_cursor_like_name}: c0: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      | | {name c0}: c0: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      | | {shape_def}: has_row_check_table: { a: text notnull, b: text }
      |   | {like}: ok
      |     | {name has_row_check_table}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c0}: c0: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name a}: a: text notnull
      |     |   | {name_list}
      |     |     | {name b}: b: text
      |     | {insert_list}: ok
      |       | {strlit 'text'}: text notnull
      |       | {insert_list}
      |         | {null}: null
      | {let_stmt}: x0: text notnull variable
      | | {name x0}: x0: text notnull variable
      | | {dot}: c0.a: text notnull variable
      |   | {name c0}
      |   | {name a}
      | {declare_cursor_like_name}: c1: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      | | {name c1}: c1: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      | | {shape_def}: has_row_check_table: { a: text notnull, b: text }
      |   | {like}: ok
      |     | {name has_row_check_table}
      | {fetch_values_stmt}: ok
      | | {name_columns_values}
      |   | {name c1}: c1: has_row_check_table: { a: text notnull, b: text } variable shape_storage value_cursor
      |   | {columns_values}: ok
      |     | {column_spec}
      |     | | {name_list}
      |     |   | {name a}: a: text notnull
      |     |   | {name_list}
      |     |     | {name b}: b: text
      |     | {insert_list}: ok
      |       | {dot}: a_: text notnull variable in
      |       | | {name ARGUMENTS}
      |       | | {name a}
      |       | {insert_list}
      |         | {dot}: b_: text variable in
      |           | {name ARGUMENTS}
      |           | {name b}
      | {let_stmt}: x1: text notnull variable
      | | {name x1}: x1: text notnull variable
      | | {dot}: c1.a: text notnull variable
      |   | {name c1}
      |   | {name a}
      | {declare_vars_type}: blob<has_row_check_blob>
      | | {name_list}: b: blob<has_row_check_blob> variable
      | | | {name b}: b: blob<has_row_check_blob> variable
      | | {type_blob}: blob<has_row_check_blob>
      |   | {name has_row_check_blob}
      | {declare_cursor_like_name}: c2: has_row_check_blob: { a: text notnull, b: text } variable shape_storage value_cursor serialize
      | | {name c2}: c2: has_row_check_blob: { a: text notnull, b: text } variable shape_storage value_cursor serialize
      | | {shape_def}: has_row_check_blob: { a: text notnull, b: text }
      |   | {like}: ok
      |     | {name has_row_check_blob}
      | {fetch_cursor_from_blob_stmt}: ok
      | | {name c2}: c2: has_row_check_blob: { a: text notnull, b: text } variable shape_storage value_cursor
      | | {name b}: b: blob<has_row_check_blob> variable
      | {let_stmt}: x2: text notnull variable
      | | {name x2}: x2: text notnull variable
      | | {dot}: c2.a: text notnull variable
      |   | {name c2}
      |   | {name a}
      | {declare_cursor}: c3: select: { a: text notnull, b: text } variable dml_proc
      | | {name c3}: c3: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c3: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c3}: c3: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {let_stmt}: err
        | {name x3}
        | {dot}: err
          | {name c3}
          | {name a}

The statement ending at line XXXX

CREATE PROC fetching_again_requires_another_check ()
BEGIN
  DECLARE c CURSOR FOR SELECT *
    FROM has_row_check_table;
  FETCH c;
  IF NOT c THEN
    RETURN;
  END IF;
  LET x0 := c.a;
  FETCH c;
  LET x1 := c.a;
  IF c THEN
    LET x2 := c.a;
  END IF;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c.a'

  {create_proc_stmt}: err
  | {name fetching_again_requires_another_check}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { a: text notnull, b: text } variable dml_proc
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {not}: bool notnull
      | | | | {name c}: c._has_row_: bool notnull variable
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {let_stmt}: x0: text notnull variable
      | | {name x0}: x0: text notnull variable
      | | {dot}: c.a: text notnull variable
      |   | {name c}
      |   | {name a}
      | {fetch_stmt}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {let_stmt}: err
      | | {name x1}
      | | {dot}: err
      |   | {name c}
      |   | {name a}
      | {if_stmt}: c._has_row_: bool notnull variable
        | {cond_action}: c._has_row_: bool notnull variable
        | | {name c}: c._has_row_: bool notnull variable
        | | {stmt_list}: ok
        |   | {let_stmt}: x2: text notnull variable
        |     | {name x2}: x2: text notnull variable
        |     | {dot}: c.a: text notnull variable
        |       | {name c}
        |       | {name a}
        | {if_alt}: ok

The statement ending at line XXXX

CREATE PROC fetching_with_loop_requires_no_check ()
BEGIN
  DECLARE c CURSOR FOR SELECT *
    FROM has_row_check_table;
  LOOP FETCH c
  BEGIN
    LET x0 := c.a;
  END;
  LET x1 := c.a;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c.a'

  {create_proc_stmt}: err
  | {name fetching_with_loop_requires_no_check}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c: select: { a: text notnull, b: text } variable dml_proc
      | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {loop_stmt}: ok
      | | {fetch_stmt}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | | {name c}: c: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {let_stmt}: x0: text notnull variable
      |     | {name x0}: x0: text notnull variable
      |     | {dot}: c.a: text notnull variable
      |       | {name c}
      |       | {name a}
      | {let_stmt}: err
        | {name x1}
        | {dot}: err
          | {name c}
          | {name a}

The statement ending at line XXXX

CREATE PROC refetching_within_loop_may_unimprove_cursor_earlier_in_loop ()
BEGIN
  DECLARE c0 CURSOR FOR SELECT *
    FROM has_row_check_table;
  DECLARE c1 CURSOR FOR SELECT *
    FROM has_row_check_table;
  FETCH c0;
  IF NOT c0 THEN
    RETURN;
  END IF;
  LOOP FETCH c1
  BEGIN
    LET x0 := c0.a;
    LET x1 := c1.a;
    FETCH c0;
    FETCH c1;
  END;
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0460: field of a nonnull reference type accessed before verifying that the cursor has a row 'c0.a'

  {create_proc_stmt}: err
  | {name refetching_within_loop_may_unimprove_cursor_earlier_in_loop}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor}: c0: select: { a: text notnull, b: text } variable dml_proc
      | | {name c0}: c0: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {declare_cursor}: c1: select: { a: text notnull, b: text } variable dml_proc
      | | {name c1}: c1: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {select_stmt}: select: { a: text notnull, b: text }
      |   | {select_core_list}: select: { a: text notnull, b: text }
      |   | | {select_core}: select: { a: text notnull, b: text }
      |   |   | {select_expr_list_con}: select: { a: text notnull, b: text }
      |   |     | {select_expr_list}: select: { a: text notnull, b: text }
      |   |     | | {star}: select: { a: text notnull, b: text }
      |   |     | {select_from_etc}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {table_or_subquery_list}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | | {table_or_subquery}: TABLE { has_row_check_table: has_row_check_table }
      |   |       |   | {name has_row_check_table}: TABLE { has_row_check_table: has_row_check_table }
      |   |       | {select_where}
      |   |         | {select_groupby}
      |   |           | {select_having}
      |   | {select_orderby}
      |     | {select_limit}
      |       | {select_offset}
      | {fetch_stmt}: c0: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | | {name c0}: c0: select: { a: text notnull, b: text } variable dml_proc shape_storage
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {not}: bool notnull
      | | | | {name c0}: c0._has_row_: bool notnull variable
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {loop_stmt}: err
        | {fetch_stmt}: c1: select: { a: text notnull, b: text } variable dml_proc shape_storage
        | | {name c1}: c1: select: { a: text notnull, b: text } variable dml_proc shape_storage
        | {stmt_list}: err
          | {let_stmt}: err
          | | {name x0}: x0: text notnull variable
          | | {dot}: err
          |   | {name c0}
          |   | {name a}
          | {let_stmt}: x1: text notnull variable
          | | {name x1}: x1: text notnull variable
          | | {dot}: c1.a: text notnull variable
          |   | {name c1}
          |   | {name a}
          | {fetch_stmt}: c0: select: { a: text notnull, b: text } variable dml_proc shape_storage
          | | {name c0}: c0: select: { a: text notnull, b: text } variable dml_proc shape_storage
          | {fetch_stmt}: c1: select: { a: text notnull, b: text } variable dml_proc shape_storage
            | {name c1}: c1: select: { a: text notnull, b: text } variable dml_proc shape_storage

The statement ending at line XXXX

@ENFORCE_NORMAL CURSOR HAS ROW;

  {enforce_normal_stmt}: ok
  | {int 21}

The statement ending at line XXXX

@ATTRIBUTE(potato:potato=potato)
@ATTRIBUTE(potato:potato)
@ATTRIBUTE(potato=potato)
@ATTRIBUTE(potato)
@ATTRIBUTE(cql:potato=potato)
@ATTRIBUTE(cql:potato)
@ATTRIBUTE(cql=cql)
@ATTRIBUTE(cql)
@ATTRIBUTE(cql:vault_sensitive=(privacy_context, (some_column)))
CREATE PROC attribute_test ()
BEGIN
  SELECT 'x' AS some_column;
END;

test/sem_test.sql:XXXX:1: error: in misc_attrs : CQL0239: vault_sensitive column does not exist in result set 'privacy_context'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  | | | {dot}
  | | | | {name potato}
  | | | | {name potato}
  | | | {name potato}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |   | | {dot}
  |   |   | {name potato}
  |   |   | {name potato}
  |   | {misc_attrs}
  |     | {misc_attr}
  |     | | {name potato}
  |     | | {name potato}: ok
  |     | {misc_attrs}
  |       | {misc_attr}
  |       | | {name potato}
  |       | {misc_attrs}
  |         | {misc_attr}
  |         | | {dot}
  |         | | | {name cql}
  |         | | | {name potato}
  |         | | {name potato}: ok
  |         | {misc_attrs}
  |           | {misc_attr}
  |           | | {dot}
  |           |   | {name cql}
  |           |   | {name potato}
  |           | {misc_attrs}
  |             | {misc_attr}
  |             | | {name cql}
  |             | | {name cql}: ok
  |             | {misc_attrs}
  |               | {misc_attr}
  |               | | {name cql}
  |               | {misc_attrs}
  |                 | {misc_attr}
  |                   | {dot}
  |                   | | {name cql}
  |                   | | {name vault_sensitive}
  |                   | {misc_attr_value_list}: ok
  |                     | {name privacy_context}: ok
  |                     | {misc_attr_value_list}
  |                       | {misc_attr_value_list}: ok
  |                         | {name some_column}: ok
  | {create_proc_stmt}: err
    | {name attribute_test}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { some_column: text notnull }
          | {select_core_list}: select: { some_column: text notnull }
          | | {select_core}: select: { some_column: text notnull }
          |   | {select_expr_list_con}: select: { some_column: text notnull }
          |     | {select_expr_list}: select: { some_column: text notnull }
          |     | | {select_expr}: some_column: text notnull
          |     |   | {strlit 'x'}: text notnull
          |     |   | {opt_as_alias}
          |     |     | {name some_column}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE GROUP var_group
BEGIN
  DECLARE var_group_var1 INTEGER;
  DECLARE var_group_var2 CURSOR LIKE foo;
  DECLARE var_group_var3 CURSOR LIKE SELECT 1 AS x, "2" AS y;
END;

  {declare_group_stmt}: ok
  | {name var_group}
  | {stmt_list}
    | {declare_vars_type}: integer
    | | {name_list}: var_group_var1: integer variable
    | | | {name var_group_var1}: var_group_var1: integer variable
    | | {type_int}: integer
    | {declare_cursor_like_name}: var_group_var2: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
    | | {name var_group_var2}: var_group_var2: foo: { id: integer notnull primary_key autoinc } variable shape_storage value_cursor
    | | {shape_def}: foo: { id: integer notnull primary_key autoinc }
    |   | {like}: ok
    |     | {name foo}
    | {declare_cursor_like_select}: var_group_var3: select: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | {name var_group_var3}: var_group_var3: select: { x: integer notnull, y: text notnull } variable shape_storage value_cursor
      | {select_stmt}: select: { x: integer notnull, y: text notnull }
        | {select_core_list}: select: { x: integer notnull, y: text notnull }
        | | {select_core}: select: { x: integer notnull, y: text notnull }
        |   | {select_expr_list_con}: select: { x: integer notnull, y: text notnull }
        |     | {select_expr_list}: select: { x: integer notnull, y: text notnull }
        |     | | {select_expr}: x: integer notnull
        |     | | | {int 1}: integer notnull
        |     | | | {opt_as_alias}
        |     | |   | {name x}
        |     | | {select_expr_list}
        |     |   | {select_expr}: y: text notnull
        |     |     | {strlit '2'}: text notnull
        |     |     | {opt_as_alias}
        |     |       | {name y}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE GROUP var_group
BEGIN
  DECLARE var_group_var1 INTEGER;
  DECLARE var_group_var2 CURSOR LIKE foo;
  DECLARE var_group_var3 CURSOR LIKE SELECT 1 AS x, "2" AS y;
END;

  {declare_group_stmt}: ok
  | {name var_group}
  | {stmt_list}
    | {declare_vars_type}
    | | {name_list}
    | | | {name var_group_var1}
    | | {type_int}
    | {declare_cursor_like_name}
    | | {name var_group_var2}
    | | {shape_def}
    |   | {like}
    |     | {name foo}
    | {declare_cursor_like_select}
      | {name var_group_var3}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     | | | {int 1}
        |     | | | {opt_as_alias}
        |     | |   | {name x}
        |     | | {select_expr_list}
        |     |   | {select_expr}
        |     |     | {strlit '2'}
        |     |     | {opt_as_alias}
        |     |       | {name y}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE GROUP var_group
BEGIN
  DECLARE var_group_var1 INTEGER;
END;

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : DECLARE GROUP var_group
BEGIN
  DECLARE var_group_var1 INTEGER;
END
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : DECLARE GROUP var_group
BEGIN
  DECLARE var_group_var1 INTEGER;
  DECLARE var_group_var2 CURSOR LIKE foo;
  DECLARE var_group_var3 CURSOR LIKE SELECT 1 AS x, "2" AS y;
END
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_group_stmt : CQL0463: variable definitions do not match in group 'var_group'

  {declare_group_stmt}: err
  | {name var_group}
  | {stmt_list}
    | {declare_vars_type}
      | {name_list}
      | | {name var_group_var1}
      | {type_int}

The statement ending at line XXXX

CREATE PROC proc_contains_var_group ()
BEGIN
  DECLARE GROUP var_group
  BEGIN
    DECLARE var_group_var1 INTEGER;
  END;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0462: group declared variables must be top level 'var_group'

  {create_proc_stmt}: err
  | {name proc_contains_var_group}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_group_stmt}: err
        | {name var_group}
        | {stmt_list}
          | {declare_vars_type}
            | {name_list}
            | | {name var_group_var1}
            | {type_int}

The statement ending at line XXXX

DECLARE GROUP var_group_error
BEGIN
  DECLARE var_group_var_dup INTEGER;
  DECLARE var_group_var_dup INTEGER;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0197: duplicate variable name in the same scope 'var_group_var_dup'

  {declare_group_stmt}: err
  | {name var_group_error}
  | {stmt_list}
    | {declare_vars_type}: integer
    | | {name_list}: var_group_var_dup: integer variable
    | | | {name var_group_var_dup}: var_group_var_dup: integer variable
    | | {type_int}: integer
    | {declare_vars_type}: err
      | {name_list}: err
      | | {name var_group_var_dup}: err
      | {type_int}: integer

The statement ending at line XXXX

@EMIT_GROUP var_group;

  {emit_group_stmt}: ok
  | {name_list}
    | {name var_group}

The statement ending at line XXXX

@EMIT_GROUP not_a_var_group;

test/sem_test.sql:XXXX:1: error: in str : CQL0464: group not found 'not_a_var_group'

  {emit_group_stmt}: err
  | {name_list}
    | {name not_a_var_group}

The statement ending at line XXXX

CREATE TABLE unsub_test_table(
  id INTEGER PRIMARY KEY
);

  {create_table_stmt}: unsub_test_table: { id: integer notnull primary_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name unsub_test_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

CREATE TABLE unsub_test_table_deleted(
  id INTEGER
) @DELETE(2);

  {create_table_stmt}: unsub_test_table_deleted: { id: integer } deleted @delete(2)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {delete_attr}
  | |   | {version_annotation}
  | |     | {int 2}
  | | {name unsub_test_table_deleted}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE unsub_test_table_late_create(
  id INTEGER
) @CREATE(7);

  {create_table_stmt}: unsub_test_table_late_create: { id: integer } @create(7)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 7}
  | | {name unsub_test_table_late_create}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

@UNSUB(0, unsub_test_table);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0025: version number in annotation must be positive

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 0}
    | {name unsub_test_table}

The statement ending at line XXXX

@UNSUB(1, structured_storage);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0449: unsubscribe and resubscribe do not make sense on non-physical tables 'structured_storage'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 1}
    | {name structured_storage}

The statement ending at line XXXX

@RESUB(1, structured_storage);

test/sem_test.sql:XXXX:1: error: in schema_resub_stmt : CQL0449: unsubscribe and resubscribe do not make sense on non-physical tables 'structured_storage'

  {schema_resub_stmt}: err
  | {version_annotation}
    | {int 1}
    | {name structured_storage}

The statement ending at line XXXX

@UNSUB(5);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0465: @unsub directive must provide a table or view name

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 5}

The statement ending at line XXXX

@UNSUB(5, not_a_table);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0466: the table/view named in an @unsub/@resub directive does not exist 'not_a_table'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name not_a_table}

The statement ending at line XXXX

SELECT *
  FROM unsub_test_table;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { unsub_test_table: unsub_test_table }
  |       | {table_or_subquery_list}: TABLE { unsub_test_table: unsub_test_table }
  |       | | {table_or_subquery}: TABLE { unsub_test_table: unsub_test_table }
  |       |   | {name unsub_test_table}: TABLE { unsub_test_table: unsub_test_table }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@UNSUB(5, unsub_test_table);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 5}
    | {name unsub_test_table}

The statement ending at line XXXX

SELECT *
  FROM unsub_test_table;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined (hidden by @unsub) 'unsub_test_table'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {star}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {name unsub_test_table}
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@UNSUB(5, unsub_test_table);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0471: table/view has another @unsub/@resub at this version number 'unsub_test_table'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name unsub_test_table}

The statement ending at line XXXX

@UNSUB(4, foo);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0467: @unsub/@resub versions must be in non-decreasing order

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 4}
    | {name foo}

The statement ending at line XXXX

@UNSUB(5, unsub_test_table_late_create);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0470: table/view not yet created at indicated version 'unsub_test_table_late_create'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 5}
    | {name unsub_test_table_late_create}

The statement ending at line XXXX

@UNSUB(6, unsub_test_table_deleted);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0469: table/view is already deleted 'unsub_test_table_deleted'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 6}
    | {name unsub_test_table_deleted}

The statement ending at line XXXX

@UNSUB(6, unsub_test_table);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0472: table/view is already unsubscribed 'unsub_test_table'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 6}
    | {name unsub_test_table}

The statement ending at line XXXX

@RESUB(7, unsub_test_table);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 7}
    | {name unsub_test_table}

The statement ending at line XXXX

SELECT *
  FROM unsub_test_table;

  {select_stmt}: select: { id: integer notnull }
  | {select_core_list}: select: { id: integer notnull }
  | | {select_core}: select: { id: integer notnull }
  |   | {select_expr_list_con}: select: { id: integer notnull }
  |     | {select_expr_list}: select: { id: integer notnull }
  |     | | {star}: select: { id: integer notnull }
  |     | {select_from_etc}: TABLE { unsub_test_table: unsub_test_table }
  |       | {table_or_subquery_list}: TABLE { unsub_test_table: unsub_test_table }
  |       | | {table_or_subquery}: TABLE { unsub_test_table: unsub_test_table }
  |       |   | {name unsub_test_table}: TABLE { unsub_test_table: unsub_test_table }
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

@RESUB(8, unsub_test_table);

test/sem_test.sql:XXXX:1: error: in schema_resub_stmt : CQL0472: table/view is already resubscribed 'unsub_test_table'

  {schema_resub_stmt}: err
  | {version_annotation}
    | {int 8}
    | {name unsub_test_table}

The statement ending at line XXXX

@RESUB(8, not_a_table);

test/sem_test.sql:XXXX:1: error: in schema_resub_stmt : CQL0466: the table/view named in an @unsub/@resub directive does not exist 'not_a_table'

  {schema_resub_stmt}: err
  | {version_annotation}
    | {int 8}
    | {name not_a_table}

The statement ending at line XXXX

CREATE TABLE sub_test_dependency(
  id INTEGER REFERENCES unsub_test_table (id)
);

  {create_table_stmt}: sub_test_dependency: { id: integer foreign_key }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name sub_test_dependency}
  | {col_key_list}
    | {col_def}: id: integer foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_fk}: ok
          | {fk_target_options}
            | {fk_target}
            | | {name unsub_test_table}
            | | {name_list}
            |   | {name id}: id: integer notnull
            | {int 0}

The statement ending at line XXXX

@UNSUB(8, unsub_test_table);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0473: @unsub is invalid because the table/view is still used by 'sub_test_dependency'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 8}
    | {name unsub_test_table}

The statement ending at line XXXX

@UNSUB(8, sub_test_dependency);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 8}
    | {name sub_test_dependency}

The statement ending at line XXXX

@UNSUB(8, unsub_test_table);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 8}
    | {name unsub_test_table}

The statement ending at line XXXX

@RESUB(9, sub_test_dependency);

test/sem_test.sql:XXXX:1: error: in schema_resub_stmt : CQL0474: @resub is invalid because the table/view references 'unsub_test_table'

  {schema_resub_stmt}: err
  | {version_annotation}
    | {int 9}
    | {name sub_test_dependency}

The statement ending at line XXXX

@RESUB(9, unsub_test_table);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 9}
    | {name unsub_test_table}

The statement ending at line XXXX

@RESUB(9, sub_test_dependency);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 9}
    | {name sub_test_dependency}

The statement ending at line XXXX

CREATE TABLE used_by_a_view(
  id INTEGER
);

  {create_table_stmt}: used_by_a_view: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name used_by_a_view}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE VIEW uses_a_table AS
SELECT *
  FROM used_by_a_view;

  {create_view_stmt}: uses_a_table: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name uses_a_table}
      | {select_stmt}: uses_a_table: { id: integer }
        | {select_core_list}: uses_a_table: { id: integer }
        | | {select_core}: uses_a_table: { id: integer }
        |   | {select_expr_list_con}: uses_a_table: { id: integer }
        |     | {select_expr_list}: uses_a_table: { id: integer }
        |     | | {star}: uses_a_table: { id: integer }
        |     | {select_from_etc}: TABLE { used_by_a_view: used_by_a_view }
        |       | {table_or_subquery_list}: TABLE { used_by_a_view: used_by_a_view }
        |       | | {table_or_subquery}: TABLE { used_by_a_view: used_by_a_view }
        |       |   | {name used_by_a_view}: TABLE { used_by_a_view: used_by_a_view }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TABLE used_by_a_deleted_view(
  id INTEGER
);

  {create_table_stmt}: used_by_a_deleted_view: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name used_by_a_deleted_view}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE VIEW uses_a_table_but_deleted AS
SELECT *
  FROM used_by_a_deleted_view @DELETE(2);

  {create_view_stmt}: uses_a_table_but_deleted: { id: integer } deleted @delete(2)
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
    | | {name uses_a_table_but_deleted}
    | | {select_stmt}: uses_a_table_but_deleted: { id: integer }
    |   | {select_core_list}: uses_a_table_but_deleted: { id: integer }
    |   | | {select_core}: uses_a_table_but_deleted: { id: integer }
    |   |   | {select_expr_list_con}: uses_a_table_but_deleted: { id: integer }
    |   |     | {select_expr_list}: uses_a_table_but_deleted: { id: integer }
    |   |     | | {star}: uses_a_table_but_deleted: { id: integer }
    |   |     | {select_from_etc}: TABLE { used_by_a_deleted_view: used_by_a_deleted_view }
    |   |       | {table_or_subquery_list}: TABLE { used_by_a_deleted_view: used_by_a_deleted_view }
    |   |       | | {table_or_subquery}: TABLE { used_by_a_deleted_view: used_by_a_deleted_view }
    |   |       |   | {name used_by_a_deleted_view}: TABLE { used_by_a_deleted_view: used_by_a_deleted_view }
    |   |       | {select_where}
    |   |         | {select_groupby}
    |   |           | {select_having}
    |   | {select_orderby}
    |     | {select_limit}
    |       | {select_offset}
    | {delete_attr}
      | {version_annotation}
        | {int 2}

The statement ending at line XXXX

@UNSUB(10, used_by_a_view);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0473: @unsub is invalid because the table/view is still used by 'uses_a_table'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 10}
    | {name used_by_a_view}

The statement ending at line XXXX

@UNSUB(10, used_by_a_deleted_view);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 10}
    | {name used_by_a_deleted_view}

The statement ending at line XXXX

CREATE TABLE unrelated(
  id INTEGER
);

  {create_table_stmt}: unrelated: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name unrelated}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TABLE used_by_a_trigger(
  id INTEGER
);

  {create_table_stmt}: used_by_a_trigger: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name used_by_a_trigger}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TRIGGER trigger_uses_a_table
  BEFORE DELETE ON unrelated
BEGIN
  DELETE FROM used_by_a_trigger;
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name trigger_uses_a_table}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name unrelated}: unrelated: { id: integer }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name used_by_a_trigger}: used_by_a_trigger: { id: integer }

The statement ending at line XXXX

CREATE TABLE used_by_a_deleted_trigger(
  id INTEGER
);

  {create_table_stmt}: used_by_a_deleted_trigger: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name used_by_a_deleted_trigger}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE TRIGGER trigger_uses_a_table_but_deleted
  BEFORE DELETE ON unrelated
BEGIN
  DELETE FROM used_by_a_deleted_trigger;
END @DELETE(5);

  {create_trigger_stmt}: ok deleted @delete(5)
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
    | | {name trigger_uses_a_table_but_deleted}
    | | {trigger_condition}
    |   | {int 4}
    |   | {trigger_op_target}
    |     | {trigger_operation}
    |     | | {int 64}
    |     | {trigger_target_action}
    |       | {name unrelated}: unrelated: { id: integer }
    |       | {trigger_action}
    |         | {int 0}
    |         | {trigger_when_stmts}
    |           | {stmt_list}: ok
    |             | {delete_stmt}: ok
    |               | {name used_by_a_deleted_trigger}: used_by_a_deleted_trigger: { id: integer }
    | {delete_attr}
      | {version_annotation}
        | {int 5}

The statement ending at line XXXX

@UNSUB(10, used_by_a_trigger);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0473: @unsub is invalid because the table/view is still used by 'trigger_uses_a_table'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 10}
    | {name used_by_a_trigger}

The statement ending at line XXXX

@UNSUB(10, used_by_a_deleted_trigger);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 10}
    | {name used_by_a_deleted_trigger}

The statement ending at line XXXX

CREATE TABLE unsub_with_views_test_table(
  id INTEGER
);

  {create_table_stmt}: unsub_with_views_test_table: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name unsub_with_views_test_table}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

CREATE VIEW unsub_with_views_v1 AS
SELECT *
  FROM unsub_with_views_test_table;

  {create_view_stmt}: unsub_with_views_v1: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name unsub_with_views_v1}
      | {select_stmt}: unsub_with_views_v1: { id: integer }
        | {select_core_list}: unsub_with_views_v1: { id: integer }
        | | {select_core}: unsub_with_views_v1: { id: integer }
        |   | {select_expr_list_con}: unsub_with_views_v1: { id: integer }
        |     | {select_expr_list}: unsub_with_views_v1: { id: integer }
        |     | | {star}: unsub_with_views_v1: { id: integer }
        |     | {select_from_etc}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | {table_or_subquery_list}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | | {table_or_subquery}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       |   | {name unsub_with_views_test_table}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW unsub_with_views_v2 AS
SELECT *
  FROM unsub_with_views_v1;

  {create_view_stmt}: unsub_with_views_v2: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name unsub_with_views_v2}
      | {select_stmt}: unsub_with_views_v2: { id: integer }
        | {select_core_list}: unsub_with_views_v2: { id: integer }
        | | {select_core}: unsub_with_views_v2: { id: integer }
        |   | {select_expr_list_con}: unsub_with_views_v2: { id: integer }
        |     | {select_expr_list}: unsub_with_views_v2: { id: integer }
        |     | | {star}: unsub_with_views_v2: { id: integer }
        |     | {select_from_etc}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | {table_or_subquery_list}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | | {table_or_subquery}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       |   | {name unsub_with_views_v1}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW unsub_with_views_v3 AS
SELECT *
  FROM unsub_with_views_v1;

  {create_view_stmt}: unsub_with_views_v3: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name unsub_with_views_v3}
      | {select_stmt}: unsub_with_views_v3: { id: integer }
        | {select_core_list}: unsub_with_views_v3: { id: integer }
        | | {select_core}: unsub_with_views_v3: { id: integer }
        |   | {select_expr_list_con}: unsub_with_views_v3: { id: integer }
        |     | {select_expr_list}: unsub_with_views_v3: { id: integer }
        |     | | {star}: unsub_with_views_v3: { id: integer }
        |     | {select_from_etc}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | {table_or_subquery_list}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | | {table_or_subquery}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       |   | {name unsub_with_views_v1}: TABLE { unsub_with_views_v1: unsub_with_views_v1 }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW unsub_with_views_v4 AS
SELECT *
  FROM unsub_with_views_test_table;

  {create_view_stmt}: unsub_with_views_v4: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name unsub_with_views_v4}
      | {select_stmt}: unsub_with_views_v4: { id: integer }
        | {select_core_list}: unsub_with_views_v4: { id: integer }
        | | {select_core}: unsub_with_views_v4: { id: integer }
        |   | {select_expr_list_con}: unsub_with_views_v4: { id: integer }
        |     | {select_expr_list}: unsub_with_views_v4: { id: integer }
        |     | | {star}: unsub_with_views_v4: { id: integer }
        |     | {select_from_etc}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | {table_or_subquery_list}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | | {table_or_subquery}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       |   | {name unsub_with_views_test_table}: TABLE { unsub_with_views_test_table: unsub_with_views_test_table }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE VIEW unsub_with_views_v5 AS
SELECT *
  FROM unsub_with_views_v4;

  {create_view_stmt}: unsub_with_views_v5: { id: integer }
  | {int 0}
  | {view_and_attrs}
    | {name_and_select}
      | {name unsub_with_views_v5}
      | {select_stmt}: unsub_with_views_v5: { id: integer }
        | {select_core_list}: unsub_with_views_v5: { id: integer }
        | | {select_core}: unsub_with_views_v5: { id: integer }
        |   | {select_expr_list_con}: unsub_with_views_v5: { id: integer }
        |     | {select_expr_list}: unsub_with_views_v5: { id: integer }
        |     | | {star}: unsub_with_views_v5: { id: integer }
        |     | {select_from_etc}: TABLE { unsub_with_views_v4: unsub_with_views_v4 }
        |       | {table_or_subquery_list}: TABLE { unsub_with_views_v4: unsub_with_views_v4 }
        |       | | {table_or_subquery}: TABLE { unsub_with_views_v4: unsub_with_views_v4 }
        |       |   | {name unsub_with_views_v4}: TABLE { unsub_with_views_v4: unsub_with_views_v4 }
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE TRIGGER unsub_with_views_annoying_trigger
  BEFORE DELETE ON unsub_with_views_test_table
BEGIN
  DELETE FROM unsub_with_views_test_table WHERE ( SELECT id
    FROM unsub_with_views_v3 );
END;

  {create_trigger_stmt}: ok
  | {int 0}
  | {trigger_body_vers}
    | {trigger_def}
      | {name unsub_with_views_annoying_trigger}
      | {trigger_condition}
        | {int 4}
        | {trigger_op_target}
          | {trigger_operation}
          | | {int 64}
          | {trigger_target_action}
            | {name unsub_with_views_test_table}: unsub_with_views_test_table: { id: integer }
            | {trigger_action}
              | {int 0}
              | {trigger_when_stmts}
                | {stmt_list}: ok
                  | {delete_stmt}: ok
                    | {name unsub_with_views_test_table}: unsub_with_views_test_table: { id: integer }
                    | {opt_where}: id: integer
                      | {select_stmt}: id: integer
                        | {select_core_list}: select: { id: integer }
                        | | {select_core}: select: { id: integer }
                        |   | {select_expr_list_con}: select: { id: integer }
                        |     | {select_expr_list}: select: { id: integer }
                        |     | | {select_expr}: id: integer
                        |     |   | {name id}: id: integer
                        |     | {select_from_etc}: TABLE { unsub_with_views_v3: unsub_with_views_v3 }
                        |       | {table_or_subquery_list}: TABLE { unsub_with_views_v3: unsub_with_views_v3 }
                        |       | | {table_or_subquery}: TABLE { unsub_with_views_v3: unsub_with_views_v3 }
                        |       |   | {name unsub_with_views_v3}: TABLE { unsub_with_views_v3: unsub_with_views_v3 }
                        |       | {select_where}
                        |         | {select_groupby}
                        |           | {select_having}
                        | {select_orderby}
                          | {select_limit}
                            | {select_offset}

The statement ending at line XXXX

@UNSUB(10, unsub_with_views_v2);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 10}
    | {name unsub_with_views_v2}

The statement ending at line XXXX

@UNSUB(10, unsub_with_views_v1);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0473: @unsub is invalid because the table/view is still used by 'unsub_with_views_v3'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 10}
    | {name unsub_with_views_v1}

The statement ending at line XXXX

@RESUB(11, unsub_with_views_v2);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 11}
    | {name unsub_with_views_v2}

The statement ending at line XXXX

@UNSUB(11, unsub_with_views_v3);

test/sem_test.sql:XXXX:1: error: in schema_unsub_stmt : CQL0473: @unsub is invalid because the table/view is still used by 'unsub_with_views_annoying_trigger'

  {schema_unsub_stmt}: err
  | {version_annotation}
    | {int 11}
    | {name unsub_with_views_v3}

The statement ending at line XXXX

@UNSUB(12, unsub_with_views_v5);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 12}
    | {name unsub_with_views_v5}

The statement ending at line XXXX

@UNSUB(12, unsub_with_views_v4);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 12}
    | {name unsub_with_views_v4}

The statement ending at line XXXX

@RESUB(13, unsub_with_views_v5);

test/sem_test.sql:XXXX:1: error: in schema_resub_stmt : CQL0474: @resub is invalid because the table/view references 'unsub_with_views_v4'

  {schema_resub_stmt}: err
  | {version_annotation}
    | {int 13}
    | {name unsub_with_views_v5}

The statement ending at line XXXX

DECLARE PROC any_args_at_all NO CHECK;

  {declare_proc_no_check_stmt}: ok
  | {name any_args_at_all}

The statement ending at line XXXX

CREATE PROC use_locals_expansion (x INTEGER<x> NOT NULL, y INTEGER<y>)
BEGIN
  CALL any_args_at_all(LOCALS.x, LOCALS.y);
  LET z := locals.x;
  CALL any_args_at_all(LOCALS.x, LOCALS.y, LOCALS.z);
  LET u := locals.z;
  CALL any_args_at_all(LOCALS.x, LOCALS.y, LOCALS.z, LOCALS.u);
END;

  {create_proc_stmt}: ok
  | {name use_locals_expansion}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x: integer<x> notnull variable in
    | | | {param_detail}: x: integer<x> notnull variable in
    | |   | {name x}: x: integer<x> notnull variable in
    | |   | {notnull}: integer<x> notnull
    | |     | {type_int}: integer<x>
    | |       | {name x}
    | | {params}
    |   | {param}: y: integer<y> variable in
    |     | {param_detail}: y: integer<y> variable in
    |       | {name y}: y: integer<y> variable in
    |       | {type_int}: integer<y>
    |         | {name y}
    | {stmt_list}: ok
      | {call_stmt}: ok
      | | {name any_args_at_all}: ok
      | | {expr_list}: ok
      |   | {dot}: x: integer<x> notnull variable in
      |   | | {name LOCALS}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: y: integer<y> variable in
      |       | {name LOCALS}
      |       | {name y}
      | {let_stmt}: z: integer<x> notnull variable
      | | {name z}: z: integer<x> notnull variable
      | | {dot}: x: integer<x> notnull variable in
      |   | {name locals}
      |   | {name x}
      | {call_stmt}: ok
      | | {name any_args_at_all}: ok
      | | {expr_list}: ok
      |   | {dot}: x: integer<x> notnull variable in
      |   | | {name LOCALS}
      |   | | {name x}
      |   | {expr_list}
      |     | {dot}: y: integer<y> variable in
      |     | | {name LOCALS}
      |     | | {name y}
      |     | {expr_list}
      |       | {dot}: z: integer<x> notnull variable
      |         | {name LOCALS}
      |         | {name z}
      | {let_stmt}: u: integer<x> notnull variable
      | | {name u}: u: integer<x> notnull variable
      | | {dot}: z: integer<x> notnull variable
      |   | {name locals}
      |   | {name z}
      | {call_stmt}: ok
        | {name any_args_at_all}: ok
        | {expr_list}: ok
          | {dot}: x: integer<x> notnull variable in
          | | {name LOCALS}
          | | {name x}
          | {expr_list}
            | {dot}: y: integer<y> variable in
            | | {name LOCALS}
            | | {name y}
            | {expr_list}
              | {dot}: z: integer<x> notnull variable
              | | {name LOCALS}
              | | {name z}
              | {expr_list}
                | {dot}: u: integer<x> notnull variable
                  | {name LOCALS}
                  | {name u}

The statement ending at line XXXX

CREATE PROC bogus_local_usage ()
BEGIN
  CALL any_args_at_all(locals.xyzzy);
END;

test/sem_test.sql:XXXX:1: error: in dot : CQL0201: expanding FROM LOCALS, there is no local matching 'xyzzy'

  {create_proc_stmt}: err
  | {name bogus_local_usage}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {call_stmt}: err
        | {name any_args_at_all}: ok
        | {expr_list}: err
          | {dot}: err
            | {name locals}
            | {name xyzzy}

The statement ending at line XXXX

LET no_chance_of_this_working := locals.xyzzy;

test/sem_test.sql:XXXX:1: error: in dot : CQL0201: expanding FROM LOCALS, there is no local matching 'xyzzy'

  {let_stmt}: err
  | {name no_chance_of_this_working}
  | {dot}: err
    | {name locals}
    | {name xyzzy}

The statement ending at line XXXX

CALL any_args_at_all(FROM locals);

test/sem_test.sql:XXXX:1: error: in str : CQL0069: name not found 'locals'

  {call_stmt}: err
  | {name any_args_at_all}
  | {expr_list}: err
    | {from_shape}
      | {name locals}: err

The statement ending at line XXXX

CREATE PROC locals_work_with_nullability_improvements (a_ INTEGER)
BEGIN
  DECLARE b INTEGER;
  DECLARE c_ INTEGER;
  IF a_ IS NULL OR b IS NULL OR locals.c IS NULL THEN
    RETURN;
  END IF;
  CALL requires_not_nulls(a_, b, c_);
  CALL requires_not_nulls(LOCALS.a, LOCALS.b, LOCALS.c);
  CALL requires_not_nulls(LOCALS.a_, LOCALS.b, LOCALS.c_);
  CALL requires_not_nulls(LOCALS.a, LOCALS.b, LOCALS.c);
END;

  {create_proc_stmt}: ok
  | {name locals_work_with_nullability_improvements}: ok
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: a_: integer variable in
    |   | {param_detail}: a_: integer variable in
    |     | {name a_}: a_: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {declare_vars_type}: integer
      | | {name_list}: b: integer variable
      | | | {name b}: b: integer variable
      | | {type_int}: integer
      | {declare_vars_type}: integer
      | | {name_list}: c_: integer variable
      | | | {name c_}: c_: integer variable
      | | {type_int}: integer
      | {if_stmt}: bool notnull
      | | {cond_action}: bool notnull
      | | | {or}: bool notnull
      | | | | {or}: bool notnull
      | | | | | {is}: bool notnull
      | | | | | | {name a_}: a_: integer variable in
      | | | | | | {null}: null
      | | | | | {is}: bool notnull
      | | | |   | {name b}: b: integer variable
      | | | |   | {null}: null
      | | | | {is}: bool notnull
      | | |   | {dot}: c_: integer variable
      | | |   | | {name locals}
      | | |   | | {name c}
      | | |   | {null}: null
      | | | {stmt_list}: ok
      | |   | {return_stmt}: ok
      | | {if_alt}: ok
      | {call_stmt}: ok
      | | {name requires_not_nulls}: ok
      | | {expr_list}: ok
      |   | {call}: a_: integer notnull variable in
      |   | | {name cql_inferred_notnull}: a_: integer notnull variable in
      |   | | {call_arg_list}
      |   |   | {call_filter_clause}
      |   |   | {arg_list}: ok
      |   |     | {name a_}: a_: integer inferred_notnull variable in
      |   | {expr_list}
      |     | {call}: b: integer notnull variable
      |     | | {name cql_inferred_notnull}: b: integer notnull variable
      |     | | {call_arg_list}
      |     |   | {call_filter_clause}
      |     |   | {arg_list}: ok
      |     |     | {name b}: b: integer inferred_notnull variable
      |     | {expr_list}
      |       | {call}: c_: integer notnull variable
      |         | {name cql_inferred_notnull}: c_: integer notnull variable
      |         | {call_arg_list}
      |           | {call_filter_clause}
      |           | {arg_list}: ok
      |             | {name c_}: c_: integer inferred_notnull variable
      | {call_stmt}: ok
      | | {name requires_not_nulls}: ok
      | | {expr_list}: ok
      |   | {call}: a_: integer notnull variable in
      |   | | {name cql_inferred_notnull}: a_: integer notnull variable in
      |   | | {call_arg_list}
      |   |   | {call_filter_clause}
      |   |   | {arg_list}: ok
      |   |     | {dot}: a_: integer variable in
      |   |       | {name LOCALS}
      |   |       | {name a}
      |   | {expr_list}
      |     | {call}: b: integer notnull variable
      |     | | {name cql_inferred_notnull}: b: integer notnull variable
      |     | | {call_arg_list}
      |     |   | {call_filter_clause}
      |     |   | {arg_list}: ok
      |     |     | {dot}: b: integer variable
      |     |       | {name LOCALS}
      |     |       | {name b}
      |     | {expr_list}
      |       | {call}: c_: integer notnull variable
      |         | {name cql_inferred_notnull}: c_: integer notnull variable
      |         | {call_arg_list}
      |           | {call_filter_clause}
      |           | {arg_list}: ok
      |             | {dot}: c_: integer variable
      |               | {name LOCALS}
      |               | {name c}
      | {call_stmt}: ok
      | | {name requires_not_nulls}: ok
      | | {expr_list}: ok
      |   | {call}: a_: integer notnull variable in
      |   | | {name cql_inferred_notnull}: a_: integer notnull variable in
      |   | | {call_arg_list}
      |   |   | {call_filter_clause}
      |   |   | {arg_list}: ok
      |   |     | {dot}: a_: integer variable in
      |   |       | {name LOCALS}
      |   |       | {name a_}
      |   | {expr_list}
      |     | {call}: b: integer notnull variable
      |     | | {name cql_inferred_notnull}: b: integer notnull variable
      |     | | {call_arg_list}
      |     |   | {call_filter_clause}
      |     |   | {arg_list}: ok
      |     |     | {dot}: b: integer variable
      |     |       | {name LOCALS}
      |     |       | {name b}
      |     | {expr_list}
      |       | {call}: c_: integer notnull variable
      |         | {name cql_inferred_notnull}: c_: integer notnull variable
      |         | {call_arg_list}
      |           | {call_filter_clause}
      |           | {arg_list}: ok
      |             | {dot}: c_: integer variable
      |               | {name LOCALS}
      |               | {name c_}
      | {call_stmt}: ok
        | {name requires_not_nulls}: ok
        | {expr_list}: ok
          | {call}: a_: integer notnull variable in
          | | {name cql_inferred_notnull}: a_: integer notnull variable in
          | | {call_arg_list}
          |   | {call_filter_clause}
          |   | {arg_list}: ok
          |     | {dot}: a_: integer variable in
          |       | {name LOCALS}
          |       | {name a}
          | {expr_list}
            | {call}: b: integer notnull variable
            | | {name cql_inferred_notnull}: b: integer notnull variable
            | | {call_arg_list}
            |   | {call_filter_clause}
            |   | {arg_list}: ok
            |     | {dot}: b: integer variable
            |       | {name LOCALS}
            |       | {name b}
            | {expr_list}
              | {call}: c_: integer notnull variable
                | {name cql_inferred_notnull}: c_: integer notnull variable
                | {call_arg_list}
                  | {call_filter_clause}
                  | {arg_list}: ok
                    | {dot}: c_: integer variable
                      | {name LOCALS}
                      | {name c}

The statement ending at line XXXX

CREATE TABLE parent_subs_table(
  id INTEGER PRIMARY KEY
) @CREATE(9) @DELETE(25);

  {create_table_stmt}: parent_subs_table: { id: integer notnull primary_key } deleted @create(9) @delete(25)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 9}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 25}
  | | {name parent_subs_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}

The statement ending at line XXXX

CREATE TABLE child_subs_table(
  id INTEGER PRIMARY KEY REFERENCES parent_subs_table (id)
) @CREATE(9) @DELETE(25);

  {create_table_stmt}: child_subs_table: { id: integer notnull primary_key foreign_key } deleted @create(9) @delete(25)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |   | | {int 9}
  | |   | {delete_attr}
  | |     | {version_annotation}
  | |       | {int 25}
  | | {name child_subs_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key foreign_key
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
        | | {name id}
        | | {type_int}: integer
        | {col_attrs_pk}: ok
          | {autoinc_and_conflict_clause}
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name parent_subs_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@UNSUB(20, child_subs_table);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 20}
    | {name child_subs_table}

The statement ending at line XXXX

@UNSUB(20, parent_subs_table);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 20}
    | {name parent_subs_table}

The statement ending at line XXXX

@RESUB(21, parent_subs_table);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 21}
    | {name parent_subs_table}

The statement ending at line XXXX

@RESUB(22, child_subs_table);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 22}
    | {name child_subs_table}

The statement ending at line XXXX

CREATE TABLE self_ref_table(
  id INTEGER PRIMARY KEY,
  id2 INTEGER REFERENCES self_ref_table (id)
) @CREATE(10);

  {create_table_stmt}: self_ref_table: { id: integer notnull primary_key, id2: integer foreign_key } @create(10)
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | | {create_attr}
  | |   | {version_annotation}
  | |     | {int 10}
  | | {name self_ref_table}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: id2: integer foreign_key
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
          | | {name id2}
          | | {type_int}: integer
          | {col_attrs_fk}: ok
            | {fk_target_options}
              | {fk_target}
              | | {name self_ref_table}
              | | {name_list}
              |   | {name id}: id: integer notnull
              | {int 0}

The statement ending at line XXXX

@UNSUB(23, self_ref_table);

  {schema_unsub_stmt}: ok
  | {version_annotation}
    | {int 23}
    | {name self_ref_table}

The statement ending at line XXXX

@RESUB(24, self_ref_table);

  {schema_resub_stmt}: ok
  | {version_annotation}
    | {int 24}
    | {name self_ref_table}

The statement ending at line XXXX

DECLARE PROC broken_thing (LIKE does_not_exist ARGUMENTS);

test/sem_test.sql:XXXX:1: error: in like : CQL0069: name not found 'does_not_exist'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name broken_thing}
  | | {int 0}
  | {proc_params_stmts}
    | {params}: err
      | {param}: err
        | {param_detail}
          | {shape_def}: err
            | {like}: err
              | {name does_not_exist}: err
              | {name does_not_exist}: err

The statement ending at line XXXX

DECLARE PROC uses_broken_thing () (LIKE broken_thing ARGUMENTS);

test/sem_test.sql:XXXX:1: error: in like : CQL0069: name not found (proc had errors, cannot be used) 'broken_thing'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name uses_broken_thing}
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: err
      | {typed_name}: err
        | {shape_def}: err
          | {like}: err
            | {name broken_thing}: err
            | {name broken_thing}: err

The statement ending at line XXXX

DECLARE FUNC external_cursor_func (x CURSOR) INTEGER;

  {declare_func_stmt}: integer
  | {name external_cursor_func}: integer
  | {func_params_return}
    | {params}: ok
    | | {param}: x: cursor variable in
    |   | {param_detail}: x: cursor variable in
    |     | {name x}: x: cursor variable in
    |     | {type_cursor}: cursor
    | {type_int}: integer

The statement ending at line XXXX

LET result := external_cursor_func(shape_storage);

  {let_stmt}: result: integer variable
  | {name result}: result: integer variable
  | {call}: integer
    | {name external_cursor_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {name shape_storage}: shape_storage: select: { one: integer notnull, two: integer notnull } variable dml_proc shape_storage

The statement ending at line XXXX

SET result := external_cursor_func(1);

test/sem_test.sql:XXXX:1: error: in num : CQL0205: not a cursor '1'

  {assign}: err
  | {name result}: result: integer variable
  | {call}: err
    | {name external_cursor_func}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: err

The statement ending at line XXXX

DECLARE PROC uses_broken_thing () (LIKE broken_thing ARGUMENTS);

test/sem_test.sql:XXXX:1: error: in like : CQL0069: name not found (proc had errors, cannot be used) 'broken_thing'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name uses_broken_thing}
  | | {int 3}
  | {proc_params_stmts}
    | {typed_names}: err
      | {typed_name}: err
        | {shape_def}: err
          | {like}: err
            | {name broken_thing}: err
            | {name broken_thing}: err

The statement ending at line XXXX

DECLARE INTERFACE proc4 (id INTEGER);

test/sem_test.sql:XXXX:1: error: in declare_interface_stmt : CQL0478: interface name conflicts with procedure name 'proc4'

  {declare_interface_stmt}: err
  | {name proc4}
  | {proc_params_stmts}
    | {typed_names}
      | {typed_name}
        | {name id}
        | {type_int}

The statement ending at line XXXX

DECLARE INTERFACE interface1 (id INTEGER);

  {declare_interface_stmt}: interface1: { id: integer }
  | {name interface1}
  | {proc_params_stmts}
    | {typed_names}: interface1: { id: integer }
      | {typed_name}: id: integer
        | {name id}
        | {type_int}: id: integer

The statement ending at line XXXX

DECLARE INTERFACE interface1 (id INTEGER);

  {declare_interface_stmt}: interface1: { id: integer }
  | {name interface1}
  | {proc_params_stmts}
    | {typed_names}: interface1: { id: integer }
      | {typed_name}: id: integer
        | {name id}
        | {type_int}: id: integer

The statement ending at line XXXX

DECLARE INTERFACE interface1 (id INTEGER, id TEXT);

test/sem_test.sql:XXXX:1: error: in str : CQL0190: duplicate column name 'id'

  {declare_interface_stmt}: err
  | {name interface1}
  | {proc_params_stmts}
    | {typed_names}: err
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: err
          | {name id}
          | {type_text}

The statement ending at line XXXX

DECLARE INTERFACE interface1 (id INTEGER, name TEXT);

Incompatible declarations found
test/sem_test.sql:XXXX:1: error: in declare_interface_stmt : DECLARE INTERFACE interface1 (id INTEGER)
test/sem_test.sql:XXXX:1: error: in declare_interface_stmt : DECLARE INTERFACE interface1 (id INTEGER, name TEXT)
The above must be identical.
test/sem_test.sql:XXXX:1: error: in declare_interface_stmt : CQL0479: interface declarations do not match 'interface1'

  {declare_interface_stmt}: err
  | {name interface1}
  | {proc_params_stmts}
    | {typed_names}: interface1: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

DECLARE INTERFACE interface2 (id INTEGER, name TEXT);

  {declare_interface_stmt}: interface2: { id: integer, name: text }
  | {name interface2}
  | {proc_params_stmts}
    | {typed_names}: interface2: { id: integer, name: text }
      | {typed_name}: id: integer
      | | {name id}
      | | {type_int}: id: integer
      | {typed_names}
        | {typed_name}: name: text
          | {name name}
          | {type_text}: name: text

The statement ending at line XXXX

CREATE PROC interface_source (id_ INTEGER, name_ TEXT)
BEGIN
END;

  {create_proc_stmt}: ok
  | {name interface_source}: ok
  | {proc_params_stmts}
    | {params}: ok
      | {param}: id_: integer variable in
      | | {param_detail}: id_: integer variable in
      |   | {name id_}: id_: integer variable in
      |   | {type_int}: integer
      | {params}
        | {param}: name_: text variable in
          | {param_detail}: name_: text variable in
            | {name name_}: name_: text variable in
            | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface1)
CREATE PROC test_interface1_implementation_correct (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT id_ AS id, name_ AS name;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface1}: ok
  | {create_proc_stmt}: test_interface1_implementation_correct: { id: integer, name: text } dml_proc
    | {name test_interface1_implementation_correct}: test_interface1_implementation_correct: { id: integer, name: text } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      | | | {param_detail}: id_: integer variable in
      | |   | {name id_}: id_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: name_: text variable in
      |     | {param_detail}: name_: text variable in
      |       | {name name_}: name_: text variable in
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer variable in, name: text variable in }
          | {select_core_list}: select: { id: integer variable in, name: text variable in }
          | | {select_core}: select: { id: integer variable in, name: text variable in }
          |   | {select_expr_list_con}: select: { id: integer variable in, name: text variable in }
          |     | {select_expr_list}: select: { id: integer variable in, name: text variable in }
          |     | | {select_expr}: id: integer variable in
          |     | | | {name id_}: id_: integer variable in
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text variable in
          |     |     | {name name_}: name_: text variable in
          |     |     | {opt_as_alias}
          |     |       | {name name}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface1)
CREATE PROC test_interface1_implementation_wrong_nullability (id_ INTEGER NOT NULL)
BEGIN
  SELECT id_ AS id, "5" AS col2;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0485: column types returned by proc need to be the same as defined on the interface (expected integer; found integer notnull) 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface1}: ok
  | {create_proc_stmt}: err
    | {name test_interface1_implementation_wrong_nullability}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer notnull variable in
      |   | {param_detail}: id_: integer notnull variable in
      |     | {name id_}: id_: integer notnull variable in
      |     | {notnull}: integer notnull
      |       | {type_int}: integer
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull variable in, col2: text notnull }
          | {select_core_list}: select: { id: integer notnull variable in, col2: text notnull }
          | | {select_core}: select: { id: integer notnull variable in, col2: text notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull variable in, col2: text notnull }
          |     | {select_expr_list}: select: { id: integer notnull variable in, col2: text notnull }
          |     | | {select_expr}: id: integer notnull variable in
          |     | | | {name id_}: id_: integer notnull variable in
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: col2: text notnull
          |     |     | {strlit '5'}: text notnull
          |     |     | {opt_as_alias}
          |     |       | {name col2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface1)
CREATE PROC test_interface1_implementation_wrong_type (id_ TEXT NOT NULL)
BEGIN
  SELECT id_ AS id, "5" AS col2;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0485: column types returned by proc need to be the same as defined on the interface (expected integer; found text notnull) 'id'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface1}: ok
  | {create_proc_stmt}: err
    | {name test_interface1_implementation_wrong_type}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: text notnull variable in
      |   | {param_detail}: id_: text notnull variable in
      |     | {name id_}: id_: text notnull variable in
      |     | {notnull}: text notnull
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { id: text notnull variable in, col2: text notnull }
          | {select_core_list}: select: { id: text notnull variable in, col2: text notnull }
          | | {select_core}: select: { id: text notnull variable in, col2: text notnull }
          |   | {select_expr_list_con}: select: { id: text notnull variable in, col2: text notnull }
          |     | {select_expr_list}: select: { id: text notnull variable in, col2: text notnull }
          |     | | {select_expr}: id: text notnull variable in
          |     | | | {name id_}: id_: text notnull variable in
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: col2: text notnull
          |     |     | {strlit '5'}: text notnull
          |     |     | {opt_as_alias}
          |     |       | {name col2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface1)
CREATE PROC test_interface1_implementation_wrong_order (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT name_ AS name, id_ AS id;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface1}: ok
  | {create_proc_stmt}: test_interface1_implementation_wrong_order: { name: text, id: integer } dml_proc
    | {name test_interface1_implementation_wrong_order}: test_interface1_implementation_wrong_order: { name: text, id: integer } dml_proc
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      | | | {param_detail}: id_: integer variable in
      | |   | {name id_}: id_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: name_: text variable in
      |     | {param_detail}: name_: text variable in
      |       | {name name_}: name_: text variable in
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { name: text variable in, id: integer variable in }
          | {select_core_list}: select: { name: text variable in, id: integer variable in }
          | | {select_core}: select: { name: text variable in, id: integer variable in }
          |   | {select_expr_list_con}: select: { name: text variable in, id: integer variable in }
          |     | {select_expr_list}: select: { name: text variable in, id: integer variable in }
          |     | | {select_expr}: name: text variable in
          |     | | | {name name_}: name_: text variable in
          |     | | | {opt_as_alias}
          |     | |   | {name name}
          |     | | {select_expr_list}
          |     |   | {select_expr}: id: integer variable in
          |     |     | {name id_}: id_: integer variable in
          |     |     | {opt_as_alias}
          |     |       | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface1)
CREATE PROC test_interface1_implementation_wrong_name (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT id_ AS id2, name_ AS name;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0484: procedure 'test_interface1_implementation_wrong_name' is missing column 'id' of interface 'interface1'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface1}: ok
  | {create_proc_stmt}: err
    | {name test_interface1_implementation_wrong_name}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      | | | {param_detail}: id_: integer variable in
      | |   | {name id_}: id_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: name_: text variable in
      |     | {param_detail}: name_: text variable in
      |       | {name name_}: name_: text variable in
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { id2: integer variable in, name: text variable in }
          | {select_core_list}: select: { id2: integer variable in, name: text variable in }
          | | {select_core}: select: { id2: integer variable in, name: text variable in }
          |   | {select_expr_list_con}: select: { id2: integer variable in, name: text variable in }
          |     | {select_expr_list}: select: { id2: integer variable in, name: text variable in }
          |     | | {select_expr}: id2: integer variable in
          |     | | | {name id_}: id_: integer variable in
          |     | | | {opt_as_alias}
          |     | |   | {name id2}
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text variable in
          |     |     | {name name_}: name_: text variable in
          |     |     | {opt_as_alias}
          |     |       | {name name}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface2)
CREATE PROC test_interface1_missing_column (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT id_ AS id;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0484: procedure 'test_interface1_missing_column' is missing column 'name' of interface 'interface2'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name interface2}: ok
  | {create_proc_stmt}: err
    | {name test_interface1_missing_column}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      | | | {param_detail}: id_: integer variable in
      | |   | {name id_}: id_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: name_: text variable in
      |     | {param_detail}: name_: text variable in
      |       | {name name_}: name_: text variable in
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer variable in }
          | {select_core_list}: select: { id: integer variable in }
          | | {select_core}: select: { id: integer variable in }
          |   | {select_expr_list_con}: select: { id: integer variable in }
          |     | {select_expr_list}: select: { id: integer variable in }
          |     | | {select_expr}: id: integer variable in
          |     |   | {name id_}: id_: integer variable in
          |     |   | {opt_as_alias}
          |     |     | {name id}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=missing_interface)
CREATE PROC test_interface1_missing_interface (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT id_ AS id, name_ AS name;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0482: interface not found 'missing_interface'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  |   | {dot}
  |   | | {name cql}
  |   | | {name implements}
  |   | {name missing_interface}: err
  | {create_proc_stmt}: err
    | {name test_interface1_missing_interface}: err
    | {proc_params_stmts}
      | {params}: ok
      | | {param}: id_: integer variable in
      | | | {param_detail}: id_: integer variable in
      | |   | {name id_}: id_: integer variable in
      | |   | {type_int}: integer
      | | {params}
      |   | {param}: name_: text variable in
      |     | {param_detail}: name_: text variable in
      |       | {name name_}: name_: text variable in
      |       | {type_text}: text
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer variable in, name: text variable in }
          | {select_core_list}: select: { id: integer variable in, name: text variable in }
          | | {select_core}: select: { id: integer variable in, name: text variable in }
          |   | {select_expr_list_con}: select: { id: integer variable in, name: text variable in }
          |     | {select_expr_list}: select: { id: integer variable in, name: text variable in }
          |     | | {select_expr}: id: integer variable in
          |     | | | {name id_}: id_: integer variable in
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text variable in
          |     |     | {name name_}: name_: text variable in
          |     |     | {opt_as_alias}
          |     |       | {name name}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE PROC interface1 (id_ INTEGER, name_ TEXT);

test/sem_test.sql:XXXX:1: error: in declare_proc_stmt : CQL0481: proc name conflicts with interface name 'interface1'

  {declare_proc_stmt}: err
  | {proc_name_type}
  | | {name interface1}
  | | {int 0}
  | {proc_params_stmts}
    | {params}
      | {param}
      | | {param_detail}
      |   | {name id_}
      |   | {type_int}
      | {params}
        | {param}
          | {param_detail}
            | {name name_}
            | {type_text}

The statement ending at line XXXX

CREATE PROC interface1 (id_ INTEGER, name_ TEXT)
BEGIN
  SELECT id_ AS id2, name_ AS name;
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0481: proc name conflicts with interface name 'interface1'

  {create_proc_stmt}: err
  | {name interface1}: err
  | {proc_params_stmts}
    | {params}
    | | {param}
    | | | {param_detail}
    | |   | {name id_}
    | |   | {type_int}
    | | {params}
    |   | {param}
    |     | {param_detail}
    |       | {name name_}
    |       | {type_text}
    | {stmt_list}
      | {select_stmt}
        | {select_core_list}
        | | {select_core}
        |   | {select_expr_list_con}
        |     | {select_expr_list}
        |     | | {select_expr}
        |     | | | {name id_}
        |     | | | {opt_as_alias}
        |     | |   | {name id2}
        |     | | {select_expr_list}
        |     |   | {select_expr}
        |     |     | {name name_}
        |     |     | {opt_as_alias}
        |     |       | {name name}
        |     | {select_from_etc}
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

DECLARE INTERFACE interface_foo1 (id INTEGER NOT NULL, name TEXT NOT NULL);

  {declare_interface_stmt}: interface_foo1: { id: integer notnull, name: text notnull }
  | {name interface_foo1}
  | {proc_params_stmts}
    | {typed_names}: interface_foo1: { id: integer notnull, name: text notnull }
      | {typed_name}: id: integer notnull
      | | {name id}
      | | {notnull}: id: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: name: text notnull
          | {name name}
          | {notnull}: name: text notnull
            | {type_text}: text

The statement ending at line XXXX

DECLARE INTERFACE interface_foo2 (id2 INTEGER NOT NULL, name TEXT NOT NULL);

  {declare_interface_stmt}: interface_foo2: { id2: integer notnull, name: text notnull }
  | {name interface_foo2}
  | {proc_params_stmts}
    | {typed_names}: interface_foo2: { id2: integer notnull, name: text notnull }
      | {typed_name}: id2: integer notnull
      | | {name id2}
      | | {notnull}: id2: integer notnull
      |   | {type_int}: integer
      | {typed_names}
        | {typed_name}: name: text notnull
          | {name name}
          | {notnull}: name: text notnull
            | {type_text}: text

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface_foo1)
@ATTRIBUTE(cql:implements=interface_foo2)
CREATE PROC interface_proc1 ()
BEGIN
  SELECT 1 AS id, "2" AS name;
END;

test/sem_test.sql:XXXX:1: error: in create_proc_stmt : CQL0484: procedure 'interface_proc1' is missing column 'id2' of interface 'interface_foo2'

  {stmt_and_attr}: err
  | {misc_attrs}: err
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name implements}
  | | | {name interface_foo1}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name implements}
  |     | {name interface_foo2}: ok
  | {create_proc_stmt}: err
    | {name interface_proc1}: err
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text notnull }
          | {select_core_list}: select: { id: integer notnull, name: text notnull }
          | | {select_core}: select: { id: integer notnull, name: text notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull }
          |     | {select_expr_list}: select: { id: integer notnull, name: text notnull }
          |     | | {select_expr}: id: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text notnull
          |     |     | {strlit '2'}: text notnull
          |     |     | {opt_as_alias}
          |     |       | {name name}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

@ATTRIBUTE(cql:implements=interface_foo1)
@ATTRIBUTE(cql:implements=interface_foo2)
CREATE PROC interface_proc2 ()
BEGIN
  SELECT 1 AS id, "2" AS name, 3 AS id2;
END;

  {stmt_and_attr}: ok
  | {misc_attrs}: ok
  | | {misc_attr}
  | | | {dot}
  | | | | {name cql}
  | | | | {name implements}
  | | | {name interface_foo1}: ok
  | | {misc_attrs}
  |   | {misc_attr}
  |     | {dot}
  |     | | {name cql}
  |     | | {name implements}
  |     | {name interface_foo2}: ok
  | {create_proc_stmt}: interface_proc2: { id: integer notnull, name: text notnull, id2: integer notnull } dml_proc
    | {name interface_proc2}: interface_proc2: { id: integer notnull, name: text notnull, id2: integer notnull } dml_proc
    | {proc_params_stmts}
      | {stmt_list}: ok
        | {select_stmt}: select: { id: integer notnull, name: text notnull, id2: integer notnull }
          | {select_core_list}: select: { id: integer notnull, name: text notnull, id2: integer notnull }
          | | {select_core}: select: { id: integer notnull, name: text notnull, id2: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull, name: text notnull, id2: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull, name: text notnull, id2: integer notnull }
          |     | | {select_expr}: id: integer notnull
          |     | | | {int 1}: integer notnull
          |     | | | {opt_as_alias}
          |     | |   | {name id}
          |     | | {select_expr_list}
          |     |   | {select_expr}: name: text notnull
          |     |   | | {strlit '2'}: text notnull
          |     |   | | {opt_as_alias}
          |     |   |   | {name name}
          |     |   | {select_expr_list}
          |     |     | {select_expr}: id2: integer notnull
          |     |       | {int 3}: integer notnull
          |     |       | {opt_as_alias}
          |     |         | {name id2}
          |     | {select_from_etc}: ok
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC no_check_select_fun NO CHECK TEXT;

  {declare_select_func_no_check_stmt}: text select_func
  | {name no_check_select_fun}: text
  | {func_params_return}
    | {type_text}: text

The statement ending at line XXXX

DECLARE SELECT FUNC no_check_select_fun NO CHECK TEXT;

  {declare_select_func_no_check_stmt}: text select_func
  | {name no_check_select_fun}: text
  | {func_params_return}
    | {type_text}: text

The statement ending at line XXXX

DECLARE SELECT FUNC no_check_select_fun () TEXT;

test/sem_test.sql:XXXX:1: error: in declare_select_func_stmt : CQL0486: function cannot be both a normal function and an unchecked function 'no_check_select_fun'

  {declare_select_func_stmt}: err
  | {name no_check_select_fun}
  | {func_params_return}
    | {type_text}

The statement ending at line XXXX

SELECT no_check_select_fun(0, "hello");

  {select_stmt}: select: { _anon: text }
  | {select_core_list}: select: { _anon: text }
  | | {select_core}: select: { _anon: text }
  |   | {select_expr_list_con}: select: { _anon: text }
  |     | {select_expr_list}: select: { _anon: text }
  |     | | {select_expr}: text
  |     |   | {call}: text
  |     |     | {name no_check_select_fun}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: ok
  |     |         | {int 0}: integer notnull
  |     |         | {arg_list}
  |     |           | {strlit 'hello'}: text notnull
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT no_check_select_fun(0, *);

test/sem_test.sql:XXXX:1: error: in star : CQL0051: argument can only be used in count(*) '*'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}: err
  |     |   | {call}: err
  |     |     | {name no_check_select_fun}
  |     |     | {call_arg_list}
  |     |       | {call_filter_clause}
  |     |       | {arg_list}: err
  |     |         | {int 0}: integer notnull
  |     |         | {arg_list}
  |     |           | {star}: err
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE SELECT FUNC no_check_select_table_valued_fun NO CHECK (t TEXT, i INTEGER);

  {declare_select_func_no_check_stmt}: select: { t: text, i: integer } select_func
  | {name no_check_select_table_valued_fun}: select: { t: text, i: integer }
  | {func_params_return}
    | {typed_names}: select: { t: text, i: integer }
      | {typed_name}: t: text
      | | {name t}
      | | {type_text}: t: text
      | {typed_names}
        | {typed_name}: i: integer
          | {name i}
          | {type_int}: i: integer

The statement ending at line XXXX

SELECT t, i
  FROM no_check_select_table_valued_fun(0, "hello");

  {select_stmt}: select: { t: text, i: integer }
  | {select_core_list}: select: { t: text, i: integer }
  | | {select_core}: select: { t: text, i: integer }
  |   | {select_expr_list_con}: select: { t: text, i: integer }
  |     | {select_expr_list}: select: { t: text, i: integer }
  |     | | {select_expr}: t: text
  |     | | | {name t}: t: text
  |     | | {select_expr_list}
  |     |   | {select_expr}: i: integer
  |     |     | {name i}: i: integer
  |     | {select_from_etc}: TABLE { no_check_select_table_valued_fun: select } table_valued_function
  |       | {table_or_subquery_list}: TABLE { no_check_select_table_valued_fun: select } table_valued_function
  |       | | {table_or_subquery}: TABLE { no_check_select_table_valued_fun: select } table_valued_function
  |       |   | {table_function}: TABLE { no_check_select_table_valued_fun: select } table_valued_function
  |       |     | {name no_check_select_table_valued_fun}: TABLE { no_check_select_table_valued_fun: select } table_valued_function
  |       |     | {arg_list}: ok
  |       |       | {int 0}: integer notnull
  |       |       | {arg_list}
  |       |         | {strlit 'hello'}: text notnull
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

SELECT t, i
  FROM no_check_select_table_valued_fun(0, *);

test/sem_test.sql:XXXX:1: error: in star : CQL0051: argument can only be used in count(*) '*'

  {select_stmt}: err
  | {select_core_list}: err
  | | {select_core}: err
  |   | {select_expr_list_con}: err
  |     | {select_expr_list}: err
  |     | | {select_expr}
  |     | | | {name t}
  |     | | {select_expr_list}
  |     |   | {select_expr}
  |     |     | {name i}
  |     | {select_from_etc}: err
  |       | {table_or_subquery_list}: err
  |       | | {table_or_subquery}: err
  |       |   | {table_function}: err
  |       |     | {name no_check_select_table_valued_fun}
  |       |     | {arg_list}: err
  |       |       | {int 0}: integer notnull
  |       |       | {arg_list}
  |       |         | {star}: err
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}

The statement ending at line XXXX

DECLARE PROC interface1 NO CHECK;

test/sem_test.sql:XXXX:1: error: in declare_proc_no_check_stmt : CQL0481: proc name conflicts with interface name 'interface1'

  {declare_proc_no_check_stmt}: err
  | {name interface1}

The statement ending at line XXXX

DECLARE INTERFACE maybe_create_func_text (id INTEGER, name TEXT);

test/sem_test.sql:XXXX:1: error: in str : CQL0477: interface name conflicts with func name 'maybe_create_func_text'

  {declare_interface_stmt}: err
  | {name maybe_create_func_text}
  | {proc_params_stmts}
    | {typed_names}
      | {typed_name}
      | | {name id}
      | | {type_int}
      | {typed_names}
        | {typed_name}
          | {name name}
          | {type_text}

The statement ending at line XXXX

CREATE PROC nested_interface_wrapper ()
BEGIN
  DECLARE INTERFACE foo (LIKE interface1);
END;

test/sem_test.sql:XXXX:1: error: in str : CQL0480: declared interface must be top level 'foo'

  {create_proc_stmt}: err
  | {name nested_interface_wrapper}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_interface_stmt}: err
        | {name foo}
        | {proc_params_stmts}
          | {typed_names}
            | {typed_name}
              | {shape_def}
                | {like}
                  | {name interface1}

The statement ending at line XXXX

CREATE PROC test_parent (x_ INTEGER)
BEGIN
  SELECT x_ AS x;
END;

  {create_proc_stmt}: test_parent: { x: integer } dml_proc
  | {name test_parent}: test_parent: { x: integer } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer variable in
    |   | {param_detail}: x_: integer variable in
    |     | {name x_}: x_: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {select_stmt}: select: { x: integer variable in }
        | {select_core_list}: select: { x: integer variable in }
        | | {select_core}: select: { x: integer variable in }
        |   | {select_expr_list_con}: select: { x: integer variable in }
        |     | {select_expr_list}: select: { x: integer variable in }
        |     | | {select_expr}: x: integer variable in
        |     |   | {name x_}: x_: integer variable in
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC test_child (x_ INTEGER)
BEGIN
  SELECT x_ AS x;
END;

  {create_proc_stmt}: test_child: { x: integer } dml_proc
  | {name test_child}: test_child: { x: integer } dml_proc
  | {proc_params_stmts}
    | {params}: ok
    | | {param}: x_: integer variable in
    |   | {param_detail}: x_: integer variable in
    |     | {name x_}: x_: integer variable in
    |     | {type_int}: integer
    | {stmt_list}: ok
      | {select_stmt}: select: { x: integer variable in }
        | {select_core_list}: select: { x: integer variable in }
        | | {select_core}: select: { x: integer variable in }
        |   | {select_expr_list_con}: select: { x: integer variable in }
        |     | {select_expr_list}: select: { x: integer variable in }
        |     | | {select_expr}: x: integer variable in
        |     |   | {name x_}: x_: integer variable in
        |     |   | {opt_as_alias}
        |     |     | {name x}
        |     | {select_from_etc}: ok
        |       | {select_where}
        |         | {select_groupby}
        |           | {select_having}
        | {select_orderby}
          | {select_limit}
            | {select_offset}

The statement ending at line XXXX

CREATE PROC test_parent_child ()
BEGIN
  DECLARE __result__0 BOOL NOT NULL;
  DECLARE __key__0 CURSOR LIKE test_child(x);
  LET __partition__0 := cql_partition_create();
  DECLARE __child_cursor__0 CURSOR FOR CALL test_child(1);
  LOOP FETCH __child_cursor__0
  BEGIN
    FETCH __key__0(x) FROM VALUES(__child_cursor__0.x);
    SET __result__0 := cql_partition_cursor(__partition__0, __key__0, __child_cursor__0);
  END;
  DECLARE __out_cursor__0 CURSOR LIKE (x INTEGER, my_child OBJECT<test_child SET> NOT NULL);
  DECLARE __parent__0 CURSOR FOR CALL test_parent(2);
  LOOP FETCH __parent__0
  BEGIN
    FETCH __key__0(x) FROM VALUES(__parent__0.x);
    FETCH __out_cursor__0(x, my_child) FROM VALUES(__parent__0.x, cql_extract_partition(__partition__0, __key__0));
    OUT UNION __out_cursor__0;
  END;
END;

  {create_proc_stmt}: __out_cursor__0: test_parent_child: { x: integer, my_child: object<test_child SET> notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {name test_parent_child}: __out_cursor__0: test_parent_child: { x: integer, my_child: object<test_child SET> notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: bool notnull
      | | {name_list}: __result__0: bool notnull variable was_set
      | | | {name __result__0}: __result__0: bool notnull variable was_set
      | | {notnull}: bool notnull
      |   | {type_bool}: bool
      | {declare_cursor_like_name}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
      | | {name __key__0}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
      | | {shape_def}: select: { x: integer }
      |   | {like}: ok
      |   | | {name test_child}
      |   | {shape_exprs}
      |     | {shape_expr}
      |       | {name x}
      |       | {name x}
      | {let_stmt}: __partition__0: object<partitioning> notnull variable
      | | {name __partition__0}: __partition__0: object<partitioning> notnull variable
      | | {call}: object<partitioning> notnull create_func
      |   | {name cql_partition_create}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {declare_cursor}: __child_cursor__0: test_child: { x: integer } variable dml_proc
      | | {name __child_cursor__0}: __child_cursor__0: test_child: { x: integer } variable dml_proc shape_storage serialize
      | | {call_stmt}: test_child: { x: integer } dml_proc
      |   | {name test_child}: test_child: { x: integer } dml_proc
      |   | {expr_list}: ok
      |     | {int 1}: integer notnull
      | {loop_stmt}: ok
      | | {fetch_stmt}: __child_cursor__0: test_child: { x: integer } variable dml_proc shape_storage
      | | | {name __child_cursor__0}: __child_cursor__0: test_child: { x: integer } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {fetch_values_stmt}: ok
      |   | | {name_columns_values}
      |   |   | {name __key__0}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
      |   |   | {columns_values}: ok
      |   |     | {column_spec}
      |   |     | | {name_list}
      |   |     |   | {name x}: x: integer
      |   |     | {insert_list}: ok
      |   |       | {dot}: __child_cursor__0.x: integer variable
      |   |         | {name __child_cursor__0}
      |   |         | {name x}
      |   | {assign}: __result__0: bool notnull variable was_set
      |     | {name __result__0}: __result__0: bool notnull variable was_set
      |     | {call}: bool notnull
      |       | {name cql_partition_cursor}
      |       | {call_arg_list}
      |         | {call_filter_clause}
      |         | {arg_list}: ok
      |           | {name __partition__0}: __partition__0: object<partitioning> notnull variable
      |           | {arg_list}
      |             | {name __key__0}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
      |             | {arg_list}
      |               | {name __child_cursor__0}: __child_cursor__0: test_child: { x: integer } variable dml_proc shape_storage serialize
      | {declare_cursor_like_typed_names}: __out_cursor__0: select: { x: integer, my_child: object<test_child SET> notnull } variable shape_storage value_cursor
      | | {name __out_cursor__0}: __out_cursor__0: select: { x: integer, my_child: object<test_child SET> notnull } variable shape_storage value_cursor
      | | {typed_names}: select: { x: integer, my_child: object<test_child SET> notnull }
      |   | {typed_name}: x: integer
      |   | | {name x}
      |   | | {type_int}: x: integer
      |   | {typed_names}
      |     | {typed_name}: my_child: object<test_child SET> notnull
      |       | {name my_child}
      |       | {notnull}: my_child: object<test_child SET> notnull
      |         | {type_object}: object<test_child SET>
      |           | {name test_child SET}
      | {declare_cursor}: __parent__0: test_parent: { x: integer } variable dml_proc
      | | {name __parent__0}: __parent__0: test_parent: { x: integer } variable dml_proc shape_storage
      | | {call_stmt}: test_parent: { x: integer } dml_proc
      |   | {name test_parent}: test_parent: { x: integer } dml_proc
      |   | {expr_list}: ok
      |     | {int 2}: integer notnull
      | {loop_stmt}: ok
        | {fetch_stmt}: __parent__0: test_parent: { x: integer } variable dml_proc shape_storage
        | | {name __parent__0}: __parent__0: test_parent: { x: integer } variable dml_proc shape_storage
        | {stmt_list}: ok
          | {fetch_values_stmt}: ok
          | | {name_columns_values}
          |   | {name __key__0}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name x}: x: integer
          |     | {insert_list}: ok
          |       | {dot}: __parent__0.x: integer variable
          |         | {name __parent__0}
          |         | {name x}
          | {fetch_values_stmt}: ok
          | | {name_columns_values}
          |   | {name __out_cursor__0}: __out_cursor__0: select: { x: integer, my_child: object<test_child SET> notnull } variable shape_storage value_cursor
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name x}: x: integer
          |     |   | {name_list}
          |     |     | {name my_child}: my_child: object<test_child SET> notnull
          |     | {insert_list}: ok
          |       | {dot}: __parent__0.x: integer variable
          |       | | {name __parent__0}
          |       | | {name x}
          |       | {insert_list}
          |         | {call}: object notnull create_func
          |           | {name cql_extract_partition}
          |           | {call_arg_list}
          |             | {call_filter_clause}
          |             | {arg_list}: ok
          |               | {name __partition__0}: __partition__0: object<partitioning> notnull variable
          |               | {arg_list}
          |                 | {name __key__0}: __key__0: select: { x: integer } variable shape_storage value_cursor serialize
          | {out_union_stmt}: __out_cursor__0: select: { x: integer, my_child: object<test_child SET> notnull } variable shape_storage value_cursor
            | {name __out_cursor__0}: __out_cursor__0: select: { x: integer, my_child: object<test_child SET> notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC test_parent_child2 ()
BEGIN
  DECLARE __result__1 BOOL NOT NULL;
  DECLARE __key__1 CURSOR LIKE test_child(x);
  LET __partition__1 := cql_partition_create();
  DECLARE __child_cursor__1 CURSOR FOR CALL test_child(1);
  LOOP FETCH __child_cursor__1
  BEGIN
    FETCH __key__1(x) FROM VALUES(__child_cursor__1.x);
    SET __result__1 := cql_partition_cursor(__partition__1, __key__1, __child_cursor__1);
  END;
  DECLARE __out_cursor__1 CURSOR LIKE (x INTEGER, child1 OBJECT<test_child SET> NOT NULL);
  DECLARE __parent__1 CURSOR FOR CALL test_parent(2);
  LOOP FETCH __parent__1
  BEGIN
    FETCH __key__1(x) FROM VALUES(__parent__1.x);
    FETCH __out_cursor__1(x, child1) FROM VALUES(__parent__1.x, cql_extract_partition(__partition__1, __key__1));
    OUT UNION __out_cursor__1;
  END;
END;

  {create_proc_stmt}: __out_cursor__1: test_parent_child2: { x: integer, child1: object<test_child SET> notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {name test_parent_child2}: __out_cursor__1: test_parent_child2: { x: integer, child1: object<test_child SET> notnull } variable dml_proc shape_storage uses_out_union value_cursor
  | {proc_params_stmts}
    | {stmt_list}: ok
      | {declare_vars_type}: bool notnull
      | | {name_list}: __result__1: bool notnull variable was_set
      | | | {name __result__1}: __result__1: bool notnull variable was_set
      | | {notnull}: bool notnull
      |   | {type_bool}: bool
      | {declare_cursor_like_name}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
      | | {name __key__1}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
      | | {shape_def}: select: { x: integer }
      |   | {like}: ok
      |   | | {name test_child}
      |   | {shape_exprs}
      |     | {shape_expr}
      |       | {name x}
      |       | {name x}
      | {let_stmt}: __partition__1: object<partitioning> notnull variable
      | | {name __partition__1}: __partition__1: object<partitioning> notnull variable
      | | {call}: object<partitioning> notnull create_func
      |   | {name cql_partition_create}
      |   | {call_arg_list}
      |     | {call_filter_clause}
      | {declare_cursor}: __child_cursor__1: test_child: { x: integer } variable dml_proc
      | | {name __child_cursor__1}: __child_cursor__1: test_child: { x: integer } variable dml_proc shape_storage serialize
      | | {call_stmt}: test_child: { x: integer } dml_proc
      |   | {name test_child}: test_child: { x: integer } dml_proc
      |   | {expr_list}: ok
      |     | {int 1}: integer notnull
      | {loop_stmt}: ok
      | | {fetch_stmt}: __child_cursor__1: test_child: { x: integer } variable dml_proc shape_storage
      | | | {name __child_cursor__1}: __child_cursor__1: test_child: { x: integer } variable dml_proc shape_storage
      | | {stmt_list}: ok
      |   | {fetch_values_stmt}: ok
      |   | | {name_columns_values}
      |   |   | {name __key__1}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
      |   |   | {columns_values}: ok
      |   |     | {column_spec}
      |   |     | | {name_list}
      |   |     |   | {name x}: x: integer
      |   |     | {insert_list}: ok
      |   |       | {dot}: __child_cursor__1.x: integer variable
      |   |         | {name __child_cursor__1}
      |   |         | {name x}
      |   | {assign}: __result__1: bool notnull variable was_set
      |     | {name __result__1}: __result__1: bool notnull variable was_set
      |     | {call}: bool notnull
      |       | {name cql_partition_cursor}
      |       | {call_arg_list}
      |         | {call_filter_clause}
      |         | {arg_list}: ok
      |           | {name __partition__1}: __partition__1: object<partitioning> notnull variable
      |           | {arg_list}
      |             | {name __key__1}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
      |             | {arg_list}
      |               | {name __child_cursor__1}: __child_cursor__1: test_child: { x: integer } variable dml_proc shape_storage serialize
      | {declare_cursor_like_typed_names}: __out_cursor__1: select: { x: integer, child1: object<test_child SET> notnull } variable shape_storage value_cursor
      | | {name __out_cursor__1}: __out_cursor__1: select: { x: integer, child1: object<test_child SET> notnull } variable shape_storage value_cursor
      | | {typed_names}: select: { x: integer, child1: object<test_child SET> notnull }
      |   | {typed_name}: x: integer
      |   | | {name x}
      |   | | {type_int}: x: integer
      |   | {typed_names}
      |     | {typed_name}: child1: object<test_child SET> notnull
      |       | {name child1}
      |       | {notnull}: child1: object<test_child SET> notnull
      |         | {type_object}: object<test_child SET>
      |           | {name test_child SET}
      | {declare_cursor}: __parent__1: test_parent: { x: integer } variable dml_proc
      | | {name __parent__1}: __parent__1: test_parent: { x: integer } variable dml_proc shape_storage
      | | {call_stmt}: test_parent: { x: integer } dml_proc
      |   | {name test_parent}: test_parent: { x: integer } dml_proc
      |   | {expr_list}: ok
      |     | {int 2}: integer notnull
      | {loop_stmt}: ok
        | {fetch_stmt}: __parent__1: test_parent: { x: integer } variable dml_proc shape_storage
        | | {name __parent__1}: __parent__1: test_parent: { x: integer } variable dml_proc shape_storage
        | {stmt_list}: ok
          | {fetch_values_stmt}: ok
          | | {name_columns_values}
          |   | {name __key__1}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name x}: x: integer
          |     | {insert_list}: ok
          |       | {dot}: __parent__1.x: integer variable
          |         | {name __parent__1}
          |         | {name x}
          | {fetch_values_stmt}: ok
          | | {name_columns_values}
          |   | {name __out_cursor__1}: __out_cursor__1: select: { x: integer, child1: object<test_child SET> notnull } variable shape_storage value_cursor
          |   | {columns_values}: ok
          |     | {column_spec}
          |     | | {name_list}
          |     |   | {name x}: x: integer
          |     |   | {name_list}
          |     |     | {name child1}: child1: object<test_child SET> notnull
          |     | {insert_list}: ok
          |       | {dot}: __parent__1.x: integer variable
          |       | | {name __parent__1}
          |       | | {name x}
          |       | {insert_list}
          |         | {call}: object notnull create_func
          |           | {name cql_extract_partition}
          |           | {call_arg_list}
          |             | {call_filter_clause}
          |             | {arg_list}: ok
          |               | {name __partition__1}: __partition__1: object<partitioning> notnull variable
          |               | {arg_list}
          |                 | {name __key__1}: __key__1: select: { x: integer } variable shape_storage value_cursor serialize
          | {out_union_stmt}: __out_cursor__1: select: { x: integer, child1: object<test_child SET> notnull } variable shape_storage value_cursor
            | {name __out_cursor__1}: __out_cursor__1: select: { x: integer, child1: object<test_child SET> notnull } variable shape_storage value_cursor

The statement ending at line XXXX

CREATE PROC test_object_types ()
BEGIN
  DECLARE C CURSOR LIKE (id INTEGER);
  DECLARE u OBJECT<goo CURSOR>;
  DECLARE w OBJECT<C CURSOR>;
  DECLARE x OBJECT<C SET>;
  DECLARE y OBJECT<test_parent_child SET>;
END;

test/sem_test.sql:XXXX:1: error: in like : CQL0202: must be a cursor, proc, table, or view 'goo'
test/sem_test.sql:XXXX:1: error: in type_object : CQL0090: object<T SET> has a T that is not a procedure with a result set 'C SET'

  {create_proc_stmt}: err
  | {name test_object_types}: err
  | {proc_params_stmts}
    | {stmt_list}: err
      | {declare_cursor_like_typed_names}: C: select: { id: integer } variable shape_storage value_cursor
      | | {name C}: C: select: { id: integer } variable shape_storage value_cursor
      | | {typed_names}: select: { id: integer }
      |   | {typed_name}: id: integer
      |     | {name id}
      |     | {type_int}: id: integer
      | {declare_vars_type}: err
      | | {name_list}
      | | | {name u}
      | | {type_object}: err
      |   | {name goo CURSOR}
      | {declare_vars_type}: object<C CURSOR>
      | | {name_list}: w: object<C CURSOR> variable
      | | | {name w}: w: object<C CURSOR> variable
      | | {type_object}: object<C CURSOR>
      |   | {name C CURSOR}
      | {declare_vars_type}: err
      | | {name_list}
      | | | {name x}
      | | {type_object}: err
      |   | {name C SET}
      | {declare_vars_type}: object<test_parent_child SET>
        | {name_list}: y: object<test_parent_child SET> variable
        | | {name y}: y: object<test_parent_child SET> variable
        | {type_object}: object<test_parent_child SET>
          | {name test_parent_child SET}

The statement ending at line XXXX

LET compressed_string := cql_compressed("foo foo");

  {let_stmt}: compressed_string: text notnull variable
  | {name compressed_string}: compressed_string: text notnull variable
  | {call}: text notnull
    | {name cql_compressed}: text notnull
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'foo foo'}: text notnull

The statement ending at line XXXX

SET compressed_string := ( SELECT cql_compressed('hello hello') );

test/sem_test.sql:XXXX:1: error: in call : CQL0080: function may not appear in this context 'cql_compressed'

  {assign}: err
  | {name compressed_string}: compressed_string: text notnull variable
  | {select_stmt}: err
    | {select_core_list}: err
    | | {select_core}: err
    |   | {select_expr_list_con}: err
    |     | {select_expr_list}: err
    |     | | {select_expr}: err
    |     |   | {call}: err
    |     |     | {name cql_compressed}
    |     |     | {call_arg_list}
    |     |       | {call_filter_clause}
    |     |       | {arg_list}: ok
    |     |         | {strlit 'hello hello'}: text notnull
    |     | {select_from_etc}: ok
    |       | {select_where}
    |         | {select_groupby}
    |           | {select_having}
    | {select_orderby}
      | {select_limit}
        | {select_offset}

The statement ending at line XXXX

SET compressed_string := cql_compressed("foo foo", 1);

test/sem_test.sql:XXXX:1: error: in str : CQL0079: function got incorrect number of arguments 'cql_compressed'

  {assign}: err
  | {name compressed_string}: compressed_string: text notnull variable
  | {call}: err
    | {name cql_compressed}: err
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {strlit 'foo foo'}: text notnull
        | {arg_list}
          | {int 1}: integer notnull

The statement ending at line XXXX

SET compressed_string := cql_compressed(1);

test/sem_test.sql:XXXX:1: error: in call : CQL0421: first argument must be a string literal 'cql_compressed'

  {assign}: err
  | {name compressed_string}: compressed_string: text notnull variable
  | {call}: err
    | {name cql_compressed}
    | {call_arg_list}
      | {call_filter_clause}
      | {arg_list}: ok
        | {int 1}: integer notnull

The statement ending at line XXXX

CREATE TABLE dummy_table_for_backed_test(
  id INTEGER
);

  {create_table_stmt}: dummy_table_for_backed_test: { id: integer }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name dummy_table_for_backed_test}
  | {col_key_list}
    | {col_def}: id: integer
      | {col_def_type_attrs}: ok
        | {col_def_name_type}
          | {name id}
          | {type_int}: integer

The statement ending at line XXXX

DECLARE backed_cursor CURSOR FOR WITH
simple_backed_table (rowid, id, name) AS (CALL _simple_backed_table())
SELECT *
  FROM simple_backed_table;

  {declare_cursor}: backed_cursor: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } variable dml_proc
  | {name backed_cursor}: backed_cursor: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } variable dml_proc
  | {with_select_stmt}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
    | {with}
    | | {cte_tables}: ok
    |   | {cte_table}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
    |     | {cte_decl}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
    |     | | {name simple_backed_table}
    |     | | {name_list}
    |     |   | {name rowid}
    |     |   | {name_list}
    |     |     | {name id}
    |     |     | {name_list}
    |     |       | {name name}
    |     | {shared_cte}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
    |       | {call_stmt}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
    |         | {name _simple_backed_table}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
    | {select_stmt}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      | {select_core_list}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      | | {select_core}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      |   | {select_expr_list_con}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      |     | {select_expr_list}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      |     | | {star}: select: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
      |     | {select_from_etc}: TABLE { simple_backed_table: simple_backed_table }
      |       | {table_or_subquery_list}: TABLE { simple_backed_table: simple_backed_table }
      |       | | {table_or_subquery}: TABLE { simple_backed_table: simple_backed_table }
      |       |   | {name simple_backed_table}: TABLE { simple_backed_table: simple_backed_table }
      |       | {select_where}
      |         | {select_groupby}
      |           | {select_having}
      | {select_orderby}
        | {select_limit}
          | {select_offset}

The statement ending at line XXXX

WITH
simple_backed_table (rowid, id, name) AS (CALL _simple_backed_table())
INSERT INTO dummy_table_for_backed_test(id) SELECT id
  FROM simple_backed_table;

  {with_insert_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | {cte_decl}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | | {name simple_backed_table}
  |     | | {name_list}
  |     |   | {name rowid}
  |     |   | {name_list}
  |     |     | {name id}
  |     |     | {name_list}
  |     |       | {name name}
  |     | {shared_cte}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |       | {call_stmt}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |         | {name _simple_backed_table}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  | {insert_stmt}: ok
    | {insert_normal}
    | {name_columns_values}
      | {name dummy_table_for_backed_test}: dummy_table_for_backed_test: { id: integer }
      | {columns_values}: ok
        | {column_spec}
        | | {name_list}
        |   | {name id}: id: integer
        | {select_stmt}: select: { id: integer notnull }
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {select_expr}: id: integer notnull
          |     |   | {name id}: id: integer notnull
          |     | {select_from_etc}: TABLE { simple_backed_table: simple_backed_table }
          |       | {table_or_subquery_list}: TABLE { simple_backed_table: simple_backed_table }
          |       | | {table_or_subquery}: TABLE { simple_backed_table: simple_backed_table }
          |       |   | {name simple_backed_table}: TABLE { simple_backed_table: simple_backed_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

WITH
simple_backed_table (rowid, id, name) AS (CALL _simple_backed_table())
DELETE FROM dummy_table_for_backed_test WHERE id IN (SELECT id
  FROM simple_backed_table);

  {with_delete_stmt}: ok
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | {cte_decl}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | | {name simple_backed_table}
  |     | | {name_list}
  |     |   | {name rowid}
  |     |   | {name_list}
  |     |     | {name id}
  |     |     | {name_list}
  |     |       | {name name}
  |     | {shared_cte}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |       | {call_stmt}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |         | {name _simple_backed_table}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  | {delete_stmt}: ok
    | {name dummy_table_for_backed_test}: dummy_table_for_backed_test: { id: integer }
    | {opt_where}: bool
      | {in_pred}: bool
        | {name id}: id: integer
        | {select_stmt}: id: integer
          | {select_core_list}: select: { id: integer notnull }
          | | {select_core}: select: { id: integer notnull }
          |   | {select_expr_list_con}: select: { id: integer notnull }
          |     | {select_expr_list}: select: { id: integer notnull }
          |     | | {select_expr}: id: integer notnull
          |     |   | {name id}: id: integer notnull
          |     | {select_from_etc}: TABLE { simple_backed_table: simple_backed_table }
          |       | {table_or_subquery_list}: TABLE { simple_backed_table: simple_backed_table }
          |       | | {table_or_subquery}: TABLE { simple_backed_table: simple_backed_table }
          |       |   | {name simple_backed_table}: TABLE { simple_backed_table: simple_backed_table }
          |       | {select_where}
          |         | {select_groupby}
          |           | {select_having}
          | {select_orderby}
            | {select_limit}
              | {select_offset}

The statement ending at line XXXX

WITH
simple_backed_table (rowid, id, name) AS (CALL _simple_backed_table())
UPDATE dummy_table_for_backed_test
SET id = id + 1
  WHERE id IN (SELECT id
  FROM simple_backed_table);

  {with_update_stmt}: dummy_table_for_backed_test: { id: integer }
  | {with}
  | | {cte_tables}: ok
  |   | {cte_table}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | {cte_decl}: simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull }
  |     | | {name simple_backed_table}
  |     | | {name_list}
  |     |   | {name rowid}
  |     |   | {name_list}
  |     |     | {name id}
  |     |     | {name_list}
  |     |       | {name name}
  |     | {shared_cte}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |       | {call_stmt}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  |         | {name _simple_backed_table}: _simple_backed_table: { rowid: longint notnull, id: integer notnull, name: text<cool_text> notnull } dml_proc
  | {update_stmt}: dummy_table_for_backed_test: { id: integer }
    | {name dummy_table_for_backed_test}: dummy_table_for_backed_test: { id: integer }
    | {update_set}
      | {update_list}: ok
      | | {update_entry}: id: integer
      |   | {name id}: id: integer
      |   | {add}: integer
      |     | {name id}: id: integer
      |     | {int 1}: integer notnull
      | {update_from}
        | {update_where}
          | {opt_where}: bool
          | | {in_pred}: bool
          |   | {name id}: id: integer
          |   | {select_stmt}: id: integer
          |     | {select_core_list}: select: { id: integer notnull }
          |     | | {select_core}: select: { id: integer notnull }
          |     |   | {select_expr_list_con}: select: { id: integer notnull }
          |     |     | {select_expr_list}: select: { id: integer notnull }
          |     |     | | {select_expr}: id: integer notnull
          |     |     |   | {name id}: id: integer notnull
          |     |     | {select_from_etc}: TABLE { simple_backed_table: simple_backed_table }
          |     |       | {table_or_subquery_list}: TABLE { simple_backed_table: simple_backed_table }
          |     |       | | {table_or_subquery}: TABLE { simple_backed_table: simple_backed_table }
          |     |       |   | {name simple_backed_table}: TABLE { simple_backed_table: simple_backed_table }
          |     |       | {select_where}
          |     |         | {select_groupby}
          |     |           | {select_having}
          |     | {select_orderby}
          |       | {select_limit}
          |         | {select_offset}
          | {update_orderby}

The statement ending at line XXXX

CREATE TABLE update_from_target(
  id INTEGER PRIMARY KEY,
  name TEXT
);

  {create_table_stmt}: update_from_target: { id: integer notnull primary_key, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name update_from_target}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE update_test_1(
  id INTEGER PRIMARY KEY,
  name TEXT
);

  {create_table_stmt}: update_test_1: { id: integer notnull primary_key, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name update_test_1}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

CREATE TABLE update_test_2(
  id INTEGER PRIMARY KEY,
  name TEXT
);

  {create_table_stmt}: update_test_2: { id: integer notnull primary_key, name: text }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name update_test_2}
  | {col_key_list}
    | {col_def}: id: integer notnull primary_key
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |   | | {name id}
    |   | | {type_int}: integer
    |   | {col_attrs_pk}: ok
    |     | {autoinc_and_conflict_clause}
    | {col_key_list}
      | {col_def}: name: text
        | {col_def_type_attrs}: ok
          | {col_def_name_type}
            | {name name}
            | {type_text}: text

The statement ending at line XXXX

UPDATE update_from_target
SET name = update_test_2.name FROM update_test_1
  INNER JOIN update_test_2 ON update_test_1.id = update_test_2.id
  WHERE update_test_1.name = 'x' AND update_from_target.id = update_test_1.id;

  {update_stmt}: update_from_target: { id: integer notnull primary_key, name: text }
  | {name update_from_target}: update_from_target: { id: integer notnull primary_key, name: text }
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: name: text
    |   | {name name}: name: text
    |   | {dot}: name: text
    |     | {name update_test_2}
    |     | {name name}
    | {update_from}
      | {join_clause}: JOIN { update_test_1: update_test_1, update_test_2: update_test_2 }
      | | {table_or_subquery}: TABLE { update_test_1: update_test_1 }
      | | | {name update_test_1}: TABLE { update_test_1: update_test_1 }
      | | {join_target_list}
      |   | {join_target}: JOIN { update_test_1: update_test_1, update_test_2: update_test_2 }
      |     | {int 1} {join_inner}
      |     | {table_join}
      |       | {table_or_subquery}: TABLE { update_test_2: update_test_2 }
      |       | | {name update_test_2}: TABLE { update_test_2: update_test_2 }
      |       | {join_cond}: JOIN { update_test_1: update_test_1, update_test_2: update_test_2 }
      |         | {on}: bool notnull
      |         | {eq}: bool notnull
      |           | {dot}: id: integer notnull
      |           | | {name update_test_1}
      |           | | {name id}
      |           | {dot}: id: integer notnull
      |             | {name update_test_2}
      |             | {name id}
      | {update_where}
        | {opt_where}: bool
        | | {and}: bool
        |   | {eq}: bool
        |   | | {dot}: name: text
        |   | | | {name update_test_1}
        |   | | | {name name}
        |   | | {strlit 'x'}: text notnull
        |   | {eq}: bool notnull
        |     | {dot}: id: integer notnull
        |     | | {name update_from_target}
        |     | | {name id}
        |     | {dot}: id: integer notnull
        |       | {name update_test_1}
        |       | {name id}
        | {update_orderby}

The statement ending at line XXXX

UPDATE update_from_target
SET name = update_test_2.name FROM table_does_not_exist;

test/sem_test.sql:XXXX:1: error: in table_or_subquery : CQL0095: table/view not defined 'table_does_not_exist'

  {update_stmt}: err
  | {name update_from_target}: update_from_target: { id: integer notnull primary_key, name: text }
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name name}
    |   | {dot}
    |     | {name update_test_2}
    |     | {name name}
    | {update_from}
      | {table_or_subquery_list}: err
      | | {table_or_subquery}: err
      |   | {name table_does_not_exist}
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

UPDATE simple_backed_table
SET id = 5 FROM update_test_1;

test/sem_test.sql:XXXX:1: error: in update_stmt : CQL0497: FROM clause not supported when updating backed table 'simple_backed_table'

  {update_stmt}: err
  | {name simple_backed_table}: simple_backed_table: { id: integer notnull primary_key, name: text<cool_text> notnull } backed
  | {update_set}
    | {update_list}: ok
    | | {update_entry}: id: integer notnull
    |   | {name id}: id: integer notnull
    |   | {int 5}: integer notnull
    | {update_from}
      | {table_or_subquery_list}: TABLE { update_test_1: update_test_1 }
      | | {table_or_subquery}: TABLE { update_test_1: update_test_1 }
      |   | {name update_test_1}: TABLE { update_test_1: update_test_1 }
      | {update_where}
        | {update_orderby}

The statement ending at line XXXX

@ENFORCE_STRICT UPDATE FROM;

  {enforce_strict_stmt}: ok
  | {int 22}

The statement ending at line XXXX

UPDATE update_from_target
SET name = update_test_2.name FROM update_test_1;

test/sem_test.sql:XXXX:1: error: in update_stmt : CQL0498: strict UPDATE ... FROM validation requires that the UPDATE statement not include a FROM clause

  {update_stmt}: err
  | {name update_from_target}
  | {update_set}
    | {update_list}
    | | {update_entry}
    |   | {name name}
    |   | {dot}
    |     | {name update_test_2}
    |     | {name name}
    | {update_from}
      | {table_or_subquery_list}
      | | {table_or_subquery}
      |   | {name update_test_1}
      | {update_where}
        | {update_orderby}

