<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CQL Internals</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">CQL Internals</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#part-1-lexing-parsing-and-the-ast"
id="toc-part-1-lexing-parsing-and-the-ast">Part 1: Lexing, Parsing, and
the AST</a>
<ul>
<li><a href="#preface" id="toc-preface">Preface</a></li>
</ul></li>
<li><a href="#general-structure" id="toc-general-structure">General
Structure</a>
<ul>
<li><a href="#lexical-analysis" id="toc-lexical-analysis">Lexical
Analysis</a></li>
<li><a href="#parsing-and-the-abstract-syntax-tree"
id="toc-parsing-and-the-abstract-syntax-tree">Parsing and the Abstract
Syntax Tree</a></li>
<li><a href="#examples" id="toc-examples">Examples</a></li>
<li><a href="#ast-definitions" id="toc-ast-definitions">AST
definitions</a></li>
</ul></li>
<li><a href="#echoing-the-ast" id="toc-echoing-the-ast">Echoing the
AST</a>
<ul>
<li><a href="#configuring-the-output-with-callbacks-and-flags"
id="toc-configuring-the-output-with-callbacks-and-flags">Configuring the
Output with Callbacks and Flags</a></li>
<li><a href="#invoking-the-generator"
id="toc-invoking-the-generator">Invoking the Generator</a></li>
<li><a href="#generator-internals"
id="toc-generator-internals">Generator Internals</a></li>
</ul></li>
<li><a href="#part-2-semantic-analysis"
id="toc-part-2-semantic-analysis">Part 2: Semantic Analysis</a>
<ul>
<li><a href="#preface-1" id="toc-preface-1">Preface</a></li>
</ul></li>
<li><a href="#semantic-analysis" id="toc-semantic-analysis">Semantic
Analysis</a>
<ul>
<li><a href="#decorated-ast-examples"
id="toc-decorated-ast-examples">Decorated AST examples</a></li>
<li><a href="#the-base-data-structures"
id="toc-the-base-data-structures">The Base Data Structures</a></li>
<li><a href="#initiating-semantic-analysis"
id="toc-initiating-semantic-analysis">Initiating Semantic
Analysis</a></li>
<li><a href="#semantic-errors" id="toc-semantic-errors">Semantic
Errors</a></li>
<li><a href="#the-primitive-types" id="toc-the-primitive-types">The
Primitive Types</a></li>
<li><a href="#unary-operators" id="toc-unary-operators">Unary
Operators</a></li>
<li><a href="#binary-operators" id="toc-binary-operators">Binary
Operators</a></li>
<li><a href="#simple-statement-validation"
id="toc-simple-statement-validation">Simple Statement
Validation</a></li>
<li><a href="#expression-contexts"
id="toc-expression-contexts">Expression Contexts</a></li>
<li><a href="#name-resolution" id="toc-name-resolution">Name
Resolution</a></li>
<li><a href="#flow-analysis" id="toc-flow-analysis">Flow
Analysis</a></li>
<li><a href="#nullability-improvements"
id="toc-nullability-improvements">Nullability Improvements</a></li>
<li><a href="#initialization-improvements"
id="toc-initialization-improvements">Initialization
Improvements</a></li>
<li><a href="#structure-types-and-the-notion-of-shapes"
id="toc-structure-types-and-the-notion-of-shapes">Structure types and
the notion of Shapes</a></li>
<li><a href="#join-types" id="toc-join-types">Join Types</a></li>
<li><a href="#schema-regions" id="toc-schema-regions">Schema
Regions</a></li>
<li><a href="#results-of-semantic-analysis"
id="toc-results-of-semantic-analysis">Results of Semantic
Analysis</a></li>
<li><a href="#recap" id="toc-recap">Recap</a></li>
</ul></li>
<li><a href="#part-3-c-code-generation"
id="toc-part-3-c-code-generation">Part 3: C Code Generation</a>
<ul>
<li><a href="#preface-2" id="toc-preface-2">Preface</a></li>
</ul></li>
<li><a href="#c-code-generation" id="toc-c-code-generation">C Code
Generation</a>
<ul>
<li><a href="#launching-the-code-generator"
id="toc-launching-the-code-generator">Launching the Code
Generator</a></li>
<li><a href="#character-buffers-and-byte-buffers"
id="toc-character-buffers-and-byte-buffers">Character Buffers and Byte
Buffers</a></li>
<li><a href="#expressions" id="toc-expressions">Expressions</a></li>
<li><a href="#basic-control-flow-patterns"
id="toc-basic-control-flow-patterns">Basic Control Flow
Patterns</a></li>
<li><a href="#cleanup-and-errors" id="toc-cleanup-and-errors">Cleanup
and Errors</a></li>
<li><a href="#string-literals" id="toc-string-literals">String
Literals</a></li>
<li><a href="#executing-sqlite-statements"
id="toc-executing-sqlite-statements">Executing SQLite
Statements</a></li>
<li><a href="#reading-single-values"
id="toc-reading-single-values">Reading Single Values</a></li>
<li><a href="#reading-rows-with-cursors"
id="toc-reading-rows-with-cursors">Reading Rows With Cursors</a></li>
<li><a href="#fetching-data-from-cursors"
id="toc-fetching-data-from-cursors">Fetching Data From Cursors</a></li>
<li><a href="#cursors-with-storage"
id="toc-cursors-with-storage">Cursors With Storage</a></li>
<li><a href="#flowing-sqlite-statements-between-procedures"
id="toc-flowing-sqlite-statements-between-procedures">Flowing SQLite
Statements Between Procedures</a></li>
<li><a href="#value-cursors" id="toc-value-cursors">Value
Cursors</a></li>
<li><a href="#returning-value-cursors"
id="toc-returning-value-cursors">Returning Value Cursors</a></li>
<li><a href="#result-sets" id="toc-result-sets">Result Sets</a></li>
<li><a href="#recap-1" id="toc-recap-1">Recap</a></li>
</ul></li>
<li><a href="#part-4-testing" id="toc-part-4-testing">Part 4:
Testing</a>
<ul>
<li><a href="#preface-3" id="toc-preface-3">Preface</a></li>
</ul></li>
<li><a href="#testing" id="toc-testing">Testing</a>
<ul>
<li><a href="#parse-tests" id="toc-parse-tests">Parse Tests</a></li>
<li><a href="#sematic-tests" id="toc-sematic-tests">Sematic
Tests</a></li>
<li><a href="#code-generation-tests" id="toc-code-generation-tests">Code
Generation Tests</a></li>
<li><a href="#run-tests" id="toc-run-tests">Run Tests</a></li>
<li><a href="#schema-upgrade-testing"
id="toc-schema-upgrade-testing">Schema Upgrade Testing</a></li>
<li><a href="#testing-the-line-directives-produced-by-cql"
id="toc-testing-the-line-directives-produced-by-cql">Testing the
<code>#line</code> directives produced by CQL</a></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
</ul></li>
<li><a href="#part-5-cql-runtime" id="toc-part-5-cql-runtime">Part 5:
CQL Runtime</a>
<ul>
<li><a href="#preface-4" id="toc-preface-4">Preface</a></li>
</ul></li>
<li><a href="#cql-runtime" id="toc-cql-runtime">CQL Runtime</a>
<ul>
<li><a href="#standard-headers" id="toc-standard-headers">Standard
headers</a></li>
<li><a href="#contract-and-error-macros"
id="toc-contract-and-error-macros">Contract and Error Macros</a></li>
<li><a href="#the-value-types" id="toc-the-value-types">The Value
Types</a></li>
<li><a href="#the-reference-types" id="toc-the-reference-types">The
Reference Types</a></li>
<li><a href="#mocking" id="toc-mocking">Mocking</a></li>
<li><a href="#profiling" id="toc-profiling">Profiling</a></li>
<li><a href="#encoding-of-sensitive-columns"
id="toc-encoding-of-sensitive-columns">Encoding of Sensitive
Columns</a></li>
<li><a href="#boxing-statements" id="toc-boxing-statements">Boxing
Statements</a></li>
<li><a href="#the-common-headers" id="toc-the-common-headers">The Common
Headers</a></li>
<li><a href="#the-cqlrt_cf-runtime" id="toc-the-cqlrt_cf-runtime">The
<code>cqlrt_cf</code> Runtime</a></li>
<li><a href="#recap-2" id="toc-recap-2">Recap</a></li>
</ul></li>
<li><a href="#part-6-schema-management"
id="toc-part-6-schema-management">Part 6: Schema Management</a>
<ul>
<li><a href="#preface-5" id="toc-preface-5">Preface</a></li>
</ul></li>
<li><a href="#schema-management" id="toc-schema-management">Schema
Management</a>
<ul>
<li><a href="#check-for-errors-check-for---global_proc"
id="toc-check-for-errors-check-for---global_proc">Check for errors,
check for <code>--global_proc</code></a></li>
<li><a href="#preparing-the-attributes"
id="toc-preparing-the-attributes">Preparing the Attributes</a></li>
<li><a href="#creating-the-global-crc"
id="toc-creating-the-global-crc">Creating the Global CRC</a></li>
<li><a href="#output-fragments" id="toc-output-fragments">Output
Fragments</a></li>
<li><a href="#declarations-section"
id="toc-declarations-section">Declarations Section</a></li>
<li><a href="#the-schema-helpers" id="toc-the-schema-helpers">The Schema
Helpers</a></li>
<li><a href="#declared-upgrade-procedures"
id="toc-declared-upgrade-procedures">Declared Upgrade
Procedures</a></li>
<li><a href="#the-upgrading-workers" id="toc-the-upgrading-workers">The
Upgrading Workers</a></li>
<li><a href="#recap-3" id="toc-recap-3">Recap</a></li>
</ul></li>
<li><a href="#part-7-json-generation"
id="toc-part-7-json-generation">Part 7: JSON Generation</a>
<ul>
<li><a href="#preface-6" id="toc-preface-6">Preface</a></li>
</ul></li>
<li><a href="#json-schema" id="toc-json-schema">JSON Schema</a>
<ul>
<li><a href="#walking-the-ast" id="toc-walking-the-ast">Walking the
AST</a></li>
<li><a href="#formatting-the-json"
id="toc-formatting-the-json">Formatting the JSON</a></li>
<li><a href="#dependency-analysis"
id="toc-dependency-analysis">Dependency Analysis</a></li>
<li><a href="#additional-test-output"
id="toc-additional-test-output">Additional Test Output</a></li>
<li><a href="#recap-4" id="toc-recap-4">Recap</a></li>
</ul></li>
<li><a href="#part-8-test-helpers" id="toc-part-8-test-helpers">Part 8:
Test Helpers</a>
<ul>
<li><a href="#preface-7" id="toc-preface-7">Preface</a></li>
</ul></li>
<li><a href="#test-helpers" id="toc-test-helpers">Test Helpers</a>
<ul>
<li><a href="#initialization"
id="toc-initialization">Initialization</a></li>
<li><a href="#dummy-table-dummy-insert-dummy-select-dummy-result-set"
id="toc-dummy-table-dummy-insert-dummy-select-dummy-result-set">Dummy
Table, Dummy Insert, Dummy Select, Dummy Result Set</a></li>
<li><a href="#dummy-test" id="toc-dummy-test">Dummy Test</a></li>
<li><a href="#recap-5" id="toc-recap-5">Recap</a></li>
</ul></li>
</ul>
</nav>
<!--- @generated -->
<h2 id="part-1-lexing-parsing-and-the-ast">Part 1: Lexing, Parsing, and
the AST</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface">Preface</h3>
<p>The following is a summary of the implementation theory of the CQL
compiler. This is an adjunct to the <a href="/cql-guide/ch01">Guide
proper</a>, which describes the language, and to a lesser extent the
code that the compiler generates.</p>
<p>The actual code is heavily commented, so it’s better to read the code
to see the details of how any particular operation happens rather than
try to guess from the language specification or from this overview.
However, some things, like general principles, really are nowhere (or
everywhere) in the codebase and it’s important to understand how things
hang together.</p>
<p>If you choose to go on adventures in the source code, especially if
you aren’t already familiar with compilers and how they are typically
built, this document is a good place to start.</p>
<h2 id="general-structure">General Structure</h2>
<p>The CQL compiler uses a very standard lex+yacc parser, though to be
more precise it’s flex+bison. The grammar is a large subset of the
SQLite dialect of SQL augmented with control flow and compiler
directives. As a consequence, it’s a useful asset in-and-of-itself. If
you’re looking for an economical SQL grammar, you could do a lot worse
than start with the one CQL uses. The grammar is of course in the usual
<code>.y</code> format that bison consumes but it’s also extracted into
more readable versions for use in the <a
href="/program-diagram">railroad diagram</a> and the Guide
documentation. Any of those sources would be a good starting place for a
modest SQL project in need of a grammar.</p>
<h3 id="lexical-analysis">Lexical Analysis</h3>
<p>Inside of <code>cql.l</code> you’ll find the formal definition of all
the tokens. These of course correspond to the various tokens needed to
parse the SQL language, plus a few more of the CQL control flow
extensions. There’s no need to discuss the approximately 150 such
tokens, but the following points are of general interest:</p>
<ul>
<li>the lexer expects plain text files, and all the tokens are defined
in plain ASCII only, however
<ul>
<li>the presence of UTF8 characters in places where any text is legal
(such as string literals) should just work</li>
</ul></li>
<li>all of the tokens are case-insensitive
<ul>
<li>this means only vanilla ASCII insensitivity; no attempt is made to
understand more complex UNICODE code-points</li>
</ul></li>
<li>multi-word tokens typically are defined with an expression like
this: <code>IS[ \t]+NOT[ \t]+FALSE/[^A-Z_]</code>
<ul>
<li>in most cases, to avoid ambiguity, and to get order of operations
correct, the entire word sequence is one token</li>
<li>only spaces and tabs are allowed between the words</li>
<li>the token ends on non-identifier characters, so the text “X IS NOT
FALSEY” must become the tokens { <code>X</code>, <code>IS_NOT</code>,
<code>FALSEY</code> } and not { <code>X</code>,
<code>IS_NOT_FALSE</code>, <code>Y</code> }
<ul>
<li>the second option is actually the longest token, so without the
trailing qualifier it would be preferred</li>
<li>hence, where a continuation is possible, the trailing context must
be specified in multi-word tokens</li>
</ul></li>
</ul></li>
<li>there is special processing needed to lex <code>/* ... */</code>
comments correctly</li>
<li>there are token types for each of the sorts of literals that can be
encountered
<ul>
<li>special care is taken to keep the literals in string form so that no
precision is lost</li>
<li>integer literals are compared against 0x7fffffff and if greater they
automatically become long literals even if they are not marked with the
trailing <code>L</code> as in <code>1L</code></li>
<li>string literals include the quotation marks in the token text which
distinguishes them from identifiers; they are otherwise encoded
similarly</li>
</ul></li>
<li>the character class <code>[-+&amp;~|^/%*(),.;!&lt;&gt;:=]</code>
produces single character tokens for operators; other non-matching
single characters (e.g. <code>'$'</code>) produce an error</li>
<li>line directives <code>^#line\ [0-9]+\ \"[^"]*\".*</code> or
<code>^#\ [0-9]+\ \"[^"]*\".*</code> get special processing so that
pre-processed input does not lose file and line number fidelity</li>
</ul>
<h3 id="parsing-and-the-abstract-syntax-tree">Parsing and the Abstract
Syntax Tree</h3>
<p>Inside of <code>cql.y</code> you will find the token declarations,
precedence rules, and all of the productions in the overall grammar. The
grammar processing does as little as possible in that stage to create an
abstract syntax tree (AST). The AST itself is a simple binary tree;
where nodes might require more than just left and right children to
specify the syntax fully, additional nodes are used in the tree shape
rather than introduce n-ary nodes. This means the tree is sometimes
bigger, but generally not very much bigger. The benefit of this choice
is that the AST can always be walked generically as a binary tree, so if
you need to find all the <code>table_factor</code> nodes it is easy to
do so without having to worry about how every kind of node expands. If
new node types come along the generic walkers can go through those new
nodes as well. All of the grammar productions simply make one or more
AST nodes and link them together so that in the end there is a single
root for the entire program in a binary tree.</p>
<p>There are 4 kinds of AST nodes, they all begin with the following
five fields. These represent the AST “base type”, if you like.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nonnull type<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_node <span class="op">*</span>_Nullable sem<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable parent<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> lineno<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nonnull filename<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>type</code> : a string literal that uniquely identifies the
node type
<ul>
<li>the string literal is compared for identity (it’s an exact pointer
match: you don’t <code>strcmp</code> types)</li>
</ul></li>
<li><code>sem</code> : begins as <code>NULL</code> this is where the
semantic type goes once semantic processing happens</li>
<li><code>parent</code> : the parent node in the AST (not often used but
sometimes indispensible)</li>
<li><code>lineno</code> : the line number of the file that had the text
that led to this AST (useful for errors)</li>
<li><code>filename</code> : the name of the file that had the text that
led to this AST (useful for errors)
<ul>
<li>this string is durable, should not be mutated, and is shared between
MANY nodes</li>
</ul></li>
</ul>
<h4 id="the-generic-binary-ast-node-ast_node">The Generic Binary AST
node <code>ast_node</code></h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> ast_node <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable left<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nullable right<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> ast_node<span class="op">;</span></span></code></pre></div>
<p>This node gives the tree its shape and is how all the expression
operators and statements get encoded. An example shows this more
clearly:</p>
<pre><code>SET X := 1 + 3;

  {assign}
  | {name X}
  | {add}
    | {int 1}
    | {int 3}</code></pre>
<p>In the above, “assign” and “add” are the generic nodes. Note that
this node type can be a leaf but usually is not. The other types are
always leaves.</p>
<p>Note that in the above output, the node <code>type</code> was
directly printed (because it’s a meaningful name). Likewise, the type
needs no decoding when viewing the AST in a debugger. Simply printing
the node with something like <code>p *ast</code> in lldb will show you
all the node fields and the type in human-readable form.</p>
<h4 id="the-grammar-code-node-int_ast_node">The Grammar Code Node
<code>int_ast_node</code></h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> int_ast_node <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> value<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> int_ast_node<span class="op">;</span></span></code></pre></div>
<p>This kind of node holds an integer that quantifies some kind of
choice in the grammar. Note that this does NOT hold numeric literals
(see below). The file <code>ast.h</code> includes many
<code>#define</code> constants for this purpose such as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>define JOIN_INNER <span class="dv">1</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>define JOIN_CROSS <span class="dv">2</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>define JOIN_LEFT_OUTER <span class="dv">3</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>define JOIN_RIGHT_OUTER <span class="dv">4</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>define JOIN_LEFT <span class="dv">5</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>define JOIN_RIGHT <span class="dv">6</span></span></code></pre></div>
<p>The integer for this fragment will be one of those defined values. It
can be a bitmask, or an enumeration. In this statement:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">FROM</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> b;</span></code></pre></div>
<p>a part of the AST will look like this:</p>
<pre><code>| {join_clause}
| | {table_or_subquery}
| | | {name a}
| | {join_target_list}
|   | {join_target}
|     | {int 3}
|     | {table_join}
|       | {table_or_subquery}
|         | {name b}</code></pre>
<p>The <code>{int 3}</code> above is an <code>int_ast_node</code> and it
corresponds to <code>JOIN_LEFT_OUTER</code>.</p>
<p>This node type is always a leaf.</p>
<h4 id="the-string-node-str_ast_node">The String Node
<code>str_ast_node</code></h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> str_ast_node <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nullable value<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  bool_t cstr_literal<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> str_ast_node<span class="op">;</span></span></code></pre></div>
<p>This node type holds: * string literals * blob literals *
identifiers</p>
<ul>
<li><code>value</code> : the text of the string</li>
<li><code>cstr_literal</code> : true if the string was specified using
“C” syntax (see below)</li>
</ul>
<p>CQL supports C style string literals with C style escapes such as
<code>"foo\n"</code>. These are normalized into the SQL version of the
same literal so that SQLite will see a literal it understands. However,
if the origin of the string was the C string form (i.e. like
<code>"foo"</code> rather than <code>'bar'</code>) then the
<code>cstr_literal</code> boolean flag will be set. When echoing the
program back as plain text, the C string will be converted back to the C
form for display to a user. But when providing the string to Sqlite,
it’s in SQL format.</p>
<p>Identifiers can be distinguished from string literals because the
quotation marks (always <code>''</code>) are still in the string.</p>
<p>This node type is always a leaf.</p>
<h4 id="the-number-node-num_ast_node">The Number Node
<code>num_ast_node</code></h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> num_ast_node <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> the common fields</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> num_type<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nullable value<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> num_ast_node<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>num_type</code> : the kind of numeric</li>
<li><code>value</code> : the text of the number</li>
</ul>
<p>All numerics are stored as strings so that there is no loss of
precision. This is important because it is entirely possible that the
CQL compiler is built with a different floating point library, than the
target system, or different integer sizes. As a result CQL does not
evaluate anything outside of an explicit <code>const(...)</code>
expression. This policy avoids integer overflows at compile time or loss
of floating point precision. Constants in the text of the output are
emitted byte-for-byte as they appeared in the source code.</p>
<p>This node type is always a leaf.</p>
<h3 id="examples">Examples</h3>
<h4 id="example-1-a-let-statement-and-expression">Example 1: A LET
statement and expression</h4>
<pre><code>LET x := 1 + (3 - 2);

  {let_stmt}
  | {name x}
  | {add}
    | {int 1}
    | {sub}
      | {int 3}
      | {int 2}</code></pre>
<p>Note that there are no parentheses in the AST but it exactly and
authoritatively captures the precedence with its shape. This means,
among other things, that when CQL echos its input, any redundant
parentheses will be gone.</p>
<h4 id="example-2-an-ifelse-construct">Example 2: An IF/ELSE
construct</h4>
<pre><code>IF x THEN
  LET x := 1.5e7;
ELSE IF y THEN
  LET y := &#39;that&#39;;
ELSE
  LET z := &quot;this&quot;;
END IF;

  {if_stmt}
  | {cond_action}
  | | {name x}
  | | {stmt_list}
  |   | {let_stmt}
  |     | {name x}
  |     | {dbl 1.5e7}
  | {if_alt}
    | {elseif}
    | | {cond_action}
    |   | {name y}
    |   | {stmt_list}
    |     | {let_stmt}
    |       | {name y}
    |       | {strlit &#39;that&#39;}
    | {else}
      | {stmt_list}
        | {let_stmt}
          | {name z}
          | {strlit &#39;this&#39;}</code></pre>
<p>Note that the string “this” was normalized to ‘this’ (which was
trivial in this case) but rest assured that <code>cstr_literal</code>
was set. This is shown because the text of the statement came out with
double quotes. The text above was not the input to the compiler, the
compiler was actually given this text:</p>
<pre><code>if x then let x := 1.5e7; else if y then let y := &#39;that&#39;; else let z := &quot;this&quot;; end if;</code></pre>
<p>And it was normalized into what you see as part of the output. We’ll
talk about this output echoing in coming sections. As you can see, the
compiler can be used as a SQL normalizer/beautifier.</p>
<h4 id="example-3-a-select-statement">Example 3: A SELECT statement</h4>
<pre><code>SELECT *
  FROM foo
  INNER JOIN bar
  WHERE foo.x = 1
LIMIT 3;

  {select_stmt}
  | {select_core_list}
  | | {select_core}
  |   | {select_expr_list_con}
  |     | {select_expr_list}
  |     | | {star}
  |     | {select_from_etc}
  |       | {join_clause}
  |       | | {table_or_subquery}
  |       | | | {name foo}
  |       | | {join_target_list}
  |       |   | {join_target}
  |       |     | {int 1}
  |       |     | {table_join}
  |       |       | {table_or_subquery}
  |       |         | {name bar}
  |       | {select_where}
  |         | {opt_where}
  |         | | {eq}
  |         |   | {dot}
  |         |   | | {name foo}
  |         |   | | {name x}
  |         |   | {int 1}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {opt_limit}
      | | {int 3}
      | {select_offset}</code></pre>
<p>As you can see the trees rapidly get more complex. The
<code>SELECT</code> statement has many optional pieces and so the AST
actually has places in its skeleton where these could go but are absent
(e.g. <code>GROUP BY</code>, <code>HAVING</code>, <code>ORDER BY</code>,
and <code>OFFSET</code> are all missing).</p>
<p>The shape of the AST is largely self-evident from the above, but you
can easily cross check it against what’s in <code>cql.y</code> for
details and then look at <code>gen_sql.c</code> for decoding tips
(discussed below).</p>
<p>The compiler can produce these diagrams in ‘dot’ format which makes
pretty pictures, but the reality is that for non-trivial examples those
pictures are so large as to be unreadable whereas the simple text format
remains readable even up to several hundred lines of output. The text is
also readily searchable, and diffable. The test suites for semantic
analysis do pattern matching on the text of the AST to verify
correctness.</p>
<p>We’ll discuss semantic analysis in <a
href="https://cgsql.dev/cql-guide/int02">Part 2</a>.</p>
<h3 id="ast-definitions">AST definitions</h3>
<p><code>ast.h</code> defines all the tree types mentioned above. There
are helper methods to create AST nodes with type safety. It includes
helper functions for the various leaf types mentioned above but also for
the various “normal” types. These are specified using the AST macros
<code>AST</code>, <code>AST1</code>, and <code>AST0</code>.</p>
<p>Examples:</p>
<pre><code>AST0(star)
AST1(not)
AST(or)</code></pre>
<p>This says that:</p>
<ul>
<li>the <code>star</code> AST node (used in <code>select *</code>) is a
leaf, it has 0 children
<ul>
<li>this means the left and right nodes will always be
<code>NULL</code></li>
</ul></li>
<li>the <code>not</code> AST node (used in <code>select NOT x</code>) is
unary
<ul>
<li>this means only the left node is populated, the right is always
<code>NULL</code></li>
<li>node many unary nodes have optional children, so the left node might
still be <code>NULL</code></li>
</ul></li>
<li>the <code>or</code> AST node (used in <code>select x OR y</code>) is
binary
<ul>
<li>this means both its left and right children are populated</li>
<li>note that some binary nodes have optional children, so left or right
still might be <code>NULL</code></li>
</ul></li>
</ul>
<p>At present there are about 300 unique AST node types.</p>
<h2 id="echoing-the-ast">Echoing the AST</h2>
<p>The first set of features that were built (after parsing) provided
the ability to echo back the parse tree as SQL again. This all happens
in <code>gen_sql.c</code>. Since this code has to be able to echo back
any tree, it often has the best and simplest examples of how to crack
the AST for any particular type of node you might be interested in.</p>
<p>There are several reasons why we might want to echo the SQL, but the
inescapable one is this: any hunk of SQL that appears as part of a CQL
program (i.e. DDL/DML rather than control flow like
<code>IF</code>/<code>WHILE</code>) has to go to SQLite and SQLite
expects that code to be plain text. So the AST must be reformatted as
plain text that is exactly equivalent to the original input. The process
of parsing removes extra white space and parentheses, so to get
something that looks reasonable, some standard formatting (including
indenting) is applied to the output text. This has the effect of
normalizing the input and potentially beautifying it as well (especially
if it was poorly formatted initially).</p>
<p>To see these features, run <code>cql</code> with the
<code>--echo</code> flag. For example:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">out/cql</span> <span class="at">--echo</span> <span class="op">&lt;</span> your_file.sql</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">out/cql</span> <span class="at">--echo</span> <span class="at">--in</span> your_file.sql</span></code></pre></div>
<p>By default, it reads <code>stdin</code>, makes the AST, and then
emits the normalized, formatted text. If there are no syntax errors, the
input and the output should be equivalent.</p>
<p>Standard formatting is essential, but CQL also has a number of extra
demands.</p>
<p>CQL includes a lot of versioning directives like
<code>@create(...)</code> <code>@delete(...)</code> and so forth. SQLite
should never see these things when the DDL for SQLite is emitted. But
when echoing the input they should be included. Additionally, any local
or global variables in a SQL statement should be replaced with
<code>?</code> in the text that goes to SQLite and then followed up with
binding instructions. We’ll cover the binding more in the section code
generation, but importantly this also has to significantly alter the
output. As a result the standard formatter includes extensive
configurability to get these various results.</p>
<h3 id="configuring-the-output-with-callbacks-and-flags">Configuring the
Output with Callbacks and Flags</h3>
<p>Some of these features, like variable binding, require a callback to
the formatter’s client. The client gets a notification, along with a few
control variables, and it can then decide exactly what goes in the
output. The control structure is <code>struct gen_sql_callbacks</code>,
and it is described below. This structure includes the various callbacks
(all of which are optional) and each callback gets a ‘context’ pointer
of its choice. The context pointer is some arbitrary <code>void *</code>
value that you provide, which will be given to your function along with
the AST pointer relevant to the call. The callback also gets the current
output buffer so it can choose to emit something (like ‘?’) into the
stream.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// signature for a callback, you get your context plus the ast</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">// if you return true then the normal output is suppressed</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">// in any case the output you provide is emitted</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> bool_t <span class="op">(*</span>_Nullable gen_sql_callback<span class="op">)(</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> ast_node <span class="op">*</span>_Nonnull ast<span class="op">,</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable context<span class="op">,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>_Nonnull output</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>The meaning of the <code>bool_t</code> return value varies depend on
which callback it is.</p>
<p>The coarsest control is provided by the generation mode. It is one of
these values:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// These modes control the overall style of the output</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> gen_sql_mode <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  gen_mode_echo<span class="op">,</span>          <span class="co">// Prints everything in the original, with standard whitespace and parentheses</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  gen_mode_sql<span class="op">,</span>           <span class="co">// Prints the AST formatted for SQLite consumption, omits anything CQL specific</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  gen_mode_no_annotations <span class="co">// Equivalent to gen_mode_echo without versioning attributes or generic attributes</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// * @create, @delete, @recreate, and @attribute are removed</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                          <span class="co">// * statements like @echo are not affected, nor is the type specifier @sensitive</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The actual callbacks structure is optional, if it is
<code>NULL</code> then a full echo of the AST with no changes will be
produced. Otherwise the callbacks and flags alter the behavior of the
echoer somewhat.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Callbacks allow you to significantly alter the generated sql, see the particular flags below.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> gen_sql_callbacks <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Each time a local/global variable is encountered in the AST, this callback is invoked</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this is to allow the variable reference to be noted and replaced with ? in the generated SQL</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable variables_callback<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable variables_context<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Each time a column definition is emitted this callback is invoked, it may choose to</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// suppress that column.  This is used to remove columns that were added in later schema</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// versions from the baseline schema.</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable col_def_callback<span class="op">;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable col_def_context<span class="op">;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This callback is used to explain the * in select * or select T.*</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable star_callback<span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable star_context<span class="op">;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This callback is used to force the &quot;IF NOT EXISTS&quot; form of DDL statements when generating</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// schema upgrade steps.  e.g. a &quot;CREATE TABLE Foo declarations get &quot;IF NOT EXISTS&quot; added</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to them in upgrade steps.</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  gen_sql_callback _Nullable if_not_exists_callback<span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable if_not_exists_context<span class="op">;</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true, hex literals are converted to decimal.  This is for JSON which does not support hex literals.</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>  bool_t convert_hex<span class="op">;</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true casts like &quot;CAST(NULL as TEXT)&quot; are reduced to just NULL.  The type information is not needed</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// by SQLite so it just wasts space.</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>  bool_t minify_casts<span class="op">;</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If true then unused aliases in select statements are elided to save space.  This is safe because</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">// CQL always binds the top level select statement by ordinal anyway.</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>  bool_t minify_aliases<span class="op">;</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// mode to print cql statement: gen_mode_echo, gen_mode_sql, gen_mode_no_annotations.</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">// gen_mode_sql mode causes the AS part of virtual table to be suppressed</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> gen_sql_mode mode<span class="op">;</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If CQL finds a column such as &#39;x&#39; below&#39;</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">// create table foo(</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   x long_int primary key autoincrement</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">// );</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">// that column must be converted to this form:</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">// create table foo(</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   x integer primary key autoincrement</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">// );</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This is because SQLite mandates that autoincrement must be exactly</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>  <span class="co">// in the second example above however, it is also the case that in SQLite</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>  <span class="co">// an integer can store a 64 bit value.  So sending &quot;integer&quot; to SQLite while</span></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>  <span class="co">// keeping the sense that the column is to be treated as 64 bits in CQL works</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>  <span class="co">// just fine.</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>  <span class="co">// However, when we are emitting CQL (rather than SQL) we want to keep</span></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the original long_int type so as not to lose fidelity when processing</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>  <span class="co">// schema for other semantic checks (such as matching FK data types).</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This flag is for that purpose: It tells us that the target isn&#39;t SQLite</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and we don&#39;t need to do the mapping (yet). Indeed, we shouldn&#39;t, or the</span></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// types will be messed up.</span></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>  <span class="co">// In short, if CQL is going to process the output again, use this flag</span></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a>  <span class="co">// to control the autoincrement transform.  It might be possible to fold</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this flag with the mode flag but it&#39;s sufficiently weird that this</span></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>  <span class="co">// extra documentation and special handling is probably worth the extra</span></span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>  <span class="co">// boolean storage.</span></span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a>  bool_t long_to_int_conv<span class="op">;</span></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> gen_sql_callbacks<span class="op">;</span></span></code></pre></div>
<p>Each callback can be best understood by reading the source, so we’ll
avoid trying to precisely define it here. But it is helpful to give the
gist of these options.</p>
<ul>
<li><code>mode</code> : one of the three enum modes that control overall
behavior</li>
<li><code>variables_callback</code> : invoked when a variable appears in
the SQL, the caller can record the specific variable and then use it for
binding</li>
<li><code>col_def_callback</code> : when creating the “baseline” schema
you don’t want column definitions from later schema to be included, this
gives you a chance to suppress them</li>
<li><code>star_callback</code> : normally the <code>*</code> in
<code>select *</code> or <code>select T.*</code> is expanded when
emitting for SQLite, this callback does the expansion when
appropriate</li>
<li><code>if_not_exists_callback</code> : when generating DDL for schema
upgrade you typically want to force <code>IF NOT EXISTS</code> to be
added to the schema even if it wasn’t present in the declaration; this
callback lets you do that</li>
<li><code>convert_hex</code> : if true, hex constants are converted to
decimal; used when emitting JSON because JSON doesn’t understand hex
constants</li>
<li><code>minify_casts</code> : minification converts casts like
<code>CAST(NULL AS TEXT)</code> to just <code>NULL</code> – the former
is only useful for type information, SQLite does need to see it</li>
<li><code>minify_aliases</code> : unused column aliases as in
<code>select foo.x as some_really_long_alias</code> can be removed from
the output when targeting SQLite to save space</li>
</ul>
<h3 id="invoking-the-generator">Invoking the Generator</h3>
<p>There are several generation functions but they all follow a similar
pattern, the differences are essentially what fragment of the AST they
expect to begin on. We’ll just cover one here.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_statement_with_callbacks<span class="op">(</span>ast_node <span class="op">*</span>_Nonnull ast<span class="op">,</span> gen_sql_callbacks <span class="op">*</span>_Nullable _callbacks<span class="op">);</span></span></code></pre></div>
<p>This has the typical signature for all these generators:</p>
<ul>
<li><code>ast</code> : the part of the tree to print</li>
<li><code>_callbacks</code> : the optional callbacks described
above</li>
</ul>
<p>To use these you’ll need to these functions as well:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_init<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_cleanup<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span></code></pre></div>
<p>You’ll want to call <code>gen_init()</code> one time before doing any
generation. That sets up the necessary tables. When you’re done use
<code>gen_cleanup()</code> to release any memory that was allocated in
setup. You don’t have to do the cleanup step if the process is going to
exit anyway, however, because of the amalgam options,
<code>cql_main()</code> assumes it might be called again and so it
tidies things up rather than risk leaking.</p>
<p>With the one time initialization in place there are these
preliminaries:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> init_gen_sql_callbacks<span class="op">(</span>gen_sql_callbacks <span class="op">*</span>_Nullable callbacks<span class="op">);</span></span></code></pre></div>
<p>Use <code>init_gen_sql_callbacks</code> to fill in your callback
structure with the normal defaults. This give you normal echo for SQL by
default. To get a full echo, a <code>NULL</code> callback may be used.
And of course other options are possible.</p>
<p>Finally,</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_set_output_buffer<span class="op">(</span><span class="kw">struct</span> charbuf <span class="op">*</span>_Nonnull buffer<span class="op">);</span></span></code></pre></div>
<p>Use this before the call to
<code>gen_&lt;something&gt;_with_callbacks</code> to redirect the output
into a growable character buffer of your choice.</p>
<p>The buffers can then be written where they are needed. Maybe further
processed into a C string literal for compiler output, or into a C style
comment, or just right back to stdout.</p>
<p>There are a few simplified versions of this sequence like this
one:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_stmt_list_to_stdout<span class="op">(</span>ast_node <span class="op">*</span>_Nullable ast<span class="op">);</span></span></code></pre></div>
<p>This uses <code>NULL</code> for the callbacks and emits directly to
stdout with no extra steps. The extra wiring is done for you.</p>
<h3 id="generator-internals">Generator Internals</h3>
<p>The generator has to be able to walk the entire tree and emit plain
text, and in many areas the tree is very flexible so we want a simple
dynamic dispatch mechanism that can call the right formatting function
from anywhere in the tree.</p>
<p>It turns out two different signatures are needed to do this properly,
one for formatting statements and the other for expressions – the
difference being that expressions have to concern themselves with the
precedence of the various operators so that parentheses can be correctly
(re)inserted into the output.</p>
<p>To do this there are two symbol tables that map from an AST node type
string to a formatting function. They are initialized with a series of
statements similar to these:</p>
<h4 id="generating-expressions">Generating Expressions</h4>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> gen_init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  gen_stmts <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  gen_exprs <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>if_stmt<span class="op">);</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mul<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;*&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>div<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;/&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mod<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;%&quot;</span><span class="op">,</span> EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>add<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;+&quot;</span><span class="op">,</span> EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>sub<span class="op">,</span> gen_binary<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">,</span> EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>not<span class="op">,</span> gen_unary<span class="op">,</span> <span class="st">&quot;NOT &quot;</span><span class="op">,</span> EXPR_PRI_NOT<span class="op">);</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>tilde<span class="op">,</span> gen_unary<span class="op">,</span> <span class="st">&quot;~&quot;</span><span class="op">,</span> EXPR_PRI_TILDE<span class="op">);</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These statements populate the symbol tables. * For statements, the
entry maps <code>if_stmt</code> to the function <code>gen_if_stmt</code>
* For expressions, the entry maps <code>mul</code> to
<code>gen_binary</code> including the metadata <code>"*"</code> and
<code>EXPR_PRI_MUL</code></p>
<p>As you can see, nearly all binary operators are handled identically
as are all unary operators. Let’s look at those two in detail.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_binary<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">,</span> <span class="dt">int32_t</span> pri<span class="op">,</span> <span class="dt">int32_t</span> pri_new<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We add parens if our priority is less than the parent priority</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// meaning something like this:</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// * we&#39;re a + node, our parent is a * node</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// * we need parens because the tree specifies that the + happens before the *</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Also, grouping of equal operators is left to right</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so for so if our right child is the same precedence as us</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// that means there were parens there in the original expression</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e.g.  3+(4-7);</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// effectively it&#39;s like we&#39;re one binding strength higher for our right child</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so we call it with pri_new + 1.  If it&#39;s equal to us it must emit parens</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> pri_new<span class="op">);</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot; %s &quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> pri_new <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The convention gives us: * <code>ast</code> : pointer to the current
AST node * <code>op</code> : the text of the operator (<code>CSTR</code>
is simply <code>const char *</code>) * <code>pri</code> : the binding
strength of the node above us * <code>pri_new</code> : the binding
strength of this node (the new node)</p>
<p>So generically, if the binding strength of the current operator
<code>pri_new</code> is weaker than the context it is contained in
<code>pri</code>, then parentheses are required to preserve order of
operations. See the comment for more details.</p>
<p>With parens taken care of, we emit the left expression, the operator,
and the right expression.</p>
<p>And as you can see below, unary operators are much the same.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_unary<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">,</span> <span class="dt">int32_t</span> pri<span class="op">,</span> <span class="dt">int32_t</span> pri_new<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;%s&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  gen_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> pri_new<span class="op">);</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>pri_new <span class="op">&lt;</span> pri<span class="op">)</span> gen_printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are special case formatters for some of the postfix operators
and other cases that are special like
<code>CASE... WHEN... THEN... ELSE... END</code> but they operate on the
same principles down to the leaf nodes.</p>
<h4 id="generating-statements">Generating Statements</h4>
<p>With no binding strength to worry about, statement processing is
quite a bit simpler.</p>
<p>Here’s the code for the <code>IF</code> statement mentioned
above.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_if_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_if_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NOTNULL<span class="op">(</span>cond_action<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NOTNULL<span class="op">(</span>if_alt<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>elseif<span class="op">,</span> if_alt<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NAMED<span class="op">(</span>elsenode<span class="op">,</span> <span class="cf">else</span><span class="op">,</span> if_alt<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;IF &quot;</span><span class="op">);</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  gen_cond_action<span class="op">(</span>cond_action<span class="op">);</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elseif<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    gen_elseif_list<span class="op">(</span>elseif<span class="op">);</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elsenode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    gen_printf<span class="op">(</span><span class="st">&quot;ELSE</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> elsenode<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    gen_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot;END IF&quot;</span><span class="op">);</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There is a general boilerplate sort of recursive form to all of
these; they follow the same basic shape. These patterns are designed to
make it impossible to walk the tree incorrectly. If the tree shape
changes because of a grammar change, you get immediate concrete failures
where the tree walk has to change. Since there are test cases to cover
every tree shape you can always be sure you have it exactly right if the
macros do not force assertion failures.</p>
<p>The steps were:</p>
<ul>
<li>use <code>Contract</code> to assert that the node we are given is
the type we expect</li>
<li>use <code>EXTRACT</code> macros (detailed below) to get the tree
parts you want starting from your root</li>
<li>use <code>gen_printf</code> to emit the constant pieces of the
statement</li>
<li>use recursion to print sub-fragments (like the IF condition in this
case)</li>
<li>test the tree fragments where optional pieces are present, emit them
as needed</li>
</ul>
<p>It might be instructive to include <code>gen_cond_action</code>; it
is entirely unremarkable:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> gen_cond_action<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_cond_action<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  gen_root_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  gen_printf<span class="op">(</span><span class="st">&quot; THEN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  gen_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A <code>cond_action</code> node has an expression on the left and a
statement list on the right; it can appear in the base
<code>IF x THEN y</code> part of the <code>IF</code> or as
<code>ELSE IF x THEN y</code>. Either case is formatted the same.</p>
<h4 id="extraction-macros">Extraction Macros</h4>
<p>These macros are used by all the parts of CQL that walk the AST. They
are designed to make it impossible for you to get the tree shape wrong
without immediately failing. We do not ever want to walk off the tree in
some exotic way and then continue to several levels of recursion before
things go wrong. CQL locks this down by checking the node type at every
step – any problems are found immediately, exactly at the extraction
site, and can be quickly corrected. Again 100% coverage of all the tree
shapes makes this rock solid, so CQL never compromises on 100% code
coverage. The most common macros all appear in this example:</p>
<ul>
<li><code>EXTRACT_NOTNULL(cond_action, ast-&gt;left);</code>
<ul>
<li>read ast-&gt;left, assert that it is of type
<code>cond_action</code>, it must not be NULL</li>
<li>declare a local variable named <code>cond_action</code> to hold the
result</li>
</ul></li>
<li><code>EXTRACT_NOTNULL(if_alt, ast-&gt;right);</code>
<ul>
<li>read ast-&gt;right, assert that it is of type <code>if_alt</code>,
it must not be NULL</li>
<li>declare a local variable named <code>if_alt</code> to hold the
result</li>
</ul></li>
<li><code>EXTRACT(elseif, if_alt-&gt;left);</code>
<ul>
<li>read <code>if_alt-&gt;left</code>, assert that it is either NULL or
else of type <code>elseif</code></li>
<li>declare a variable named <code>elseif</code> to hold the result</li>
</ul></li>
<li><code>EXTRACT_NAMED(elsenode, else, if_alt-&gt;right);</code>
<ul>
<li>read <code>if_alt-&gt;right</code>, assert that it is either NULL or
else of type <code>else</code></li>
<li>declare a variable named <code>elsenode</code> to hold the
result</li>
<li>note that we can’t use a variable named <code>else</code> because
<code>else</code> is a keyword in C</li>
</ul></li>
</ul>
<p>Other options:</p>
<ul>
<li><code>EXTRACT_NAMED_NOTNULL</code> : like the <code>NAMED</code>
variant</li>
<li><code>EXTRACT_ANY</code> : if the tree type is not known
(e.g. <code>expr-&gt;left</code> could be any expression type)</li>
<li><code>EXTRACT_ANY_NOTNULL</code> : as above but not optional</li>
<li><code>EXTRACT_NUM_TYPE</code> : extracts the num_type field from a
numeric AST node</li>
</ul>
<p>The <code>ANY</code> variants are usually re-dispatched with
something like <code>gen_expr</code> that uses the name table again (and
that will check the type) or else the extracted value is checked with ad
hoc logic immediately after extraction if it’s perhaps one of two or
three variations. In all cases the idea is to force a failure very
quickly. <code>gen_root_expr()</code> for instance in the
<code>if_cond</code> example will fail immediately if the node it gets
is not an expression type.</p>
<p>Because of the clear use of <code>EXTRACT</code>, the
<code>gen_</code> family of functions are often the best/fastest way to
understand the shape of the AST. You can dump a few samples and look at
the <code>gen_</code> function and quickly see exactly what the options
are authoritatively. As a result it’s very normal to paste the
extraction code from a <code>gen_</code> function into a new/needed
semantic analysis or code-generation function.</p>
<h2 id="part-2-semantic-analysis">Part 2: Semantic Analysis</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-1">Preface</h3>
<p>Part 2 continues with a discussion of the essentials of the semantic
analysis pass of the CQL compiler. As in the previous sections, the goal
here is not to go over every single rule but rather to give a sense of
how semantic analysis happens in general – the core strategies and
implementation choices – so that when reading the code you will have an
idea of how smaller pieces fit into the whole. To accomplish this,
various key data structures will be explained in detail and selected
examples of their use are included.</p>
<h2 id="semantic-analysis">Semantic Analysis</h2>
<p>The overall goal of the semantic analysis pass is to verify that a
correct program has been submitted to the compiler. The compiler does
this by “decorating” the AST with semantic information. This information
is mainly concerned with the “types” of the various things in the
program. A key function of the semantic analyzer, the primary “weapon”
in computing these types, if you will, is name resolution. The semantic
analyzer decides what any given name means in any context and then uses
that meaning, which is itself based on the AST constructs that came
before, to compute types and then check those types for errors.</p>
<p>Broadly speaking, the errors that can be discovered are of these
forms:</p>
<ul>
<li>mentioned names do not exist
<ul>
<li>e.g. using a variable or table or column without declaring it</li>
</ul></li>
<li>mentioned names are not unique, or are ambiguous
<ul>
<li>e.g. every view must have a unique name</li>
<li>e.g. table names need to be unique, or aliased when joining
tables</li>
</ul></li>
<li>operands are not compatible with each other or with the intended
operation
<ul>
<li>e.g. you can’t add a string to a real</li>
<li>e.g. you can’t do the <code>%</code> operation on a real</li>
<li>e.g. the expression in a <code>WHERE</code> clause must result in a
numeric</li>
<li>e.g. the first argument to <code>printf</code> must be a string
literal</li>
<li>e.g. you can’t assign a long value to an integer variable</li>
<li>e.g. you can’t assign a possibly null result to a not-null
variable</li>
</ul></li>
<li>there are too many or two few operands for an operation
<ul>
<li>e.g. an <code>INSERT</code> statement must include sufficiently many
columns and no extras</li>
<li>e.g. a function or procedure call must have the correct number of
operands</li>
</ul></li>
<li>an operation is happening in a context where it is not allowed
<ul>
<li>e.g. use of aggregate functions in the <code>WHERE</code>
clause</li>
<li>e.g. use of unique SQLite functions outside of a SQL statement</li>
</ul></li>
</ul>
<p>There are several hundred possible errors, and no attempt will be
made to cover them all here but we will talk about how errors are
created, recorded, and reported.</p>
<h3 id="decorated-ast-examples">Decorated AST examples</h3>
<p>Recalling the AST output from <a
href="https://cgsql.dev/cql-guide/int01">Part 1</a>, this is what that
same tree looks like with semantic information attached:</p>
<pre><code>LET X := 1 + 3;

  {let_stmt}: X: integer notnull variable
  | {name X}: X: integer notnull variable
  | {add}: integer notnull
    | {int 1}: integer notnull
    | {int 3}: integer notnull</code></pre>
<p>And here’s an example with some structure types:</p>
<pre><code>SELECT 1 AS x, 3.2 AS y;

  {select_stmt}: select: { x: integer notnull, y: real notnull }
  | {select_core_list}: select: { x: integer notnull, y: real notnull }
  | | {select_core}: select: { x: integer notnull, y: real notnull }
  |   | {select_expr_list_con}: select: { x: integer notnull, y: real notnull }
  |     | {select_expr_list}: select: { x: integer notnull, y: real notnull }
  |     | | {select_expr}: x: integer notnull
  |     | | | {int 1}: integer notnull
  |     | | | {opt_as_alias}
  |     | |   | {name x}
  |     | | {select_expr_list}
  |     |   | {select_expr}: y: real notnull
  |     |     | {dbl 3.2}: real notnull
  |     |     | {opt_as_alias}
  |     |       | {name y}
  |     | {select_from_etc}: ok
  |       | {select_where}
  |         | {select_groupby}
  |           | {select_having}
  | {select_orderby}
    | {select_limit}
      | {select_offset}</code></pre>
<p>These can be generated by adding <code>--sem --ast</code> to the CQL
command line along with <code>--in your_file.sql</code>.</p>
<p>Keep these shapes in mind as we discuss the various sources of type
information.</p>
<h3 id="the-base-data-structures">The Base Data Structures</h3>
<p>First recall that every AST node has this field in it:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> sem_node <span class="op">*</span>_Nullable sem<span class="op">;</span></span></code></pre></div>
<p>This is the pointer to the semantic information for that node.
Semantic analysis happens immediately after parsing and before any of
the code-generators run. Importantly, code generators never run if
semantic analysis reported any errors. Before we get into the shape of
the semantic node, we should start with the fundamental unit of type
info <code>sem_t</code> which is usually stored in a variable called
<code>sem_type</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint64_t</span> sem_t<span class="op">;</span></span></code></pre></div>
<p>The low order bits of a <code>sem_t</code> encode the core type and
indeed there is a helper function to extract the core type from a
<code>sem_t</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Strips out all the flag bits and gives you the base/core type.</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>cql_noexport sem_t core_type_of<span class="op">(</span>sem_t sem_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_type <span class="op">&amp;</span> SEM_TYPE_CORE<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The core bits are as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_NULL 0         </span><span class="co">// the subtree is a null literal (not just nullable)</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BOOL 1         </span><span class="co">// the subtree is a bool</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_INTEGER 2      </span><span class="co">// the subtree is an integer</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_LONG_INTEGER 3 </span><span class="co">// the subtree is a long integer</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_REAL 4         </span><span class="co">// the subtree is a real</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_TEXT 5         </span><span class="co">// the subtree is a text type</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BLOB 6         </span><span class="co">// the subtree is a blob type</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OBJECT 7       </span><span class="co">// the subtree is any object type</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_STRUCT 8       </span><span class="co">// the subtree is a table/view</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_JOIN 9         </span><span class="co">// the subtree is a join</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_ERROR 10       </span><span class="co">// marks the subtree as having a problem</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OK 11          </span><span class="co">// sentinel for ok but no type info</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_PENDING 12     </span><span class="co">// sentinel for type calculation in flight</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_REGION 13      </span><span class="co">// the ast is a schema region</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CURSOR_FORMAL 14      </span><span class="co">// this is used for the cursor parameter type uniquely</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CORE 0xff      </span><span class="co">// bit mask for the core types</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_MAX_UNITARY (SEM_TYPE_OBJECT+1) </span><span class="co">// the last unitary type</span></span></code></pre></div>
<p>These break into a few categories: * <code>NULL</code> to
<code>OBJECT</code> are the “unitary” types – these are the types that a
single simple variable can be * a column can be any of these except
<code>OBJECT</code> or <code>NULL</code> * the <code>NULL</code> type
comes only from the <code>NULL</code> literal which has no type *
instances of, say, a <code>TEXT</code> column might have a
<code>NULL</code> value but they are known to be <code>TEXT</code> *
<code>STRUCT</code> indicates that the object has many fields, like a
table, or a cursor * <code>JOIN</code> indicates that the object is the
concatenation of many <code>STRUCT</code> types *
e.g. <code>T1 inner join T2</code> is a <code>JOIN</code> type with
<code>T1</code> and <code>T2</code> being the parts * a
<code>JOIN</code> could be flattened to <code>STRUCT</code>, but this is
typically not done * the type of a <code>SELECT</code> statement will be
a <code>STRUCT</code> representing the expressions that were selected *
those expressions in turn used columns from the <code>JOIN</code> that
was the <code>FROM</code> clause * <code>ERROR</code> indicates that the
subtree had an error * the error will have been already reported * the
error type generally cascades up the AST to the root * <code>OK</code>
indicates that there is no type information but there was no problem *
e.g. a correct <code>IF</code> statement will resolve to simply
<code>OK</code> (no error) * <code>PENDING</code> is used sometimes
while a type computation is in progress * this type doesn’t appear in
the AST, but has its own unique value so as to not conflict with any
others * <code>REGION</code> is used to identify AST fragments that
correspond to schema regions * see <a
href="https://cgsql.dev/cql-guide/ch10">Chapter 10</a> of the Guide for
more information on regions * <code>CORE</code> is the mask for the core
parts, <code>0xf</code> would do the job but for easy reading in the
debugger we use <code>0xff</code> * new core types are not added very
often, adding a new one is usually a sign that you are doing something
wrong</p>
<p>The core type can be modified by various flags. The flags, in
principle, can be combined in any way but in practice many combinations
make no sense. For instance, <code>HAS_DEFAULT</code> is for table
columns and <code>CREATE_FUNC</code> is for function declarations. There
is no one object that could require both of these.</p>
<p>The full list as of this writing is as follows:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_NOTNULL               _64(0x0100) </span><span class="co">// set if and only if null is not possible</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_DEFAULT           _64(0x0200) </span><span class="co">// set for table columns with a default</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_AUTOINCREMENT         _64(0x0400) </span><span class="co">// set for table columns with autoinc</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VARIABLE              _64(0x0800) </span><span class="co">// set for variables and parameters</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_IN_PARAMETER          _64(0x1000) </span><span class="co">// set for in parameters (can mix with below)</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_OUT_PARAMETER         _64(0x2000) </span><span class="co">// set for out parameters (can mix with above)</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DML_PROC              _64(0x4000) </span><span class="co">// set for stored procs that have DML/DDL</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_SHAPE_STORAGE     _64(0x8000) </span><span class="co">// set for a cursor with simplified fetch syntax</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CREATE_FUNC          _64(0x10000) </span><span class="co">// set for a function that returns a created object +1 ref</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_SELECT_FUNC          _64(0x20000) </span><span class="co">// set for a sqlite UDF function declaration</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DELETED              _64(0x40000) </span><span class="co">// set for columns that are not visible in the current schema version</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VALIDATED            _64(0x80000) </span><span class="co">// set if item has already been validated against previous schema</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_USES_OUT            _64(0x100000) </span><span class="co">// set if proc has a one rowresult using the OUT statement</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_USES_OUT_UNION      _64(0x200000) </span><span class="co">// set if proc uses the OUT UNION form for multi row result</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_PK                  _64(0x400000) </span><span class="co">// set if column is a primary key</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_FK                  _64(0x800000) </span><span class="co">// set if column is a foreign key</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_UK                 _64(0x1000000) </span><span class="co">// set if column is a unique key</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VALUE_CURSOR       _64(0x2000000) </span><span class="co">// set only if SEM_TYPE_HAS_SHAPE_STORAGE is set and the cursor has no statement</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_SENSITIVE          _64(0x4000000) </span><span class="co">// set if the object is privacy sensitive</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_DEPLOYABLE         _64(0x8000000) </span><span class="co">// set if the object is a deployable region</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_BOXED             _64(0x10000000) </span><span class="co">// set if a cursor&#39;s lifetime is managed by a box object</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_CHECK         _64(0x20000000) </span><span class="co">// set for table column with a &quot;check&quot; clause</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HAS_COLLATE       _64(0x40000000) </span><span class="co">// set for table column with a &quot;collate&quot; clause</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_INFERRED_NOTNULL  _64(0x80000000) </span><span class="co">// set if inferred to not be nonnull (but was originally nullable)</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_VIRTUAL          _64(0x100000000) </span><span class="co">// set if and only if this is a virtual table</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_HIDDEN_COL       _64(0x200000000) </span><span class="co">// set if and only if hidden column on a virtual table</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_TVF              _64(0x400000000) </span><span class="co">// set if and only table node is a table valued function</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_IMPLICIT         _64(0x800000000) </span><span class="co">// set if and only the variable was declare implicitly (via declare out)</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_TYPE_CALLS_OUT_UNION _64(0x1000000000) </span><span class="co">// set if proc calls an out union proc for</span></span></code></pre></div>
<p>Note: <code>_64(x)</code> expands to either a trailing <code>L</code>
or a trailing <code>LL</code> depending on the bitness of the compiler,
whichever yields an <code>int64_t</code>.</p>
<p>Going over the meaning of all of the above is again beyond the scope
of this document; some of the flags are very specialized and essentially
the validation just requires a bit of storage in the tree to do its job
so that storage is provided with a flag. However two flag bits are
especially important and are computed almost everywhere
<code>sem_t</code> is used. These are <code>SEM_TYPE_NOTNULL</code> and
<code>SEM_TYPE_SENSITIVE</code>.</p>
<ul>
<li><code>SEM_TYPE_NOTNULL</code> indicates that the marked item is
known to be <code>NOT NULL</code>, probably because it was declared as
such, or directly derived from a not null item
<ul>
<li>Typically when two operands are combined both must be marked
<code>NOT NULL</code> for the result to still be <code>NOT NULL</code>
(there are exceptions like <code>COALESCE</code>)</li>
<li>Values that might be null cannot be assigned to targets that must
not be null</li>
</ul></li>
<li><code>SEM_TYPE_SENSITIVE</code> indicates that the marked item is
some kind of PII or other sensitive data.
<ul>
<li>Any time a sensitive operand is combined with another operand the
resulting type is sensitive</li>
<li>There are very few ways to “get rid” of the sensitive bit – it
corresponds to the presence of <code>@sensitive</code> in the data type
declaration</li>
<li>Values that are sensitive cannot be assigned to targets that are not
marked sensitive</li>
</ul></li>
</ul>
<p>The semantic node <code>sem_node</code> carries all the possible
semantic info we might need, and the <code>sem_type</code> holds the
flags above and tells us how to interpret the rest of the node. There
are many fields – we’ll talk about some of the most important ones here
to give you a sense of how things hang together.</p>
<p>Note that <code>CSTR</code> is simply an alias for
<code>const char *</code>. <code>CSTR</code> is used extensively in the
codebase for brevity.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_node <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type<span class="op">;</span>                   <span class="co">// core type plus flags</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  CSTR name<span class="op">;</span>                        <span class="co">// for named expressions in select columns, etc.</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  CSTR kind<span class="op">;</span>                        <span class="co">// the Foo in object&lt;Foo&gt;, not a variable or column name</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  CSTR error<span class="op">;</span>                       <span class="co">// error text for test output, not used otherwise</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">*</span>sptr<span class="op">;</span>          <span class="co">// encoded struct if any</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_join <span class="op">*</span>jptr<span class="op">;</span>            <span class="co">// encoded join if any</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> create_version<span class="op">;</span>           <span class="co">// create version if any (really only for tables and columns)</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> delete_version<span class="op">;</span>           <span class="co">// delete version if any (really only for tables and columns)</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  bool_t recreate<span class="op">;</span>                  <span class="co">// for tables only, true if marked @recreate</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>  CSTR recreate_group_name<span class="op">;</span>         <span class="co">// for tables only, the name of the recreate group if they are in one</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  CSTR region<span class="op">;</span>                      <span class="co">// the schema region, if applicable; null means unscoped (default)</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>used_symbols<span class="op">;</span>             <span class="co">// for select statements, we need to know which of the ids in the select list was used, if any</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  list_item <span class="op">*</span>index_list<span class="op">;</span>            <span class="co">// for tables we need the list of indices that use this table (so we can recreate them together if needed)</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> eval_node <span class="op">*</span>value<span class="op">;</span>          <span class="co">// for enum values we have to store the evaluated constant value of each member of the enum</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_node<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>sem_type</code> : already discussed above, this tells you how
to interpret everything else</li>
<li><code>name</code> : variables, columns, etc. have a canonical name –
when a name case-insensitivity resolves, the canonical name is stored
here
<ul>
<li>typically later passes emit the canonical variable name
everywhere</li>
<li>e.g. because <code>FoO</code> and <code>fOO</code> might both
resolve to an object declared as <code>foo</code>, we always emit
<code>foo</code> in codegen</li>
</ul></li>
<li><code>kind</code> : in CQL any type can be discriminated as in
<code>declare foo real&lt;meters&gt;</code>, the kind here is
<code>meters</code>
<ul>
<li>two expressions of the same core type (e.g. <code>real</code>) are
incompatible if they have a <code>kind</code> and the <code>kind</code>
does not match</li>
<li>e.g. if you have <code>bar real&lt;liters&gt;</code> then
<code>set foo := bar;</code> this is an error even though both are
<code>real</code> because <code>foo</code> above is
<code>real&lt;meters&gt;</code></li>
</ul></li>
<li><code>sptr</code> : if the item’s core type is
<code>SEM_TYPE_STRUCT</code> then this is populated (see below)</li>
<li><code>jptr</code> : if the item’s core type is
<code>SEM_TYPE_JOIN</code> then this is populated (see below)</li>
</ul>
<p>If the object is a structure type then this is simply an array of
names, kinds, and semantic types. In fact the semantic types will be all
be unitary, possibly modified by <code>NOT_NULL</code> or
<code>SENSITIVE</code> but none of the other flags apply. A single
<code>sptr</code> directly corresponds to the notion of a “shape” in the
analyzer. Shapes come from anything that looks like a table, such as a
cursor, or the result of a <code>SELECT</code> statement.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for tables and views and the result of a select</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_struct <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  CSTR struct_name<span class="op">;</span>               <span class="co">// struct name</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of fields</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// field names</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>kinds<span class="op">;</span>                    <span class="co">// the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>semtypes<span class="op">;</span>                <span class="co">// typecode for each field</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_struct<span class="op">;</span></span></code></pre></div>
<p>If the object is a join type (such as the parts of the
<code>FROM</code> clause) then the <code>jptr</code> field will be
populated. This is nothing more than a named list of struct types.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for the data type of (parts of) the FROM clause</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">// sometimes I refer to as a &quot;joinscope&quot;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_join <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of table/views in the join</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// names of the table/view</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">**</span>tables<span class="op">;</span>     <span class="co">// struct type of each table/view</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_join<span class="op">;</span></span></code></pre></div>
<p>With these building blocks we can represent the type of anything in
the CQL language.</p>
<h3 id="initiating-semantic-analysis">Initiating Semantic Analysis</h3>
<p>The semantic analysis pass runs much the same way as the AST emitter.
In <code>sem.c</code> there is the essential function
<code>sem_main</code>. It suffices to call <code>sem_main</code> on the
root of the AST. That root node is expected to be a
<code>stmt_list</code> node.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This method loads up the global symbol tables in either empty state or</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">// with the appropriate tokens ready to go.  Using our own symbol tables for</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co">// dispatch saves us a lot of if/else string comparison verbosity.</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> sem_main<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// restore all globals and statics we own</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  sem_cleanup<span class="op">();</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  eval_init<span class="op">();</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As you can see, <code>sem_main</code> begins by resetting all the
global state. You can of course do this yourself after calling
<code>sem_main</code> (when you’re done with the results).</p>
<p><code>sem_main</code> sets a variety of useful and public global
variables that describe the results of the analysis. The ones in
<code>sem.h</code> are part of the contract and you should feel free to
use them in a downstream code-generator. Other items are internal and
should be avoided. The internal items are typically defined statically
in <code>sem.c</code>. The essential outputs will be described in the
last section of this part.</p>
<p>The cleanup has this structure:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This method frees all the global state of the semantic analyzer</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> sem_cleanup<span class="op">()</span> <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  eval_cleanup<span class="op">();</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>deployable_validations<span class="op">);</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>recreate_annotations<span class="op">);</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  BYTEBUF_CLEANUP<span class="op">(</span>schema_annotations<span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>funcs<span class="op">);</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>globals<span class="op">);</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>indices<span class="op">);</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>locals<span class="op">);</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// these are getting zeroed so that leaksanitizer will not count those objects as reachable from a global root.</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  all_ad_hoc_list <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>  all_functions_list <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>This basically deallocates everything and resets all the globals to
<code>NULL</code>.</p>
<p><code>sem_main</code> of course has to walk the AST and it does so in
much the same way as we saw in <code>gen_sql.c</code>. There is a series
of symbol tables whose key is an AST type and whose value is a function
plus arguments to dispatch (effectively a lambda.) The semantic analyzer
doesn’t have to think about things like “should I emit parentheses?” so
the signature of each type of lambda can be quite a bit simpler. We’ll
go over each kind with some examples.</p>
<p>First we have the non-SQL statements, these are basic flow control or
other things that SQLite will never see directly.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>syms <span class="op">=</span> non_sql_stmts<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>if_stmt<span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>while_stmt<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>switch_stmt<span class="op">);</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>leave_stmt<span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Here <code>STMT_INIT</code> creates a binding between (e.g.) the AST
type <code>if_stmt</code> and the function <code>sem_if_stmt</code>.
This lets us dispatch any part of the AST to its handler directly.</p>
<p>Next we have the SQL statements. These get analyzed in the same way
as the others, and with functions that have the same signature, however,
if you use one of these it means that procedure that contained this
statement must get a database connection in order to run. Use of the
database will require the procedure’s signature to change; this is
recorded by the setting the <code>SEM_TYPE_DML_PROC</code> flag bit to
be set on the procedure’s AST node.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  syms <span class="op">=</span> sql_stmts<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_table_stmt<span class="op">);</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>drop_table_stmt<span class="op">);</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_index_stmt<span class="op">);</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>create_view_stmt<span class="op">);</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>select_stmt<span class="op">);</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>delete_stmt<span class="op">);</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>update_stmt<span class="op">);</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>insert_stmt<span class="op">);</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Again <code>STMT_INIT</code> creates a binding between (e.g.) the AST
type <code>delete_stmt</code> and the function
<code>sem_delete_stmt</code> so we can dispatch to the handler.</p>
<p>Next we have expression types. These are set up with
<code>EXPR_INIT</code>. Many of the operators require exactly the same
kinds of verification, so in order to be able to share the code, the
expression analysis functions get an extra argument for the operator in
question. Typically the string of the operator is only needed to make a
good quality error message with validation being otherwise identical.
Here are some samples…</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>num<span class="op">,</span> sem_expr_num<span class="op">,</span> <span class="st">&quot;NUM&quot;</span><span class="op">);</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>str<span class="op">,</span> sem_expr_str<span class="op">,</span> <span class="st">&quot;STR&quot;</span><span class="op">);</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>blob<span class="op">,</span> sem_expr_blob<span class="op">,</span> <span class="st">&quot;BLB&quot;</span><span class="op">);</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>null<span class="op">,</span> sem_expr_null<span class="op">,</span> <span class="st">&quot;NULL&quot;</span><span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>dot<span class="op">,</span> sem_expr_dot<span class="op">,</span> <span class="st">&quot;DOT&quot;</span><span class="op">);</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span><span class="dt">const</span><span class="op">,</span> sem_expr_const<span class="op">,</span> <span class="st">&quot;CONST&quot;</span><span class="op">);</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mul<span class="op">,</span> sem_binary_math<span class="op">,</span> <span class="st">&quot;*&quot;</span><span class="op">);</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mod<span class="op">,</span> sem_binary_integer_math<span class="op">,</span> <span class="st">&quot;%&quot;</span><span class="op">);</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>not<span class="op">,</span> sem_unary_logical<span class="op">,</span> <span class="st">&quot;NOT&quot;</span><span class="op">);</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>is_true<span class="op">,</span> sem_unary_is_true_or_false<span class="op">,</span> <span class="st">&quot;IS TRUE&quot;</span><span class="op">);</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>tilde<span class="op">,</span> sem_unary_integer_math<span class="op">,</span> <span class="st">&quot;~&quot;</span><span class="op">);</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>uminus<span class="op">,</span> sem_unary_math<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Looking at the very first entry as an example, we see that
<code>EXPR_INIT</code> creates a mapping between the AST type
<code>num</code> and the analysis function <code>sem_expr_num</code> and
that function will get the text <code>"NUM"</code> as an extra argument.
As it happens <code>sem_expr_num</code> doesn’t need the extra argument,
but <code>sem_binary_math</code> certainly needs the <code>"*"</code> as
that function handles a large number of binary operators.</p>
<p>Let’s quickly go over this list as these are the most important
analyzers:</p>
<ul>
<li><code>sem_expr_num</code> : analyzes any numeric constant</li>
<li><code>sem_expr_str</code> : analyzes any string literal or
identifier</li>
<li><code>sem_expr_blob</code> : analyzes any blob literal</li>
<li><code>sem_expr_null</code> : analyzes the NULL literal (and nothing
else)</li>
<li><code>sem_expr_dot</code> : analyzes a compound name like
<code>T1.id</code></li>
<li><code>sem_expr_const</code> : analyzes a <code>const(...)</code>
expression, doing the constant evaluation</li>
<li><code>sem_binary_math</code> : analyzes any normal binary math
operator like ‘+’, ‘-’, ‘/’ etc.</li>
<li><code>sem_binary_integer_math</code> : analyzes any binary math
operator where the operands must be integers like ‘%’ or ‘|’</li>
<li><code>sem_unary_logical</code> : analyzes any unary logical operator
(the result is a bool) – this is really only <code>NOT</code></li>
<li><code>sem_unary_is_true_or_false</code> : analyzes any of the
<code>IS TRUE</code>, <code>IS FALSE</code> family of postfix unary
operators</li>
<li><code>sem_unary_integer_math</code> : analyzes any unary operator
where the operand must be an integer – this is really only
<code>~</code></li>
<li><code>sem_unary_math</code> : analyzes any any math unary operator,
presently only negation (but in the future unary <code>+</code>
too)</li>
</ul>
<p>The last group of normal associations are for builtin functions, like
these:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>changes<span class="op">);</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>printf<span class="op">);</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>strftime<span class="op">);</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>date<span class="op">);</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>time<span class="op">);</span></span></code></pre></div>
<p>Each of these is dispatched when a function call is found in the
tree. By way of example <code>FUNC_INIT(changes)</code> causes the
<code>changes</code> function to map to <code>sem_func_changes</code>
for validation.</p>
<p>There are a few other similar macros for more exotic cases but the
general pattern should be clear now. With these in place it’s very easy
to traverse arbitrary statement lists and arbitrary expressions with sub
expressions and have the correct function invoked without having large
<code>switch</code> blocks all over.</p>
<h3 id="semantic-errors">Semantic Errors</h3>
<p>Some of the following examples will show the handling of semantic
errors more precisely but the theory is pretty simple. Each of the
analyzers that has been registered is responsible for putting an
appropriate <code>sem_node</code> into the AST it is invoked on. The
caller will look to see if that <code>sem_node</code> is of type
<code>SEM_TYPE_ERROR</code> using <code>is_error(ast)</code>. If it is,
the caller will mark its own AST as errant using
<code>record_error(ast)</code> and this continues all the way up the
tree. The net of this is that wherever you begin semantic analysis, you
can know if there were any problems by checking for an error at the top
of the tree you provided.</p>
<p>At the point of the initial error, the analyzer is expected to also
call <code>report_error</code> providing a suitable message. This will
be logged to <code>stderr</code>. In test mode it is also stored in the
AST so that verification steps can confirm that errors were reported at
exactly the right place.</p>
<p>If there are no errors, then a suitable <code>sem_node</code> is
created for the resulting type or else, at minimum,
<code>record_ok(ast)</code> is used to place the shared “OK” type on the
node. The “OK” type indicates no type information, but no errors either.
“OK” is helpful for statements that don’t involve expressions like
<code>DROP TABLE Foo</code>.</p>
<h3 id="the-primitive-types">The Primitive Types</h3>
<p>Perhaps the simplest analysis of all happens at the leaves of the
AST. By way of example, here is the code for expression nodes of type
<code>num</code>, the numeric literals.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Expression type for numeric primitives</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_expr_num<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR cstr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_num<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  EXTRACT_NUM_TYPE<span class="op">(</span>num_type<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>num_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_BOOL<span class="op">:</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_BOOL <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_INT<span class="op">:</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> NUM_LONG<span class="op">:</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_LONG_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span><span class="op">:</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is all that&#39;s left</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>num_type <span class="op">==</span> NUM_REAL<span class="op">);</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_REAL <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">);</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As you can see the code simply looks at the AST node, confirming
first that it is a <code>num</code> node. Then it extracts the
<code>num_type</code>. Then <code>ast-&gt;sem</code> is set to a
semantic node of the matching type adding in
<code>SEM_TYPE_NOTNULL</code> because literals are never null.</p>
<p>The <code>new_sem</code> function is used to make an empty
<code>sem_node</code> with the <code>sem_type</code> filled in as
specified. Nothing can go wrong creating a literal so there are no
failure modes.</p>
<p>It doesn’t get much simpler unless maybe…</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Expression type for constant NULL</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_expr_null<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR cstr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_null<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// null literal</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_NULL<span class="op">);</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s hard to get simpler than doing semantic analysis of the
<code>NULL</code> literal. Its code should be clear with no further
explanation needed.</p>
<h3 id="unary-operators">Unary Operators</h3>
<p>Let’s dive in to a simple case that does require some analysis – the
unary operators. There are comparatively few and there isn’t much code
required to handle them all.</p>
<p>Here’s the code for the unary math operators:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The only unary math operators are &#39;-&#39; and &#39;~&#39;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Reference types are not allowed</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_unary_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  sem_t core_type<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_unary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_validate_numeric<span class="op">(</span>ast<span class="op">,</span> core_type<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The result of unary math promotes to integer.  Basically this converts</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// bool to integer.  Long integer and Real stay as they are.  Text is</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// already ruled out.</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type_result <span class="op">=</span> sem_combine_types<span class="op">(</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>SEM_TYPE_INTEGER <span class="op">|</span> SEM_TYPE_NOTNULL<span class="op">),</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>core_type <span class="op">|</span> combined_flags<span class="op">));</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>sem_type_result<span class="op">);</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind <span class="op">=</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// note ast-&gt;sem-&gt;name is NOT propagated because SQLite doesn&#39;t let you refer to</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the column &#39;x&#39; in &#39;select -x&#39; -- the column name is actually &#39;-x&#39; which is useless</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so we have no name once you apply unary math (unless you use &#39;as&#39;)</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// hence ast-&gt;sem-&gt;name = ast-&gt;left-&gt;sem-&gt;name is WRONG here and it is not missing on accident</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>Unary Prep</em></p>
<p>OK already we need to pause because there is a “prep” pattern here
common to most of the shared operators that we should discuss. The prep
step takes care of most of the normal error handling which is the same
for all the unary operators and the same pattern happens in binary
operators. Let’s take a look at <code>sem_unary_prep</code>.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The unary operators all have a similar prep to the binary.  We need</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to visit the left side (it&#39;s always the left node even if the operator goes on the right)</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">// if that&#39;s ok then we need the combined_flags and core type.  There is only</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">// the one.  Returns true if everything is ok.</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_unary_prep<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t <span class="op">*</span>core_type<span class="op">,</span> sem_t <span class="op">*</span>combined_flags<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// op left | left op</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">))</span> <span class="op">{</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>combined_flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>  sem_node <span class="op">*</span>sem <span class="op">=</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type <span class="op">=</span> sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type <span class="op">=</span> core_type_of<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>combined_flags <span class="op">=</span> not_nullable_flag<span class="op">(</span>sem_type<span class="op">)</span> <span class="op">|</span> sensitive_flag<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type<span class="op">));</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Reviewing the steps:</p>
<ul>
<li>first we analyze the operand, it will be in
<code>ast-&gt;left</code></li>
<li>if that’s an error, we just return the error code from the prep
steps</li>
<li>now that it’s not an error, we pull the core type out of the
operand</li>
<li>then we pull the not nullable and sensitive flag bits out of the
operand</li>
<li>finally return a boolean indicating the presence of an error (or
not) for convenience</li>
</ul>
<p>This is useful setup for all the unary operators, and as we’ll see,
the binary operators have a similar prep step.</p>
<p><em>Back to Unary Processing</em></p>
<p>Looking at the overall steps we see:</p>
<ul>
<li><code>sem_unary_prep</code> : verifies that the operand is not an
error, and gets its core type and flag bits</li>
<li><code>sem_validate_numeric</code> : verifies that the operand is a
numeric type
<ul>
<li>recall these are the math unary operators, so the operand must be
numeric</li>
</ul></li>
<li><code>sem_combine_types</code> : creates the smallest type that
holds two compatible types
<ul>
<li>by combining with “integer not null” we ensure that the resulting
type is at least as big as an integer</li>
<li>if the argument is of type <code>long</code> or <code>real</code>
then it will be the bigger type and the resulting type will be
<code>long</code> or <code>real</code> as appropriate</li>
<li>in short, <code>bool</code> is promoted to <code>int</code>,
everything else stays the same</li>
<li><code>sem_combine_types</code> also combines the nullability and
sensitivity appropriately</li>
</ul></li>
<li>a new <code>sem_node</code> of the combined type is created
<ul>
<li>the type “kind” of the operand is preserved (e.g. the
<code>meters</code> in <code>real&lt;meters&gt;</code>)</li>
<li>any column alias or variable name is not preserved, the value is now
anonymous</li>
</ul></li>
</ul>
<p>These primitives are designed to combine well, for instance, consider
<code>sem_unary_integer_math</code></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_unary_integer_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  sem_unary_math<span class="op">(</span>ast<span class="op">,</span> op<span class="op">);</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  sem_reject_real<span class="op">(</span>ast<span class="op">,</span> op<span class="op">);</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The steps are:</p>
<ul>
<li><code>sem_unary_math</code> : do the sequence we just discussed</li>
<li><code>sem_reject_real</code> : report/record an error if the result
type is <code>real</code> otherwise do nothing</li>
</ul>
<p>Note that in all cases the <code>op</code> string simply gets pushed
down to the place where the errors happen. Let’s take a quick look at
one of the sources of errors in the above. Here’s the numeric
validator:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_validate_numeric<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t core_type<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_blob<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0045: blob operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0046: object operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_text<span class="op">(</span>core_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0047: string operand not allowed in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>That function is pretty much dumb as rocks. The non-numeric types are
blob, object, and text. There is a custom error for each type (it could
have been shared but specific error messages seem to help users.) This
code doesn’t know its context, but all it needs is <code>op</code> to
tell it what the numeric-only operator was and it can produce a nice
error message. It leaves an error in the AST using
<code>record_error</code>. Its caller can then simply
<code>return</code> if anything goes wrong.</p>
<p>It’s not hard to guess how <code>sem_reject_real</code> works:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Some math operators like &lt;&lt; &gt;&gt; &amp; | % only make sense on integers</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">// This function does the extra checking to ensure they do not get real values</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">// as arguments.  It&#39;s a post-pass after the normal math checks.</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_reject_real<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>is_error<span class="op">(</span>ast<span class="op">))</span> <span class="op">{</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    sem_t core_type <span class="op">=</span> core_type_of<span class="op">(</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>core_type <span class="op">==</span> SEM_TYPE_REAL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>      report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0001: operands must be an integer type, not real&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>if the AST node isn’t already an error, and the node is of type
“real”, report an error</li>
<li>it assumes the type is already known to be numeric</li>
<li>the pre-check for errors is to avoid double reporting; if something
has already gone wrong, the core type will be
<code>SEM_TYPE_ERROR</code>
<ul>
<li>no new error recording is needed in that case, as obviously an error
was already recorded</li>
</ul></li>
</ul>
<h3 id="binary-operators">Binary Operators</h3>
<h4 id="binary-prep">Binary Prep</h4>
<p>With the knowledge we have so far, this code pretty much speaks for
itself, but we’ll walk through it.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// All the binary ops do the same preparation -- they evaluate the left and the</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">// right expression, then they check those for errors.  Then they need</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the types of those expressions and the combined_flags of the result.  This</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co">// does exactly that for its various callers.  Returns true if all is well.</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_binary_prep<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t <span class="op">*</span>core_type_left<span class="op">,</span> sem_t <span class="op">*</span>core_type_right<span class="op">,</span> sem_t <span class="op">*</span>combined_flags<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>left<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>right<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// left op right</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>left<span class="op">);</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>right<span class="op">);</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>left<span class="op">)</span> <span class="op">||</span> is_error<span class="op">(</span>right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type_left <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>core_type_right <span class="op">=</span> SEM_TYPE_ERROR<span class="op">;</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>combined_flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type_left <span class="op">=</span> core_type_of<span class="op">(</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>core_type_right <span class="op">=</span> core_type_of<span class="op">(</span>right<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>combined_flags <span class="op">=</span> combine_flags<span class="op">(</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">,</span> right<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">);</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type_left<span class="op">));</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>is_unitary<span class="op">(*</span>core_type_right<span class="op">));</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_expr</code> : used to recursively walk the left and right
nodes</li>
<li><code>is_error</code> : checks if either side had errors, and, if
so, simply propagates the error</li>
<li>extract the left and right core types</li>
<li>combine nullability and sensitivity flags</li>
</ul>
<p>And that’s it! These are the standard prep steps for all binary
operators. With this done, the caller has the core types of the left and
right operands plus combined flags on a silver platter and one check is
needed to detect if anything went wrong.</p>
<h4 id="example-is-or-is-not">Example: Is or Is Not</h4>
<p>This analyzer is the simplest of all the binaries</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// IS and IS NOT are special in that they return a not null boolean.</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_binary_is_or_is_not<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  sem_t core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_binary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type_left<span class="op">,</span> <span class="op">&amp;</span>core_type_right<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_compat<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the result of is or is not is always a bool and never null</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_BOOL <span class="op">|</span> SEM_TYPE_NOTNULL <span class="op">|</span> sensitive_flag<span class="op">(</span>combined_flags<span class="op">));</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_binary_prep</code> : checks for errors in the left or
right</li>
<li><code>sem_verify_compat</code> : ensures that left and right
operands are type compatible (discussed later)</li>
<li>the result is always of type <code>bool not null</code></li>
</ul>
<p>If either step goes wrong the error will naturally propagate.</p>
<h4 id="example-binary-math">Example: Binary Math</h4>
<p>This is the general worker for binary math operations, the most
common operations like ‘+’, ‘-’, ’*’ and so forth.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// For all math operations, we combine the types and yield the type that</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">// holds both using the helper.  If any text, that&#39;s an error.</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_binary_math<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  sem_t core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> combined_flags<span class="op">;</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_binary_prep<span class="op">(</span>ast<span class="op">,</span> <span class="op">&amp;</span>core_type_left<span class="op">,</span> <span class="op">&amp;</span>core_type_right<span class="op">,</span> <span class="op">&amp;</span>combined_flags<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_object<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_blob_types<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>error_any_text_types<span class="op">(</span>ast<span class="op">,</span> core_type_left<span class="op">,</span> core_type_right<span class="op">,</span> op<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>  sem_t core_type <span class="op">=</span> sem_combine_types<span class="op">(</span>core_type_left<span class="op">,</span> core_type_right<span class="op">);</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>  CSTR kind <span class="op">=</span> sem_combine_kinds<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">);</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>core_type <span class="op">|</span> combined_flags<span class="op">);</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind <span class="op">=</span> kind<span class="op">;</span></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s have a look at those steps:</p>
<ul>
<li><code>sem_binary_prep</code> : checks for errors on the left or
right</li>
<li><code>error_any_object</code> : reports an error if the left or
right is of type object</li>
<li><code>error_any_blob_types</code> : reports an error if the left or
right is of type blob</li>
<li><code>error_any_text_types</code> : reports an error if the left or
right is of type text</li>
<li><code>sem_combine_type</code> : computes the combined type, the
smallest numeric type that holds both left and right
<ul>
<li>note the operands are now known to be numeric</li>
<li>the three type error checkers give nice tight errors about the left
or right operand</li>
</ul></li>
<li><code>sem_combine_kinds</code> : tries to create a single type
<code>kind</code> for both operands
<ul>
<li>if their <code>kind</code> is incompatible, records an error on the
right</li>
</ul></li>
<li><code>new_sem</code> : creates a <code>sem_node</code> with the
combined type, flags, and then the <code>kind</code> is set</li>
</ul>
<p>At this point it might help to look at a few more of the base
validators – they are rather unremarkable.</p>
<h4 id="example-validator-error_any_object">Example Validator:
error_any_object</h4>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If either of the types is an object, then produce an error on the ast.</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t error_any_object<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t core_type_left<span class="op">,</span> sem_t core_type_right<span class="op">,</span> CSTR op<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type_left<span class="op">))</span> <span class="op">{</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0002: left operand cannot be an object in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_object<span class="op">(</span>core_type_right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>right<span class="op">,</span> <span class="st">&quot;CQL0003: right operand cannot be an object in&quot;</span><span class="op">,</span> op<span class="op">);</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>is_object</code> : checks a <code>sem_type</code> against
<code>SEM_TYPE_OBJECT</code>
<ul>
<li>if the left or right child is an object, an appropriate error is
generated</li>
</ul></li>
<li>there is no strong convention for returning <code>true</code> if ok,
or <code>true</code> if error; it’s pretty ad hoc
<ul>
<li>this doesn’t seem to cause a lot of problems</li>
</ul></li>
</ul>
<h4 id="example-validator-sem_combine_kinds">Example Validator:
sem_combine_kinds</h4>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we check that type&lt;Foo&gt; only combines with type&lt;Foo&gt; or type.</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">// If there is a current object type, then the next item must match</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">// If there is no such type, then an object type that arrives becomes the required type</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co">// if they ever don&#39;t match, record an error</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> CSTR sem_combine_kinds_general<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR kleft<span class="op">,</span> CSTR kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>kleft<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>strcmp<span class="op">(</span>kleft<span class="op">,</span> kright<span class="op">))</span> <span class="op">{</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        CSTR errmsg <span class="op">=</span> dup_printf<span class="op">(</span><span class="st">&quot;CQL0070: expressions of different kinds can&#39;t be mixed: &#39;%s&#39; vs. &#39;%s&#39;&quot;</span><span class="op">,</span> kright<span class="op">,</span> kleft<span class="op">);</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        report_error<span class="op">(</span>ast<span class="op">,</span> errmsg<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kright<span class="op">;</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> kleft<span class="op">;</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a><span class="co">// helper to crack the ast nodes first and then call the normal comparisons</span></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> CSTR sem_combine_kinds<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR kright<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>  CSTR kleft <span class="op">=</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_combine_kinds_general<span class="op">(</span>ast<span class="op">,</span> kleft<span class="op">,</span> kright<span class="op">);</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_combine_kinds</code> : uses the worker
<code>sem_combine_kinds_general</code> after extracting the
<code>kind</code> from the left node
<ul>
<li>usually you already have one <code>kind</code> and you want to know
if another <code>kind</code> is compatible, hence this helper</li>
</ul></li>
<li><code>sem_combine_kinds_general</code> : applies the general rules
for “kind” strings:
<ul>
<li>NULL + NULL =&gt; NULL</li>
<li>NULL + x =&gt; x</li>
<li>x + NULL =&gt; x</li>
<li>x + x =&gt; x</li>
<li>x + y =&gt; error (if x != y)</li>
</ul></li>
<li>this is one of the rare functions that creates a dynamic error
message</li>
</ul>
<h4 id="example-validator-is_numeric_compat">Example Validator :
is_numeric_compat</h4>
<p>This helper is frequently called several times in the course of other
semantic checks. This one produces no errors, that’s up to the caller.
Often there is a numeric path and a non-numeric path so this helper
can’t create the errors as it doesn’t yet know if anything bad has
happened. Most of the <code>is_something</code> functions are the same
way.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>cql_noexport bool_t is_numeric_compat<span class="op">(</span>sem_t sem_type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  sem_type <span class="op">=</span> core_type_of<span class="op">(</span>sem_type<span class="op">);</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sem_type <span class="op">&gt;=</span> SEM_TYPE_NULL <span class="op">&amp;&amp;</span> sem_type <span class="op">&lt;=</span> SEM_TYPE_REAL<span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>is_numeric_compat</code> operates by checking the core type for
the numeric range. Note that <code>NULL</code> is compatible with
numerics because expressions like <code>NULL + 2</code> have meaning in
SQL. The type of that expression is nullable integer and the result is
<code>NULL</code>.</p>
<h4 id="example-validator-sem_combine_types">Example Validator :
sem_combine_types</h4>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The second workhorse of semantic analysis, given two types that</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">// are previously known to be compatible, it returns the smallest type</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">// that holds both.  If either is nullable, the result is nullable.</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: in the few cases where that isn&#39;t true, the normal algorithm for</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="co">// nullability result must be overridden (see coalesce, for instance).</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> sem_t sem_combine_types<span class="op">(</span>sem_t sem_type_1<span class="op">,</span> sem_t sem_type_2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> too much code <span class="op">...</span> summary below</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This beast is rather lengthy but unremarkable. It follows these
rules: * text is only compatible with text * object is only compatible
with object * blob is only compatible with blob * numerics are only
compatible with other numerics and NULL * NULL promotes the other
operand, whatever it is (might still be NULL) * bool promotes to integer
if needed * integer promotes to long integer if needed * long integer
promotes to real if needed * the combined type is the smallest numeric
type that holds left and right according to the above rules</p>
<p>Some examples might be helpful:</p>
<ul>
<li>1 + 2L -&gt; long</li>
<li>false + 3.1 -&gt; real</li>
<li>2L + 3.1 -&gt; real</li>
<li>true + 2 -&gt; integer</li>
<li>‘x’ + 1 -&gt; not compatible</li>
</ul>
<p>Note that <code>sem_combine_types</code> assumes the types have
already been checked for compatibility and will use
<code>Contract</code> to enforce this. You should be using other helpers
like <code>is_numeric_compat</code> and friends to ensure the types
agree before computing the combined type. A list of values that must be
compatible with each other (e.g. in <code>needle IN (haystack)</code>)
can be checked using <code>sem_verify_compat</code> repeatedly.</p>
<h4 id="example-validator-sem_verify_assignment">Example Validator :
sem_verify_assignment</h4>
<p>The <code>sem_verify_assignment</code> function is used any time
there is something like a logical <code>assignment</code> going on.
There are two important cases:</p>
<ul>
<li><code>SET x := y</code> : an actual assignment</li>
<li><code>call foo(x)</code> : the expression <code>x</code> must be
“assignable” to the formal variable for the argument of
<code>foo</code></li>
</ul>
<p>This is a lot like normal binary operator compatibility with one
extra rule: the source expression must not be a bigger type than the
target. e.g. you cannot assign a <code>long</code> to an
<code>integer</code>, nor pass a long expression to a function that has
an integer parameter.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This verifies that the types are compatible and that it&#39;s ok to assign</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the expression to the variable.  In practice that means:</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable type core type and kind must be compatible with the expression core type and kind</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable must be nullable if the expression is nullable</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable must be sensitive if the assignment is sensitive</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co">// * the variable type must be bigger than the expression type</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Here ast is used only to give a place to put any errors.</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_verify_assignment<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t sem_type_needed<span class="op">,</span> sem_t sem_type_found<span class="op">,</span> CSTR var_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_compat<span class="op">(</span>ast<span class="op">,</span> sem_type_needed<span class="op">,</span> sem_type_found<span class="op">,</span> var_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_safeassign<span class="op">(</span>ast<span class="op">,</span> sem_type_needed<span class="op">,</span> sem_type_found<span class="op">,</span> var_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_nullable<span class="op">(</span>sem_type_found<span class="op">)</span> <span class="op">&amp;&amp;</span> is_not_nullable<span class="op">(</span>sem_type_needed<span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0013: cannot assign/copy possibly null expression to not null target&quot;</span><span class="op">,</span> var_name<span class="op">);</span></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>sensitive_flag<span class="op">(</span>sem_type_found<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>sensitive_flag<span class="op">(</span>sem_type_needed<span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0014: cannot assign/copy sensitive expression to non-sensitive target&quot;</span><span class="op">,</span> var_name<span class="op">);</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>sem_verify_compat</code> : checks for standard type
compatibility between the left and the right</li>
<li><code>sem_verify_safeassign</code> : checks that if the types are
different the right operand is the smaller of the two</li>
<li>nullability checks ensure you aren’t trying to assign a nullable
value to a not null variable</li>
<li>sensitivity checks ensure you aren’t trying to assign a sensitive
value to a not sensitive variable</li>
</ul>
<h3 id="simple-statement-validation">Simple Statement Validation</h3>
<p>With the expression building blocks, most of the usual kind of
language statements become quite simple to check for correctness. It’s
probably easiest to illustrate this with an example. Let’s look at
validation for the <code>WHILE</code> statement:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">// While semantic analysis is super simple.</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the condition must be numeric</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the statement list must be error-free</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co">//  * loop_depth is increased allowing the use of interior leave/continue</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_while_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_while_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>expr<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// WHILE [expr] </span><span class="re">BEGIN</span><span class="co"> [stmt_list] </span><span class="re">END</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  sem_numeric_expr<span class="op">(</span>expr<span class="op">,</span> ast<span class="op">,</span> <span class="st">&quot;WHILE&quot;</span><span class="op">,</span> SEM_EXPR_CONTEXT_NONE<span class="op">);</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>expr<span class="op">))</span> <span class="op">{</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>stmt_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    loop_depth<span class="op">++;</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>    sem_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    loop_depth<span class="op">--;</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_error<span class="op">(</span>stmt_list<span class="op">))</span> <span class="op">{</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>  record_ok<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>EXTRACT*</code> : pulls out the tree parts we need</li>
<li><code>sem_numeric_expr</code> : verifies the loop expression is
numeric</li>
<li><code>sem_stmt_list</code> : recursively validates the body of the
loop</li>
</ul>
<p>Note: the while expression is one of the loop constructs which means
that <code>LEAVE</code> and <code>CONTINUE</code> are legal inside it.
The <code>loop_depth</code> global tracks the fact that we are in a loop
so that analysis for <code>LEAVE</code> and <code>CONTINUE</code> can
report errors if we are not.</p>
<p>It’s not hard to imagine that <code>sem_stmt_list</code> will
basically walk the AST, pulling out statements and dispatching them
using the <code>STMT_INIT</code> tables previously discussed. You might
land right back in <code>sem_while_stmt</code> for a nested
<code>WHILE</code> – it’s turtles all the way down.</p>
<p>If <code>SEM_EXPR_CONTEXT_NONE</code> is a mystery, don’t worry, it’s
covered in the next section.</p>
<h3 id="expression-contexts">Expression Contexts</h3>
<p>It turns out that in the SQL language some expression types are only
valid in some parts of a SQL statement (e.g. aggregate functions can’t
appear in a <code>LIMIT</code> clause) and so there is always a context
for any numeric expression. When a new root expression is being
evaluated, it sets the expression context per the caller’s
specification.</p>
<p>The expression contexts are as follows:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_NONE           0x0001</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_SELECT_LIST    0x0002</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WHERE          0x0004</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_ON             0x0008</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_HAVING         0x0010</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_ORDER_BY       0x0020</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_GROUP_BY       0x0040</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_LIMIT          0x0080</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_OFFSET         0x0100</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_TABLE_FUNC     0x0200</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WINDOW         0x0400</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_WINDOW_FILTER  0x0800</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SEM_EXPR_CONTEXT_CONSTRAINT     0x1000</span></span></code></pre></div>
<p>The idea here is simple: when calling a root expression, the analyzer
provides the context value that has the bit that corresponds to the
current context. For instance, the expression being validated in is the
<code>WHERE</code> clause – the code will provide
<code>SEM_EXPR_CONTEXT_WHERE</code>. The inner validators check this
context, in particular anything that is only available in some contexts
has a bit-mask of that is the union of the context bits where it can be
used. The validator can check those possibilities against the current
context with one bitwise “and” operation. A zero result indicates that
the operation is not valid in the current context.</p>
<p>This bitwise “and” is performed by one of these two helper macros
which makes the usage a little clearer:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CURRENT_EXPR_CONTEXT_IS(x)  (!!(current_expr_context &amp; (x)))</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CURRENT_EXPR_CONTEXT_IS_NOT(x)  (!(current_expr_context &amp; (x)))</span></span></code></pre></div>
<h4 id="expression-context-example-concat">Expression Context Example :
Concat</h4>
<p>The concatenation operator <code>||</code> is challenging to
successfully emulate because it does many different kinds of numeric to
string conversions automatically. Rather than perennially getting this
wrong, we simply do not support this operator in a context where SQLite
isn’t going to be doing the concatenation. So typically users use
“printf” instead to get formatting done outside of a SQL context. The
check for invalid use of <code>||</code> is very simple and it happens,
of course, in <code>sem_concat</code>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>CURRENT_EXPR_CONTEXT_IS<span class="op">(</span>SEM_EXPR_CONTEXT_NONE<span class="op">))</span> <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0241: CONCAT may only appear in the context of a SQL statement&quot;</span><span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<h4 id="expression-context-example-in">Expression Context Example :
IN</h4>
<p>A slightly more complex example happens processing the
<code>IN</code> operator. This operator has two forms: the form with an
expression list, which can be used anywhere, and the form with a
<code>SELECT</code> statement. The latter form can only appear in some
sections of SQL, and not at all in loose expressions. For instance, that
form may not appear in the <code>LIMIT</code> or <code>OFFSET</code>
sections of a SQLite statement.</p>
<p>We use this construct to do the validation:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> valid <span class="op">=</span> SEM_EXPR_CONTEXT_SELECT_LIST</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_WHERE</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_ON</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_HAVING</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span>SEM_EXPR_CONTEXT_TABLE_FUNC<span class="op">;</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>CURRENT_EXPR_CONTEXT_IS_NOT<span class="op">(</span>valid<span class="op">))</span> <span class="op">{</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>      report_error<span class="op">(</span> ast<span class="op">,</span> <span class="st">&quot;CQL0078: [not] in (select ...) is only allowed inside &quot;</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>                         <span class="st">&quot;of select lists, where, on, and having clauses&quot;</span><span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>      record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>If the reader is interested in a simple learning exercise, run down
the purpose of <code>SEM_EXPR_CONTEXT_TABLE_FUNC</code> – it’s simple,
but important, and it only has one use case so it’s easy to find.</p>
<h3 id="name-resolution">Name Resolution</h3>
<p>We’ve gotten pretty far without talking about the elephant in the
room: name resolution.</p>
<p>Like SQL, many statements in CQL have names in positions where the
type of the name is completely unambiguous. For instance nobody could be
confused what sort of symbol <code>Foo</code> is in
<code>DROP INDEX Foo</code>.</p>
<p>This type, with a clear name category, is the easiest name
resolutions, and there are a lot in this form. Let’s do an example.</p>
<h4 id="example-index-name-resolution">Example: Index Name
Resolution</h4>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is the basic checking for the drop index statement</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">// * the index must exist (have been declared) in some version</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">// * it could be deleted now, that&#39;s ok, but the name has to be valid</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_drop_index_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_drop_index_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">);</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>index_ast <span class="op">=</span> find_usable_index<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">,</span>  <span class="st">&quot;CQL0112: index in drop statement was not declared&quot;</span><span class="op">);</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>index_ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>  record_ok<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Well, this is interesting. But what’s going on with
<code>find_usable_index</code>? What is usable? Why aren’t we just
looking up the index name in some name table? Let’s have a look at the
details of <code>find_usable_index</code>.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">// returns the node only if it exists and is not restricted by the schema region.</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> ast_node <span class="op">*</span>find_usable_index<span class="op">(</span>CSTR name<span class="op">,</span> ast_node <span class="op">*</span>err_target<span class="op">,</span> CSTR msg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>index_ast <span class="op">=</span> find_index<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>index_ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>err_target<span class="op">,</span> msg<span class="op">,</span> name<span class="op">);</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_validate_object_ast_in_current_region<span class="op">(</span>name<span class="op">,</span> index_ast<span class="op">,</span> err_target<span class="op">,</span> msg<span class="op">))</span> <span class="op">{</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> index_ast<span class="op">;</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We haven’t discussed schema regions yet but what you need to know
about them for now is this: * any object can be in a region. * a region
may depend on other regions</p>
<p>If an object is in a region, then it may only use schema parts that
are in the same region, or the region’s dependencies (transitively).</p>
<p>The point of this is that you might have a rather large schema and
you probably don’t want any piece of code to use just any piece of
schema. You can use regions to ensure that the code for feature “X”
doesn’t try to use schema designed exclusively for feature “Y”. That “X”
code probably has no business even knowing of the existence of “Y”
schema.</p>
<p>So now <code>usable</code> simply means this: *
<code>find_index</code> can find the name in the symbol table for
indices * the found index is accessible in the current region</p>
<p>If we had used an example that was looking up a table name, the same
region considerations would apply, however, additionally tables can be
deprecated with <code>@delete</code> so there would be additional checks
to make sure we’re talking about a live table and not a table’s
tombstone.</p>
<p>In short, these simple cases just require looking up the entity and
verifying that it’s accessible in the current context.</p>
<h4 id="flexible-name-resolution">Flexible Name Resolution</h4>
<p>The “hard case” for name resolution is where the name is occurring in
an expression. Such a name can refer to all manner of things. It could
be a global variable, a local variable, an argument, a table column, a
field in a cursor, and others. The general name resolver goes through
several phases looking for the name. Each phase can either report an
affirmative success or error (in which case the search stops), or it may
simply report that the name was not found but the search should
continue.</p>
<p>We can demystify this a bit by looking at the most common way to get
name resolution done.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Resolves a (potentially qualified) identifier, writing semantic information</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">// into `ast` if successful, or reporting and recording an error for `ast` if</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="co">// not.</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_resolve_id<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR name<span class="op">,</span> CSTR scope<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_id<span class="op">(</span>ast<span class="op">)</span> <span class="op">||</span> is_ast_dot<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We have no use for `type` and simply throw it away.</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>type <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>  sem_resolve_id_with_type<span class="op">(</span>ast<span class="op">,</span> name<span class="op">,</span> scope<span class="op">,</span> <span class="op">&amp;</span>type<span class="op">);</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The name resolver works on either a vanilla name
(e.g. <code>x</code>) or a scoped name (e.g. <code>T1.x</code>). The
name and scope are provided. The <code>ast</code> parameter is used only
as a place to report errors; there is no further cracking of the AST
needed to resolve the name. As you can see <code>sem_resolve_id</code>
just calls the more general function
<code>sem_resolve_id_with_type</code> and is used in the most common
case where you don’t need to be able to mutate the semantic type info
for the identifier. That’s the 99% case.</p>
<p>So let’s move on to the “real” resolver.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This function is responsible for resolving both unqualified identifiers (ids)</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co">// and qualified identifiers (dots). It performs the following two roles:</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="co">// - If an optional `ast` is provided, it works the same way most semantic</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   analysis functions work: semantic information will be written into the</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co">//   ast, errors will be reported to the user, and errors will be recorded in</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="co">//   the AST.</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="co">// - `*type_ptr` will be set to mutable type (`sem_t *`) in the current</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co">//   environment if the identifier successfully resolves to a type. (There are,</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="co">//   unfortunately, a few exceptions in which a type will be successfully</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="co">//   resolved and yet `*type_ptr` will not be set. These include when a cursor is</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a><span class="co">//   in an expression position, when the expression is `rowid` (or similar), and</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a><span class="co">//   when the id resolves to an enum case. The reason no mutable type is</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a><span class="co">//   returned in these cases is that a new type is allocated as part of semantic</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a><span class="co">//   analysis, and there exists no single, stable type in the environment to</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a><span class="co">//   which a pointer could be returned. This is a limitation of this function,</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a><span class="co">//   albeit one that&#39;s currently not problematic.)</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  Resolution is attempted in the order that the `sem_try_resolve_*` functions</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a><span class="co">//  appear in the `resolver` array. Each takes the same arguments: An (optional)</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a><span class="co">//  AST, a mandatory name, an optional scope, and mandatory type pointer. If the</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a><span class="co">//  identifier provided to one of these resolvers is resolved successfully, *or*</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a><span class="co">//  if the correct resolver was found but there was an error in the program,</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a><span class="co">//  `SEM_RESOLVE_STOP` is returned and resolution is complete, successful or not.</span></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a><span class="co">//  If a resolver is tried and it determines that it is not the correct resolver</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a><span class="co">//  for the identifier in question, `SEM_RESOLVE_CONTINUE` is returned and the</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a><span class="co">//  next resolver is tried.</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a><span class="co">// This function should not be called directly. If one is interested in</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a><span class="co">// performing semantic analysis, call `sem_resolve_id` (or, if within an</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a><span class="co">// expression, `sem_resolve_id_expr`.) Alternatively, if one wants to get a</span></span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a><span class="co">// mutable type from the environment, call `find_mutable_type`.</span></span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_resolve_id_with_type<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR name<span class="op">,</span> CSTR scope<span class="op">,</span> sem_t <span class="op">**</span>type_ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>type_ptr<span class="op">);</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>type_ptr <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a>  sem_resolve <span class="op">(*</span>resolver<span class="op">[])(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR<span class="op">,</span> CSTR<span class="op">,</span> sem_t <span class="op">**)</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_arguments<span class="op">,</span></span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_column<span class="op">,</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_rowid<span class="op">,</span></span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_cursor_as_expression<span class="op">,</span></span>
<span id="cb69-45"><a href="#cb69-45" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_variable<span class="op">,</span></span>
<span id="cb69-46"><a href="#cb69-46" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_enum<span class="op">,</span></span>
<span id="cb69-47"><a href="#cb69-47" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_cursor_field<span class="op">,</span></span>
<span id="cb69-48"><a href="#cb69-48" aria-hidden="true" tabindex="-1"></a>    sem_try_resolve_arg_bundle<span class="op">,</span></span>
<span id="cb69-49"><a href="#cb69-49" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb69-50"><a href="#cb69-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-51"><a href="#cb69-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>resolver<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">void</span> <span class="op">*);</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb69-52"><a href="#cb69-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>resolver<span class="op">[</span>i<span class="op">](</span>ast<span class="op">,</span> name<span class="op">,</span> scope<span class="op">,</span> type_ptr<span class="op">)</span> <span class="op">==</span> SEM_RESOLVE_STOP<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-53"><a href="#cb69-53" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb69-54"><a href="#cb69-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-55"><a href="#cb69-55" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb69-56"><a href="#cb69-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-57"><a href="#cb69-57" aria-hidden="true" tabindex="-1"></a>  report_resolve_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0069: name not found&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb69-58"><a href="#cb69-58" aria-hidden="true" tabindex="-1"></a>  record_resolve_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb69-59"><a href="#cb69-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This function is well described in its own comments. We can easily
see the “mini-resolvers” which attempt to find the name in order:</p>
<ul>
<li><code>sem_try_resolve_arguments</code> : an argument in the argument
list</li>
<li><code>sem_try_resolve_column</code> : a column name (possibly
scoped)</li>
<li><code>sem_try_resolve_rowid</code> : the virtual rowid column
(possibly scoped)</li>
<li><code>sem_try_resolve_cursor_as_expression</code> : use of a cursor
as a boolean – the bool is true if the cursor has data</li>
<li><code>sem_try_resolve_variable</code> : local or global
variables</li>
<li><code>sem_try_resolve_enum</code> : the constant value of an enum
(must be scoped)</li>
<li><code>sem_try_resolve_cursor_field</code> : a field in a cursor
(must be scoped)</li>
<li><code>sem_try_resolve_arg_bundle</code> : a field in an argument
bundle (must be scoped)</li>
</ul>
<p>These all use this enum to communicate progress:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co">// All `sem_try_resolve_*` functions return either `SEM_RESOLVE_CONTINUE` to</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="co">// indicate that another resolver should be tried, or `SEM_RESOLVE_STOP` to</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">// indicate that the correct resolver was found. Continuing implies that no</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="co">// failure has (yet) occurred, but stopping implies neither success nor failure.</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  SEM_RESOLVE_CONTINUE <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>  SEM_RESOLVE_STOP <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_resolve<span class="op">;</span></span></code></pre></div>
<p>Each of these mini-resolvers will have a series of rules, for example
<code>sem_try_resolve_cursor_field</code> is going to have to do
something like this:</p>
<ul>
<li>if there is no scope, it can’t be a cursor field, return
<code>CONTINUE</code></li>
<li>if the scope is not the name of a cursor, return
<code>CONTINUE</code></li>
<li>if the name is a field in the cursor, return <code>STOP</code> with
success</li>
<li>else, report that the name is not a valid member of the cursor, and
return <code>STOP</code> with an error</li>
</ul>
<p>All the mini-resolvers are similarly structured, generically:</p>
<ul>
<li>if it’s not my case, return <code>CONTINUE</code></li>
<li>if it is my case return <code>STOP</code> (maybe with an error)</li>
</ul>
<p>Some of the mini-resolvers have quite a few steps, but any one
mini-resolver is only about a screenful of code and it does one job.</p>
<h3 id="flow-analysis">Flow Analysis</h3>
<p>CQL implements a basic form of control flow analysis in “flow.c”. The
header “flow.h” exposes a small set of primitives used by “sem.c” during
semantic analysis.</p>
<p>Flow analysis in CQL involves two important concepts: <strong>flow
contexts</strong> and <strong>improvements</strong>. These are rather
entangled concepts — one is useless without the other — and so the
approach to describing them here will alternate between giving a bit of
background on one and then the other, with a greater level of detail
about the specific types of improvements being supplied later on.</p>
<p>A flow context is used, in essence, to create a boundary around a
portion of a user’s program. At the moment, there are four types of
contexts.</p>
<p>The first type of context is called, rather boringly, a
<strong>normal</strong> context. Normal contexts are used for portions
of a user’s code that may be entered conditionally. A good example of
this is in <code>SELECT</code> expressions: When a <code>WHERE</code>
clause is present, the expression list is only evaluated when the
<code>WHERE</code> clause is true. If we look at
<code>sem_select_expr_list_con</code>, we can get an idea of how this
works in terms of flow contexts:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_select_expr_list_con<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Analyze the FROM portion (if it exists).</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>  sem_select_from<span class="op">(</span>select_from_etc<span class="op">);</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>  error <span class="op">=</span> is_error<span class="op">(</span>select_from_etc<span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Push a flow context to contain improvements made via the WHERE clause that</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// will be in effect for the SELECT expression list.</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  FLOW_PUSH_CONTEXT_NORMAL<span class="op">();</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    sem_sensitive <span class="op">=</span> sem_select_where_etc<span class="op">(</span>select_from_etc<span class="op">);</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>    sem_set_improvements_for_true_condition<span class="op">(</span>where_expr<span class="op">);</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>    sem_select_expr_list<span class="op">(</span>select_expr_list<span class="op">);</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>  FLOW_POP_CONTEXT_NORMAL<span class="op">();</span></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>While very much simplified above, it can be seen that the steps are
essentially as follows:</p>
<ol type="1">
<li>Analyze the <code>FROM</code> clause.</li>
<li>Push a new normal context.</li>
<li>Analyze the <code>WHERE</code> clause.</li>
<li>Set improvements given the <code>WHERE</code> clause (ultimately by
calling <code>flow_set_flag_for_type</code>); we’ll come back to this
part shortly.</li>
<li>Analyze the expression list with the improvements from the
<code>WHERE</code> in effect.</li>
<li>Pop the context, un-setting the improvements from the
<code>WHERE</code>.</li>
</ol>
<p>This, of course, only begins to make sense once one understands what
we mean by improvements.</p>
<p>CQL, at the moment, supports two forms of improvements: nullability
improvements and initialization improvements. Both of these will be
discussed in more detail later, but the basic idea is that an
improvement upgrades the type of some value within a particular flow
context. For example, in the expression
<code>SELECT x + x FROM t WHERE x IS NOT NULL</code>, we can reason that
<code>x + x</code> can safely be given a nonnull type because of the
<code>WHERE</code> clause. This is exactly what we do in
<code>sem_select_expr_list_con</code>: We make a context to hold the
improvements that may come from the <code>WHERE</code>, analyze the
<code>WHERE</code>, set the appropriate improvements given the
<code>WHERE</code>, analyze the expression list, and then pop the
context to unset the improvements (as they must not affect any enclosing
expressions).</p>
<p>In addition to normal contexts, there are also <strong>branch
contexts</strong> and <strong>branch group contexts</strong>. These two
context types are designed to work together for handling
<code>IF</code>, <code>CASE</code>, <code>IIF</code>,
<code>SWITCH</code>, et cetera.</p>
<p>Like normal contexts, branch contexts assume that they are entered
when some condition is true. The difference is that branch contexts lie
within a branch group context, and branch groups know that <em>at
most</em> one branch of a given set of branches will be entered. A great
example of this can be found in <code>sem_if_stmt</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_if_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Each branch gets its own flow context in `sem_cond_action` where its</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// condition is known to be true. We also create one more context for the</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// entire set of branches. In addition to grouping the branches together, this</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// outer context holds all of the negative improvements that result from the</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// knowledge that, if a given branch&#39;s statements are being evaluated, all</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// previous branches&#39; conditions must have been false.</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>  FLOW_PUSH_CONTEXT_BRANCH_GROUP<span class="op">();</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// IF [cond_action]</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>  sem_cond_action<span class="op">(</span>cond_action<span class="op">);</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elseif<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    sem_elseif_list<span class="op">(</span>elseif<span class="op">);</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>elsenode<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ELSE [stmt_list]</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>    flow_set_context_branch_group_covers_all_cases<span class="op">(</span>true<span class="op">);</span></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> elsenode<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>stmt_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>      FLOW_PUSH_CONTEXT_BRANCH<span class="op">();</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>      sem_stmt_list_in_current_flow_context<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>      FLOW_POP_CONTEXT_BRANCH<span class="op">();</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>      flow_context_branch_group_add_empty_branch<span class="op">();</span></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>    record_ok<span class="op">(</span>elsenode<span class="op">);</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>  FLOW_POP_CONTEXT_BRANCH_GROUP<span class="op">();</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It’s instructive to look at <code>sem_cond_action</code> as well:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_cond_action<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [expr] THEN stmt_list</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  sem_expr<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>stmt_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    FLOW_PUSH_CONTEXT_BRANCH<span class="op">();</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Add improvements for `stmt_list` where `expr` must be true.</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    sem_set_improvements_for_true_condition<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    sem_stmt_list_in_current_flow_context<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    FLOW_POP_CONTEXT_BRANCH<span class="op">();</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>    flow_context_branch_group_add_empty_branch<span class="op">();</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If a later branch will be taken, `expr` must be false. Add its negative</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// improvements to the context created in `sem_if_stmt` so that all later</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// branches will be improved by the OR-linked spine of IS NULL checks in</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `expr`.</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>  sem_set_improvements_for_false_condition<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Putting all of this together, we can see that the basic steps for
analyzing an <code>IF</code> statement are as follows:</p>
<ol type="1">
<li>Push a new branch group context to hold all of the branch contexts
that are to come.</li>
<li>Analyze the condition in the <code>IF condition THEN</code> portion
of the statement.</li>
<li>Push a new branch context to hold the nullability improvements from
the condition (e.g., in <code>IF x IS NOT NULL THEN</code>, we can
improve <code>x</code> to have a nonnull type in the statement list
after the <code>THEN</code>).</li>
<li>Set the improvements.</li>
<li>Anaylze the statement list after the <code>THEN</code>.</li>
<li>Pop the branch context.</li>
<li>Set the <em>negative</em> improvements resulting from the knowledge
that <code>condition</code> <em>must have been false</em> if the
previous branch wasn’t entered (e.g., in
<code>IF y    IS NULL THEN</code>, we know that <code>y</code> must be
nonnull from just after the end of the branch until the end of the
current branch group).</li>
<li>Repeat for the <code>ELSE IF</code> and <code>ELSE</code> branches
(if any).</li>
<li>Pop the branch group context.</li>
</ol>
<p>What makes all of this work are the following:</p>
<ul>
<li><p>When a branch context is popped, it <em>resets all
improvements</em> such that they become exactly what they were before
the branch was analyzed. This is done to reflect the fact that, because
at most one branch will be entered, neither adding improvements (via
<code>flow_set_flag_for_type</code>) nor removing existing improvements
(via <code>flow_unset_flag_for_type</code>) in a branch should affect
any of the other branches in the group.</p></li>
<li><p>When a branch group context is popped, it <em>merges</em> the
effects of all of its branches. This is a key step that allows CQL to
retain an improvement after a branch group is popped whenever the same
improvement is made within every one of its branches <em>and</em> when
the branches given cover all possible cases (which is indicated by the
call to <code>flow_set_context_branch_group_covers_all_cases</code> in
the code above).</p></li>
</ul>
<p>The final type of context is called a <strong>jump context</strong>.
Jump contexts are a maximally pessimistic form of context that assume
every improvement that might be unset within them will be unset and that
every improvement that might be set within them will not be set. Jump
contexts are used to make semantic analysis safe in the possible
presence of control flow statements like <code>CONTINUE</code>,
<code>LEAVE</code>, and <code>THROW</code>, and so jump contexts are
used for the analysis of statements like <code>LOOP</code>,
<code>WHILE</code>, and <code>TRY</code>. Take the following
line-numbered code as an example:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="dv">001</span>  <span class="kw">DECLARE</span> x TEXT;</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="dv">002</span>  <span class="kw">SET</span> x <span class="op">:=</span> <span class="ot">&quot;foo&quot;</span>;</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="dv">003</span>  <span class="cf">WHILE</span> some_condition</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="dv">004</span>  <span class="cf">BEGIN</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="dv">005</span>    <span class="cf">IF</span> another_condition <span class="cf">THEN</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="dv">006</span>      <span class="kw">SET</span> x <span class="op">:=</span> <span class="kw">NULL</span>;</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="dv">007</span>      <span class="cf">IF</span> yet_another_condition <span class="cf">THEN</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="dv">008</span>        LEAVE;</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="dv">009</span>      <span class="cf">END</span> <span class="cf">IF</span>;</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a><span class="dv">010</span>      <span class="kw">SET</span> x <span class="op">:=</span> <span class="ot">&quot;bar&quot;</span>;</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="dv">011</span>    <span class="cf">ELSE</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a><span class="dv">012</span>      <span class="co">-- do nothing</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="dv">013</span>    <span class="cf">END</span> <span class="cf">IF</span>;</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a><span class="dv">014</span>  <span class="cf">END</span>;</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a><span class="dv">015</span>  <span class="kw">CALL</span> requires_text_notnull(x);</span></code></pre></div>
<p>Here, even though the outer <code>IF</code> makes no change overall
to the nullability improvement to <code>x</code> from line 2 – it unsets
it on line 6 and then re-sets it on line 10 and the <code>ELSE</code>
does nothing—there is no guarantee that line 10 will ever be evaluated
because we may jump straight from line 8 to line 15. As a result, it is
necessary that <code>x</code> be un-improved after the
<code>WHILE</code> loop; a normal context would not accomplish this, but
a jump context does. See the comments within
<code>_flow_push_context_branch</code> for additional discussion.</p>
<p>While jump contexts are necessary for the safety of improvements in
the presence of loops, they are not sufficient: It’s actually necessary
to analyze loops <em>twice</em>. This is because execution of a loop
might repeat, and so a statement that results in the unsetting of an
improvement later in a loop must affect improvements earlier in that
loop. For example:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> x <span class="dt">INT</span>;</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SET</span> x <span class="op">:=</span> <span class="dv">1</span>;</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="cf">WHILE</span> some_condition</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- okay on the first analysis pass, but not the second</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">CALL</span> requires_int_notnull(x);</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- must negatively affect the call on the line above</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> <span class="kw">NULL</span>;</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Semantic analysis keeps track of whether or not it is currently
reanalyzing the statement list of a loop via the
<code>current_loop_analysis_state</code> variable:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The analysis of loops like LOOP and WHILE is done in two passes. First, we</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="co">// analyze the loop to conservatively figure out every improvement that the loop</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="co">// could possibly unset. After that, we reanalyze it with said improvements</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="co">// unset to ensure that everything is safe. See `sem_stmt_list_within_loop` for</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="co">// more information on why this is necessary.</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>  LOOP_ANALYSIS_STATE_NONE<span class="op">,</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>  LOOP_ANALYSIS_STATE_ANALYZE<span class="op">,</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>  LOOP_ANALYSIS_STATE_REANALYZE</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> loop_analysis_state<span class="op">;</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Keeps tracks of the current loop analysis state. If this is equal to</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="co">// `LOOP_ANALYSIS_STATE_ANALYZE`, we are analyzing with a non-final set of</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a><span class="co">// improvements. This is useful for two reasons:</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. Procedures that perform rewrites based on improvements (e.g.,</span></span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a><span class="co">//    `sem_resolve_id_expr`) can use this to verify whether a rewrite is safe to</span></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a><span class="co">//    perform (`LOOP_ANALYSIS_STATE_NONE` or `LOOP_ANALYSIS_STATE_REANALYZE`) or</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a><span class="co">//    whether they should wait because they do not yet have definitive</span></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a><span class="co">//    information (`LOOP_ANALYSIS_STATE_ANALYZE`).</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. Analyses that would otherwise fail if called during reanalysis (e.g.,</span></span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a><span class="co">//    `sem_verify_legal_variable_name`) can use this to check whether the</span></span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a><span class="co">//    current state is `LOOP_ANALYSIS_STATE_REANALYZE` and adjust their</span></span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a><span class="co">//    behaviors accordingly.</span></span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> loop_analysis_state current_loop_analysis_state <span class="op">=</span> LOOP_ANALYSIS_STATE_NONE<span class="op">;</span></span></code></pre></div>
<p>As indicated in the first comment above, the comments within
<code>sem_stmt_list_within_loop</code> go into further detail.</p>
<p>At this point, we’ve only scratched the surface of control flow
analysis in CQL. Fortunately, the files “flow.h” and “flow.c” are
heavily commented and can be studied to deepen one’s understanding.</p>
<h3 id="nullability-improvements">Nullability Improvements</h3>
<p>Via a form of occurrence typing (also known as flow typing), CQL has
the ability to determine that, due to a prior conditional check, a
nullable variable or cursor field cannot be null within a particular
context, and CQL will improve its type in that context.</p>
<p>Unlike most forms of semantic analysis performed by CQL, the analysis
for nullability improvements, as is the case for all types of
improvements, makes heavy use of the <code>find_mutable_type</code>
function:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Returns the *mutable* type (`sem_t *`) for a given (potentially qualified)</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="co">// identifier if one exists in the environment. See the documentation for</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">// `sem_resolve_id_with_type` for limitations.</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> sem_t <span class="op">*</span>find_mutable_type<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span></code></pre></div>
<p>This function allows us to look up the type of the original binding
referred to by a particular name/scope pair. In essence, it provides
access to the current type environment for whichever part of the program
we are analyzing. It also allows us to mutate that environment by virtue
of the fact that it returns a pointer to the type of the binding, not
merely the type itself.</p>
<p>By using <code>find_mutable_type</code> to get a type pointer and
toggling the <code>SEM_TYPE_INFERRED_NOTNULL</code> flag via
<code>flow_set_flag_for_type</code> and
<code>flow_unset_flag_for_type</code>, the procedures
<code>sem_set_notnull_improved</code> and
<code>sem_unset_notnull_improved</code> are able to record that a
nullable identifier or cursor field is either temporarily nonnull or no
longer nonnull respectively:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Enables a nonnull improvement, if possible.</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_set_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="co">// This needs to be called for everything that is no longer safe to consider NOT</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL due to a mutation. It is fine to call this for something not currently</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="co">// subject to improvement, but it must only be called with a name/scope pair</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a><span class="co">// referring to something that has a mutable type (e.g., it must not be an unbound</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a><span class="co">// variable, a cursor used as an expression, an enum case, et cetera).</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_unset_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span></code></pre></div>
<p>Similarly, <code>sem_is_notnull_improved</code> uses
<code>find_mutable_type</code> to check whether or not something is
currently improved:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Returns true if currently improved to be nonnull, else false.</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_is_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span></code></pre></div>
<p>Why does nullability inference use this approach? The reason is that
the alternative would be maintaining some sort of set of currently
improved identifiers and cursor fields and checking it whenever
resolving an identifier or cursor field. The problem would be that
merely knowing that some identifier “x” is improved would not be
sufficient, however: We’d have to know <em>which</em> “x”. Is it the
local variable “x”? Is it the column “x” of the table from which we’re
currently selecting? In essence, correctly maintaining an independent
set of all currently active improvements would involve re-implementing
all of the scoping rules of the language. By using
<code>find_mutable_type</code>, we can simply piggyback on the existing
name resolution logic and avoid all of these issues.</p>
<p>A nullability improvement is always created within a particular flow
context. When an improvement is added via
<code>sem_set_notnull_improved</code>, a record of that improvement is
recorded in the current context. When that context ends, that same
record is used to remove the improvement. It is also the case that
<code>sem_unset_notnull_improved</code> may be used to remove an
improvement before a context has ended due to a <code>SET</code>,
<code>FETCH</code>, or call to a procedure or function with an
<code>OUT</code> argument resulting in the improvement no longer being
safe.</p>
<p>Improvements can be introduced into the current context via
<code>sem_set_notnull_improved</code> directly (when a variable is
<code>SET</code> to a value of a nonnull type), but more commonly they
are introduced via one of the following two functions:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Given a conditional expression `ast` possibly containing AND-linked</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">// subexpressions, set all of the applicable nullability and has-row</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="co">// improvements within the current flow context. Generally speaking, calls to</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="co">// this function should be bounded by a new flow context corresponding to the</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="co">// portion of the program for which the condition `ast` must be be true.</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_set_improvements_for_true_condition<span class="op">(</span>ast_node <span class="op">*</span>expr<span class="op">);</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Improvements for known-false conditions are dual to improvements for</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a><span class="co">// known-true conditions.</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a><span class="co">// For nullability, known-false conditions improve ids and dots verified to be</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL via `IS NULL` along the outermost spine of `OR` expressions, whereas</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="co">// known-true conditions improve ids and dots verified to be nonnull via `IS NOT</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL` along the outermost spine of `AND` expressions. For example, the</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a><span class="co">// following two statements introduce the same improvements:</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a><span class="co">//   IF a IS NOT NULL AND b IS NOT NULL THEN</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a><span class="co">//     -- `a` and `b` are improved here because we know the condition is true</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a><span class="co">//   </span><span class="re">END</span><span class="co"> IF;</span></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a><span class="co">//   IF a IS NULL OR b IS NULL RETURN;</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a><span class="co">//   -- `a` and `b` are improved here because we know the condition is false</span></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a><span class="co">//   -- since we must not have returned if we got this far</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_set_improvements_for_false_condition<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">);</span></span></code></pre></div>
<p>These functions introduce improvements by gathering up all of the
<code>IS NOT NULL</code> checks (in the true case) or
<code>IS NULL</code> checks (in the false case) and introducing
improvements appropriately. The true version is used when we enter a
context that will only be evaluated at runtime when some particular
condition is true; the false version, conversely, is used when we enter
a context that will only be evaluated at runtime when some particular
condition is false:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="cf">IF</span> some_condition <span class="cf">THEN</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- &quot;true&quot; improvements from `some_condition` are in</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- effect here</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="cf">ELSE</span> <span class="cf">IF</span> another_condition <span class="cf">THEN</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- &quot;false&quot; improvements from `some_condition` and true</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- improvements from `another_condition` are in effect</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- here</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="cf">ELSE</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>   <span class="co">-- &quot;false&quot; improvements from both `some_condition` and</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">-- `another_condition` are in effect here</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span> <span class="cf">IF</span>;</span></code></pre></div>
<p>Global variables in CQL require special treatment when it comes to
nullability improvements. This is because any procedure call could
potentially mutate any number of global variables, and so all currently
improved globals must be un-improved at every such call. The following
list keeps track of which global variables are currently improved:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> global_notnull_improvement_item <span class="op">{</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>type<span class="op">;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> global_notnull_improvement_item <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> global_notnull_improvement_item<span class="op">;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Keeps track of all global variables that may currently be improved to be NOT</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="co">// NULL. We need this because we must un-improve all such variables after every</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="co">// procedure call (because we don&#39;t do interprocedural analysis and cannot know</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="co">// which globals may have been set to NULL).</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> global_notnull_improvement_item <span class="op">*</span>global_notnull_improvements<span class="op">;</span></span></code></pre></div>
<p>The fact that we don’t do interprocedural analysis (as the comment
above indicates) is not a deficiency. Programmers should be able to
reason locally about nullability improvements, and an analysis that
depended upon the details of how other procedures were implemented would
make that impossible.</p>
<p>So far, we have talked a lot about how improvements are set and
unset, but we haven’t talked about how the improvement actually happens
in terms of code generation. Since CQL represents values of nullable and
nonnull types differently (at least in the case of non-reference types),
we cannot simply treat a value of a nullable type as though it were of a
nonnull type: We need to actually change its representation.</p>
<p>The way this works is that, whenever we resolve a name/scope pair via
<code>sem_resolve_id_expr</code>, we check whether the pair is currently
improved via <code>sem_is_notnull_improved</code>. If it is, we call
<code>rewrite_nullable_to_notnull</code> to wrap the id or dot we’re
resolving with a call to the function <code>cql_inferred_notnull</code>
(for which we generate code in
<code>cg_func_cql_inferred_notnull</code>):</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Wraps an id or dot in a call to cql_inferred_notnull.</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> rewrite_nullable_to_unsafe_notnull<span class="op">(</span>ast_node <span class="op">*</span>_Nonnull ast<span class="op">);</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co">// The `cql_inferred_notnull` function is not used by the programmer directly,</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="co">// but rather inserted via a rewrite during semantic analysis to coerce a value</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="co">// of a nullable type to be nonnull. The reason for this approach, as opposed to</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="co">// just changing the type directly, is that there are also representational</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="co">// differences between values of nullable and nonnull types; some conversion is</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="co">// required.</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_func_cql_inferred_notnull<span class="op">(</span>ast_node <span class="op">*</span>call_ast<span class="op">,</span> charbuf <span class="op">*</span>is_null<span class="op">,</span> charbuf <span class="op">*</span>value<span class="op">);</span></span></code></pre></div>
<p>As the comment for <code>cg_func_cql_inferred_notnull</code>
indicates, programmers do not use <code>cql_inferred_notnull</code>
directly: It is only inserted as a product of the above-mentioned
rewrite. In fact, we explicitly disallow its use by programmers in the
parser:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We insert calls to `cql_inferred_notnull` as part of a rewrite so we expect</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to see it during semantic analysis, but it cannot be allowed to appear in a</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="co">// program. It would be unsafe if it could: It coerces a value from a nullable</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="co">// type to a nonnull type without any runtime check.</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define YY_ERROR_ON_CQL_INFERRED_NOTNULL(x) \</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="pp">  EXTRACT_STRING(proc_name, x); \</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="pp">  if (!strcmp(proc_name, &quot;cql_inferred_notnull&quot;)) { \</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="pp">    yyerror(&quot;Call to internal function is not allowed &#39;cql_inferred_notnull&#39;&quot;); \</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="pp">  }</span></span></code></pre></div>
<p>One subtle aspect of the rewrite is that the rewrite itself performs
analysis to validate the product of the rewrite (as do other many other
rewrites). To avoid going into a loop of rewriting, analyzing the result
(which ultimately happens in
<code>sem_special_func_cql_inferred_notnull</code>), rewriting again
because the result contains a name that is improved, et cetera, we keep
track of whether or not we’re currently analyzing a subexpression under
a call to <code>cql_inferred_notnull</code> and avoid re-rewriting
appropriately:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is true if we are analyzing a call to `cql_inferred_notnull`. This can</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="co">// happen for three reasons:</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="co">// * We just did a rewrite that produced a `cql_inferred_notnull` call and now</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   we&#39;re computing its type.</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="co">// * We&#39;re analyzing an expression that was already analyzed (e.g., in a CTE).</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="co">// * We&#39;re analyzing the output of a previous CQL run within which calls to</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="co">//   `cql_inferrred_notnull` may occur.</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Regardless of the cause, if `is_analyzing_notnull_rewrite` is true, we do not</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a><span class="co">// want to rewrite again.</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t is_analyzing_notnull_rewrite<span class="op">;</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_special_func_cql_inferred_notnull<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> <span class="dt">uint32_t</span> arg_count<span class="op">,</span> bool_t <span class="op">*</span>is_aggregate<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Since we&#39;re checking a call to `cql_inferred_notnull`, its arguments have</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// already been rewritten and we don&#39;t want to do it again. Setting</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `is_analyzing_notnull_rewrite` prevents that.</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>  is_analyzing_notnull_rewrite <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>  sem_arg_list<span class="op">(</span>arg_list<span class="op">,</span> IS_NOT_COUNT<span class="op">);</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>  is_analyzing_notnull_rewrite <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a><span class="co">// Like `sem_resolve_id`, but specific to expression contexts (where nullability</span></span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a><span class="co">// improvements are applicable).</span></span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_resolve_id_expr<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> CSTR name<span class="op">,</span> CSTR scope<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_analyzing_notnull_rewrite<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we&#39;re analyzing the product of a rewrite and we&#39;re already inside of a</span></span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// call to `cql_inferred_notnull`, do not expand again.</span></span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// forever.</span></span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At this point, you should have a decent understanding of how
nullability improvements function, both in terms of semantic analysis
and in terms of code generation. The implementation is heavily
commented, so reading the code and searching for calls to the core
functions listed below should be sufficient to fill in any gaps:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>bool_t sem_is_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_set_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_unset_notnull_improved<span class="op">(</span>CSTR name<span class="op">,</span> CSTR scope<span class="op">);</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_unset_global_notnull_improvements<span class="op">();</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_set_improvements_for_true_condition<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">);</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_set_improvements_for_false_condition<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">);</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sem_special_func_cql_inferred_notnull<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> <span class="dt">uint32_t</span> arg_count<span class="op">,</span> bool_t <span class="op">*</span>is_aggregate<span class="op">)</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rewrite_nullable_to_unsafe_notnull<span class="op">(</span>ast_node <span class="op">*</span>_Nonnull ast<span class="op">);</span></span></code></pre></div>
<h3 id="initialization-improvements">Initialization Improvements</h3>
<p>Compared to nullability improvements, initialization improvements are
relatively simple.</p>
<p>The idea behind initialization improvements is that, if one declares
a variable of a reference type (<code>BLOB</code>, <code>OBJECT</code>,
or <code>TEXT</code>) that is also <code>NOT NULL</code>, it is not safe
to use the variable until it has been given a value. For example:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> x TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="cf">IF</span> some_condition <span class="cf">THEN</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> some_text_notnull_value;</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- `x` is safe to use here</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="cf">ELSE</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- `x` is NOT safe to use here (it might be uninitialized)</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span> <span class="cf">IF</span>;</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- `x` is NOT safe to use here either (it might be uninitialized)</span></span></code></pre></div>
<p>As with nullability improvements, initialization improvements rely
heavily on flow contexts. The function
<code>sem_set_initialization_improved</code>, similarly to
<code>sem_set_notnull_improved</code> for nullability, is used to enable
an initialization improvement. (There is nothing analogous to
<code>sem_unset_notnull_improved</code> for initialization because
nothing can ever be uninitialized once it has been given a value.)</p>
<p>Unlike nullability improvements, initialization improvements use
<em>two</em> flags: <code>SEM_TYPE_INIT_REQUIRED</code> and
<code>SEM_TYPE_INIT_COMPLETE</code>. Rather than assuming everything is
uninitalized by default and requiring the presence of some
<code>SEM_TYPE_INITIALIZED</code> flag before anything can be used, we
explicitly tag things that are not initialized but need to be with
<code>SEM_TYPE_INIT_REQUIRED</code> and later tag them with
<code>SEM_TYPE_INIT_COMPLETE</code> once they’ve been initialized. Doing
it in this way has two benefits:</p>
<ol type="1">
<li><p>It reduces the amount of noise in the AST output significantly:
Code like <code>LET x := 10;</code> can remain
<code>{let_stmt}: x: integer notnull variable</code> in the AST without
the need of the extra noise of some <code>initialized</code>
flag.</p></li>
<li><p>More importantly, it means we only have to deal with
initialization in a tiny portion of “sem.c”. For example, we must handle
it in <code>sem_declare_vars_type</code> to add the
<code>SEM_TYPE_INIT_REQUIRED</code> flag and in <code>sem_assign</code>
to add <code>SEM_TYPE_INIT_COMPLETE</code>, but
<code>sem_let_stmt</code> can remain blissfully ignorant of
initialization altogether.</p></li>
</ol>
<p>There are only three places in which a variable may be initialized:
<code>sem_assign</code> (as mentioned), <code>sem_fetch_stmt</code> (for
the <code>FETCH...INTO</code> form), and
<code>sem_arg_for_out_param</code> (as passing a variable to a procedure
requiring an <code>OUT</code> argument of a <code>NOT NULL</code> type
can initialize it).</p>
<p>Regarding <code>sem_arg_for_out_param</code>, we can only set
initialization improvements when a variable is passed as an
<code>OUT</code> argument because we require that all procedures
initialize all of their <code>OUT</code> parameters of a nonnull
reference type. This is handled in two places:</p>
<ol type="1">
<li><p>In <code>sem_param</code>, we set the
<code>SEM_TYPE_INIT_REQUIRED</code> flag when
<code>param_should_require_initialization</code> is true.</p></li>
<li><p>In <code>sem_validate_current_proc_params_are_initialized</code>,
which is called both after analyzing the statement list of a procedure
and for each return statement within the procedure, we ensure that
<code>SEM_TYPE_INIT_COMPLETE</code> is present on all parameters that
have <code>SEM_TYPE_INIT_REQUIRED</code>.</p></li>
</ol>
<p>There is only one wrinkle in all of this: the
<code>cql:try_is_proc_body</code> attribute. If
<code>cql:try_is_proc_body</code> is present on a <code>TRY</code>
statement, we call
<code>sem_validate_current_proc_params_are_initialized</code> at the end
of the <code>TRY</code> and <em>not</em> at the end of the procedure.
The rationale for this is explained thoroughly in the comments for
<code>sem_find_ast_misc_attr_trycatch_is_proc_body_callback</code>.</p>
<p>That’s all there is to it: “flow.c” does most of the hard work for
us.</p>
<h3 id="structure-types-and-the-notion-of-shapes">Structure types and
the notion of Shapes</h3>
<p>Earlier we discussed <code>SEM_TYPE_STRUCT</code> briefly. Recall the
basic notion of the <code>structure</code> type:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for tables and views and the result of a select</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_struct <span class="op">{</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  CSTR struct_name<span class="op">;</span>               <span class="co">// struct name</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of fields</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// field names</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>kinds<span class="op">;</span>                    <span class="co">// the &quot;kind&quot; text of each column, if any, e.g. integer&lt;foo&gt; foo is the kind</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  sem_t <span class="op">*</span>semtypes<span class="op">;</span>                <span class="co">// typecode for each field</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_struct<span class="op">;</span></span></code></pre></div>
<p>The structure is nothing more than an array of names, types and kinds
with a count. But it creates the notion of what’s usually called a
“shape” in the codebase. Shapes can be used in a variety of ways as is
described in <a
href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms">Chapter
5</a> of the CQL Guide. But before we get into shapes, let’s look at an
example of how a structure type is created.</p>
<p>The code that follows is the back end of
<code>sem_create_table_stmt</code>. At this point the bulk of the
analysis is done and the columns all have their types. We’re about to
build the struct type for the table. Let’s see how that goes.</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// now create a struct type with the correct number of columns</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the types have already been computed so all we have to do is</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// check for duplicates</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  sem_struct <span class="op">*</span>sptr <span class="op">=</span> new_sem_struct<span class="op">(</span>name<span class="op">,</span> cols<span class="op">);</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>columns <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>ast_node <span class="op">*</span>item <span class="op">=</span> col_key_list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>is_ast_col_key_list<span class="op">(</span>item<span class="op">));</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>def<span class="op">,</span> item<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_col_def<span class="op">(</span>def<span class="op">))</span> <span class="op">{</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>col <span class="op">&lt;=</span> cols<span class="op">);</span>  <span class="co">// it&#39;s possible that the rest are deleted and we&#39;re at the end.</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">// columns must be unique, including deleted columns</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(!</span>symtab_add<span class="op">(</span>columns<span class="op">,</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">,</span> NULL<span class="op">))</span> <span class="op">{</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>        EXTRACT_NOTNULL<span class="op">(</span>col_def_type_attrs<span class="op">,</span> def<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>        EXTRACT_NOTNULL<span class="op">(</span>col_def_name_type<span class="op">,</span> col_def_type_attrs<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>        EXTRACT_ANY_NOTNULL<span class="op">(</span>col_def_ast<span class="op">,</span> col_def_name_type<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>        report_error<span class="op">(</span>col_def_ast<span class="op">,</span> <span class="st">&quot;CQL0142: duplicate column name&quot;</span><span class="op">,</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>        symtab_delete<span class="op">(</span>columns<span class="op">);</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> cleanup<span class="op">;;</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>is_deleted<span class="op">(</span>def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>      Invariant<span class="op">(</span>col <span class="op">&lt;</span> cols<span class="op">);</span></span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>names<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">;</span></span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>semtypes<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>      sptr<span class="op">-&gt;</span>kinds<span class="op">[</span>col<span class="op">]</span> <span class="op">=</span> def<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>kind<span class="op">;</span></span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>      col<span class="op">++;</span></span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>  symtab_delete<span class="op">(</span>columns<span class="op">);</span></span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(</span>col <span class="op">==</span> cols<span class="op">);</span></span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_STRUCT<span class="op">);</span></span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr <span class="op">=</span> sptr<span class="op">;</span></span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>jptr <span class="op">=</span> sem_join_from_sem_struct<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region <span class="op">=</span> current_region<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>new_sem_struct</code> : makes a struct to hold the result, we
already have the count of columns and the table name</li>
<li><code>symtab_new</code> : is going to give us a scratch symbol table
so we can check for duplicate column names</li>
<li>we walk all the items in the table and use
<code>is_ast_col_def(def)</code> to find the column definitions</li>
<li><code>Invariant(def-&gt;sem-&gt;name)</code> : claims that we must
have already computed the semantic info for the column and it has its
name populated
<ul>
<li>this was done earlier</li>
</ul></li>
<li><code>symtab_add(columns, def-&gt;sem-&gt;name, NULL)</code> : adds
a nil entry under the column name – if this fails we have a duplicate
column,
<ul>
<li>in which case we report errors and stop</li>
</ul></li>
<li><code>is_deleted</code> : tells us if the column was marked with
<code>@delete</code> in which case it no longer counts as part of the
table</li>
<li>if all this is good we set the <code>names</code>,
<code>kinds</code>, and <code>semtypes</code> from the column
definition’s semantic info</li>
<li><code>symtab_delete</code> : cleans up the temporary symbol
table</li>
<li><code>new_sem</code> : creates a <code>sem_node</code> of type
<code>SEM_TYPE_STRUCT</code> which is filled in
<ul>
<li><code>sem_join_from_sem_struct</code> will be discussed shortly, but
it creates a <code>jptr</code> with one table in it</li>
</ul></li>
</ul>
<p>Structure types often come from the shape of a table, but other
things can create a structure type. For instance, the columns of a view,
or any select statement, are also described by a structure type and are
therefore valid “shapes”. The return type of a procedure usually comes
from a <code>SELECT</code> statement, so the procedure too can be the
source of a shape. The arguments of a procedure form a shape. The fields
of a cursor form a shape. You can even have a named subset of the
arguments of a procedure and use them like a shape. All of these things
are described by structure types.</p>
<h4 id="shapes-and-the-like-construct">Shapes and the LIKE
construct</h4>
<p>There are many cases where you want to be able to capture or re-use
something with a known shape and you don’t want to have to fully
re-declare the thing. CQL uses the <code>LIKE</code> construct to do
these sorts of things. This is more fully explained in <a
href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms">Chapter
5</a> of the Guide, but for now let’s look at two different cases that
are of interest.</p>
<p>First, a cursor:</p>
<pre><code>DECLARE C CURSOR LIKE Foo;  -- Foo something with a shape</code></pre>
<p>So, in the above, Foo could be a table, a view, a procedure with a
result, another cursor, and so forth.</p>
<p>How might we do this? This is the business of
<code>sem_declare_cursor_like_name</code></p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we&#39;re going to make a new value cursor using the indicated name for the shape.</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="co">// The name has to be &quot;likeable&quot; meaning it refers to some named thing with a shape</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="co">// such as a table, a view, another cursor, or a procedure that returns a result set.</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co">// These are the so called &quot;value cursors&quot; in that they have no underlying statement</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="co">// that they move through.  You can just load them up with a row and pass them around.</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_declare_cursor_like_name<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_declare_cursor_like_name<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>new_cursor_ast<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>new_cursor_name<span class="op">,</span> new_cursor_ast<span class="op">);</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>shape_def<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// no duplicates allowed</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>sem_verify_legal_variable_name<span class="op">(</span>ast<span class="op">,</span> new_cursor_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>new_cursor_ast<span class="op">);</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// must be a valid shape</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>found_shape <span class="op">=</span> sem_find_shape_def<span class="op">(</span>shape_def<span class="op">,</span> LIKEABLE_FOR_VALUES<span class="op">);</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>found_shape<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// good to go, make our cursor, with storage.</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>  shape_def<span class="op">-&gt;</span>sem <span class="op">=</span> found_shape<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_STRUCT <span class="op">|</span> SEM_TYPE_VARIABLE <span class="op">|</span> SEM_TYPE_VALUE_CURSOR <span class="op">|</span> SEM_TYPE_HAS_SHAPE_STORAGE<span class="op">);</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr <span class="op">=</span> found_shape<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr<span class="op">;</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>  new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name <span class="op">=</span> new_cursor_name<span class="op">;</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_cursor_ast<span class="op">-&gt;</span>sem<span class="op">;</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>  symtab_add<span class="op">(</span>current_variables<span class="op">,</span> new_cursor_name<span class="op">,</span> new_cursor_ast<span class="op">);</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>EXTRACT</code> : gets the pieces we need from the AST</li>
<li><code>sem_verify_legal_variable_name</code> : makes sure the cursor
name is unique and doesn’t hide a table name</li>
<li><code>sem_find_shape_def</code> : searches for something with a
suitable name that has a shape</li>
<li>we populate the name node with the semantic type that we found</li>
<li><code>new_sem</code> : makes a new <code>sem_node</code> for the
cursor variable with <code>SEM_TYPE_STRUCT</code>
<ul>
<li>set the <code>sptr</code> field using the discovered shape</li>
</ul></li>
</ul>
<p>Note: <code>name_ast-&gt;sem</code> isn’t actually used for anything
but it is helpful for debugging. If the AST is printed it shows the
original unmodified semantic type which can be helpful.</p>
<p>Briefly <code>sem_find_shape_def</code> does these steps:</p>
<ul>
<li>if the right of the <code>LIKE</code> refers to procedure arguments
(e.g. C LIKE Foo ARGUMENTS), get the args of the named procedure and use
them as a shape</li>
<li>if the right is a local or global, and its a cursor, use the shape
of that cursor for the new cursor</li>
<li>if the right is the name of an argument bundle, use the shape of the
bundle
<ul>
<li>e.g. in <code>CREATE PROC Foo(p1 like Person, p2 like Person)</code>
<code>p1</code> and <code>p2</code> are the names of argument bundles
shaped like <code>Person</code></li>
</ul></li>
<li>if the right is the name of a table or view, use that shape</li>
<li>if the right is the name of a procedure with a structure result, use
that shape</li>
<li>if it’s none of these, produce an error</li>
</ul>
<p>This is the primary source of shape reuse. Let’s look at how we might
use that.</p>
<p>Suppose we want to write a procedure that inserts a row into the
table <code>Foo</code>, we could certainly list the columns of
<code>Foo</code> as arguments like this:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC InsertIntoFoo(<span class="kw">id</span> <span class="dt">integer</span>, t text, r <span class="dt">real</span>, b <span class="dt">blob</span>)</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">INSERT</span> <span class="kw">INTO</span> Foo(<span class="kw">id</span>, t, r, b) <span class="kw">VALUES</span>(<span class="kw">id</span>, t, r, b);</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>But that approach is going to get a lot less exciting when there are
lots of columns and it will be increasingly a maintenance headache.</p>
<p>Compare that with the following:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC InsertIntoFoo(<span class="kw">row</span> <span class="kw">LIKE</span> Foo)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">INSERT</span> <span class="kw">INTO</span> Foo <span class="kw">FROM</span> <span class="kw">row</span>;</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Those two versions of <code>InsertIntoFoo</code> compile into the
same code. The semantic analyzer expands the <code>(row LIKE Foo)</code>
into <code>(row_id integer, row_t text, row_r real, row_b blob)</code>
and then replaces <code>FROM row</code> with
<code>(row_id, row_t, row_r, row_b)</code>. In both case it simply
looked up the shape using <code>sem_find_shape_def</code> and then
altered the AST to the canonical pattern. This kind of “shape sugar” is
all over CQL and greatly increases maintainability while eliminating
common errors. The most common operation is simply to expland a “shape”
into a list of arguments or columns (maybe with or without type names).
SQLite doesn’t know any of this shape magic so by the time SQLite sees
the code it has to look “normal” – the shapes are all resolved.</p>
<h3 id="join-types">Join Types</h3>
<p>The last of the type building data structure is the join type. Recall
that we have this shape:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for the data type of (parts of) the FROM clause</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="co">// sometimes I refer to as a &quot;joinscope&quot;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> sem_join <span class="op">{</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count<span class="op">;</span>                 <span class="co">// count of table/views in the join</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>  CSTR <span class="op">*</span>names<span class="op">;</span>                    <span class="co">// names of the table/view</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> sem_struct <span class="op">**</span>tables<span class="op">;</span>     <span class="co">// struct type of each table/view</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> sem_join<span class="op">;</span></span></code></pre></div>
<p>This is an array of named structure types, which is exactly what you
get when you do something like this:</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="op">*</span> <span class="kw">from</span> T1 <span class="kw">INNER</span> <span class="kw">JOIN</span> T2;</span></code></pre></div>
<p>The result has all of the columns of <code>T1</code> and all of the
columns of <code>T2</code>. They can be referred to with scoped names
like <code>T1.x</code> which means “find the <code>sptr</code>
corresponding to the name <code>T1</code> then within that structure
find the column named <code>x</code>”. In general, when we join, we take
a <code>jptr</code> on the left and concatenate it with a
<code>jptr</code> on the right. For all this to work we have to start
somewhere, usually single tables.</p>
<p>As we saw when we make a table we use
<code>sem_join_from_sem_struct</code> to make its initial
<code>jptr</code>. Let’s have a look at that now:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a base join type from a single struct.</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> sem_join <span class="op">*</span>sem_join_from_sem_struct<span class="op">(</span>sem_struct <span class="op">*</span>sptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>  sem_join <span class="op">*</span>jptr <span class="op">=</span> new_sem_join<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>  jptr<span class="op">-&gt;</span>names<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> sptr<span class="op">-&gt;</span>struct_name<span class="op">;</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>  jptr<span class="op">-&gt;</span>tables<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> new_sem_struct_strip_table_flags<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> jptr<span class="op">;</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It doesn’t get much simpler than the above, here are the steps
briefly:</p>
<ul>
<li><code>new_sem_join</code> : gives us an empty <code>sem_join</code>
with room for 1 table</li>
<li>we use the struct name for the name and the table’s
<code>sptr</code> for the shape</li>
<li><code>new_sem_struct_strip_table_flags</code> : copies the table’s
<code>sptr</code> keeping only the essential flags
<ul>
<li><code>SEM_TYPE_HIDDEN_COL</code></li>
<li><code>SEM_FLAG_NOTNULL</code></li>
<li><code>SEM_FLAG_SENSITIVE</code></li>
</ul></li>
</ul>
<p>The other flags (e.g. <code>SEM_TYPE_PK</code>) have no value in
doing type checking and were only needed to help validate the table
itself. Those extra flags would be harmless but they would also
contaminate all of the debug output, so they are stripped. As a result
the type of columns as they appear in say <code>SELECT</code> statements
is simpler than how they appear in a <code>CREATE TABLE</code>
statement.</p>
<p>When we need to create a new join type we simply (*) make a new
<code>sem_join</code> that is the concatenation of the left and right
sides of the join operation.</p>
<ul>
<li>some join types change the nullability of columns like
<code>LEFT JOIN</code>, so we have to handle that too</li>
<li>the names of the tables in the new concatenated joinscope have to be
unambiguous so there is also error checking to do</li>
<li>but basically it’s just a concatenation</li>
</ul>
<p>Importantly, we call the thing a “joinscope” because it creates a
namespace. When we are evaluating names inside of the <code>FROM</code>
clause or even later in, say, a <code>WHERE</code> clause, the joinscope
that we have created so far controls the <code>table.column</code>
combinations that you can use in expressions. This changes again when
there is a subquery, so the joinscopes can be pushed and popped as
needed.</p>
<p>By way of example, you’ll see these two patterns in the code:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>  PUSH_JOIN<span class="op">(</span>from_scope<span class="op">,</span> select_from_etc<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>jptr<span class="op">);</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>  error <span class="op">=</span> sem_select_orderby<span class="op">(</span>select_orderby<span class="op">);</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  POP_JOIN<span class="op">();</span></span></code></pre></div>
<ul>
<li><code>PUSH_JOIN</code> : use the <code>jptr</code> from the
<code>FROM</code> clause to put things back in scope for the
<code>ORDER BY</code> clause</li>
</ul>
<div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>  PUSH_JOIN_BLOCK<span class="op">();</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>  sem_numeric_expr<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> ast<span class="op">,</span> <span class="st">&quot;LIMIT&quot;</span><span class="op">,</span> SEM_EXPR_CONTEXT_LIMIT<span class="op">);</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  POP_JOIN<span class="op">();</span></span></code></pre></div>
<ul>
<li><code>PUSH_JOIN_BLOCK</code> : causes the name search to stop –
nothing deeper in the stack is searched</li>
<li>in this case we do not allow <code>LIMIT</code> expressions to see
any joinscopes, as they may not use any columns
<ul>
<li>even if the <code>LIMIT</code> clause is appearing in a subquery it
can’t refer to columns in the parent query</li>
</ul></li>
</ul>
<h3 id="schema-regions">Schema Regions</h3>
<p>We touched briefly on schema regions earlier in this section. The
purpose and language for regions is described more fully in <a
href="https://cgsql.dev/cql-guide/ch10#schema-regions">Chapter 10</a> of
the Guide. In this section we’ll deal with how they are implemented and
what you should expect to see in the code.</p>
<p>When a region declaration is found this method is used:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co">// A schema region is an partitioning of the schema such that it</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="co">// only uses objects in the same partition or one of its declared</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="co">// dependencies.  One schema region may be upgraded independently</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="co">// from any others (assuming they happen such that dependents are done first).</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we validate:</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the region name is unique</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="co">//  * the dependencies (if any) are unique and exist</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_declare_schema_region_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span>  <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>The general rules are described in the comment, but effectively it
accumulates the list of the declared region’s dependencies. Sometimes
these are called the antecedent regions. Since a region can only depend
on regions that have already been declared, it’s not possible to make
any cycles. Regions are declared before you put anything into them.</p>
<p>Pieces of schema or procedures (or anything really) can go into a
region by putting that code inside a begin/end pair for the named
region. Like so:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="ot">@begin_schema_region your_region;</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- your stuff</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="ot">@end_schema_region;</span></span></code></pre></div>
<p>Now whatever happens to be in “your stuff” is:</p>
<ul>
<li>limited to seeing only the things that <code>your_region</code> is
allowed to see, and</li>
<li>contributes its contents to <code>your_region</code> thereby
limiting how others will be able to use “your stuff”</li>
</ul>
<p>To see how this happens, let’s have a look at
<code>sem_begin_schema_region_stmt</code>.</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Entering a schema region makes all the objects that follow part of that</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="co">// region.  It also means that all the contained objects must refer to</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="co">// only pieces of schema that are in the same region or a dependent region.</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Here we validate that region we are entering is in fact a valid region</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="co">// and that there isn&#39;t already a schema region.</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> sem_begin_schema_region_stmt<span class="op">(</span>ast_node <span class="op">*</span> ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_begin_schema_region_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// @BEGIN_SCHEMA_REGION name</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>verify_schema_region_out_of_proc<span class="op">(</span>ast<span class="op">))</span> <span class="op">{</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>current_region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">,</span> <span class="st">&quot;CQL0246: schema regions do not nest; end the current region before starting a new one&quot;</span><span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>region <span class="op">=</span> find_region<span class="op">(</span>name<span class="op">);</span></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>    report_error<span class="op">(</span>ast<span class="op">-&gt;</span>left<span class="op">,</span> <span class="st">&quot;CQL0244: unknown schema region&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>    record_error<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Get the canonical name of the region (case adjusted)</span></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_region<span class="op">(</span>region<span class="op">));</span></span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>region_name<span class="op">,</span> region<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// we already know we are not in a region</span></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>  Invariant<span class="op">(!</span>current_region_image<span class="op">);</span></span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>  current_region_image <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>  sem_accumulate_public_region_image<span class="op">(</span>current_region_image<span class="op">,</span> region_name<span class="op">);</span></span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this is the one and only text pointer value for this region</span></span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a>  current_region <span class="op">=</span> region_name<span class="op">;</span></span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>  record_ok<span class="op">(</span>ast<span class="op">);</span></span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We see these basic steps:</p>
<ul>
<li><code>EXTRACT</code> : gets the region name</li>
<li><code>verify_schema_region_out_of_proc</code> : makes sure we are
out of any procedure (we have to be at the top level)
<ul>
<li>errors if in a procedure</li>
</ul></li>
<li><code>current_region</code> : is tested to make sure we are not
already in a region (no nesting)
<ul>
<li>errors if already in a region</li>
</ul></li>
<li><code>find_region</code> : is used to find the region AST by name
<ul>
<li>errors if the region name isn’t valid</li>
</ul></li>
<li><code>EXTRACT</code> : is used again to get the canonical name of
the region
<ul>
<li>you could write <code>@begin_schema_region YoUr_ReGION;</code> but
we want the canonical name <code>your_region</code>, as it was
declared</li>
</ul></li>
<li><code>symtab_new</code> : creates a new symbol table
<code>current_region_image</code></li>
<li><code>sem_accumulate_public_region_image</code> : populates
<code>current_region_image</code> by recursively walking this region
adding the names of all the regions we find along the way
<ul>
<li>note the regions form a DAG so we might find the same name twice; we
can stop if we find a region that is already in the image symbol
table</li>
</ul></li>
<li><code>current_region</code> : set it to the now new current
region</li>
</ul>
<p>Now we’re all set up.</p>
<ul>
<li>We can use <code>current_region</code> to set the
<code>region</code> in the <code>sem_node</code> of anything we
encounter</li>
<li>We can use <code>current_region_image</code> to quickly see if we
are allowed to use any given region
<ul>
<li>if it’s in the symbol table we can use it</li>
</ul></li>
</ul>
<p>Recall that at the end of <code>sem_create_table_stmt</code> we do
this:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem <span class="op">=</span> new_sem<span class="op">(</span>SEM_TYPE_STRUCT<span class="op">);</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sptr <span class="op">=</span> sptr<span class="op">;</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>jptr <span class="op">=</span> sem_join_from_sem_struct<span class="op">(</span>sptr<span class="op">);</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>  ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region <span class="op">=</span> current_region<span class="op">;</span></span></code></pre></div>
<p>That should make a lot more sense now.</p>
<p>When doing the symmetric check in
<code>sem_validate_object_ast_in_current_region</code> we see this
pattern:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Validate whether or not an object is usable with a schema region. The object</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="co">// can only be a table, view, trigger or index.</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> bool_t sem_validate_object_ast_in_current_region<span class="op">(</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>  CSTR name<span class="op">,</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>table_ast<span class="op">,</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>err_target<span class="op">,</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>  CSTR msg<span class="op">)</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We&#39;re in a non-region therefore no validation needed because non-region stmt</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// can reference schema in any region.</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>current_region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>table_ast<span class="op">-&gt;</span>sem <span class="op">&amp;&amp;</span> table_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if we have a current region then the image is always computed!</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>current_region_image<span class="op">);</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>symtab_find<span class="op">(</span>current_region_image<span class="op">,</span> table_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region<span class="op">))</span> <span class="op">{</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>      <span class="co">// The target region is not accessible from this region</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// while in schema region &#39;%s&#39;, accessing an object that isn&#39;t in a region is invalid</span></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I’ve elided some of the code here, but only the part that generates
error messages. The essential logic is:</p>
<ul>
<li>if we are not in a region we can access anything</li>
<li>if we’re in a region then…
<ul>
<li>the thing we’re trying to access must also be in a region, and</li>
<li>that region must be in <code>current_region_image</code></li>
<li>otherwise, we can’t access it</li>
</ul></li>
</ul>
<p>This is enough to do all the region validation we need.</p>
<h3 id="results-of-semantic-analysis">Results of Semantic Analysis</h3>
<p>Semantic Analysis leaves a lot of global state ready for the
remaining stages to harvest. If the state is defined in
<code>sem.h</code> then it’s ok to harvest. Here we’ll highlight some of
the most important things you can use in later passes. These are heavily
used in the code generators.</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_tables_list <span class="op">);</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_functions_list <span class="op">);</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_views_list <span class="op">);</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_indices_list <span class="op">);</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_triggers_list <span class="op">);</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_regions_list <span class="op">);</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_ad_hoc_list <span class="op">);</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_select_functions_list <span class="op">);</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="kw">struct</span> list_item <span class="op">*</span>all_enums_list <span class="op">);</span></span></code></pre></div>
<p>These linked lists are authoritiative; they let you easily enumerate
all the objects of the specified type. For instance, if you wanted to do
some validation of all indices, you could simply walk
<code>all_indices_list</code>.</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>cql_noexport ast_node <span class="op">*</span>find_proc<span class="op">(</span>CSTR name<span class="op">);</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>cql_noexport ast_node <span class="op">*</span>find_region<span class="op">(</span>CSTR name<span class="op">);</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>cql_noexport ast_node <span class="op">*</span>find_func<span class="op">(</span>CSTR name<span class="op">);</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>cql_noexport ast_node <span class="op">*</span>find_table_or_view_even_deleted<span class="op">(</span>CSTR name<span class="op">);</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>cql_noexport ast_node <span class="op">*</span>find_enum<span class="op">(</span>CSTR name<span class="op">);</span></span></code></pre></div>
<p>These functions give you access to the core name tables (which are
still valid!) so that you can look up procedures, functions, tables,
etc. by name.</p>
<p>Finally, information about all the schema annotations is invaluable
for building schema upgraders. These two buffers hold dense arrays of
annotation records as shown below.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> bytebuf <span class="op">*</span>schema_annotations <span class="op">);</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> bytebuf <span class="op">*</span>recreate_annotations <span class="op">);</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> recreate_annotation <span class="op">{</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  CSTR target_name<span class="op">;</span>               <span class="co">// the name of the target</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>  CSTR group_name<span class="op">;</span>                <span class="co">// group name or &quot;&quot; if no group (not null, safe to sort)</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>target_ast<span class="op">;</span>           <span class="co">// top level target (table, view, or index)</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>annotation_ast<span class="op">;</span>       <span class="co">// the actual annotation</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> ordinal<span class="op">;</span>                <span class="co">// when sorting we want to use the original order (reversed actually) within a group</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> recreate_annotation<span class="op">;</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> schema_annotation <span class="op">{</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> version<span class="op">;</span>                <span class="co">// the version number (always &gt; 0)</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>target_ast<span class="op">;</span>           <span class="co">// top level target (table, view, or index)</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>  CSTR target_name<span class="op">;</span>               <span class="co">// the name of the target</span></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> annotation_type<span class="op">;</span>       <span class="co">// one of the codes below for the type of annotation</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>annotation_ast<span class="op">;</span>       <span class="co">// the actual annotation</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> column_ordinal<span class="op">;</span>         <span class="co">// -1 if not a column</span></span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>column_ast<span class="op">;</span>           <span class="co">// a particular column if column annotation</span></span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> schema_annotation<span class="op">;</span></span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: schema annotations are processed in the indicated order: the numbers matter!</span></span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_INVALID 0</span></span>
<span id="cb106-24"><a href="#cb106-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_FIRST 1</span></span>
<span id="cb106-25"><a href="#cb106-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_UNSUB 1</span></span>
<span id="cb106-26"><a href="#cb106-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_CREATE_TABLE 2</span></span>
<span id="cb106-27"><a href="#cb106-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_CREATE_COLUMN 3</span></span>
<span id="cb106-28"><a href="#cb106-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_DELETE_TRIGGER 4</span></span>
<span id="cb106-29"><a href="#cb106-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_DELETE_VIEW 5</span></span>
<span id="cb106-30"><a href="#cb106-30" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_DELETE_INDEX 6</span></span>
<span id="cb106-31"><a href="#cb106-31" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_DELETE_COLUMN 7</span></span>
<span id="cb106-32"><a href="#cb106-32" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_DELETE_TABLE 8</span></span>
<span id="cb106-33"><a href="#cb106-33" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_AD_HOC 9</span></span>
<span id="cb106-34"><a href="#cb106-34" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_RESUB 10</span></span>
<span id="cb106-35"><a href="#cb106-35" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_ANNOTATION_LAST 10</span></span></code></pre></div>
<p>And of course, each “back end” is provided with the root of the AST
so that it can also search and/or walk the AST in its own manner. We
will see examples of this in later sections.</p>
<h3 id="recap">Recap</h3>
<p>At present, there are nearly 20000 lines in <code>sem.c</code> and it
would no doubt take more than 20000 lines of text to explain what they
all do, and that would be more imprecise than the source code, and
probably less readable. <code>sem.c</code> includes over 4000 lines of
comments, and probably should have more. While there is a lot of code
there, it’s very readable and I encourage you to do just that – read it
– to get your answers.</p>
<p>The point of this part of the Internals Guide isn’t to fully explain
all 400+ error checks in about as many semantic error checking
functions, it is to showcase the key concepts shared by all of them.
Things like:</p>
<ul>
<li>errors are reported largely in the AST and percolate up</li>
<li>expressions and statements have general purpose dispatch logic for
continuing a statement walk</li>
<li><code>EXTRACT</code> macros are used to keep the tree walk on track
and correct in the face of changes</li>
<li>regions are used for visibility</li>
<li>versioning contributes to visibility</li>
<li>nullability and sensitivity are tracked throughout using type
bits</li>
<li>type “kind” is managed by a simple string in the
<code>sem_node</code> payload</li>
<li>the three main payloads are
<ul>
<li><code>sem_node</code> for basic info, and</li>
<li><code>sem_struct</code> or <code>sem_join</code> for the non-unitary
types</li>
</ul></li>
</ul>
<p>This isn’t everything but it should leave you well armed to begin
your own exploration of <code>sem.c</code>.</p>
<p>Note: details on unsub/resub are forthcoming. This code is under
development.</p>
<h2 id="part-3-c-code-generation">Part 3: C Code Generation</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-2">Preface</h3>
<p>Part 3 continues with a discussion of the essentials of the C code
generation pass of the CQL compiler. As in the previous sections, the
goal here is not to go over every detail of code generation but rather
to give a sense of how codegen happens in general – the core strategies
and implementation choices – so that when reading the code you will have
an idea how smaller pieces would fit into the whole. To accomplish this,
various key data structures will be explained in detail as well as
selected examples of their use.</p>
<h2 id="c-code-generation">C Code Generation</h2>
<p>There are several key pieces of C code that we have to generate to
make working CQL procedures using C functions. This all happens in
<code>cg_c.c</code>. From a big picture perspective, these are the
essential problems:</p>
<ul>
<li>we have to compile SQL expressions into C
<ul>
<li>including expressions with variables that are nullable</li>
<li>including SQL expressions that are highly complex like
<code>CASE..WHEN..THEN..END</code> and <code>IN (..)</code></li>
</ul></li>
<li>we have to generate control flow for things like <code>IF</code>,
<code>WHILE</code> and, <code>SWITCH</code></li>
<li>we have to make result sets
<ul>
<li>including the code to slurp up all the rows from a SQL statement
into an array of values</li>
<li>we want to do this very economically</li>
</ul></li>
<li>we have to be able to create the text for every SQLite statement and
bind any variables to it</li>
<li>we have to check every SQLite API for errors and throw exceptions
consistently and deal with them
<ul>
<li>including constructs that allow users to handle exceptions, such as
<code>TRY/CATCH</code></li>
</ul></li>
<li>we have to track any reference types carefully so that
retain/release pairs are done consistently
<ul>
<li>even in the presence of SQLite errors or other exceptions</li>
</ul></li>
<li>we have to produce a <code>.h</code> and a <code>.c</code> file for
the C compiler
<ul>
<li>contributions to these files could come from various places, not
necessarily in order</li>
<li>the <code>.c</code> file will itself have various sections and we
might need to contribute to them at various points in the
compilation</li>
</ul></li>
<li>we want to do this all in one pass over the AST</li>
<li>we get to assume that the program is error-free – codegen never runs
unless semantic analysis reports zero errors
<ul>
<li>so nothing can be wrong by the time the codegen pass runs, we never
detect errors here</li>
<li>sometimes we add <code>Contract</code> and <code>Invariant</code>
statements to <code>cg.c</code> to make our assumptions clear and to
prevent regressions</li>
</ul></li>
</ul>
<p>There are some very important building blocks used to solve these
problems: we will start with those, then move to a discussion of each of
the essential kinds of code generation that we have to do to get working
programs.</p>
<h3 id="launching-the-code-generator">Launching the Code Generator</h3>
<p>Once semantic analysis is done, all of the code generators have the
same contract: they have a main function like <code>cg_c_main</code> for
the C code generator. It gets the root of the AST and it can use the
public interface of the semantic analyzer to get additional information.
See <a href="https://cgsql.dev/cql-guide/int02">Part 2</a> for those
details.</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Main entry point for code-gen.  This will set up the buffers for the global</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="co">// variables and any loose calls or DML.  Any code that needs to run in the</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="co">// global scope will be added to the global_proc.  This is the only codegen</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">// error that is possible.  If you need global code and you don&#39;t have a global</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="co">// proc then you can&#39;t proceed.  Semantic analysis doesn&#39;t want to know that stuff.</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Otherwise all we do is set up the most general buffers for the global case and</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="co">// spit out a function with the correct name.</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> cg_c_main<span class="op">(</span>ast_node <span class="op">*</span>head<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>In addition to initializing its scratch storage, the main entry point
also sets up a symbol table for AST dispatch just like the
<code>gen_</code> and <code>sem_</code> functions do. Here are some
samples from that table with the most common options:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>  DDL_STMT_INIT<span class="op">(</span>drop_table_stmt<span class="op">);</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>  DDL_STMT_INIT<span class="op">(</span>drop_view_stmt<span class="op">);</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>  DDL_STMT_INIT<span class="op">(</span>create_table_stmt<span class="op">);</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>  DDL_STMT_INIT<span class="op">(</span>create_view_stmt<span class="op">);</span></span></code></pre></div>
<p>The DDL (Data Definition Language) statements all get the same
handling: The text of the statement is generated from the AST. Any
variables are bound and then the statement is executed. The work is done
with <code>cg_bound_sql_statement</code> which will be discussed
later.</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Straight up DDL invocation.  The ast has the statement, execute it!</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="co">// We don&#39;t minify the aliases because DDL can have views and the view column names</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="co">// can be referred to in users of the view.  Loose select statements can have</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="co">// no external references to column aliases.</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_any_ddl_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>  cg_bound_sql_statement<span class="op">(</span>NULL<span class="op">,</span> ast<span class="op">,</span> CG_EXEC<span class="op">|</span>CG_NO_MINIFY_ALIASES<span class="op">);</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>DML (Data Manipulation Language) statements are declared
similarly:</p>
<pre><code>  STD_DML_STMT_INIT(begin_trans_stmt);
  STD_DML_STMT_INIT(commit_trans_stmt);
  STD_DML_STMT_INIT(rollback_trans_stmt);
  STD_DML_STMT_INIT(savepoint_stmt);
  STD_DML_STMT_INIT(delete_stmt);</code></pre>
<p>The DML statements are handled by <code>cg_std_dml_exec_stmt</code>;
the processing is identical to DDL except <code>CG_MINIFY_ALIASES</code>
is specified. This allows the code generator to remove unused column
aliases in <code>SELECT</code> statements to save space.</p>
<pre><code>// Straight up DML invocation.  The ast has the statement, execute it!
static void cg_std_dml_exec_stmt(ast_node *ast) {
  cg_bound_sql_statement(NULL, ast, CG_EXEC|CG_MINIFY_ALIASES);
}</code></pre>
<p>Note that this flag difference only matters for the
<code>CREATE VIEW</code> statement but for symmetry all the DDL is
handled with one macro and all the DML with the second macro.</p>
<p>Next, the easiest case… there are a bunch of statements that create
no code-gen at all. These statements are type definitions that are
interesting only to the semantic analyzer, or other control statements.
Some examples:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>  NO_OP_STMT_INIT<span class="op">(</span>declare_enum_stmt<span class="op">);</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>  NO_OP_STMT_INIT<span class="op">(</span>declare_named_type<span class="op">);</span></span></code></pre></div>
<p>Next, the general purpose statement handler. <code>STMT_INIT</code>
creates mappings such as the <code>if_stmt</code> AST node mapping to
<code>cg_if_stmt</code>.</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>if_stmt<span class="op">);</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>switch_stmt<span class="op">);</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>while_stmt<span class="op">);</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  STMT_INIT<span class="op">(</span>assign<span class="op">);</span></span></code></pre></div>
<p>The next group of declarations are the expressions, with precedence
and operator specified. There is a lot of code sharing between AST types
as you can see from this sample:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>num<span class="op">,</span> cg_expr_num<span class="op">,</span> <span class="st">&quot;num&quot;</span><span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>str<span class="op">,</span> cg_expr_str<span class="op">,</span> <span class="st">&quot;STR&quot;</span><span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>null<span class="op">,</span> cg_expr_null<span class="op">,</span> <span class="st">&quot;NULL&quot;</span><span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>dot<span class="op">,</span> cg_expr_dot<span class="op">,</span> <span class="st">&quot;DOT&quot;</span><span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mul<span class="op">,</span> cg_binary<span class="op">,</span> <span class="st">&quot;*&quot;</span><span class="op">,</span> C_EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>div<span class="op">,</span> cg_binary<span class="op">,</span> <span class="st">&quot;/&quot;</span><span class="op">,</span> C_EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>mod<span class="op">,</span> cg_binary<span class="op">,</span> <span class="st">&quot;%&quot;</span><span class="op">,</span> C_EXPR_PRI_MUL<span class="op">);</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>add<span class="op">,</span> cg_binary<span class="op">,</span> <span class="st">&quot;+&quot;</span><span class="op">,</span> C_EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>sub<span class="op">,</span> cg_binary<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">,</span> C_EXPR_PRI_ADD<span class="op">);</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>not<span class="op">,</span> cg_unary<span class="op">,</span> <span class="st">&quot;!&quot;</span><span class="op">,</span> C_EXPR_PRI_UNARY<span class="op">);</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>tilde<span class="op">,</span> cg_unary<span class="op">,</span> <span class="st">&quot;~&quot;</span><span class="op">,</span> C_EXPR_PRI_UNARY<span class="op">);</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>  EXPR_INIT<span class="op">(</span>uminus<span class="op">,</span> cg_unary<span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">,</span> C_EXPR_PRI_UNARY<span class="op">);</span></span></code></pre></div>
<p>Most (not all) of the binary operators are handled with one function
<code>cg_binary</code> and likewise most unary operators are handled
with <code>cg_unary</code>.</p>
<p>Note: the precedence constants are the <code>C_EXPR_PRI_*</code>
flavor because, naturally, parentheses will be generated based on the C
rules during C codegen. Importantly, the AST still, and always,
authoritatively encodes the user-specified order of operations – there’s
no change there. The only thing that changes is where parentheses are
needed to get the desired result. Some parens may need to be added, and
some that were present in the original text might no longer be
needed.</p>
<p>Here are some helpful examples:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* NOT is weaker than + */</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>  LET x <span class="op">:=</span> (<span class="kw">NOT</span> <span class="dv">1</span>) <span class="op">+</span> (<span class="kw">NOT</span> <span class="dv">2</span>);</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> <span class="kw">NOT</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>;</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  cql_bool x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* ! is stronger than + */</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="op">!</span> <span class="dv">1</span> <span class="op">+</span> <span class="op">!</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="op">!</span> <span class="op">(</span><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Finally, many built-in functions need special codegen, such as:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>coalesce<span class="op">);</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  FUNC_INIT<span class="op">(</span>printf<span class="op">);</span></span></code></pre></div>
<p><code>FUNC_INIT(coalesce)</code> creates a mapping between the
function name <code>coalesce</code> and the generator
<code>cg_func_coalesce</code>.</p>
<h3 id="character-buffers-and-byte-buffers">Character Buffers and Byte
Buffers</h3>
<p>The first kind of text output that CQL could produce was the AST
echoing. This was originally done directly with <code>fprintf</code> but
that was never going to be flexible enough – we have to be able to emit
that output into other places like comments, or the text of SQL
statements. This need forces that pass to use character buffers, which
we touched on in Part 1. C Code generation has a more profound
dependency on character buffers – they are literally all over
<code>cg_c.c</code> and we need to go over how they are used if we’re
going to understand the codegen passes.</p>
<p>The public interface for <code>charbuf</code> is in
<code>charbuf.h</code> and it’s really quite simple. You allocate a
<code>charbuf</code> and then you can <code>bprintf</code> into it.
Let’s be a bit more specific:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHARBUF_INTERNAL_SIZE 1024</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHARBUF_GROWTH_SIZE 1024</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> charbuf</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>ptr<span class="op">;</span>      <span class="co">// pointer to stored data, if any</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> used<span class="op">;</span>  <span class="co">// bytes used in current buffer</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> max<span class="op">;</span>   <span class="co">// max bytes in current buffer</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// builtin buffer storage</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> internal<span class="op">[</span>CHARBUF_INTERNAL_SIZE<span class="op">];</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> charbuf<span class="op">;</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>cql_data_decl<span class="op">(</span> <span class="dt">int32_t</span> charbuf_open_count <span class="op">);</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> bopen<span class="op">(</span>charbuf<span class="op">*</span> b<span class="op">);</span></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> bclose<span class="op">(</span>charbuf <span class="op">*</span>b<span class="op">);</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> bprintf<span class="op">(</span>charbuf <span class="op">*</span>b<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>The typical pattern goes something like this:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>  charbuf foo<span class="op">;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  bopen<span class="op">(&amp;</span>foo<span class="op">);</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>foo<span class="op">,</span> <span class="st">&quot;Hello %s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;World&quot;</span><span class="op">);</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// do something with foo.ptr</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>  bclose<span class="op">(&amp;</span>foo<span class="op">);</span></span></code></pre></div>
<p>Note that <code>charbuf</code> includes
<code>CHARBUF_INTERNAL_SIZE</code> of storage that does not have to be
allocated with <code>malloc</code> and it doesn’t grow very
aggressively. This economy reflects that fact that most
<code>charbuf</code> instances are very small. Of course a
<code>charbuf</code> could go on the heap if it needs to outlive the
function it appears in, but this is exceedingly rare.</p>
<p>To make sure buffers are consistently closed – and this is a problem
because there are often a lot of them – they are allocated with these
simple helper macros:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHARBUF_OPEN(x) \</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="pp">  int32_t __saved_charbuf_count##x = charbuf_open_count; \</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="pp">  charbuf x; \</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="pp">  bopen(&amp;x)</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CHARBUF_CLOSE(x) \</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="pp">  bclose(&amp;x); \</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="pp">  Invariant(__saved_charbuf_count##x == charbuf_open_count)</span></span></code></pre></div>
<p>The earlier example would be written more properly:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>foo<span class="op">);</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>foo<span class="op">,</span> <span class="st">&quot;Hello %s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;World&quot;</span><span class="op">);</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do something with foo.ptr</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>foo<span class="op">);</span></span></code></pre></div>
<p>If you forget to close a buffer the count will get messed up and the
next close will trigger an assertion failure.</p>
<p>It’s normal to create several buffers in the course of doing code
generation. In fact some of these buffers become “globally” visible and
get swapped out as needed. For instance, the kind of chaining we see
inside of <code>cg_create_proc_stmt</code> is normal, here is the
sequence:</p>
<p>Make new buffers…</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>proc_fwd_ref<span class="op">);</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>proc_body<span class="op">);</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>proc_locals<span class="op">);</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>proc_cleanup<span class="op">);</span></span></code></pre></div>
<p>Save the current buffer pointers…</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>saved_main <span class="op">=</span> cg_main_output<span class="op">;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>saved_decls <span class="op">=</span> cg_declarations_output<span class="op">;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>saved_scratch <span class="op">=</span> cg_scratch_vars_output<span class="op">;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>saved_cleanup <span class="op">=</span> cg_cleanup_output<span class="op">;</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>saved_fwd_ref <span class="op">=</span> cg_fwd_ref_output<span class="op">;</span></span></code></pre></div>
<p>Switch to the new buffers…</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>  cg_fwd_ref_output <span class="op">=</span> <span class="op">&amp;</span>proc_fwd_ref<span class="op">;</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>  cg_main_output <span class="op">=</span> <span class="op">&amp;</span>proc_body<span class="op">;</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>  cg_declarations_output <span class="op">=</span> <span class="op">&amp;</span>proc_locals<span class="op">;</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>  cg_scratch_vars_output <span class="op">=</span> <span class="op">&amp;</span>proc_locals<span class="op">;</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>  cg_cleanup_output <span class="op">=</span> <span class="op">&amp;</span>proc_cleanup<span class="op">;</span></span></code></pre></div>
<p>And of course the code puts the original values back when it’s done
and then closes what it opened.</p>
<p>This means that while processing a procedure the codegen that
declares say scratch variables, which would go to
<code>cg_scratch_vars_output</code>, is going to target the
<code>proc_locals</code> buffer which will be emitted before the
<code>proc_body</code>. By the time <code>cg_stmt_list</code> is invoked
the <code>cg_main_output</code> variable will be pointing to the
procedure body, thus any statements will go into there rather than being
accumulated at the global level.</p>
<p>Note: it’s possible to have code that is not in a procedure (see <a
href="https://cgsql.dev/cql-guide/x1#--global_proc-name"><code>--global_proc</code></a>).</p>
<p>In general, it’s very useful to have different buffers open at the
same time. New local variables or scratch variables can be added to
their own buffer. New cleanup steps that are necessary can be added to
<code>cg_cleanup_output</code> which will appear at the end of a
procedure. The final steps of procedure codegen combines all of these
pieces plus a little glue to make a working procedure.</p>
<p>All codegen works like this – statements, expressions, all of it.</p>
<p>One interesting but unexpected feature of <code>charbuf</code> is
that it provides helper methods for indenting a buffer by whatever
amount you like. This turns out to be invaluable in creating well
formatted C code because of course we want (e.g.) the body of an
<code>if</code> statement to be indented. CQL tries to create well
formatted code that is readable by humans as much as possible.</p>
<h4 id="byte-buffers">Byte Buffers</h4>
<p>The byte buffers type, creatively called <code>bytebuf</code> is less
commonly used. It is a peer to <code>charbuf</code> and provides a
growable binary buffer. <code>bytebuf</code> is often used to hold
arrays of structures. Interestingly, <code>cg_c.c</code> doesn’t
currently consume byte buffers, the presence of <code>bytebuf.c</code>
actually came late to the CQL compiler. However the CQL runtime
<code>cqlrt.c</code> (and <code>cqlrt_common.c</code>) provide
<code>cql_bytebuf_open</code>, <code>cql_bytebuf_alloc</code> and,
<code>cql_bytebuf_close</code> which are akin to the
<code>charbuf</code> methods. These functions <em>are</em> used in the
generated code to create result sets at runtime.</p>
<p><code>bytebuf</code> was so useful that it found its way back from
the runtime into the compiler itself, and is used by other
code-generators like the schema upgraded. The semantic analyzer also
uses it to help with query fragments and to track the various upgrade
annotations.</p>
<p>Both <code>charbuf</code> and <code>bytebuf</code> are simple enough
that they don’t need special discussion. Surveying their code and
comments is an excellent exercise for the reader.</p>
<h3 id="expressions">Expressions</h3>
<p>Many of the output needs of CQL stemmed from the base case of
creating the code for CQL expressions. A simple CQL expression like:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> x <span class="op">+</span> y;</span></code></pre></div>
<p>seems innocuous enough, and we’d like that expression to compile to
this code:</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span></code></pre></div>
<p>And indeed, it does. Here’s some actual output from the compiler:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="co">CREATE PROC p ()</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="re">BEGIN</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="co">  DECLARE x, y INTEGER NOT NULL;</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="co">  SET x := x + y;</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="re">END</span><span class="co">;</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _PROC_ &quot;p&quot;</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>  cql_int32 x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>  cql_int32 y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef _PROC_</span></span></code></pre></div>
<p>(*) the output above was created by using
<code>out/cql --in x --cg x.h x.c --nolines</code> to avoid all the
<code>#</code> directives</p>
<p>That expression looks easy enough. And indeed if all expressions were
like this, we could do expression compilation pretty simply – every
binary operator would look something like this:</p>
<ul>
<li>recurse left</li>
<li>emit infix operator</li>
<li>recurse right</li>
</ul>
<p>This would sort of build up your expressions inside out and your
final buffer after all the recursion was done would have the whole
expression.</p>
<p>This doesn’t work at all.</p>
<p>To illustrate what goes wrong, we only have to change the test case a
tiny bit. The result is telling:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="co">CREATE PROC p ()</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="re">BEGIN</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="co">  DECLARE x, y INTEGER;</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="co">  SET x := x + y;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a><span class="re">END</span><span class="co">;</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _PROC_ &quot;p&quot;</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 x<span class="op">;</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 y<span class="op">;</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>  cql_combine_nullables<span class="op">(</span>x<span class="op">,</span> x<span class="op">.</span>is_null<span class="op">,</span> y<span class="op">.</span>is_null<span class="op">,</span> x<span class="op">.</span>value <span class="op">+</span> y<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef _PROC_</span></span></code></pre></div>
<p>In this new example above, <code>x</code> and <code>y</code> became
nullable variables i.e. the <code>NOT NULL</code> was removed from their
declarations – this makes all the difference in the world.</p>
<p>Let’s take a quick look at <code>cql_nullable_int32</code> and we’ll
see the crux of the problem immediately:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_nullable_int32 <span class="op">{</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a> cql_bool is_null<span class="op">;</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a> cql_int32 value<span class="op">;</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_nullable_int32<span class="op">;</span></span></code></pre></div>
<p>The problem is that nullable value types like
<code>cql_nullable_int32</code> have both their <code>value</code> field
and a boolean <code>is_null</code> and these don’t flow into expressions
that use operators like <code>+</code>, <code>-</code>, <code>/</code>
and so forth. This means that even simple expressions involving nullable
types actually expand into several statements. And, in general, these
statements need a place to put their temporary results to accumulate the
correct answer, so scratch variables are required to make all this
work.</p>
<p>Here’s a more realistic example:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="co">CREATE PROC combine (x INTEGER, y INTEGER, OUT result INTEGER)</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="re">BEGIN</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="co">  SET result := 5 * x + 3 * y;</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="re">END</span><span class="co">;</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _PROC_ &quot;combine&quot;</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> combine<span class="op">(</span>cql_nullable_int32 x<span class="op">,</span> cql_nullable_int32 y<span class="op">,</span> cql_nullable_int32 <span class="op">*</span>_Nonnull result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>  cql_contract_argument_notnull<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>result<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 _tmp_n_int_1<span class="op">;</span></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>_tmp_n_int_1<span class="op">);</span></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 _tmp_n_int_2<span class="op">;</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>_tmp_n_int_2<span class="op">);</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(*</span>result<span class="op">);</span> <span class="co">// set out arg to non-garbage</span></span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>  cql_set_nullable<span class="op">(</span>_tmp_n_int_1<span class="op">,</span> x<span class="op">.</span>is_null<span class="op">,</span> <span class="dv">5</span> <span class="op">*</span> x<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a>  cql_set_nullable<span class="op">(</span>_tmp_n_int_2<span class="op">,</span> y<span class="op">.</span>is_null<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> y<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb130-20"><a href="#cb130-20" aria-hidden="true" tabindex="-1"></a>  cql_combine_nullables<span class="op">(*</span>result<span class="op">,</span> _tmp_n_int_1<span class="op">.</span>is_null<span class="op">,</span> _tmp_n_int_2<span class="op">.</span>is_null<span class="op">,</span> _tmp_n_int_1<span class="op">.</span>value <span class="op">+</span> _tmp_n_int_2<span class="op">.</span>value<span class="op">);</span></span>
<span id="cb130-21"><a href="#cb130-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-22"><a href="#cb130-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb130-23"><a href="#cb130-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef _PROC_</span></span>
<span id="cb130-24"><a href="#cb130-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma clang diagnostic pop</span></span></code></pre></div>
<ul>
<li><code>_tmp_n_int_1</code> : holds the product of x and 5, it’s null
if <code>x.is_null</code> is true</li>
<li><code>_tmp_n_int_2</code> : holds the product of y and 3, it’s null
if <code>y.is_null</code> is true</li>
<li><code>*result</code> : holds the answer, it’s null if either of
<code>_tmp_n_int_1.is_null</code>, <code>_tmp_n_int_2.is_null</code> is
true
<ul>
<li>otherwise it’s
<code>_tmp_n_int_1.value + _tmp_n_int_2.value</code></li>
</ul></li>
</ul>
<p>So, in general, we need to emit arbitrarily many statements in the
course of evaluating even simple looking expressions and we need good
mechanisms to manage that. This is what we’ll talk about in the coming
sections.</p>
<h4 id="managing-scratch-variables">Managing Scratch Variables</h4>
<p>The function that actually assigns scratch variables is
<code>cg_scratch_var</code></p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The scratch variable helper uses the given sem_type and the current</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="co">// stack level to create a temporary variable name for that type at that level.</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="co">// If the variable does not already have a declaration (as determined by the masks)</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="co">// then a declaration is added to the scratch_vars section.  This is one of the root</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ways of getting an .is_null and .value back.  Note that not null variables always</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="co">// have a .is_null of &quot;0&quot; which becomes important when deciding how to assign</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a><span class="co">// one result to another.  Everything stays uniform.</span></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_scratch_var<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">,</span> sem_t sem_type<span class="op">,</span> charbuf <span class="op">*</span>var<span class="op">,</span> charbuf <span class="op">*</span>is_null<span class="op">,</span> charbuf <span class="op">*</span>value<span class="op">)</span></span></code></pre></div>
<p>The signature is a bit unexpected so we’ll go over it, some of below
will make more sense as we learn about expressions generally, but this
is as good an introduction as any.</p>
<ul>
<li><code>ast</code> : holds a reference to a variable we want to assign
to
<ul>
<li>this argument is normally <code>NULL</code> for scratch
variables</li>
<li><code>ast</code> is not null for the <code>RESULT</code> macros
which we’ll study later</li>
<li>for now, we can basically ignore this argument</li>
</ul></li>
<li><code>sem_type</code> : holds the type of the variable we need
<ul>
<li>it must be a unitary type, optionally with
<code>SEM_TYPE_NOTNULL</code> set</li>
</ul></li>
<li><code>var</code> : a character buffer that will get the name of the
variable</li>
<li><code>is_null</code> : a character buffer that will get the
<code>is_null</code> expression for this variable (more below)</li>
<li><code>value</code> : a character buffer that will get the
<code>value</code> expression for this variable (more below)</li>
</ul>
<p>And this is a good time to talk about <code>is_null</code> and
<code>value</code> because they will be everywhere.</p>
<p>The codegen for expressions in the C code generator produces two
results: * the text that corresponds to the current value so far
(e.g. “(1+2)<em>3”), and, </em> the text that will tell you if the
current value is null * this could be as simple as”0” for an expression
that is known to be not null</p>
<p>Let’s make this a little more concrete:</p>
<p>Suppose we ask for a scratch “not null integer”, we get results like
this:</p>
<ul>
<li><code>var</code>: <code>"_tmp_n_int_1"</code></li>
<li><code>is_null</code>: <code>"0"</code></li>
<li><code>value</code>: <code>"_tmp_n_int_1"</code></li>
</ul>
<p>Meaning: if we want the value, use the text
<code>"_tmp_n_int_1"</code> if we want to know if the variable is null,
we use the text <code>"0"</code></p>
<p>Note: many parts of <code>cg_c.c</code> special case an
<code>is_null</code> value of <code>"0"</code> to make better code
because such a thing is known to be not null at compile time.</p>
<p>Now let’s suppose we ask for a scratch nullable integer, we get
results like this:</p>
<ul>
<li><code>var</code>: <code>"_tmp_int_1"</code></li>
<li><code>is_null</code>: <code>"_tmp_int_1.is_null"</code></li>
<li><code>value</code>: <code>"_tmp_int_1.value"</code></li>
</ul>
<p>So again, we have exactly the text we need to test for null, and the
test we need to get the value.</p>
<p>Additional notes:</p>
<ul>
<li>scratch variables can be re-used, they are on a “stack”</li>
<li>a bitmask is used to track which scratch variables have already had
a declaration emitted, so they are only declared once</li>
<li>the variable name is based on the current value of the
<code>stack_level</code> variable which is increased in a push/pop
fashion as temporaries come in and out of scope
<ul>
<li>this strategy isn’t perfect, but the C compiler can consolidate
locals even if the CQL codegen is not perfect so it ends up being not so
bad</li>
<li>importantly, there is one <code>stack_level</code> variable for all
temporaries not one <code>stack_level</code> for every type of
temporary, this seemed like a reasonable simplification</li>
</ul></li>
</ul>
<h4 id="allocating-scratch-variables">Allocating Scratch Variables</h4>
<p>The most common reason to create a “scratch” variable is that a
temporary variable is needed for some part of the computation. The most
common reason for a temporary variable is to hold an intermediate result
of a computation involving nullable arithmetic.</p>
<p>These temporaries are created with <code>CG_PUSH_TEMP</code> which
simply creates the three <code>charbuf</code> variables needed and then
asks for a scratch variable of the required type. The variables follow a
simple naming convention. The stack level is increased after each
temporary is allocated.</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create buffers for a temporary variable.  Use cg_scratch_var to fill in the buffers</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="co">// with the text needed to refer to the variable.  cg_scratch_var picks the name</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="co">// based on stack level-and type.</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_PUSH_TEMP(name, sem_type) \</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_OPEN(name); \</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_OPEN(name##_is_null); \</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_OPEN(name##_value); \</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="pp">  cg_scratch_var(NULL, sem_type, &amp;name, &amp;name##_is_null, &amp;name##_value); \</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a><span class="pp">  stack_level++;</span></span></code></pre></div>
<p>Symmetrically, <code>CG_POP_TEMP</code> closes the
<code>charbuf</code> variables and restores the stack level.</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Release the buffers for the temporary, restore the stack level.</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_POP_TEMP(name) \</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_CLOSE(name##_value); \</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_CLOSE(name##_is_null); \</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_CLOSE(name); \</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="pp">  stack_level--;</span></span></code></pre></div>
<p>As with the other <code>PUSH/POP</code> <code>OPEN/CLOSE</code> macro
types, these macros are designed to make it impossible to forget to free
the buffers, or to get the stack level wrong. The stack level can be
(and is) checked at strategic places to ensure it’s back to baseline –
this is easy because the code can always just snapshot
<code>stack_level</code>, do some work that should be clean, and then
check that <code>stack_level</code> is back to where it’s supposed to be
with an <code>Invariant</code>.</p>
<h4 id="recursing-sub-expressions">Recursing Sub-expressions</h4>
<p>Now that we understand that we can create scratch variables as
needed, it’s time to take a look at the typical evaluation patterns and
how the evaluation works within that pattern. This is everywhere in
<code>cg_c.c</code>.</p>
<p>So let’s look at an actual evaluator, the simplest of them all, this
one does code generation for the <code>NULL</code> literal.</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_expr_null<span class="op">(</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>expr<span class="op">,</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  CSTR op<span class="op">,</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>is_null<span class="op">,</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>value<span class="op">,</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> pri<span class="op">,</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> pri_new<span class="op">)</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_null<span class="op">(</span>expr<span class="op">));</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// null literal</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>value<span class="op">,</span> <span class="st">&quot;NULL&quot;</span><span class="op">);</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>is_null<span class="op">,</span> <span class="st">&quot;1&quot;</span><span class="op">);</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now this may be looking familiar: the signature of the code generator
is something very much like the signature of the the <code>gen_</code>
functions in the echoing code. That’s really because in some sense the
echoing code is a very simple code generator itself.</p>
<ul>
<li><code>expr</code> : the AST we are generating code for</li>
<li><code>op</code> : the relevant operator if any (operators share
code)</li>
<li><code>is_null</code> : a <code>charbuf</code> into which we can
write the <code>is_null</code> expression text</li>
<li><code>value</code> : a <code>charbuf</code> into which we can write
the <code>value</code> expression text</li>
<li><code>pri</code> : the binding strength of the node above this
one</li>
<li><code>pri_new</code> : the binding strength of this node</li>
</ul>
<p>This particular generator is going to produce <code>"NULL"</code> for
the <code>value</code> and <code>"1"</code> for the <code>is_null</code>
expression.</p>
<p><code>is_null</code> and <code>value</code> are the chief outputs,
and the caller will use these to create its own expression results with
recursive logic. But the expression logic can also write into the
statement stream, the cleanup stream, even into the header file stream,
and as we’ll see, it does.</p>
<p><code>pri</code> and <code>pri_new</code> work exactly like they did
in the echoing code (see <a
href="https://cgsql.dev/cql-guide/int01">Part 1</a>), they are used to
allow the code generator to decide if it needs to emit parentheses. But
recall that the binding strengths now will be the C binding strengths
NOT the SQL binding strengths (discussed above).</p>
<p>Let’s look at one of the simplest operators: the <code>IS NULL</code>
operator handled by <code>cg_expr_is_null</code></p>
<p>Note: this code has a simpler signature because it’s actually part of
codegen for <code>cg_expr_is</code> which has the general contract.</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The code-gen for is_null is one of the easiest.  The recursive call</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="co">// produces is_null as one of the outputs.  Use that.  Our is_null result</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="co">// is always zero because IS NULL is never, itself, null.</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_expr_is_null<span class="op">(</span>ast_node <span class="op">*</span>expr<span class="op">,</span> charbuf <span class="op">*</span>is_null<span class="op">,</span> charbuf <span class="op">*</span>value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type_expr <span class="op">=</span> expr<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// expr IS NULL</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>is_null<span class="op">,</span> <span class="st">&quot;0&quot;</span><span class="op">);</span> <span class="co">// the result of is null is never null</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The fact that this is not constant not null for not null reference types reflects</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the weird state of affairs with uninitialized reference variables which</span></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// must be null even if they are typed not null.</span></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_not_nullable<span class="op">(</span>sem_type_expr<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>is_ref_type<span class="op">(</span>sem_type_expr<span class="op">))</span> <span class="op">{</span></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Note, sql has no side-effects so we can fold this away.</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>value<span class="op">,</span> <span class="st">&quot;0&quot;</span><span class="op">);</span></span>
<span id="cb135-17"><a href="#cb135-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb135-18"><a href="#cb135-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb135-19"><a href="#cb135-19" aria-hidden="true" tabindex="-1"></a>    CG_PUSH_EVAL<span class="op">(</span>expr<span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb135-20"><a href="#cb135-20" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>value<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> expr_is_null<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb135-21"><a href="#cb135-21" aria-hidden="true" tabindex="-1"></a>    CG_POP_EVAL<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb135-22"><a href="#cb135-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb135-23"><a href="#cb135-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So walking through the above: * the result of <code>IS NULL</code> is
never null, so we can immediately put “0” into the <code>is_null</code>
buffer * if the operand is a not-null numeric type then the result of
<code>IS NULL</code> is <code>0</code> * if the operand might actually
be null then * use <code>CG_PUSH_EVAL</code> to recursively do codegen
for it * copy its <code>expr_is_null</code> text into our
<code>value</code> text</p>
<p>Note: the code reveals one of the big CQL secrets – that not null
reference variables can be null… C has the same issue with
<code>_Nonnull</code> globals.</p>
<p>Now let’s look at those helper macros, they are pretty simple:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Make a temporary buffer for the evaluation results using the canonical</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="co">// naming convention.  This might exit having burned some stack slots</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="co">// for its result variables, that&#39;s normal.</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_PUSH_EVAL(expr, pri) \</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_OPEN(expr##_is_null); \</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_OPEN(expr##_value); \</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a><span class="pp">cg_expr(expr, &amp;expr##_is_null, &amp;expr##_value, pri);</span></span></code></pre></div>
<p>The push macro simply creates buffers to hold the
<code>is_null</code> and <code>value</code> results, then it calls
<code>cg_expr</code> to dispatch the indicated expression. The
<code>pri</code> value provided to this macro represents the binding
strength that the callee should assume its parent has. Usually this is
the <code>pri_new</code> of the caller. but often
<code>C_EXPR_PRI_ROOT</code> can be used if the current context implies
that the callee will never need parentheses.</p>
<p>How do we know that parens are not needed here? It seems like the
operand of <code>IS NULL</code> could be anything, surely it might need
parentheses? Let’s consider:</p>
<ul>
<li>if the operand is of not null numeric type then we aren’t even going
to evaluate it, we’re on the easy “no it’s not null” path
<ul>
<li>no parens there</li>
</ul></li>
<li>if the operand is nullable then the only place the answer can be
stored is in a scratch variable and its <code>is_null</code> expression
will be exactly like <code>var.is_null</code>
<ul>
<li>no parens there</li>
</ul></li>
<li>if the operand is a reference type, there are no operators that
combine reference types to get more reference types, so again the result
must be in a variable, and is <code>is_null</code> expression will be
like <code>!var</code>
<ul>
<li>no parens there</li>
</ul></li>
</ul>
<p>So, none of these require further wrapping regardless of what is
above the <code>IS NULL</code> node in the tree because of the high
strength of the <code>.</code> and <code>!</code> operators.</p>
<p>Other cases are usually simpler, such as “no parentheses need to be
added by the child node because it will be used as the argument to a
helper function so there will always be parens hard-coded anyway”.
However these things need to be carefully tested hence the huge variety
of codegen tests.</p>
<p>Note that after calling <code>cg_expr</code> the temporary stack
level might be increased. We’ll get to that in the next section. For
now, looking at <code>POP_EVAL</code> we can see it’s very
straightforward:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Close the buffers used for the above.</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="co">// The scratch stack is not restored so that any temporaries used in</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the evaluation of expr will not be re-used prematurely.  They</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="co">// can&#39;t be used again until either the expression is finished,</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="co">// or they have been captured in a less-nested result variable.</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_POP_EVAL(expr) \</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_CLOSE(expr##_value); \</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_CLOSE(expr##_is_null);</span></span></code></pre></div>
<p><code>CG_POP_EVAL</code> simply closes the buffers, leaving the stack
level unchanged. More on this in the coming section.</p>
<h4 id="result-variables">Result Variables</h4>
<p>When recursion happens in the codegen, a common place that the result
will be found is in a temporary variable i.e. the generated code will
use one or more statements to arrange for the correct answer to be in a
variable. To do this, the codegen needs to first get the name of a
result variable of a suitable type. This is the “other” reason for
making scratch variables.</p>
<p>There are three macros that make this pretty simple. The first is
<code>CG_RESERVE_RESULT_VAR</code></p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Make a scratch variable to hold the final result of an evaluation.</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a><span class="co">// It may or may not be used.  It should be the first thing you put</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a><span class="co">// so that it is on the top of your stack.  This only saves the slot.</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a><span class="co">// If you use this variable you can reclaim other temporaries that come</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a><span class="co">// from deeper in the tree since they will no longer be needed.</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_RESERVE_RESULT_VAR(ast, sem_type) \</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a><span class="pp">int32_t stack_level_reserved = stack_level; \</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a><span class="pp">sem_t sem_type_reserved = sem_type; \</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a><span class="pp">ast_node *ast_reserved = ast; \</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_OPEN(result_var); \</span></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_OPEN(result_var_is_null); \</span></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_OPEN(result_var_value); \</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a><span class="pp">stack_level++;</span></span></code></pre></div>
<p>If this looks a lot like <code>PUSH_TEMP</code> that shouldn’t be
surprising. The name of the variable and the expression parts always go
into <code>charbuf</code> variables named <code>result_var</code>,
<code>result_var_is_null</code>, and <code>result_var_value</code> but
the scratch variable isn’t actually allocated! However – we burn the
stack_level as though it had been allocated.</p>
<p>The name of the macro provides a clue: this macro reserves a slot for
the result variable, it’s used if the codegen might need a result
variable, but it might not. If/when the result variable is needed, it we
can artificially move the stack level back to the reserved spot,
allocate the scratch variable, and then put the stack level back. When
the name is set we know that the scratch variable was actually used.</p>
<p>The <code>CG_USE_RESULT_VAR</code> macro does exactly this
operation.</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If the result variable is going to be used, this writes its name</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="co">// and .value and .is_null into the is_null and value fields.</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_USE_RESULT_VAR() \</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="pp">int32_t stack_level_now = stack_level; \</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a><span class="pp">stack_level = stack_level_reserved; \</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a><span class="pp">cg_scratch_var(ast_reserved, sem_type_reserved, &amp;result_var, &amp;result_var_is_null, &amp;result_var_value); \</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a><span class="pp">stack_level = stack_level_now; \</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a><span class="pp">Invariant(result_var.used &gt; 1); \</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a><span class="pp">bprintf(is_null, &quot;%s&quot;, result_var_is_null.ptr); \</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a><span class="pp">bprintf(value, &quot;%s&quot;, result_var_value.ptr)</span></span></code></pre></div>
<p>Once the code generator decides that it will in fact be using a
result variable to represent the answer, then the <code>is_null</code>
and <code>value</code> buffers can be immediately populated to whatever
the values were for the result variable. That text will be correct
regardless of what codegen is used to populate the variable. The
variable is the result.</p>
<p>There is a simpler macro that reserves and uses the result variable
in one step, it’s used frequently. The “reserve” pattern is only
necessary when there are some paths that need a result variable and some
that don’t.</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This does reserve and use in one step</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_SETUP_RESULT_VAR(ast, sem_type) \</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="pp">  CG_RESERVE_RESULT_VAR(ast, sem_type); \</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a><span class="pp">  CG_USE_RESULT_VAR();</span></span></code></pre></div>
<p>And now armed with this knowledge we can look at the rest of the
scratch stack management.</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Release the buffer holding the name of the variable.</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="co">// If the result variable was used, we can re-use any temporaries</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="co">// with a bigger number.  They&#39;re no longer needed since they</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="co">// are captured in this result.  We know it was used if it</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="co">// has .used &gt; 1 (there is always a trailing null so empty is 1).</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CG_CLEANUP_RESULT_VAR() \</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="pp">if (result_var.used &gt; 1) stack_level = stack_level_reserved + 1; \</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_CLOSE(result_var_value); \</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_CLOSE(result_var_is_null); \</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a><span class="pp">CHARBUF_CLOSE(result_var);</span></span></code></pre></div>
<p>As it happens when you use <code>CG_PUSH_EVAL</code> it is entirely
possible, even likely, that the result of <code>cg_expr</code> is in a
result variable. The convention is that if the codegen requires a result
variable it is allocated <em>first</em>, before any other temporaries.
This is why there is a way to reserve a variable that you <em>might</em>
need.</p>
<p>Now if it turns out that you used the result variable at your level
it means that any temporary result variables from deeper levels have
been used and their values plus whatever math was needed is now in your
result variable. This means that the <code>stack_level</code> variable
can be decreased to one more than the level of the present result. This
is in the fact the only time it is safe to start re-using result
variables because you otherwise never know how many references to result
variables that were “deep in the tree” are left in the contents of
<code>expr_value</code> or <code>expr_is_null</code>.</p>
<p>Now, armed with the knowledge that there are result variables and
temporary variables and both come from the scratch variables we can
resolve the last mystery we left hanging. Why does the scratch variable
API accept an AST pointer?</p>
<p>The only place that AST pointer can be not null is in the
<code>CG_USE_RESULT_VAR</code> macro, it was this line:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>cg_scratch_var<span class="op">(</span>ast_reserved<span class="op">,</span> sem_type_reserved<span class="op">,</span> <span class="op">&amp;</span>result_var<span class="op">,</span> <span class="op">&amp;</span>result_var_is_null<span class="op">,</span> <span class="op">&amp;</span>result_var_value<span class="op">);</span></span></code></pre></div>
<p>And <code>ast_reserved</code> refers to the AST that we are trying to
evaluate. There’s an important special case that we want to optimize
that saves a lot of scratch variables. That case is handled by this code
in <code>cg_scratch_var</code>:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// try to avoid creating a scratch variable if we can use the target of an assignment in flight.</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_assignment_target_reusable<span class="op">(</span>ast<span class="op">,</span> sem_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>ast <span class="op">&amp;&amp;</span> ast<span class="op">-&gt;</span>parent <span class="op">&amp;&amp;</span> ast<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> ast<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">);</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_out_parameter<span class="op">(</span>name_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>var<span class="op">,</span> <span class="st">&quot;*%s&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>var<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>The idea is that if the generator is doing an assignment like:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> a <span class="op">+</span> b;</span></code></pre></div>
<p>Then the code generator doesn’t need a scratch variable to hold the
result of the expression <code>a + b</code> like it would in many other
contexts. It can use <code>x</code> as the result variable! The
<code>SET</code> codegen will discover that the value it’s supposed to
set is already in <code>x</code> so it does nothing and everything just
works out. The price of this is a call to
<code>is_assignment_target_reusable</code> and then some logic to handle
the case where <code>x</code> is an out argument (hence call by
reference, hence needs to be used as <code>*x</code>).</p>
<h3 id="basic-control-flow-patterns">Basic Control Flow Patterns</h3>
<p>To get a sense of how the compiler generates code for statements, we
can look at some of the easiest cases.</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;While&quot; suffers from the same problem as IF and as a consequence</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="co">// generating while (expression) would not generalize.</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="co">// The overall pattern for while has to look like this:</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="co">//  for (;;) {</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a><span class="co">//    prep statements;</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a><span class="co">//    condition = final expression;</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a><span class="co">//    if (!condition) break;</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a><span class="co">//    statements;</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a><span class="co">//  }</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Note that while can have leave and continue substatements which have to map</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a><span class="co">// to break and continue.   That means other top level statements that aren&#39;t loops</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a><span class="co">// must not create a C loop construct or break/continue would have the wrong target.</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_while_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_while_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a>  EXTRACT_ANY_NOTNULL<span class="op">(</span>expr<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>  EXTRACT<span class="op">(</span>stmt_list<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>  sem_t sem_type <span class="op">=</span> expr<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">;</span></span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// WHILE [expr] </span><span class="re">BEGIN</span><span class="co"> [stmt_list] </span><span class="re">END</span></span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;for (;;) {</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>  CG_PUSH_EVAL<span class="op">(</span>expr<span class="op">,</span> C_EXPR_PRI_ROOT<span class="op">);</span></span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_nullable<span class="op">(</span>sem_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;if (!cql_is_nullable_true(%s, %s)) break;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> expr_is_null<span class="op">.</span>ptr<span class="op">,</span> expr_value<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;if (!(%s)) break;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> expr_value<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a>  bool_t loop_saved <span class="op">=</span> cg_in_loop<span class="op">;</span></span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a>  cg_in_loop <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb145-37"><a href="#cb145-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-38"><a href="#cb145-38" aria-hidden="true" tabindex="-1"></a>  CG_POP_EVAL<span class="op">(</span>expr<span class="op">);</span></span>
<span id="cb145-39"><a href="#cb145-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-40"><a href="#cb145-40" aria-hidden="true" tabindex="-1"></a>  cg_stmt_list<span class="op">(</span>stmt_list<span class="op">);</span></span>
<span id="cb145-41"><a href="#cb145-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-42"><a href="#cb145-42" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb145-43"><a href="#cb145-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-44"><a href="#cb145-44" aria-hidden="true" tabindex="-1"></a>  cg_in_loop <span class="op">=</span> loop_saved<span class="op">;</span></span>
<span id="cb145-45"><a href="#cb145-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The comment before the <code>cg_while_stmt</code> actually describes
the situation pretty clearly; the issue with this codegen is that the
expression in the while statement might actually require many C
statements to evaluate. There are many cases of this sort of thing, but
the simplest is probably when any nullable types are in that expression.
A particular example illustrates this pretty clearly:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> x <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> <span class="dv">1</span>;</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">WHILE</span> x <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> x <span class="op">:=</span> x <span class="op">+</span> <span class="dv">1</span>;</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>which generates:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>  cql_int32 x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* in trickier cases there would be code right here */</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!(</span>x <span class="op">&lt;</span> <span class="dv">5</span><span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this case, a <code>while</code> statement could have been used
because the condition is simply <code>x &lt; 5</code> so this more
general pattern is overkill. But consider this program, just a tiny bit
different:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> x <span class="dt">INTEGER</span>;  <span class="co">-- x is nullable</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> x <span class="op">:=</span> <span class="dv">1</span>;</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">WHILE</span> x <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> x <span class="op">:=</span> x <span class="op">+</span> <span class="dv">1</span>;</span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>which produces:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 x<span class="op">;</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>  cql_nullable_bool _tmp_n_bool_0<span class="op">;</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>  cql_set_null<span class="op">(</span>_tmp_n_bool_0<span class="op">);</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>  cql_set_notnull<span class="op">(</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>  cql_set_nullable<span class="op">(</span>_tmp_n_bool_0<span class="op">,</span> x<span class="op">.</span>is_null<span class="op">,</span> x<span class="op">.</span>value <span class="op">&lt;</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>cql_is_nullable_true<span class="op">(</span>_tmp_n_bool_0<span class="op">.</span>is_null<span class="op">,</span> _tmp_n_bool_0<span class="op">.</span>value<span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>    cql_set_nullable<span class="op">(</span>x<span class="op">,</span> x<span class="op">.</span>is_null<span class="op">,</span> x<span class="op">.</span>value <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb149-13"><a href="#cb149-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Even for this small little case, the nullable arithmetic macros have
to be used to keep <code>x</code> up to date. The result of
<code>x &lt; 5</code> is of type <code>BOOL</code> rather than
<code>BOOL NOT NULL</code> so a temporary variable captures the result
of the expression. This is an easy case, but similar things happen if
the expression includes e.g. <code>CASE...WHEN...</code> or
<code>IN</code> constructs. There are many other cases.</p>
<p>So with this in mind, let’s reconsider what
<code>cg_while_stmt</code> is doing:</p>
<ul>
<li>we start the <code>for</code> statement in the output
<ul>
<li>there’s a bprintf for that</li>
</ul></li>
<li>we evaluate the while expression, the details will be in
<code>is_null</code> and <code>value</code>
<ul>
<li>we use CG_PUSH_EVAL for that</li>
</ul></li>
<li>if the result is nullable there is a helper macro
<code>cql_is_nullable_true</code> that tells us if the value is not null
and true</li>
<li>if the result is not nullable we can use <code>expr_value.ptr</code>
directly</li>
<li>we make a note that we’re in a loop (this matters for statement
cleanup, more on that later)</li>
<li>we recurse to do more statements with <code>cg_stmt_list</code></li>
<li>finally we end the <code>for</code> that we began</li>
</ul>
<p>This kind of structure is common to all the control flow cases.
Generally, we have to deal with the fact that CQL expressions often
become C statements so we use a more general flow control strategy. But
with this in mind, it’s easy to imagine how the <code>IF</code>,
<code>LOOP</code>, and <code>SWITCH</code> switch statements are
handled.</p>
<h3 id="cleanup-and-errors">Cleanup and Errors</h3>
<p>There are a number of places where things can go wrong when running a
CQL procedure. The most common sources are: (1) SQLite APIs, almost all
of which can fail, and, (2) calling other procedures which also might
fail. Here’s a very simple example:</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> PROC something_that_might_fail (arg TEXT) <span class="kw">USING</span> <span class="kw">TRANSACTION</span>;</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>  LET arg <span class="op">:=</span> <span class="ot">&quot;test&quot;</span>;</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">CALL</span> something_that_might_fail(arg);</span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Which generates:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>cql_string_literal<span class="op">(</span>_literal_1_test_p<span class="op">,</span> <span class="st">&quot;test&quot;</span><span class="op">);</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>  cql_string_ref arg <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;</span>arg<span class="op">,</span> _literal_1_test_p<span class="op">);</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> something_that_might_fail<span class="op">(</span>_db_<span class="op">,</span> arg<span class="op">);</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a>  cql_string_release<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s look at those fragments carefully:</p>
<ul>
<li>first, we had to declare <code>something_that_might_fail</code>
<ul>
<li>the declaration included <code>USING TRANSACTION</code> indicating
the procedure uses the database</li>
<li>we didn’t provide the procedure definition, this is like an
<code>extern ... foo(...);</code> declaration</li>
</ul></li>
<li>there is a string literal named <code>_literal_1_test_p</code> that
is auto-created
<ul>
<li><code>cql_string_literal</code> can expand into a variety of things,
whatever you want “make a string literal” to mean</li>
<li>it’s defined in <code>cqlrt.h</code> and it’s designed to be
replaced</li>
</ul></li>
<li><code>cql_set_string_ref(&amp;arg, _literal_1_test_p);</code> is
expected to “retain” the string (+1 ref count)</li>
<li><code>cql_cleanup</code> is the exit label, this cleanup code will
run on all exit paths
<ul>
<li>cleanup statements are accumulated by writing to
<code>cg_cleanup_output</code> which usually writes to the
<code>proc_cleanup</code> buffer</li>
<li>because cleanup is in its own buffer you can add to it freely
whenever a new declaration that requires cleanup arises</li>
<li>in this case the declaration of the string variable caused the
<code>C</code> variable <code>arg</code> to be created and also the
cleanup code</li>
</ul></li>
<li>now we call <code>something_that_might_fail</code> passing it our
database pointer and the argument</li>
<li>the hidden <code>_db_</code> pointer is passed to all procedures
that use the database</li>
<li>these procedures are also the ones that can fail</li>
<li>any failed return code (not <code>SQLITE_OK</code>) causes two
things:
<ul>
<li>the <code>cql_error_trace()</code> macro is invoked (this macro
typically expands to nothing)</li>
<li>the code is redirected to the cleanup block via
<code>goto cql_cleanup;</code></li>
</ul></li>
</ul>
<p>The essential sequence is this one:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>The C code generator consistently uses this pattern to check if
anything went wrong and to exit with an error code. Extensive logging
can be very expensive, but in debug builds it’s quite normal for
<code>cql_error_trace</code> to expand into something like
<code>fprintf(stderr, "error %d in %s %s:%d\n", _rc_, _PROC_, __FILE__, __LINE_)</code>
which is probably a lot more logging than you want in a production build
but great if you’re debugging. Recall that CQL generates something like
<code>#define _PROC_ "p"</code> before every procedure.</p>
<p>This error pattern generalizes well and indeed if we use the
exception handling pattern, we get a lot of control. Let’s generalize
this example a tiny bit:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p (<span class="kw">OUT</span> success BOOL <span class="kw">NOT</span> <span class="kw">NULL</span>)</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>  LET arg <span class="op">:=</span> <span class="ot">&quot;test&quot;</span>;</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span> TRY</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CALL</span> something_that_might_fail(arg);</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> success <span class="op">:=</span> <span class="dv">1</span>;</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span> TRY;</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span> CATCH</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> success <span class="op">:=</span> <span class="dv">0</span>;</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span> CATCH;</span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>CQL doesn’t have complicated exception objects or anything like that,
exceptions are just simple control flow. Here’s the code for the
above:</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span> cql_bool <span class="op">*</span>_Nonnull success<span class="op">)</span> <span class="op">{</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>  cql_contract_argument_notnull<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>success<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>  cql_string_ref arg <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>success <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// set out arg to non-garbage</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;</span>arg<span class="op">,</span> _literal_1_test_p<span class="op">);</span></span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// try</span></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>    _rc_ <span class="op">=</span> something_that_might_fail<span class="op">(</span>_db_<span class="op">,</span> arg<span class="op">);</span></span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> catch_start_1<span class="op">;</span> <span class="op">}</span></span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>success <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb154-14"><a href="#cb154-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> catch_end_1<span class="op">;</span></span>
<span id="cb154-15"><a href="#cb154-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb154-16"><a href="#cb154-16" aria-hidden="true" tabindex="-1"></a>  catch_start_1<span class="op">:</span> <span class="op">{</span></span>
<span id="cb154-17"><a href="#cb154-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>success <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb154-18"><a href="#cb154-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb154-19"><a href="#cb154-19" aria-hidden="true" tabindex="-1"></a>  catch_end_1<span class="op">:;</span></span>
<span id="cb154-20"><a href="#cb154-20" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb154-21"><a href="#cb154-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-22"><a href="#cb154-22" aria-hidden="true" tabindex="-1"></a>  cql_string_release<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb154-23"><a href="#cb154-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb154-24"><a href="#cb154-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code in this case is nearly the same as the previous example.
Let’s look at the essential differences:</p>
<ul>
<li>If there is an error, <code>goto catch_start_1</code> will run</li>
<li>If the try block succeeds, <code>goto catch_end_1</code> will
run</li>
<li>both the <code>TRY</code> and <code>CATCH</code> branches set the
<code>success</code> out parameter</li>
<li>since an out argument was added, CQL generated an error check to
ensure that <code>success</code> is not null
<ul>
<li><code>cql_contract_argument_notnull((void *)success, 1)</code>, the
1 means “argument 1” and will appear in the error message if this test
fails</li>
<li>the hidden <code>_db_</code> argument doesn’t count for error
message purposes, so <code>success</code> is still the first
argument</li>
</ul></li>
</ul>
<p>How does this happen? Let’s look at <code>cg_trycatch_helper</code>
which does this work:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Very little magic is needed to do try/catch in our context.  The error</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="co">// handlers for all the sqlite calls check _rc_ and if it&#39;s an error they</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;goto&quot; the current error target.  That target is usually CQL_CLEANUP_DEFAULT_LABEL.</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Inside the try block, the cleanup handler is changed to the catch block.</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a><span class="co">// The catch block puts it back.  Otherwise, generate nested statements as usual.</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_trycatch_helper<span class="op">(</span>ast_node <span class="op">*</span>try_list<span class="op">,</span> ast_node <span class="op">*</span>try_extras<span class="op">,</span> ast_node <span class="op">*</span>catch_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>catch_start<span class="op">);</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>catch_end<span class="op">);</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We need unique labels for this block</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">++</span>catch_block_count<span class="op">;</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>catch_start<span class="op">,</span> <span class="st">&quot;catch_start_%d&quot;</span><span class="op">,</span> catch_block_count<span class="op">);</span></span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>catch_end<span class="op">,</span> <span class="st">&quot;catch_end_%d&quot;</span><span class="op">,</span> catch_block_count<span class="op">);</span></span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Divert the error target.</span></span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>  CSTR saved_error_target <span class="op">=</span> error_target<span class="op">;</span></span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a>  bool_t saved_error_target_used <span class="op">=</span> error_target_used<span class="op">;</span></span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a>  error_target <span class="op">=</span> catch_start<span class="op">.</span>ptr<span class="op">;</span></span>
<span id="cb155-19"><a href="#cb155-19" aria-hidden="true" tabindex="-1"></a>  error_target_used <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb155-20"><a href="#cb155-20" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span></span></code></pre></div>
<p>The secret is the <code>error_target</code> global variable. All of
the error handling will emit a goto <code>error_target</code> statement.
The try/catch pattern simply changes the current error target. The rest
of the code in the helper is just to save the current error target and
to create unique labels for the try/catch block.</p>
<p>The important notion is that, if anything goes wrong, whatever it is,
the generator simply does a <code>goto error_target</code> and that will
either hit the catch block or else go to cleanup.</p>
<p>The <code>THROW</code> operation illustrates this well:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Convert _rc_ into an error code.  If it already is one keep it.</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Then go to the current error target.</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_throw_stmt<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_throw_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;_rc_ = cql_best_error(%s);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> rcthrown_current<span class="op">);</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;goto %s;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> error_target<span class="op">);</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>  error_target_used <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>  rcthrown_used <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>first we make sure <code>_rc_</code> has some kind of error in it,
either <code>rcthrown_current</code> or else
<code>SQLITE_ERROR</code></li>
<li>then we go to the current error target</li>
<li><code>error_target_used</code> tracks whether if the error label was
used, this is just to avoid C compiler errors about unused labels.
<ul>
<li>if the label is not used it won’t be emitted</li>
<li>the code never jumps back to an error label, so we’ll always know if
the label was used before we need to emit it</li>
</ul></li>
</ul>
<p>Note: every catch block captures the value of <code>_rc_</code> in a
local variable whose name is in <code>rcthrown_current</code>. This
captured value is the current failing result code accessible by
<code>@RC</code> in CQL.</p>
<p>A catch block can therefore do stuff like:</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="cf">IF</span> @RC <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>  THROW;</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="cf">ELSE</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> attempt_retry();</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span> <span class="cf">IF</span>;</span></code></pre></div>
<p>This entire mechanism is built with basically just a few state
variables that nest. There is no complicated stack walking or anything
like that. All the code has to do is chain the error labels together and
let users create new catch blocks with new error labels. All that
together gives you very flexible try/catch behaviour with very little
overhead.</p>
<h3 id="string-literals">String Literals</h3>
<p>Before we move on to more complex statements we have to discuss
string literals a little bit. We’ve mentioned before that the compiler
is going to generate something like this:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>cql_string_literal<span class="op">(</span>_literal_1_test_p<span class="op">,</span> <span class="st">&quot;test&quot;</span><span class="op">);</span></span></code></pre></div>
<p>To create a reference counted object <code>_literal_1_test_p</code>
that it can use. Now we’re going to talk about how the text
<code>"test"</code> was created and how that gets more complicated.</p>
<p>The first thing to remember is that the generator creates C programs.
That means no matter what kind of literal we might be processing it’s
ending up encoded as a C string for the C compiler. The C compiler will
be the first thing the decodes the text the generator produces and puts
the byte we need into the final programs data segment or wherever. That
means if we have SQL format strings that need to go to SQLite they will
be twice-encoded, the SQL string is escaped as needed for SQLite and
<em>that</em> is escaped again for the C compiler.</p>
<p>An example might make this clearer consider the following SQL:</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SELECT</span> <span class="st">&#39;&quot;x</span><span class="ch">&#39;&#39;</span><span class="st">y&quot;&#39;</span> <span class="kw">AS</span> a, <span class="ot">&quot;&#39;y&#39;\n&quot;</span> <span class="kw">AS</span> b;</span></code></pre></div>
<p>The generated text for this statement will be:</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SELECT &#39;</span><span class="sc">\&quot;</span><span class="st">x&#39;&#39;y</span><span class="sc">\&quot;</span><span class="st">&#39;, &#39;&#39;&#39;y&#39;&#39;</span><span class="sc">\n</span><span class="st">&#39;&quot;</span></span></code></pre></div>
<p>Let’s review that in some detail:</p>
<ul>
<li>the first string “a” is a standard SQL string
<ul>
<li>it is represented unchanged in the AST, it is <em>not</em>
unescaped</li>
<li>even the outer single quotes are preserved, CQL has no need to
change it at all</li>
<li>when we emit it into our output it will be read by the C compiler,
so</li>
<li>at that time it is escaped <em>again</em> into C format
<ul>
<li>the double quotes which required no escaping in SQL become
<code>\"</code></li>
</ul></li>
<li>the single quote character requires no escape but there are still
two of them because SQLite will also process this string</li>
</ul></li>
<li>the second string “b” is a C formatted string literal
<ul>
<li>SQLite doesn’t support this format or its escapes, therefore</li>
<li>as discussed in <a href="https://cgsql.dev/cql-guide/int01">Part
1</a>, it is decoded to plain text, then re-encoded as a SQL escaped
string</li>
<li>internal newlines do not require escaping in SQL, they are in the
string as the newline character not ‘’ or anything like that
<ul>
<li>to be completely precise the byte value 0x0a is in the string
unescaped</li>
</ul></li>
<li>internal single quotes don’t require escaping in C, these have to be
doubled in a SQL string</li>
<li>the outer double quotes are removed and replaced by single quotes
during this process</li>
<li>the AST now has a valid SQL formatted string possibly with weird
characters in it</li>
<li>as before, this string has to be formatted for the C compiler so now
it has to be escaped again</li>
<li>the single quotes require no further processing, though now there
are quite a few of them</li>
<li>the embedded newline is converted to the escape sequence “” so we’re
back to sort of where we started
<ul>
<li>the C compiler will convert this back to the byte 0x0a which is what
ends up in the data segment</li>
</ul></li>
</ul></li>
</ul>
<p>In the above example we were making one overall string for the
<code>SELECT</code> statement so the outer double quotes are around the
whole statement. That was just for the convenience of this example. If
the literals had been in some other loose context then individual
strings would be produced the same way. Except, not so fast, not every
string literal is heading for SQLite. Some are just making regular
strings. In that case even if they are destined for SQLite they will go
as bound arguments to a statement not in the text of the SQL. That means
<em>those</em> strings do not need SQL escaping.</p>
<p>Consider:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>  LET a <span class="op">:=</span> <span class="st">&#39;&quot;x</span><span class="ch">&#39;&#39;</span><span class="st">y&quot;&#39;</span>;</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  LET b <span class="op">:=</span> <span class="ot">&quot;&#39;y&#39;\n&quot;</span>;</span></code></pre></div>
<p>To do those assignments we need:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>cql_string_literal<span class="op">(</span>_literal_1_x_y_p<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">x&#39;y</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>cql_string_literal<span class="op">(</span>_literal_2_y_p<span class="op">,</span> <span class="st">&quot;&#39;y&#39;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>In both of these cases the steps are:</p>
<ul>
<li>unescape the escaped SQL string in the AST to plain text
<ul>
<li>removing the outer single quotes of course</li>
</ul></li>
<li>re-escape the plain text (which might include newlines and such) as
a C string
<ul>
<li>emit that text, including its outer double quotes</li>
</ul></li>
</ul>
<p>Trivia: the name of the string literal variables include a fragment
of the string to make them a little easier to spot.</p>
<p><code>encoders.h</code> has the encoding functions *
<code>cg_decode_string_literal</code> *
<code>cg_encode_string_literal</code> *
<code>cg_encode_c_string_literal</code> *
<code>cg_decode_c_string_literal</code></p>
<p>As well as similar functions for single characters to make all this
possible. Pretty much every combination of encoding and re-encoding
happens in some path through the code generator.</p>
<h3 id="executing-sqlite-statements">Executing SQLite Statements</h3>
<p>By way of example let’s consider a pretty simple piece of SQL we
might want to run.</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> foo(<span class="kw">id</span> <span class="dt">INTEGER</span>, t TEXT);</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p (id_ <span class="dt">INTEGER</span>, t_ TEXT)</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">UPDATE</span> foo</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> t <span class="op">=</span> t_</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> <span class="kw">id</span> <span class="op">=</span> id_;</span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>To make this happen we’re going to have to do the following things: *
create a string literal with the statement we need * the references to
<code>id_</code> and <code>t_</code> have to be replaced with
<code>?</code> * we prepare that statement * we bind the values of
<code>id_</code> and <code>t_</code> * we <code>step</code> the
statement * we <code>finalize</code> the statement * suitable error
checks have to be done at each stage</p>
<p>That’s quite a bit of code and it’s easy to forget a step, this is an
area where CQL shines. The code we had to write in CQL was very clear
and all the error checking is implicit.</p>
<p>This is the generated code. We’ll walk through it and discuss how it
is created.</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>  sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>  cql_nullable_int32 id_<span class="op">,</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nullable t_<span class="op">)</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>_temp_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>_temp_stmt<span class="op">,</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;UPDATE foo &quot;</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SET t = ? &quot;</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;WHERE id = ?&quot;</span><span class="op">);</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>  cql_multibind<span class="op">(&amp;</span>_rc_<span class="op">,</span> _db_<span class="op">,</span> <span class="op">&amp;</span>_temp_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>                CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>id_<span class="op">,</span></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>                CQL_DATA_TYPE_STRING<span class="op">,</span> t_<span class="op">);</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>_temp_stmt<span class="op">);</span></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>_temp_stmt<span class="op">);</span></span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>_temp_stmt<span class="op">);</span></span>
<span id="cb164-24"><a href="#cb164-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb164-25"><a href="#cb164-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>the functions signature includes the hidden <code>_db_</code>
parameter plus the two arguments</li>
<li>we need a hidden <code>_rc_</code> variable to hold the result codes
from SQLite</li>
<li>we need a scratch <code>sqlite3_stmt *</code> named
<code>_temp_stmt</code> to talk to SQLite
<ul>
<li>when this is created, the cleanup section gets
<code>cql_finalize_stmt(&amp;_temp_stmt);</code></li>
<li><code>cql_finalize_stmt</code> sets the statement to null and does
nothing if it’s already null</li>
</ul></li>
<li>the string <code>"INSERT INTO foo(id, t) VALUES(?, ?)"</code> is
created from the AST
<ul>
<li>recall that we have <code>variables_callback</code> as an option,
it’s used here to track the variables and replace them with
<code>?</code></li>
<li>more on this shortly</li>
</ul></li>
<li><code>cql_multibind</code> is used to bind the values of
<code>id_</code> and <code>t_</code>
<ul>
<li>this is just a varargs version of the normal SQLite binding
functions, it’s only done this way to save space</li>
<li>only one error check is needed for any binding failure</li>
<li>the type of binding is encoded very economically</li>
<li>the “2” here refers to two arguments</li>
</ul></li>
<li>the usual error processing happens with <code>cql_error_trace</code>
and <code>goto cql_cleanup</code></li>
<li>the statement is executed with <code>sqlite3_step</code></li>
<li>temporary statements are finalized immediately with
<code>cql_finalize_stmt</code>
<ul>
<li>in this case its redundant because the code is going to fall through
to cleanup anyway</li>
<li>in general there could be many statements and we want to finalize
immediately</li>
<li>this is an optimization opportunity, procedures with just one
statement are very common</li>
</ul></li>
</ul>
<p>Most of these steps are actually hard coded. There is no variability
in the sequence after the <code>multibind</code> call, so that’s just
boiler-plate the compiler can inject.</p>
<p>We don’t want to declare <code>_temp_stmt</code> over and over so
there’s a flag that records whether it has already been declared in the
current procedure.</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Emit a declaration for the temporary statement _temp_stmt_ if we haven&#39;t</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="co">// already done so.  Also emit the cleanup once.</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> ensure_temp_statement<span class="op">()</span> <span class="op">{</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>temp_statement_emitted<span class="op">)</span> <span class="op">{</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_declarations_output<span class="op">,</span> <span class="st">&quot;sqlite3_stmt *_temp_stmt = NULL;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_cleanup_output<span class="op">,</span> <span class="st">&quot;  cql_finalize_stmt(&amp;_temp_stmt);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>    temp_statement_emitted <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is a great example of how, no matter where the processing
happens to be, the generator can emit things into the various sections.
Here it adds a declaration and an cleanup with no concern about what
else might be going on.</p>
<p>So most of the above is just boiler-plate, the tricky part is: *
getting the text of the SQL * binding the variables</p>
<p>All of this is the business of this function:</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is the most important function for sqlite access;  it does the heavy</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="co">// lifting of generating the C code to prepare and bind a SQL statement.</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a><span class="co">// If cg_exec is true (CG_EXEC) then the statement is executed immediately</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a><span class="co">// and finalized.  No results are expected.  To accomplish this we do the following:</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   * figure out the name of the statement, either it&#39;s given to us</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="co">//     or we&#39;re using the temp statement</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a><span class="co">//   * call get_statement_with_callback to get the text of the SQL from the AST</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a><span class="co">//     * the callback will give us all the variables to bind</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a><span class="co">//     * count the variables so we know what column numbers to use (the list is backwards!)</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a><span class="co">//   * if CG_EXEC and no variables we can use the simpler sqlite3_exec form</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a><span class="co">//   * bind any variables</span></span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true" tabindex="-1"></a><span class="co">//   * if there are variables CG_EXEC will step and finalize</span></span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_bound_sql_statement<span class="op">(</span>CSTR stmt_name<span class="op">,</span> ast_node <span class="op">*</span>stmt<span class="op">,</span> <span class="dt">int32_t</span> cg_flags<span class="op">)</span></span>
<span id="cb166-14"><a href="#cb166-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb166-15"><a href="#cb166-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb166-16"><a href="#cb166-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The core of this function looks like this:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>  gen_sql_callbacks callbacks<span class="op">;</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>  init_gen_sql_callbacks<span class="op">(&amp;</span>callbacks<span class="op">);</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>  callbacks<span class="op">.</span>variables_callback <span class="op">=</span> cg_capture_variables<span class="op">;</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>  callbacks<span class="op">.</span>variables_context <span class="op">=</span> <span class="op">&amp;</span>vars<span class="op">;</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... more flags</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>temp<span class="op">);</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>  gen_set_output_buffer<span class="op">(&amp;</span>temp<span class="op">);</span></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>  gen_statement_with_callbacks<span class="op">(</span>stmt<span class="op">,</span> <span class="op">&amp;</span>callbacks<span class="op">);</span></span></code></pre></div>
<p>It’s set up the callbacks for variables and it calls the echoing
function on the buffer. We’ve talked about
<code>gen_statement_with_callbacks</code> in <a
href="https://cgsql.dev/cql-guide/int01">Part 1</a>.</p>
<p>Let’s take a look at that callback function:</p>
<pre><code>// This is the callback method handed to the gen_ method that creates SQL for us
// it will call us every time it finds a variable that needs to be bound.  That
// variable is replaced by ? in the SQL output.  We end up with a list of variables
// to bind on a silver platter (but in reverse order).
static bool_t cg_capture_variables(ast_node *ast, void *context, charbuf *buffer) {
  list_item **head = (list_item**)context;
  add_item_to_list(head, ast);

  bprintf(buffer, &quot;?&quot;);
  return true;
}</code></pre>
<p>The <code>context</code> variable was set to be <code>vars</code>, we
convert it back to the correct type and add the current ast to that
list. <code>add_item_to_list</code> always puts things at the head so
the list will be in reverse order.</p>
<p>With this done, we’re pretty much set. We’ll produce the statement
with a sequence like this one (there are a couple of variations, but
this is the most general)</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;_rc_ = cql_prepare(_db_, %s%s_stmt,</span><span class="sc">\n</span><span class="st">  &quot;</span><span class="op">,</span> amp<span class="op">,</span> stmt_name<span class="op">);</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>  cg_pretty_quote_plaintext<span class="op">(</span>temp<span class="op">.</span>ptr<span class="op">,</span> cg_main_output<span class="op">,</span> PRETTY_QUOTE_C <span class="op">|</span> PRETTY_QUOTE_MULTI_LINE<span class="op">);</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p><code>cg_pretty_quote_plaintext</code> is one of the C string
encoding formats, it could have been just the regular C string encoding
but that would have been a bit wasteful and it wouldn’t have looked as
nice. This function does a little transform.</p>
<p>The normal echo of the update statement in question looks like
this:</p>
<pre><code>  UPDATE foo
  SET t = ?
    WHERE id = ?;</code></pre>
<p>Note that it has indenting and newlines embedded in it. The standard
encoding of that would look like this:</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;  UPDATE foo</span><span class="sc">\n</span><span class="st">  SET t = ?</span><span class="sc">\n</span><span class="st">    WHERE id = ?;&quot;</span></span></code></pre></div>
<p>That surely works, but it’s wasteful and ugly. The pretty format
instead produces:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;UPDATE foo &quot;</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SET t = ? &quot;</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;WHERE id = ?&quot;</span></span></code></pre></div>
<p>So, the newlines are gone from the string (they aren’t needed),
instead the string literal was broken into lines for readability. The
indenting is gone from the string, instead the string fragments are
indented. So what you get is a string literal that reads nicely but
doesn’t have unnecessary whitespace for SQLite. Obviously you can’t use
pretty-quoted literals in all cases, it’s exclusively for SQLite
formatting.</p>
<p>All that’s left to do is bind the arguments. Remember that arg list
is in reverse order:</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> vars<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">,</span> count<span class="op">++)</span> <span class="op">;</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>  reverse_list<span class="op">(&amp;</span>vars<span class="op">);</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;cql_multibind(&amp;_rc_, _db_, %s%s_stmt, %d&quot;</span><span class="op">,</span> amp<span class="op">,</span> stmt_name<span class="op">,</span> count<span class="op">);</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now emit the binding args for each variable</span></span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> vars<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">)</span>  <span class="op">{</span></span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>      Contract<span class="op">(</span>item<span class="op">-&gt;</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">              &quot;</span><span class="op">);</span></span>
<span id="cb173-15"><a href="#cb173-15" aria-hidden="true" tabindex="-1"></a>      cg_bind_column<span class="op">(</span>item<span class="op">-&gt;</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>sem_type<span class="op">,</span> item<span class="op">-&gt;</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb173-16"><a href="#cb173-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-17"><a href="#cb173-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-18"><a href="#cb173-18" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>cg_main_output<span class="op">,</span> <span class="st">&quot;);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb173-19"><a href="#cb173-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<ul>
<li>first compute the count, we don’t need to bind if there are no
variables</li>
<li><code>reverse_list</code> does exactly what is sounds like (finally
a real-world use-case for reverse-list-in-place)</li>
<li><code>cg_bind_column</code> creates one line of the var-args output:
column type and variable name
<ul>
<li>the type and name information is right there on the <code>AST</code>
in the <code>sem_node</code></li>
</ul></li>
</ul>
<p>And that’s it. With those few helpers we can bind any SQLite
statement the same way. All of the <code>DDL_STMT_INIT</code> and
<code>DML_STMT_INIT</code> statements are completely implemented by this
path.</p>
<h3 id="reading-single-values">Reading Single Values</h3>
<p>In many cases you need just one value</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p (id_ <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="kw">OUT</span> t_ TEXT)</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> t_ <span class="op">:=</span> ( <span class="kw">SELECT</span> t</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> foo</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> <span class="kw">id</span> <span class="op">=</span> id_ );</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>This is going to be very similar to the examples we’ve seen so
far:</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span> cql_int32 id_<span class="op">,</span> cql_string_ref _Nullable <span class="op">*</span>_Nonnull t_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>  cql_contract_argument_notnull<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>t_<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _tmp_text_0 <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>_temp_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">*(</span><span class="dt">void</span> <span class="op">**)</span>t_ <span class="op">=</span> NULL<span class="op">;</span> <span class="co">// set out arg to non-garbage</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>_temp_stmt<span class="op">,</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SELECT t &quot;</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;FROM foo &quot;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;WHERE id = ?&quot;</span><span class="op">);</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>  cql_multibind<span class="op">(&amp;</span>_rc_<span class="op">,</span> _db_<span class="op">,</span> <span class="op">&amp;</span>_temp_stmt<span class="op">,</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>                CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> id_<span class="op">);</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>_temp_stmt<span class="op">);</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>    cql_column_string_ref<span class="op">(</span>_temp_stmt<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>_tmp_text_0<span class="op">);</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>_temp_stmt<span class="op">);</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;*</span>t_<span class="op">,</span> _tmp_text_0<span class="op">);</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>  cql_string_release<span class="op">(</span>_tmp_text_0<span class="op">);</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>_temp_stmt<span class="op">);</span></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>_db_</code> : incoming arg for a procedure that uses the
database same as always, check</li>
<li><code>*(void **)t_ = NULL;</code> : out args are always set to NULL
on entry, note, there is no <code>release</code> here
<ul>
<li>argument is assumed to be garbage, that’s the ABI</li>
<li>if argument is non-garbage caller must release it first, that’s the
ABI</li>
</ul></li>
<li><code>_rc_</code> : same as always, check</li>
<li><code>_tmp_text_0</code> : new temporary text, including cleanup
(this could have been avoided)</li>
<li><code>_temp_stmt</code> : as before, including cleanup</li>
<li><code>cql_prepare</code> : same as always, check</li>
<li><code>cql_multibind</code> : just one integer bound this time</li>
<li><code>sqlite3_step</code> : as before, we’re stepping once, this
time we want the data</li>
<li><code>if (_rc_ != SQLITE_ROW)</code> new error check and goto
cleanup if no row
<ul>
<li>this is the same as the <code>IF NOTHING THROW</code> variant of
construct, that’s the default</li>
</ul></li>
<li><code>cql_column_string_ref</code> : reads one string from
<code>_temp_stmt</code></li>
<li><code>cql_finalize_stmt</code> : as before</li>
<li><code>cql_set_string_ref(&amp;*t_, _tmp_text_0)</code> : copy the
temporary string to the out arg
<ul>
<li>includes retain, out arg is NULL so <code>cql_set_string_ref</code>
will do no release</li>
<li>if this were (e.g.) running in a loop, the out arg would not be null
and there would be a release, as expected</li>
<li>if something else had previously set the out arg, again, there would
be a release as expected</li>
</ul></li>
</ul>
<p>There are variations of this form such as:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p (id_ <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="kw">OUT</span> t_ TEXT)</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SET</span> t_ <span class="op">:=</span> ( <span class="kw">SELECT</span> t</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> foo</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> <span class="kw">id</span> <span class="op">=</span> id_</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">IF</span> <span class="kw">NOTHING</span> <span class="st">&#39;&#39;</span>);</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>This simply changes the handling of the case where there is no row.
The that part of the code ends up looking like this:</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">==</span> SQLITE_ROW<span class="op">)</span> <span class="op">{</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>    cql_column_string_ref<span class="op">(</span>_temp_stmt<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>_tmp_text_1<span class="op">);</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>    cql_set_string_ref<span class="op">(&amp;</span>_tmp_text_0<span class="op">,</span> _tmp_text_1<span class="op">);</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>    cql_set_string_ref<span class="op">(&amp;</span>_tmp_text_0<span class="op">,</span> _literal_1_p<span class="op">);</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<ul>
<li>any error code leads to cleanup</li>
<li><code>SQLITE_ROW</code> : leads to the same fetch as before</li>
<li><code>SQLITE_DONE</code> : leads to the no row case which sets
<code>_tmp_text_0</code> to the empty string
<ul>
<li><code>cql_string_literal(_literal_1_p, "");</code> is included as a
data declaration</li>
</ul></li>
</ul>
<p>There is also the <code>IF NOTHING OR NULL</code> variant which is
left as an exercise to the reader. You can find all the flavors in
<code>cg_c.c</code> in the this function:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a nested select expression.  To evaluate we will</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a><span class="co">//  * prepare a temporary to hold the result</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a><span class="co">//  * generate the bound SQL statement</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a><span class="co">//  * extract the exactly one argument into the result variable</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a><span class="co">//    which is of exactly the right type</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a><span class="co">//  * use that variable as the result.</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a><span class="co">// The helper methods take care of sqlite error management.</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_expr_select<span class="op">(...</span></span></code></pre></div>
<p>This handles all of the <code>(select ...)</code> expressions and it
has the usual expression handler syntax. Another great example of a CQL
expressions that might require many C statements to implement.</p>
<h3 id="reading-rows-with-cursors">Reading Rows With Cursors</h3>
<p>This section is about the cases where we are expecting results back
from SQLite. By results here I mean the results of some kind of query,
not like a return code. SQLite does this by giving you a
<code>sqlite3_stmt *</code> which you can then use like a cursor to read
out a bunch of rows. So it should be no surprise that CQL cursors map
directly to SQLite statements.</p>
<p>Most of the code to get a statement we’ve already seen before, we
only saw the <code>_temp_stmt</code> case and we did very little with
it. Let’s look at the code for something a little bit more general and
we’ll see how little it takes to generalize.</p>
<p>First, let’s look at how a CQL cursor is initialized:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Now in this case there can only be one row in the result, but it
would be no different if there were more.</p>
<p>Here’s the C code:</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>C_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>  cql_bool _C_has_row_ <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>C_stmt<span class="op">,</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SELECT 1, 2&quot;</span><span class="op">);</span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>C_stmt<span class="op">);</span></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s look over that code very carefully and see what is necessary to
make it happen.</p>
<ul>
<li><code>_db_</code> : incoming arg for a procedure that uses the
database same as always, check</li>
<li><code>_rc_</code> : same as always, check</li>
<li><code>C_stmt</code> : we need to generate this instead of using
<code>_temp_stmt</code>
<ul>
<li><code>cql_finalize_stmt(&amp;C_stmt)</code> in cleanup, just like
<code>_temp_stmt</code></li>
</ul></li>
<li><code>cql_prepare</code> : same as always, check</li>
<li><code>cql_multibind</code> : could have been binding, not none
needed here, but same as always anyway, check</li>
<li>no step, no finalize (until cleanup) : that boiler-plate is
removed</li>
</ul>
<p>And that’s it, we now have a statement in <code>C_stmt</code> ready
to go. We’ll see later that <code>_C_has_row_</code> will track whether
or not the cursor has any data in it.</p>
<p>How do we make this happen? Well you could look at
<code>cg_declare_cursor</code> and your eye might hurt at first. The
truth is there are many kinds of cursors in CQL and this method handles
all of them. We’re going to go over the various flavors but for now
we’re only discussing the so-called “statement cursor”, so named because
it simply holds a SQLite statement. This was the first, and for a while
only, type of cursor added to the CQL language.</p>
<p>OK so how do we make a statement cursor. It’s once again
<code>cg_bound_sql_statement</code> just like so:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>cg_bound_sql_statement<span class="op">(</span>cursor_name<span class="op">,</span> select_stmt<span class="op">,</span> CG_PREPARE<span class="op">|</span>CG_MINIFY_ALIASES<span class="op">);</span></span></code></pre></div>
<p>The entire difference is that the first argument is the cursor name
rather than NULL. If you pass NULL it means use the temporary
statement.</p>
<p>And you’ll notice that even in this simple example the SQLite text
was altered a bit: the text that went to SQLite was
<code>"SELECT 1, 2"</code> – that’s CG_MINIFY_ALIASES at work. SQLite
didn’t need to see those column aliases, it makes no difference in the
result. Column aliases are often long and numerous. Even in this simple
example we saved 4 bytes. But the entire query was only 12 bytes long
(including trailing null) so that’s 25%. It’s not a huge savings in
general but it’s something.</p>
<p>The other flag <code>CG_PREPARE</code> tells the binder that it
should not step or finalize the query. The alternative is
<code>CG_EXEC</code> (which was used in the previous section for the
<code>UPDATE</code> example).</p>
<h3 id="fetching-data-from-cursors">Fetching Data From Cursors</h3>
<p>The first cursor reading primitive that was implemented as
<code>FETCH [cursor] INTO [variables]</code> and it’s the simplest to
understand so let’s start there.</p>
<p>We change the example just a bit:</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> x <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> y <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>  FETCH C <span class="kw">INTO</span> x, y;</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>For simplicity I will only include the code that is added. The rest
is the same.</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>  cql_int32 x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>  cql_int32 y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// same as before</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>  _C_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>  cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>Do to the <code>FETCH</code> we do the following:</p>
<ul>
<li>step the cursor</li>
<li>set the <code>_C_has_row_</code> variable so to indicate if we got a
row or not</li>
<li>use the varargs <code>cql_multifetch</code> to read 2 columns from
the cursor
<ul>
<li>this helper simply uses the usual <code>sqlite3_*_column</code>
functions to read the data out</li>
<li>again, we do it this way so that there is less error checking needed
in the generated code</li>
<li>also, there are fewer function calls so the code is overall
smaller</li>
<li>trivia: <code>multibind</code> and <code>multifetch</code> are
totally references to <em>The Fifth Element</em>
<ul>
<li>hence, they should be pronounced like Leeloo saying “multipass”</li>
</ul></li>
</ul></li>
<li><code>multifetch</code> uses the varargs to clobber the contents of
the target variables if there is no row according to
<code>_rc_</code></li>
<li><code>multifetch</code> uses the <code>CQL_DATA_TYPE_NOT_NULL</code>
to decide if it should ask SQLite first if the column is null</li>
</ul>
<p>So now this begs the question, in the CQL, how do you know if a row
was fetched or not?</p>
<p>The answer is, you can use the cursor name like a boolean. Let’s
complicate this up a little more.</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> <span class="kw">PROCEDURE</span> printf <span class="kw">NO</span> <span class="kw">CHECK</span>;</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> x <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> y <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>  FETCH C <span class="kw">INTO</span> x, y;</span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">WHILE</span> C</span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CALL</span> printf(<span class="ot">&quot;%d, %d\n&quot;</span>, x, y);</span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>    FETCH C <span class="kw">INTO</span> x, y;</span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Again here is what is now added, we’ve seen the <code>WHILE</code>
pattern before:</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!(</span>_C_has_row_<span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d, %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>    _C_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>    cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>So, if you use the cursors name in an ordinary expression that is
converted to a reference to the boolean <code>_C_has_row_</code>. Within
the loop we’re going to print some data and then fetch the next row. The
internal fetch is of course the same as the first.</p>
<p>The next improvement that was added to the language was the
<code>LOOP</code> statement. Let’s take a look:</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> x <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> y <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">LOOP</span> FETCH C <span class="kw">INTO</span> x, y</span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CALL</span> printf(<span class="ot">&quot;%d, %d\n&quot;</span>, x, y);</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>The generated code is very similar:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    _C_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>    cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>_C_has_row_<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d, %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>This is done by:</p>
<ul>
<li>emit the <code>for (;;) {</code> to start the loop</li>
<li>generate the <code>FETCH</code> just as if it was standalone</li>
<li>emit <code>if (!_C_has_row_) break;</code> (with the correct cursor
name)</li>
<li>use <code>cg_stmt_list</code> to emit the internal statement list
(<code>CALL printf</code> in this case)</li>
<li>close the loop with <code>}</code> and we’re done</li>
</ul>
<h3 id="cursors-with-storage">Cursors With Storage</h3>
<p>We now come to the big motivating reasons for having the notion of
shapes in the CQL language. This particular case was the first such
example in the language and it’s very commonly used and saves you a lot
of typing. Like the other examples it’s only sugar in that it doesn’t
give you any new language powers you didn’t have, but it does give
clarity and maintenance advantages. And it’s just a lot less to
type.</p>
<p>Let’s go back to one of the earlier examples, but write it the modern
way:</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>  FETCH C;</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>And the generated C code:</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_C_row <span class="op">{</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 x<span class="op">;</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_C_row<span class="op">;</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>C_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a>  p_C_row C <span class="op">=</span> <span class="op">{</span> <span class="dv">0</span> <span class="op">};</span></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>C_stmt<span class="op">,</span></span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SELECT 1, 2&quot;</span><span class="op">);</span></span>
<span id="cb189-16"><a href="#cb189-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb189-17"><a href="#cb189-17" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb189-18"><a href="#cb189-18" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb189-19"><a href="#cb189-19" aria-hidden="true" tabindex="-1"></a>  cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb189-20"><a href="#cb189-20" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb189-21"><a href="#cb189-21" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb189-22"><a href="#cb189-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb189-23"><a href="#cb189-23" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb189-24"><a href="#cb189-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-25"><a href="#cb189-25" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb189-26"><a href="#cb189-26" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>C_stmt<span class="op">);</span></span>
<span id="cb189-27"><a href="#cb189-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb189-28"><a href="#cb189-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s look at what’s different here:</p>
<ul>
<li><code>struct p_C_row</code> has been created, it contains:
<ul>
<li><code>_has_row_</code> for the cursor</li>
<li><code>x</code> and <code>y</code> the data fields</li>
<li><code>_refs_count</code> the number of reference fields in the
cursor (0 in this case)</li>
<li><code>_refs_offset</code> the offset of the references fields (they
always go at the end)</li>
<li>because the references are together a cursor with lots of reference
fields can be cleaned up easily</li>
</ul></li>
<li>in the generated code the variable <code>C</code> refers to the
current data that has been fetched
<ul>
<li>convenient for debugging <code>p C</code> in lldb shows you the
row</li>
</ul></li>
<li>references to <code>x</code> and <code>y</code> became
<code>C.x</code> and <code>C.y</code></li>
<li>references to <code>_C_has_row_</code> became
<code>C._has_row_</code></li>
</ul>
<p>That’s pretty much it. The beauty of this is that you can’t get the
declarations of your locals wrong and you don’t have to list them all no
matter how big the data is. If the data shape changes the cursor change
automatically changes to accommodate it. Everything is still statically
typed.</p>
<p>Now lets look at the loop pattern:</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">LOOP</span> FETCH C</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CALL</span> printf(<span class="ot">&quot;%d, %d\n&quot;</span>, C.x, C.y);</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Note that the columns of the cursor were defined by the column
aliases of the <code>SELECT</code>.</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>    cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>C<span class="op">.</span>_has_row_<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d, %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> C<span class="op">.</span>x<span class="op">,</span> C<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>The loop is basically the same except <code>x</code> and
<code>y</code> have been replaced with <code>C.x</code> and
<code>C.y</code> and again <code>_C_has_row_</code> is now
<code>C._has_row_</code>.</p>
<p>The code generator knows that it should allocate storage for the
<code>C</code> cursor if it has the flag
<code>SEM_TYPE_HAS_SHAPE_STORAGE</code> on it. The semantic analyzer
adds that flag if it ever finds <code>FETCH C</code> with no
<code>INTO</code> part.</p>
<p>Finally let’s look at an example with cleanup required. We’ll just
change the test case a tiny bit.</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x, <span class="ot">&quot;2&quot;</span> <span class="kw">AS</span> y;</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">LOOP</span> FETCH C</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CALL</span> printf(<span class="ot">&quot;%d, %s\n&quot;</span>, C.x, C.y);</span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>The <code>x</code> column is now text. We’ll get this code which will
be studied below:</p>
<pre><code>typedef struct p_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 y;
  cql_string_ref _Nonnull x;
} p_C_row;

#define p_C_refs_offset cql_offsetof(p_C_row, x) // count = 1

CQL_WARN_UNUSED cql_code p(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  sqlite3_stmt *C_stmt = NULL;
  p_C_row C = { ._refs_count_ = 1, ._refs_offset_ = p_C_refs_offset };

  _rc_ = cql_prepare(_db_, &amp;C_stmt,
    &quot;SELECT &#39;1&#39;, 2&quot;);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &amp;C.x,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &amp;C.y);
    if (_rc_ != SQLITE_ROW &amp;&amp; _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C._has_row_) break;
    cql_alloc_cstr(_cstr_1, C.x);
    printf(&quot;%s, %d\n&quot;, _cstr_1, C.y);
    cql_free_cstr(_cstr_1, C.x);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_finalize_stmt(&amp;C_stmt);
  cql_teardown_row(C);
  return _rc_;
}</code></pre>
<p>It’s very similar to what we had before, let’s quickly review the
differences.</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_C_row <span class="op">{</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_C_row<span class="op">;</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_C_refs_offset cql_offsetof(p_C_row, x) </span><span class="co">// count = 1</span></span></code></pre></div>
<ul>
<li><code>x</code> is now <code>cql_string_ref _Nonnull x;</code> rather
than <code>cql_int32</code></li>
<li><code>x</code> has moved to the end (because it’s a reference
type)</li>
<li>the offset of the first ref is computed in a constant</li>
</ul>
<p>Recall the reference types are always at the end and together.</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>  p_C_row C <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">.</span>_refs_offset_ <span class="op">=</span> p_C_refs_offset <span class="op">};</span></span></code></pre></div>
<ul>
<li><code>p_C_row</code> is now initialized to to ref count 1 and refs
offset <code>p_C_refs_offset</code> defined above</li>
</ul>
<div class="sourceCode" id="cb196"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>  cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_STRING<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>y<span class="op">);</span></span></code></pre></div>
<ul>
<li>C.x is now of type string</li>
</ul>
<div class="sourceCode" id="cb197"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>    cql_alloc_cstr<span class="op">(</span>_cstr_1<span class="op">,</span> C<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%s, %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> _cstr_1<span class="op">,</span> C<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    cql_free_cstr<span class="op">(</span>_cstr_1<span class="op">,</span> C<span class="op">.</span>x<span class="op">);</span></span></code></pre></div>
<ul>
<li>C.x has to be converted to a C style string before it can be used
with <code>printf</code> as a <code>%s</code> argument</li>
</ul>
<div class="sourceCode" id="cb198"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>C<span class="op">);</span></span></code></pre></div>
<ul>
<li>the cleanup section has to include code to teardown the cursor, this
will release all of its reference variables in bulk
<ul>
<li>remember we know the count, and the offset of the first one – that’s
all we need to do them all</li>
</ul></li>
</ul>
<p>With these primitives we can easily create cursors of any shape and
load them up with data. We don’t have to redundantly declare locals that
match the shape of our select statements which is both error prone and a
hassle.</p>
<p>All of this is actually very easy for the code-generator. The
semantic analysis phase knows if the cursor needs shape storage. And it
also recognizes when a variable reference like <code>C.x</code> happens,
the variable references are re-written in the AST so that the
code-generator doesn’t even have to know there was a cursor reference,
from its perspective the variable IS <code>C.x</code> (which it sort of
is). The code generator does have to create the storage for the cursor
but it knows it should do so because the cursor variable is marked with
<code>SEM_TYPE_HAS_SHAPE_STORAGE</code>. A cursor without this marking
only gets its statement (but not always as we’ll see later) and its
<code>_cursor_has_row_</code> hidden variable.</p>
<h3 id="flowing-sqlite-statements-between-procedures">Flowing SQLite
Statements Between Procedures</h3>
<p>Earlier we saw that we can get a cursor from a SQLite
<code>SELECT</code> statement. The cursor is used to iterate over the
<code>sqlite3_stmt *</code> that SQLite provides to us. This process can
be done between procedures. Here’s a simple example:</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="ot">@ATTRIBUTE(cql:private)</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC q ()</span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SELECT</span> <span class="ot">&quot;1&quot;</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>This is the first example of a procedure that return a result set
that we’ve seen. The wiring for this is very simple.</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> CQL_WARN_UNUSED cql_code q<span class="op">(</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>  sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>_Nullable <span class="op">*</span>_Nonnull _result_stmt<span class="op">)</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>_result_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> _result_stmt<span class="op">,</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SELECT &#39;1&#39;, 2&quot;</span><span class="op">);</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">==</span> SQLITE_OK <span class="op">&amp;&amp;</span> <span class="op">!*</span>_result_stmt<span class="op">)</span> _rc_ <span class="op">=</span> cql_no_rows_stmt<span class="op">(</span>_db_<span class="op">,</span> _result_stmt<span class="op">);</span></span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>First note that there are now <em>two</em> hidden parameters to
<code>q</code>:</p>
<ul>
<li><code>_db_</code> : the database pointer as usual,</li>
<li><code>_result_stmt</code> : the statement produced by this
procedure</li>
</ul>
<p>The rest of the code is just like any other bound SQL statement. Note
that if <code>_result_stmt</code> isn’t otherwise set by the code it
will be initialized to a statement that will return zero rows.</p>
<p>All of this is pretty much old news except for the new hidden
variable. Note let’s look how we might use this. We can write a
procedure that calls <code>q</code>, like so:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">CALL</span> q();</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>  FETCH C;</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>This generates:</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>C_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>  p_C_row C <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">.</span>_refs_offset_ <span class="op">=</span> p_C_refs_offset <span class="op">};</span></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> q<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>C_stmt<span class="op">);</span></span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> sqlite3_step<span class="op">(</span>C_stmt<span class="op">);</span></span>
<span id="cb202-9"><a href="#cb202-9" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>_has_row_ <span class="op">=</span> _rc_ <span class="op">==</span> SQLITE_ROW<span class="op">;</span></span>
<span id="cb202-10"><a href="#cb202-10" aria-hidden="true" tabindex="-1"></a>  cql_multifetch<span class="op">(</span>_rc_<span class="op">,</span> C_stmt<span class="op">,</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb202-11"><a href="#cb202-11" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_STRING<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb202-12"><a href="#cb202-12" aria-hidden="true" tabindex="-1"></a>                 CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb202-13"><a href="#cb202-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_ROW <span class="op">&amp;&amp;</span> _rc_ <span class="op">!=</span> SQLITE_DONE<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb202-14"><a href="#cb202-14" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb202-15"><a href="#cb202-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-16"><a href="#cb202-16" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb202-17"><a href="#cb202-17" aria-hidden="true" tabindex="-1"></a>  cql_finalize_stmt<span class="op">(&amp;</span>C_stmt<span class="op">);</span></span>
<span id="cb202-18"><a href="#cb202-18" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb202-19"><a href="#cb202-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb202-20"><a href="#cb202-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>All of the above is <em>exactly</em> the same as the previous cases
where we got data from the database except that instead of using
<code>cql_prepare</code> the compiler produced
<code>_rc_ = q(_db_, &amp;C_stmt);</code> That function call gives us,
of course, a ready-to-use <code>sqlite3_stmt *</code> which we can then
step, and use to fetch values. The shape of the cursor <code>C</code> is
determined by the result type of procedure <code>q</code> – hence they
always match.</p>
<p>If q was in some other module, it could be declared with:</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> PROC q () (x TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>, y <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>);</span></code></pre></div>
<p>This is a procedure that takes no arguments and returns a result with
the indicated shape.</p>
<p>CQL can generate this declaration for you if you add
<code>--generate_exports</code> to the command line. Note that in this
case <code>q</code> was marked with <code>@attribute(cql:private)</code>
which caused <code>q</code> to be <code>static</code> in the output.
Hence it can’t be called outside this translation unit and
<code>--generate_exports</code> won’t provide the declaration.</p>
<p>If the private annotation were removed, the full exports for this
file would be:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> PROC q () (x TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>, y <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>);</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> PROC p () <span class="kw">USING</span> <span class="kw">TRANSACTION</span>;</span></code></pre></div>
<p>And these would allow calling both procedures from elsewhere. Simply
<code>#include</code> the exports file.</p>
<p>There is a special function in the echoing code that can emit a
procedure that was created in the form that is needed to declare it,
this is <code>gen_declare_proc_from_create_proc</code>.</p>
<h3 id="value-cursors">Value Cursors</h3>
<p>Once CQL had the ability to fetch rows into a cursor with no need to
declare all the locals it was clear that it could benefit from the
ability to save a copy of any given row. That is basic cursor operations
seemed like they should be part of the calculus of CQL. Here’s a simple
sample program that illustrates this.</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">SELECT</span> <span class="ot">&quot;1&quot;</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>  FETCH C;</span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> D <span class="kw">CURSOR</span> <span class="kw">LIKE</span> C;</span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>  FETCH D <span class="kw">from</span> C;</span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>We already have a good idea what is going to happen with
<code>C</code> in this program. Let’s look at the generated code
focusing just on the parts that involve <code>D</code>.</p>
<p>First there is a row defintion for <code>D</code>. Unsurprisingly it
is exactly the samea as the one for <code>C</code>. This must be the
case since we specified <code>D CURSOR LIKE C</code>.</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_D_row <span class="op">{</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_D_row<span class="op">;</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_D_refs_offset cql_offsetof(p_D_row, x) </span><span class="co">// count = 1</span></span></code></pre></div>
<p>Then the <code>D</code> cursor variables will be needed:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>p_D_row D <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">.</span>_refs_offset_ <span class="op">=</span> p_D_refs_offset <span class="op">};</span></span></code></pre></div>
<p>The above also implies the cleanup code:</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>D<span class="op">);</span></span></code></pre></div>
<p>finally, we fetch <code>D</code> from <code>C</code>. That’s just
some assignments:</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>  D<span class="op">.</span>_has_row_ <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;</span>D<span class="op">.</span>x<span class="op">,</span> C<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>  D<span class="op">.</span>y <span class="op">=</span> C<span class="op">.</span>y<span class="op">;</span></span></code></pre></div>
<p>Importantly, there is no <code>D_stmt</code> variable. <code>D</code>
is <em>not</em> a statement cursor like <code>C</code>, it’s a so-called
“value” cursor. In that it can only hold values.</p>
<p>A value cursor can actually be loaded from anywhere, it just holds
data. You don’t loop over it (attempts to do so will result in
errors).</p>
<p>The general syntax for loading such a cursor is something like
this:</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a> FETCH D(x, y) <span class="kw">FROM</span> <span class="kw">VALUES</span>(C.x, C.y);</span></code></pre></div>
<p>And indeed the form <code>FETCH D FROM C</code> was rewritten
automatically into the general form. The short form is just sugar.</p>
<p>Once loaded, <code>D.x</code> and <code>D.y</code> can be used as
always. The data type of <code>D</code> is similar to
<code>C</code>.</p>
<p>The AST would report:</p>
<pre><code>{declare_cursor_like_name}: D: select: { x: text notnull, y: integer notnull }
   variable shape_storage value_cursor</code></pre>
<p>meaning <code>D</code> has the flags <code>SEM_TYPE_STRUCT</code>,
<code>SEM_TYPE_VARIABLE</code>, <code>SEM_TYPE_HAS_SHAPE_STORAGE</code>,
and <code>SEM_TYPE_VALUE_CURSOR</code>. That last flag indicates that
there is no statement for this cursor, it’s just values. And all such
cursors must have <code>SEM_TYPE_HAS_SHAPE_STORAGE</code> – if they had
no statement and no storage they would be – nothing.</p>
<p>Value cursors are enormously helpful and there is sugar for loading
them from all kinds of sources with a shape. These forms are described
more properly in <a href="https://cgsql.dev/cql-guide/ch05">Chapter
5</a> of the Guide but they all end up going through the general form,
making the codegen considerably simpler. There are many examples where
the semantic analyzer rewrites a sugar form to a canonical form to keep
the codegen from forking into dozens of special cases and most of them
have to do with shapes and cursors.</p>
<h3 id="returning-value-cursors">Returning Value Cursors</h3>
<p>Let’s look at an example that is similar to the previous one:</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="ot">@ATTRIBUTE(cql:private)</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC q ()</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="kw">LIKE</span> <span class="kw">SELECT</span> <span class="ot">&quot;1&quot;</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>  FETCH C <span class="kw">USING</span></span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;foo&quot;</span> x,</span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a>   <span class="dv">3</span> y;</span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">OUT</span> C;</span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb212-12"><a href="#cb212-12" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb212-13"><a href="#cb212-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> FETCH <span class="kw">FROM</span> <span class="kw">CALL</span> q();</span>
<span id="cb212-14"><a href="#cb212-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- do something with C</span></span>
<span id="cb212-15"><a href="#cb212-15" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Let’s discuss some of what is above, first looking at
<code>q</code>:</p>
<ul>
<li><code>DECLARE C CURSOR LIKE SELECT "1" AS x, 2 AS y;</code> : this
makes an empty value cursor
<ul>
<li>note the shape is <code>LIKE</code> the indicated
<code>SELECT</code>, the <code>SELECT</code> does not actually run</li>
</ul></li>
<li><code>FETCH ... USING</code> : this form is sugar, it lets you put
the column names <code>x</code> and <code>y</code> adjacent to the
values but is otherwise equivalent to the canonical form
<ul>
<li><code>FETCH C(x, y) FROM VALUES("foo", 3);</code> is the canonical
form</li>
<li>codegen only ever sees the canonical form</li>
</ul></li>
<li><code>OUT C</code> is new, we’ll cover this shortly</li>
</ul>
<p>Now let’s look at the C for <code>q</code></p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> q_row <span class="op">{</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> q_row<span class="op">;</span></span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define q_refs_offset cql_offsetof(q_row, x) </span><span class="co">// count = 1</span></span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a>cql_string_literal<span class="op">(</span>_literal_1_foo_q<span class="op">,</span> <span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> q_C_row <span class="op">{</span></span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb213-18"><a href="#cb213-18" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb213-19"><a href="#cb213-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> q_C_row<span class="op">;</span></span>
<span id="cb213-20"><a href="#cb213-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-21"><a href="#cb213-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#define q_C_refs_offset cql_offsetof(q_C_row, x) </span><span class="co">// count = 1</span></span>
<span id="cb213-22"><a href="#cb213-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-23"><a href="#cb213-23" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> q<span class="op">(</span>q_row <span class="op">*</span>_Nonnull _result_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb213-24"><a href="#cb213-24" aria-hidden="true" tabindex="-1"></a>  memset<span class="op">(</span>_result_<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(*</span>_result_<span class="op">));</span></span>
<span id="cb213-25"><a href="#cb213-25" aria-hidden="true" tabindex="-1"></a>  q_C_row C <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">.</span>_refs_offset_ <span class="op">=</span> q_C_refs_offset <span class="op">};</span></span>
<span id="cb213-26"><a href="#cb213-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-27"><a href="#cb213-27" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>_has_row_ <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb213-28"><a href="#cb213-28" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;</span>C<span class="op">.</span>x<span class="op">,</span> _literal_1_foo_q<span class="op">);</span></span>
<span id="cb213-29"><a href="#cb213-29" aria-hidden="true" tabindex="-1"></a>  C<span class="op">.</span>y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb213-30"><a href="#cb213-30" aria-hidden="true" tabindex="-1"></a>  _result_<span class="op">-&gt;</span>_has_row_ <span class="op">=</span> C<span class="op">.</span>_has_row_<span class="op">;</span></span>
<span id="cb213-31"><a href="#cb213-31" aria-hidden="true" tabindex="-1"></a>  _result_<span class="op">-&gt;</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb213-32"><a href="#cb213-32" aria-hidden="true" tabindex="-1"></a>  _result_<span class="op">-&gt;</span>_refs_offset_ <span class="op">=</span> q_refs_offset<span class="op">;</span></span>
<span id="cb213-33"><a href="#cb213-33" aria-hidden="true" tabindex="-1"></a>  cql_set_string_ref<span class="op">(&amp;</span>_result_<span class="op">-&gt;</span>x<span class="op">,</span> C<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb213-34"><a href="#cb213-34" aria-hidden="true" tabindex="-1"></a>  _result_<span class="op">-&gt;</span>y <span class="op">=</span> C<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb213-35"><a href="#cb213-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-36"><a href="#cb213-36" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb213-37"><a href="#cb213-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>the <code>_result_</code> variable is clobbed with zeros, it is
assumed to be junk coming in
<ul>
<li>if it had valid data, the caller is expected to use
<code>cql_teardown_row</code> to clean it up <em>before</em>
calling</li>
</ul></li>
<li><code>q_row</code> : this is new, this is the structure type for the
result of <code>q</code>
<ul>
<li>it’s exactly the same shape as C</li>
<li>it has its own <code>q_refs_offset</code> like other shapes</li>
</ul></li>
<li><code>q_C_row</code> : this is the same old same old row structure
for cursor C</li>
<li><code>static void q(q_row *_Nonnull _result_)</code> : q now accepts
a q_row to fill in!
<ul>
<li>note that <code>q</code> does not have the <code>_db_</code>
parameter, it doesn’t use the database!</li>
<li>it is entirely possible to fill value cursors from non-database
sources, e.g. constants, math, whatever</li>
</ul></li>
<li><code>C</code> : the value cursor is declared as usual</li>
<li><code>C.x</code> and <code>C.y</code> are loaded, this resolves the
<code>FETCH</code> statement</li>
<li>the <code>_result_</code> fields are copied from <code>C</code>,
this resolves the <code>OUT</code> statement</li>
<li><code>C</code> can be torn down</li>
<li>there is no cleanup label, there are no error cases, nothing can go
wrong!</li>
</ul>
<p>The net of all this is that we have loaded a value cursor that was
passed in to the procedure via a hidden argument and it has retained
references as appropriate.</p>
<p>Now let’s look at <code>p</code>:</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_C_row <span class="op">{</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_C_row<span class="op">;</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_C_refs_offset cql_offsetof(p_C_row, x) </span><span class="co">// count = 1</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> p<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>  p_C_row C <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>_refs_count_ <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="op">.</span>_refs_offset_ <span class="op">=</span> p_C_refs_offset <span class="op">};</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>  q<span class="op">((</span>q_row <span class="op">*)&amp;</span>C<span class="op">);</span> <span class="co">// q_row identical to cursor type</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// usually you do something with C at this point</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>  cql_teardown_row<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>p_C_row</code> : the cursor type for <code>C</code> in the
procedure <code>p</code> is defined</li>
<li><code>p_C_refs_offset</code> : the refs offset for <code>C</code> in
<code>p</code> as usual</li>
<li><code>C = {...}</code> : the usual initialization for a cursor with
shape
<ul>
<li>note that <code>C</code> is a value cursor, so it has no
<code>C_stmt</code></li>
</ul></li>
<li><code>cql_teardown_row(C)</code> : releases any references in C,
there are none
<ul>
<li>this pattern is general purpose, the call to <code>q</code> might be
in a loop or something</li>
<li>in this instance the teardown here is totally redundant, but
harmless</li>
</ul></li>
<li><code>q((q_row *)&amp;C)</code> : fetch <code>C</code> by calling
<code>q</code>
<ul>
<li><code>p_C_row</code> has been constructed to be exactly the same as
<code>q_row</code> so this cast is safe</li>
<li>there are no error checks because <code>q</code> can’t fail!</li>
</ul></li>
<li>some code that would use <code>C</code> is absent for this sample,
it would go where the comment is</li>
<li>the cleanup label is missing because there are no error cases,
emitting the label would just cause warnings
<ul>
<li>such warnings are often escalated to errors in production
builds…</li>
</ul></li>
<li><code>cql_teardown_row(C)</code> is needed as always,
<ul>
<li>even though there is no cleanup label the <code>teardown</code> is
in the cleanup section</li>
<li>the <code>teardown</code> was added as usual when <code>C</code> was
declared</li>
</ul></li>
</ul>
<p>So with just normal value cursor codegen we can pretty easily create
a situation where procedures can move structures from one to another. As
we saw, the source of value cursors may or may not be the database.
Value cursors are frequently invaluable in test code as they can easily
hold mock rows based on any kind of computation.</p>
<h3 id="result-sets">Result Sets</h3>
<p>In addition to returning a single row into a value cursor, or
returning a statement to consume with a statement cursor, it’s possible
to generate a result set. So far the samples have included
<code>@attribute(cql:private)</code> to suppress that code. This pattern
is intended to let regular C code access the data so
<code>private</code> suppresses it.</p>
<p>Let’s consider a simple example, this example returns only one row
but the mechanism works for any number of rows, we’re just using this
form because it’s what we’ve used so far and its simple. Let’s
begin:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p ()</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">SELECT</span> <span class="ot">&quot;1&quot;</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>The core generated function is this one:</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span> sqlite3_stmt <span class="op">*</span>_Nullable <span class="op">*</span>_Nonnull _result_stmt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>_result_stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> cql_prepare<span class="op">(</span>_db_<span class="op">,</span> _result_stmt<span class="op">,</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;SELECT &#39;1&#39;, 2&quot;</span><span class="op">);</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">!=</span> SQLITE_OK<span class="op">)</span> <span class="op">{</span> cql_error_trace<span class="op">();</span> <span class="cf">goto</span> cql_cleanup<span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a>cql_cleanup<span class="op">:</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>_rc_ <span class="op">==</span> SQLITE_OK <span class="op">&amp;&amp;</span> <span class="op">!*</span>_result_stmt<span class="op">)</span> _rc_ <span class="op">=</span> cql_no_rows_stmt<span class="op">(</span>_db_<span class="op">,</span> _result_stmt<span class="op">);</span></span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We’ve seen this before, it creates the SQLite statement. But that
isn’t all the code that was generated, let’s have a look at what else we
got in our outputs:</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p_fetch_results<span class="op">(</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>  sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>  p_result_set_ref _Nullable <span class="op">*</span>_Nonnull result_set<span class="op">)</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>  sqlite3_stmt <span class="op">*</span>stmt <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>  cql_profile_start<span class="op">(</span>CRC_p<span class="op">,</span> <span class="op">&amp;</span>p_perf_index<span class="op">);</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>  cql_code rc <span class="op">=</span> p<span class="op">(</span>_db_<span class="op">,</span> <span class="op">&amp;</span>stmt<span class="op">);</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>  cql_fetch_info info <span class="op">=</span> <span class="op">{</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>rc <span class="op">=</span> rc<span class="op">,</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>db <span class="op">=</span> _db_<span class="op">,</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>stmt <span class="op">=</span> stmt<span class="op">,</span></span>
<span id="cb217-12"><a href="#cb217-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>data_types <span class="op">=</span> p_data_types<span class="op">,</span></span>
<span id="cb217-13"><a href="#cb217-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>col_offsets <span class="op">=</span> p_col_offsets<span class="op">,</span></span>
<span id="cb217-14"><a href="#cb217-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>refs_count <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb217-15"><a href="#cb217-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>refs_offset <span class="op">=</span> p_refs_offset<span class="op">,</span></span>
<span id="cb217-16"><a href="#cb217-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>encode_context_index <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb217-17"><a href="#cb217-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>rowsize <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>p_row<span class="op">),</span></span>
<span id="cb217-18"><a href="#cb217-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>crc <span class="op">=</span> CRC_p<span class="op">,</span></span>
<span id="cb217-19"><a href="#cb217-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>perf_index <span class="op">=</span> <span class="op">&amp;</span>p_perf_index<span class="op">,</span></span>
<span id="cb217-20"><a href="#cb217-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb217-21"><a href="#cb217-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cql_fetch_all_results<span class="op">(&amp;</span>info<span class="op">,</span> <span class="op">(</span>cql_result_set_ref <span class="op">*)</span>result_set<span class="op">);</span></span>
<span id="cb217-22"><a href="#cb217-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>p_fetch_results</code> does two main things:</p>
<ul>
<li><code>cql_code rc = p(_db_, &amp;stmt)</code> : it calls the
underlying function to get the statement</li>
<li><code>cql_fetch_all_results</code> : it calls a standard helper to
read all the results from the statement and put them into
<code>result_set</code>
<ul>
<li>to do the fetch, it sets up a <code>cql_fetch_info</code> for this
result set, this has all the information needed to do the fetch</li>
<li>the intent here is that even a complex fetch with lots of columns
can be done economically, and</li>
<li>the code that does the fetching is shared</li>
</ul></li>
</ul>
<p>Let’s look at the things that are needed to load up that
<code>info</code> structure.</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_row <span class="op">{</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>  cql_int32 y<span class="op">;</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>  cql_string_ref _Nonnull x<span class="op">;</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_row<span class="op">;</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a><span class="dt">uint8_t</span> p_data_types<span class="op">[</span>p_data_types_count<span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a>  CQL_DATA_TYPE_STRING <span class="op">|</span> CQL_DATA_TYPE_NOT_NULL<span class="op">,</span> <span class="co">// x</span></span>
<span id="cb218-8"><a href="#cb218-8" aria-hidden="true" tabindex="-1"></a>  CQL_DATA_TYPE_INT32 <span class="op">|</span> CQL_DATA_TYPE_NOT_NULL<span class="op">,</span> <span class="co">// y</span></span>
<span id="cb218-9"><a href="#cb218-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb218-10"><a href="#cb218-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-11"><a href="#cb218-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_refs_offset cql_offsetof(p_row, x) </span><span class="co">// count = 1</span></span>
<span id="cb218-12"><a href="#cb218-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-13"><a href="#cb218-13" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> cql_uint16 p_col_offsets<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb218-14"><a href="#cb218-14" aria-hidden="true" tabindex="-1"></a>  cql_offsetof<span class="op">(</span>p_row<span class="op">,</span> x<span class="op">),</span></span>
<span id="cb218-15"><a href="#cb218-15" aria-hidden="true" tabindex="-1"></a>  cql_offsetof<span class="op">(</span>p_row<span class="op">,</span> y<span class="op">)</span></span>
<span id="cb218-16"><a href="#cb218-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<ul>
<li><code>p_row</code> : the row structure for this result set, same as
always, reference types last</li>
<li><code>p_data_types</code> : an array with the data types encoded as
bytes</li>
<li><code>p_refs_offset</code> : the offset of the first reference
type</li>
<li><code>p_col_offsets</code> : this is the offset of each column
within the row structure
<ul>
<li>these are in column order, not offset order</li>
</ul></li>
</ul>
<p>Code generation creates a <code>.c</code> file and a <code>.h</code>
file, we haven’t talked much about the <code>.h</code> because it’s
mostly prototypes for the functions in the <code>.c</code> file. But in
this case we have a few more interesting things. We need just two of
them:</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CRC_p -6643602732498616851L</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_data_types_count 2</span></span></code></pre></div>
<p>Now we’re armed to discuss loading the <code>info</code>
structure:</p>
<ul>
<li><code>.rc</code> : the fetcher needs to know if <code>p</code> was
successful, it won’t read from the statement if it wasn’t</li>
<li><code>.db</code> : the database handle, the fetcher needs this to
call SQLite APIs</li>
<li><code>.stmt</code> : the statement that came from <code>p</code>
that is to be enumerated</li>
<li><code>.data_types</code> : types of the columns, this tells the
fetcher what columns to read to the statement in what order</li>
<li><code>.col_offsets</code> : the column offsets, this tells the
fetcher were to store the column data within each row</li>
<li><code>.refs_count</code> : the number of references in the row, this
is needed to tear down the rows in the result set when it is
released</li>
<li><code>.refs_offset</code> : the first reference offset, as usual
this tells the fetcher where the references that need to be released
are</li>
<li><code>.encode_context_index</code> : it’s possible to have sensitive
fields encoded, this identifies an optional column that will be combined
with the sensitive data . <code>.rowsize</code> : the size of
<code>p_row</code>, this is needed to allocate rows in a growable
buffer</li>
<li><code>.crc</code> : this is a CRC of the code of <code>p</code>,
it’s used to uniquely identify <code>p</code> economically, performance
logging APIs typically use this CRC in a begin/end logging pair</li>
<li><code>.perf_index</code> : performance data for stored procedures is
typically stored in an array of stats, CQL provides storage for the
index for each procedure</li>
</ul>
<p>With this data (which is in the end pretty small) the
<code>cql_fetch_all_results</code> can do all the things it needs to
do:</p>
<ul>
<li><code>cql_profile_start</code> has already been called, it can call
<code>cql_profile_end</code> once the data is fetched
<ul>
<li><code>cql_profile_start</code> and <code>_end</code> do nothing by
default, but those macros can be defined to log performance data however
you like</li>
</ul></li>
<li>it can allocate a <code>bytebuf</code> with
<code>cql_bytebuf_open</code> and then grow it with
<code>cql_bytebuf_alloc</code>
<ul>
<li>in the end all the rows are in one contiguous block of storage</li>
</ul></li>
<li><code>cql_multifetch_meta</code> is used to read each row from the
result set, it’s similar to <code>cql_multifetch</code>
<ul>
<li>the <code>meta</code> version uses <code>data_types</code> and
<code>column_offsets</code> instead of varargs but is otherwise the
same</li>
<li>the first member of the <code>col_offsets</code> array is the count
of columns</li>
</ul></li>
</ul>
<p>With this background, <code>cql_fetch_all_results</code> should be
very approachable. There’s a good bit of work but it’s all very
simple.</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="co">// By the time we get here, a CQL stored proc has completed execution and there is</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="co">// now a statement (or an error result).  This function iterates the rows that</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a><span class="co">// come out of the statement using the fetch info to describe the shape of the</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a><span class="co">// expected results.  All of this code is shared so that the cost of any given</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a><span class="co">// stored procedure is minimized.  Even the error handling is consolidated.</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>cql_code cql_fetch_all_results<span class="op">(</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>  cql_fetch_info <span class="op">*</span>_Nonnull info<span class="op">,</span></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>  cql_result_set_ref _Nullable <span class="op">*</span>_Nonnull result_set<span class="op">)</span> <span class="op">{...}</span></span></code></pre></div>
<p>The core of that function looks like this:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>  cql_bytebuf_open<span class="op">(&amp;</span>b<span class="op">);</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    rc <span class="op">=</span> sqlite3_step<span class="op">(</span>stmt<span class="op">);</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rc <span class="op">==</span> SQLITE_DONE<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rc <span class="op">!=</span> SQLITE_ROW<span class="op">)</span> <span class="cf">goto</span> cql_error<span class="op">;</span></span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true" tabindex="-1"></a>    count<span class="op">++;</span></span>
<span id="cb221-9"><a href="#cb221-9" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> cql_bytebuf_alloc<span class="op">(&amp;</span>b<span class="op">,</span> rowsize<span class="op">);</span></span>
<span id="cb221-10"><a href="#cb221-10" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>row<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> rowsize<span class="op">);</span></span>
<span id="cb221-11"><a href="#cb221-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-12"><a href="#cb221-12" aria-hidden="true" tabindex="-1"></a>    cql_multifetch_meta<span class="op">((</span><span class="dt">char</span> <span class="op">*)</span>row<span class="op">,</span> info<span class="op">);</span></span>
<span id="cb221-13"><a href="#cb221-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb221-14"><a href="#cb221-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb221-15"><a href="#cb221-15" aria-hidden="true" tabindex="-1"></a>  cql_profile_stop<span class="op">(</span>info<span class="op">-&gt;</span>crc<span class="op">,</span> info<span class="op">-&gt;</span>perf_index<span class="op">);</span></span>
<span id="cb221-16"><a href="#cb221-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<ul>
<li><code>cql_bytebuf_open</code> : open the buffer, get ready to start
appending rows</li>
<li><code>sqlite3_step</code> : keep reading while we get
<code>SQLITE_ROW</code>, stop on <code>SQLITE_DONE</code></li>
<li><code>cql_bytebuf_alloc</code> : allocate a new row in the
buffer</li>
<li><code>memset</code> : zero the row</li>
<li><code>cql_multifetch_meta</code> : read the data from the the
statement into the row</li>
<li><code>cql_profile_stop</code> : signals that processing is done and
profiling can stop</li>
<li>if all goes well, <code>SQLITE_OK</code> is returned as usual</li>
</ul>
<p>The remaining logic is largely about checking for errors and tearing
down the result set if anything goes wrong. There is not very much to
it, and it’s worth a read.</p>
<p>Now recall that the way <code>cql_fetch_all_results</code> was used,
was as follows:</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cql_fetch_all_results<span class="op">(&amp;</span>info<span class="op">,</span> <span class="op">(</span>cql_result_set_ref <span class="op">*)</span>result_set<span class="op">)</span></span></code></pre></div>
<p>And <code>result_set</code> was the out-argument for the the
<code>p_fetch_results</code> method.</p>
<p>So <code>p_fetch_results</code> is used to get that result set. But
what can you do with it? Well, the result set contains copy of all the
selected data, ready to use in with a C-friendly API. The interface is
in the generated <code>.h</code> file. Let’s look at that now, it’s the
final piece of the puzzle.</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef result_set_type_decl_p_result_set</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define result_set_type_decl_p_result_set 1</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>cql_result_set_type_decl<span class="op">(</span>p_result_set<span class="op">,</span> p_result_set_ref<span class="op">);</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> cql_string_ref _Nonnull p_get_x<span class="op">(</span>p_result_set_ref _Nonnull result_set<span class="op">,</span> cql_int32 row<span class="op">);</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> cql_int32 p_get_y<span class="op">(</span>p_result_set_ref _Nonnull result_set<span class="op">,</span> cql_int32 row<span class="op">);</span></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> cql_int32 p_result_count<span class="op">(</span>p_result_set_ref _Nonnull result_set<span class="op">);</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> CQL_WARN_UNUSED cql_code p_fetch_results<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span> p_result_set_ref _Nullable <span class="op">*</span>_Nonnull result_set<span class="op">);</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_row_hash(result_set, row) cql_result_set_get_meta( \</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a><span class="pp">  (cql_result_set_ref)(result_set))-&gt;rowHash((cql_result_set_ref)(result_set), row)</span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define p_row_equal(rs1, row1, rs2, row2) \</span></span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a><span class="pp">  cql_result_set_get_meta((cql_result_set_ref)(rs1))-&gt;rowsEqual( \</span></span>
<span id="cb223-16"><a href="#cb223-16" aria-hidden="true" tabindex="-1"></a><span class="pp">    (cql_result_set_ref)(rs1), \</span></span>
<span id="cb223-17"><a href="#cb223-17" aria-hidden="true" tabindex="-1"></a><span class="pp">    row1, \</span></span>
<span id="cb223-18"><a href="#cb223-18" aria-hidden="true" tabindex="-1"></a><span class="pp">    (cql_result_set_ref)(rs2), \</span></span></code></pre></div>
<ul>
<li><code>cql_result_set_type_decl</code> : declares
<code>p_result_set_ref</code>
<ul>
<li>to avoid being defined more than once, the declaration is protected
by <code>#ifndef result_set_type_decl_p_result_set</code></li>
</ul></li>
<li><code>p_get_x</code>, <code>p_get_y</code> : allow access to the
named fields of the result set at any given row</li>
<li><code>p_result_count</code> : provides the count of rows in the
result set</li>
<li><code>p_fetch_results</code> : the declaration of the fetcher
(previously discussed)</li>
<li><code>p_row_hash</code> : provides a hash of any given row, useful
for detecting changes between result sets</li>
<li><code>p_row_equal</code> : tests two rows in two results sets of the
same shape for equality</li>
</ul>
<p>The getters are defined very simply:</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>cql_string_ref _Nonnull p_get_x<span class="op">(</span>p_result_set_ref _Nonnull result_set<span class="op">,</span> cql_int32 row<span class="op">)</span> <span class="op">{</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>  p_row <span class="op">*</span>data <span class="op">=</span> <span class="op">(</span>p_row <span class="op">*)</span>cql_result_set_get_data<span class="op">((</span>cql_result_set_ref<span class="op">)</span>result_set<span class="op">);</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data<span class="op">[</span>row<span class="op">].</span>x<span class="op">;</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>cql_int32 p_get_y<span class="op">(</span>p_result_set_ref _Nonnull result_set<span class="op">,</span> cql_int32 row<span class="op">)</span> <span class="op">{</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>  p_row <span class="op">*</span>data <span class="op">=</span> <span class="op">(</span>p_row <span class="op">*)</span>cql_result_set_get_data<span class="op">((</span>cql_result_set_ref<span class="op">)</span>result_set<span class="op">);</span></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data<span class="op">[</span>row<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>p_row</code> is exactly the right size, and of course the
right shape, the final access looks something like
<code>data[row].x</code>.</p>
<h4 id="result-sets-from-the-out-statement">Result Sets from the OUT
statement</h4>
<p>Recalling this earlier example:</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC q ()</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="kw">LIKE</span> <span class="kw">SELECT</span> <span class="ot">&quot;1&quot;</span> <span class="kw">AS</span> x, <span class="dv">2</span> <span class="kw">AS</span> y;</span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>  FETCH C <span class="kw">USING</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;foo&quot;</span> x,</span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>   <span class="dv">3</span> y;</span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">OUT</span> C;</span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>The original example had <code>@attribute(cql:private)</code> to
suppress the result set, but normally a one-row result is is generated
from such a method. The C API is almost identical. However, there count
is always 0 or 1.</p>
<p>The getters do not have the row number:</p>
<div class="sourceCode" id="cb226"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> cql_string_ref _Nonnull q_get_x<span class="op">(</span>q_result_set_ref _Nonnull result_set<span class="op">);</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> cql_int32 q_get_y<span class="op">(</span>q_result_set_ref _Nonnull result_set<span class="op">);</span></span></code></pre></div>
<p>The actual getters are nearly the same as well</p>
<div class="sourceCode" id="cb227"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>cql_string_ref _Nonnull q_get_x<span class="op">(</span>q_result_set_ref _Nonnull result_set<span class="op">)</span> <span class="op">{</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a>  q_row <span class="op">*</span>data <span class="op">=</span> <span class="op">(</span>q_row <span class="op">*)</span>cql_result_set_get_data<span class="op">((</span>cql_result_set_ref<span class="op">)</span>result_set<span class="op">);</span></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data<span class="op">-&gt;</span>x<span class="op">;</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>cql_int32 q_get_y<span class="op">(</span>q_result_set_ref _Nonnull result_set<span class="op">)</span> <span class="op">{</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>  q_row <span class="op">*</span>data <span class="op">=</span> <span class="op">(</span>q_row <span class="op">*)</span>cql_result_set_get_data<span class="op">((</span>cql_result_set_ref<span class="op">)</span>result_set<span class="op">);</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data<span class="op">-&gt;</span>y<span class="op">;</span></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Basically <code>data[row].x</code> just became
<code>data-&gt;x</code> and the rest is nearly the same. Virtually all
the code for this is shared.</p>
<p>You can find all this and more in <code>cg_c.c</code> by looking
here:</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If a stored procedure generates a result set then we need to do some extra work</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to create the C friendly rowset creating and accessing helpers.  If stored</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a><span class="co">// proc &quot;foo&quot; creates a row set then we need to:</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a><span class="co">//  * emit a struct &quot;foo_row&quot; that has the shape of each row</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a><span class="co">//    * this isn&#39;t used by the client code but we use it in our code-gen</span></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a><span class="co">//  * emit a function &quot;foo_fetch_results&quot; that will call &quot;foo&quot; and read the rows</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a><span class="co">//    from the statement created by &quot;foo&quot;.</span></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a><span class="co">//    * this method will construct a result set object via cql_result_create and store the data</span></span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a><span class="co">//    * the remaining functions use cql_result_set_get_data and _get_count to get the data back out</span></span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a><span class="co">//  * for each named column emit a function &quot;foo_get_[column-name]&quot; which</span></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a><span class="co">//    gets that column out of the rowset for the indicated row number.</span></span>
<span id="cb228-12"><a href="#cb228-12" aria-hidden="true" tabindex="-1"></a><span class="co">//  * prototypes for the above go into the main output header file</span></span>
<span id="cb228-13"><a href="#cb228-13" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_proc_result_set<span class="op">(</span>ast_node <span class="op">*</span>ast<span class="op">)</span></span></code></pre></div>
<p>There are many variations in that function to handle the cases
mentioned so far, but they are substantially similar to each other with
a lot of shared code. There is one last variation we should talk about
and that is the <code>OUT UNION</code> form. It is the most flexible of
them all.</p>
<h4 id="result-sets-from-the-out-union-statement">Result Sets from the
OUT UNION statement</h4>
<p>The <code>OUT</code> statement, allows the programmer to produce a
result set that has exactly one row, <code>OUT UNION</code> instead
accumulates rows. This is very much like writing your own
<code>fetcher</code> procedure with your own logic. The data could come
from the database, by, for instance, enumerating a cursor. Or it can
come from some computation or a mix of both. Here’s a very simple
example:</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC q ()</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="kw">LIKE</span> <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> x;</span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>  LET i <span class="op">:=</span> <span class="dv">0</span>;</span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">WHILE</span> i <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>    FETCH C(x) <span class="kw">FROM</span> <span class="kw">VALUES</span>(i);</span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">OUT</span> <span class="kw">UNION</span> C;</span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> i <span class="op">:=</span> i <span class="op">+</span> <span class="dv">1</span>;</span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>Let’s look at the code for the above, it will be very similar to
other examples we’ve seen so far:</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> q_C_row <span class="op">{</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 x<span class="op">;</span></span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> q_C_row<span class="op">;</span></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> q_fetch_results<span class="op">(</span>q_result_set_ref _Nullable <span class="op">*</span>_Nonnull _result_set_<span class="op">)</span> <span class="op">{</span></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>  cql_bytebuf _rows_<span class="op">;</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>  cql_bytebuf_open<span class="op">(&amp;</span>_rows_<span class="op">);</span></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>_result_set_ <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>  q_C_row C <span class="op">=</span> <span class="op">{</span> <span class="dv">0</span> <span class="op">};</span></span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>  cql_int32 i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>  cql_profile_start<span class="op">(</span>CRC_q<span class="op">,</span> <span class="op">&amp;</span>q_perf_index<span class="op">);</span></span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>  i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!(</span>i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>_has_row_ <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>x <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a>    cql_retain_row<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>C<span class="op">.</span>_has_row_<span class="op">)</span> cql_bytebuf_append<span class="op">(&amp;</span>_rows_<span class="op">,</span> <span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*)&amp;</span>C<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>C<span class="op">));</span></span>
<span id="cb230-22"><a href="#cb230-22" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb230-23"><a href="#cb230-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb230-24"><a href="#cb230-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-25"><a href="#cb230-25" aria-hidden="true" tabindex="-1"></a>  cql_results_from_data<span class="op">(</span>SQLITE_OK<span class="op">,</span> <span class="op">&amp;</span>_rows_<span class="op">,</span> <span class="op">&amp;</span>q_info<span class="op">,</span> <span class="op">(</span>cql_result_set_ref <span class="op">*)</span>_result_set_<span class="op">);</span></span>
<span id="cb230-26"><a href="#cb230-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>q_C_row</code> : the shape of the cursor, as always</li>
<li><code>_rows_</code> : the <code>bytebuf</code> that will hold our
data</li>
<li><code>cql_bytebuf_open(&amp;_rows_);</code> : initializes the
buffer</li>
<li><code>cql_profile_start(CRC_q, &amp;q_perf_index);</code> : start
profiling as before</li>
<li><code>for (;;)</code> : the while pattern as before</li>
<li><code>C.x = i;</code> : loads the cursor</li>
<li><code>cql_retain_row(C);</code> : retains any references in the
cursor (there are none)
<ul>
<li>we’re about to copy the cursor into the buffer so all refs need to
be +1</li>
</ul></li>
<li><code>cql_bytebuf_append</code> : append the the cursor’s bytes into
the buffer</li>
<li>the loop does its repetitions until finally</li>
<li><code>cql_results_from_data</code> : used instead of
<code>cql_fetch_all_results</code> because all the data is already
prepared
<ul>
<li>in this particular example there is nothing to go wrong so it always
gets <code>SQLITE_OK</code></li>
<li>in a more complicated example, <code>cql_results_from_data</code>
frees any partly created result set in case of error</li>
<li><code>cql_results_from_data</code> also performs any encoding of
sensitive data that might be needed</li>
</ul></li>
<li><code>q_info</code> : created as before, but it can be static as
it’s always the same now</li>
</ul>
<p>Importantly, when using <code>OUT UNION</code> the codegen only
produces <code>q_fetch_results</code>, there is no <code>q</code>. If
you try to call <code>q</code> from CQL you will instead call
<code>q_fetch_results</code>. But since many results as possible, a
cursor is needed to make the call.</p>
<p>Here’s an example, here <code>p</code> calls the <code>q</code>
method above:</p>
<div class="sourceCode" id="cb231"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> PROC p (<span class="kw">OUT</span> s <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>)</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a><span class="cf">BEGIN</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">DECLARE</span> C <span class="kw">CURSOR</span> <span class="cf">FOR</span> <span class="kw">CALL</span> q();</span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">LOOP</span> FETCH C</span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">BEGIN</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SET</span> s <span class="op">:=</span> s <span class="op">+</span> C.x;</span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span>;</span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a><span class="cf">END</span>;</span></code></pre></div>
<p>And the relevant code for this is as follows:</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> p_C_row <span class="op">{</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  cql_bool _has_row_<span class="op">;</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_count_<span class="op">;</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>  cql_uint16 _refs_offset_<span class="op">;</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a>  cql_int32 x<span class="op">;</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> p_C_row<span class="op">;</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>CQL_WARN_UNUSED cql_code p<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull _db_<span class="op">,</span> cql_int32 <span class="op">*</span>_Nonnull s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>  cql_contract_argument_notnull<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>s<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a>  cql_code _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a>  q_result_set_ref C_result_set_ <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a>  cql_int32 C_row_num_ <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true" tabindex="-1"></a>  cql_int32 C_row_count_ <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb232-15"><a href="#cb232-15" aria-hidden="true" tabindex="-1"></a>  p_C_row C <span class="op">=</span> <span class="op">{</span> <span class="dv">0</span> <span class="op">};</span></span>
<span id="cb232-16"><a href="#cb232-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-17"><a href="#cb232-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// set out arg to non-garbage</span></span>
<span id="cb232-18"><a href="#cb232-18" aria-hidden="true" tabindex="-1"></a>  q_fetch_results<span class="op">(&amp;</span>C_result_set_<span class="op">);</span></span>
<span id="cb232-19"><a href="#cb232-19" aria-hidden="true" tabindex="-1"></a>  C_row_num_ <span class="op">=</span> C_row_count_ <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb232-20"><a href="#cb232-20" aria-hidden="true" tabindex="-1"></a>  C_row_count_ <span class="op">=</span> cql_result_set_get_count<span class="op">((</span>cql_result_set_ref<span class="op">)</span>C_result_set_<span class="op">);</span></span>
<span id="cb232-21"><a href="#cb232-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb232-22"><a href="#cb232-22" aria-hidden="true" tabindex="-1"></a>    C_row_num_<span class="op">++;</span></span>
<span id="cb232-23"><a href="#cb232-23" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>_has_row_ <span class="op">=</span> C_row_num_ <span class="op">&lt;</span> C_row_count_<span class="op">;</span></span>
<span id="cb232-24"><a href="#cb232-24" aria-hidden="true" tabindex="-1"></a>    cql_copyoutrow<span class="op">(</span>NULL<span class="op">,</span> <span class="op">(</span>cql_result_set_ref<span class="op">)</span>C_result_set_<span class="op">,</span> C_row_num_<span class="op">,</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb232-25"><a href="#cb232-25" aria-hidden="true" tabindex="-1"></a>                   CQL_DATA_TYPE_NOT_NULL <span class="op">|</span> CQL_DATA_TYPE_INT32<span class="op">,</span> <span class="op">&amp;</span>C<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb232-26"><a href="#cb232-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>C<span class="op">.</span>_has_row_<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb232-27"><a href="#cb232-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>s <span class="op">=</span> <span class="op">(*</span>s<span class="op">)</span> <span class="op">+</span> C<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb232-28"><a href="#cb232-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb232-29"><a href="#cb232-29" aria-hidden="true" tabindex="-1"></a>  _rc_ <span class="op">=</span> SQLITE_OK<span class="op">;</span></span>
<span id="cb232-30"><a href="#cb232-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-31"><a href="#cb232-31" aria-hidden="true" tabindex="-1"></a>  cql_object_release<span class="op">(</span>C_result_set_<span class="op">);</span></span>
<span id="cb232-32"><a href="#cb232-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> _rc_<span class="op">;</span></span>
<span id="cb232-33"><a href="#cb232-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>p_C_row</code> : the cursor row as always</li>
<li><code>cql_contract_argument_notnull((void *)s, 1)</code> : verify
that the out arg pointer is not null</li>
<li><code>C_result_set_</code> : this will hold the result set from
<code>q_fetch_results</code></li>
<li><code>C_row_num_</code> : the current row number being processed in
the result set</li>
<li><code>C_row_count_</code> : the total number of rows in the result
set</li>
<li>other locals are intialized as usual</li>
<li><code>*s = 0;</code> : set the out arg to non-garbage as usual</li>
<li><code>q_fetch_results</code> : get the result set from
<code>q_fetch_results</code>
<ul>
<li>in this case no database access was required so this API can’t
fail</li>
<li><code>C_row_num</code> : set to -1</li>
<li><code>C_row_count</code> : set to the row count</li>
</ul></li>
<li><code>cql_copyoutrow</code> : copies one row from the result set
into the cursor</li>
<li><code>*s = (*s) + C.x;</code> : computes the sum</li>
<li><code>cql_object_release</code> : the result set is torn down</li>
<li>if there are any reference fields in the cursor there would have
been a <code>cql_teardown_row(C)</code></li>
</ul>
<p>In short, this is another form of cursor, it’s a value cursor, so it
has no statement but it also needs a result set, a count and an index to
go with it so that it can enumerate the result set.</p>
<p>In the AST it looks like this:</p>
<pre><code>{name C}: C: select: { x: integer notnull } variable shape_storage uses_out_union</code></pre>
<p>This implies we have the semantic flags:
<code>SEM_TYPE_STRUCT</code>, <code>SEM_TYPE_VARIABLE</code>,
<code>SEM_TYPE_HAS_SHAPE_STORAGE</code>, and
<code>SEM_TYPE_USES_OUT_UNION</code>.</p>
<p>The difference is of course the presence of
<code>SEM_TYPE_USES_OUT_UNION</code>.</p>
<p>This is the last of the cursor forms and the final complication of
<code>cg_proc_result_set</code>.</p>
<h3 id="recap-1">Recap</h3>
<p>At present <code>cg_c.c</code> is a little over 7400 lines of code,
maybe 1500 of those lines are comments. So <code>cg_c.c</code> is
actually quite a bit smaller and simpler than <code>sem.c</code>
(roughly 1/3 the size). It is, however, the most complex of the code
generators by far. Part 3 of the internals guide has come out a lot
larger than Part 2 but that’s mainly because there are a few more cases
worth discussing in detail and the code examples of Part 3 are bigger
than the AST examples of Part 2.</p>
<p>Topics covered included:</p>
<ul>
<li>compiling expressions into C, including nullable types</li>
<li>techniques used to generate control flow</li>
<li>creation of result sets, including:
<ul>
<li>various helpers to do the reading economically</li>
<li>the use of <code>cql_bytebuf</code> to manage the memory</li>
</ul></li>
<li>create the text for SQLite statements and binding variables to that
text</li>
<li>error management, and how it relates to <code>TRY</code> and
<code>CATCH</code> blocks</li>
<li>use of cleanup sections to ensure that references and SQLite
statement lifetime is always correct</li>
<li>the contents of the <code>.c</code> and <code>.h</code> files and
the key sections in them</li>
<li>the use of <code>charbuf</code> to create and assemble
fragments</li>
</ul>
<p>As with the other parts, this is not a complete discussion of the
code but a useful survey that should give readers enough context to
understand <code>cg_c.c</code> and the runtime helpers in
<code>cqlrt.c</code> and <code>cqlrt_common.c</code>. Good luck in your
personal exploration!</p>
<h2 id="part-4-testing">Part 4: Testing</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-3">Preface</h3>
<p>Part 4 continues with a discussion of the essentials testing
frameworks for the CQL compiler. As in the previous sections, the goal
here is not to go over every detail but rather to give a sense of how
testing happens in general – the core strategies and implementation
choices – so that when reading the tests you will have an idea how it
all hangs together. To accomplish this, various key tools will be
explained in detail as well as selected examples of their use.</p>
<h2 id="testing">Testing</h2>
<p>There are several types of tests in the system, all of which are
launched by the <code>test.sh</code> script which builds the compiler
and does a full test pass, there are well over 3000 tests as of this
writing. Broadly these are in these few categories:</p>
<ul>
<li><strong>parse tests</strong> : these are in <code>test.sql</code>
<ul>
<li>the test script verifies that the compiler can parse this file with
no errors</li>
<li>the parse pass echoes what it read in normalized form, this is
compared against a reference copy and any differences are noted</li>
<li>each difference can be accepted or rejected; rejecting a difference
stops the script</li>
<li>verification here is very light and in fact much of parsing is
actually tested in the next pass</li>
</ul></li>
<li><strong>semantic tests</strong> : these are in
<code>sem_test.sql</code>
<ul>
<li>the file has no parse errors but it has MANY semantic errors, nearly
every such error in fact</li>
<li>semantic analysis is run with the <code>--test</code> flag which
produces AST fragments and echoed CQL</li>
<li>the test file includes patterns which either must appear, or must
not appear, in the output to pass the test</li>
<li>the AST includes full type information, so virtually anything about
the semantic results can be, and is, verified</li>
<li>many tests are designed to exercise the parser as well, ensuring
that the correct AST was built and then analyzed
<ul>
<li>e.g. operator precedence can be verified here</li>
<li>the AST echoing logic can also be verified here, e.g. placement of
parenthesis in the echoed output</li>
</ul></li>
<li>any semantic rewrites can be verified here because the rewritten
form is emitted in the test output, not the original input</li>
<li>all other operations that happen during the semantic pass
(e.g. constant evaluation) are also tested here</li>
<li>the full semantic output is also normalized (e.g. removing line
numbers) and is compared against a reference copy, any differences are
noted</li>
<li>each difference can be accepted or rejected; rejecting a difference
stops the script</li>
<li>there are additional files to test different modes like “previous
schema” validation (q.v.) as well as dev mode and the schema migrator,
the files in this family are: <code>sem_test.sql</code>,
<code>sem_test_dev.sql</code>, <code>sem_test_migrate.sql</code>,
<code>sem_test_prev.sql</code></li>
</ul></li>
<li><strong>code gen tests</strong> : the basic test in this family is
<code>cg_test.sql</code> which has the C codegen tests
<ul>
<li>these test files do pattern matching just like the semantic case
except the codegen output is checked rather than the AST</li>
<li>the test output is normalized and checked against a reference, just
like the semantic tests</li>
<li>there is generally no need to check for errors in test output
because all errors are detected during semantic analysis</li>
<li>there are MANY tests in this family, at least one for each of the
various generators:
<ul>
<li><code>cg_test.sql</code>, <code>cg_test_assembly_query.sql</code>,
<code>cg_test_base_fragment.sql</code>,
<code>cg_test_base_java_fragment.sql</code>,
<code>cg_test_c_type_getters.sql</code>,
<code>cg_test_extension_fragment.sql</code>,
<code>cg_test_extension_java_fragment.sql</code>,
<code>cg_test_generate_copy.sql</code>,
<code>cg_test_generated_from.sql</code>,
<code>cg_test_json_schema.sql</code>,
<code>cg_test_no_result_set.sql</code>,
<code>cg_test_out_object.sql</code>, <code>cg_test_out_union.sql</code>,
<code>cg_test_prev_invalid.sql</code>,
<code>cg_test_query_plan.sql</code>,
<code>cg_test_schema_upgrade.sql</code>,
<code>cg_test_single_proc_not_nullable.sql</code>,
<code>cg_test_single_proc_nullable.sql</code>,
<code>cg_test_suppressed.sql</code>,
<code>cg_test_test_helpers.sql</code>,
<code>cg_test_with_object.sql</code>,</li>
</ul></li>
</ul></li>
<li><strong>run tests</strong> : the main run test creatively named
<code>run_test.sql</code>
<ul>
<li>this test code is compiled and excuted</li>
<li>the test contains expectations like any other unit test</li>
<li>it has CQL parts and C parts, the C parts test the C API to the
procedures, plus do initial setup</li>
<li>these test include uses of all CQL features and all of the CQL
runtime features</li>
<li>the schema upgrader tests are arguably “run tests” as well in that
they run the code but they have a much different verification
strategy</li>
</ul></li>
<li><strong>unit test</strong> : the compiler supports the
<code>--run_unit_tests</code> flag
<ul>
<li>this causes the compile to self-test certain of its helper functions
that are otherwise difficult to test</li>
<li>mostly this is buffers that need to be growable to but in practice
only grow with huge input files</li>
<li>other exotic cases that would be hard to reliability hit in some
other fashion are covered by this code</li>
</ul></li>
</ul>
<p>Test coverage is maintained at 100% line coverage (sometimes there
are a few hours when it drops to 99.9% or something like that but this
never lasts). Branch coverage is not especially targetted but is
nonethless quite high. To see the true branch coverage you have to build
the compiler with the asserts (Contract and Invariant) off. Last time it
was measured, it was well over 80%.</p>
<p>To start the tests you should run <code>test.sh</code>, this launches
<code>common/test_common.sh</code> to do the work. This structure allows
anyone to make their own harness that launches the common test passes
and adds their own extra tests, or passes in additional flags.
<code>test.sh</code> itself uses <code>make</code> to build the
compiler.</p>
<p>As mentioned above, <code>test.sh</code> normally allows the user to
accept or reject differences in output, but this is automatically
disabled in non-terminal environments, and manually disabled if the
script is run with <code>--non_interactive</code>. <code>ok.sh</code>
can be run to copy all of the outputs from the most recent test run over
the previous references.</p>
<p>To get the coverage report, use <code>cov.sh</code> which in turn
launches <code>test.sh</code> with suitable flags and then assembles the
coverage report using <code>gcovr</code>.</p>
<h3 id="parse-tests">Parse Tests</h3>
<p>Looking at <code>test/test_common.sh</code> we find the source for
the most basic test. This is entirely unremarkable stuff.</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="fu">basic_test()</span> <span class="kw">{</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&#39;--------------------------------- STAGE 2 -- BASIC PARSING TEST&#39;</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> running <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/test.sql&quot;</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="va">${CQL}</span> <span class="at">--dev</span> <span class="at">--in</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/test.sql&quot;</span> <span class="op">&gt;</span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/test.out&quot;</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>   <span class="bu">echo</span> basic parsing test failed</span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>   <span class="ex">failed</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&quot;  computing diffs (empty if none)&quot;</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a>  <span class="ex">on_diff_exit</span> test.out</span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<ul>
<li>it’s “STAGE 2” because “STAGE 1” was the build</li>
<li>all it tries to do is run the compiler over
<code>test/test.sql</code></li>
<li>if there are errors the test fails</li>
<li>if there are any differences between <code>test.out</code> and
<code>test.out.ref</code> the test fails</li>
</ul>
<p>That’s it.</p>
<h3 id="sematic-tests">Sematic Tests</h3>
<p>The semantic tests are not much different but this is where the
pattern matching comes in.</p>
<p>First let’s look at the shell script:</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="fu">semantic_test()</span> <span class="kw">{</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&#39;--------------------------------- STAGE 4 -- SEMANTIC ANALYSIS TEST&#39;</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> running semantic analysis test</span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="ex">sem_check</span> <span class="at">--sem</span> <span class="at">--ast</span> <span class="at">--dev</span> <span class="at">--in</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/sem_test.sql&quot;</span> <span class="op">&gt;</span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/sem_test.out&quot;</span> <span class="dv">2</span><span class="op">&gt;</span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/sem_test.err&quot;</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>     <span class="bu">echo</span> <span class="st">&quot;CQL semantic analysis returned unexpected error code&quot;</span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>     <span class="fu">cat</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/sem_test.err&quot;</span></span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>     <span class="ex">failed</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> validating output trees</span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cql-verify&quot;</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/sem_test.sql&quot;</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/sem_test.out&quot;</span></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> failed verification</span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb235-16"><a href="#cb235-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb235-17"><a href="#cb235-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-18"><a href="#cb235-18" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> running dev semantic analysis test</span>
<span id="cb235-19"><a href="#cb235-19" aria-hidden="true" tabindex="-1"></a>  <span class="ex">...</span> same thing again for sem_test_dev.sql</span>
<span id="cb235-20"><a href="#cb235-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-21"><a href="#cb235-21" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&quot;  computing diffs (empty if none)&quot;</span></span>
<span id="cb235-22"><a href="#cb235-22" aria-hidden="true" tabindex="-1"></a>  <span class="ex">on_diff_exit</span> sem_test.out</span>
<span id="cb235-23"><a href="#cb235-23" aria-hidden="true" tabindex="-1"></a>  <span class="ex">on_diff_exit</span> sem_test.err</span>
<span id="cb235-24"><a href="#cb235-24" aria-hidden="true" tabindex="-1"></a>  <span class="ex">...</span> same thing again for sem_test_dev.out and .err</span>
<span id="cb235-25"><a href="#cb235-25" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>There are basically 3 steps:</p>
<ul>
<li>run the compiler over <code>test/sem_test.sql</code>
<ul>
<li>fail if this generates no errors (yes you read that right, see
below)</li>
</ul></li>
<li>do the pattern matching on the output using <code>cql-verify</code>
to ensure the patterns match (discussed below)
<ul>
<li>fail if the output is not consistent with the patterns</li>
</ul></li>
<li>compare the reference output for the AST and the errors
<ul>
<li>fail if there are any differences</li>
</ul></li>
</ul>
<p>In the first step the compiler MUST produce an error code, let’s look
at <code>sem_check</code> to see why:</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sem_check()</span> <span class="kw">{</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">${CQL}</span> <span class="st">&quot;</span><span class="va">$@</span><span class="st">&quot;</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">[</span> <span class="st">&quot;</span><span class="va">$?</span><span class="st">&quot;</span> <span class="ot">-ne</span> <span class="st">&quot;1&quot;</span> <span class="bu">]</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>     <span class="bu">echo</span> <span class="st">&#39;All semantic analysis checks have errors in the test&#39;</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>     <span class="bu">echo</span> <span class="st">&#39;the normal return code is &quot;1&quot; -- any other return code is bad news&#39;</span></span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>     <span class="bu">echo</span> <span class="st">&#39;A return code of zero indicates we reported success in the face of errors&#39;</span></span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>     <span class="bu">echo</span> <span class="st">&#39;A return code other than 1 indicates an unexpected fatal error of some type&#39;</span></span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb236-11"><a href="#cb236-11" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>In short <code>sem_test.sql</code> is FULL of semantic errors, that’s
part of the test. If the compiler reports success something is
<em>seriously</em> wrong.</p>
<p>In the next phase we’re going to do some pattern matching, let’s look
at a couple of examples to illustrate how this works. The program
<code>cql-verify</code> actually does all this matching and that program
is itself written in (mostly) CQL which is cute. It can be found in the
<code>tester</code> directory.</p>
<p>Here’s a very simple example:</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">TEST</span><span class="co">: we&#39;ll be using printf in lots of places in the tests as an external proc</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {declare_proc_no_check_stmt}: ok</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- - Error</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a><span class="kw">DECLARE</span> <span class="kw">PROCEDURE</span> printf <span class="kw">NO</span> <span class="kw">CHECK</span>;</span></code></pre></div>
<p>The code under test is of course
<code>DECLARE PROCEDURE printf NO CHECK</code>. The patterns happen
immediately before this code. Let’s look at each line:</p>
<ul>
<li><code>-- TEST: etc.</code> : this is just a comment, it means
nothing and serves no purpose other than documentation</li>
<li><code>-- + {declare_proc_no_check_stmt}: ok</code> : the comment
stats with <code>" + "</code>, this is a trigger
<ul>
<li>the test output from the statement under test must include indicated
text</li>
<li>this happens to be the text for the AST of
<code>declare_proc_no_check_stmt</code> after semantic success</li>
<li>there is no type info hence the <code>ok</code> designation (recall
<code>SEM_TYPE_OK</code>)</li>
</ul></li>
<li><code>-- Error</code> : the comment starts with <code>" - "</code>,
this is a trigger
<ul>
<li>the test output from the statement under test must NOT include
indicated text</li>
<li>in this case that means no reported erros</li>
</ul></li>
</ul>
<p>Easy enough. Now does this happen?</p>
<p>The test output includes:</p>
<ul>
<li>text like “The statement ending at line XXXX” where XXXX is
appropriate line number</li>
<li>an echo of the statement that was analyzed (after any rewrites)</li>
<li>the AST of that statement including semantic type info that was
computed</li>
</ul>
<p>Using the value of XXXX the tester searches the test file in this
case <code>sem_test.sql</code>, it extracts the test patterns that
happen AFTER the previous XXXX value for the previous statement and up
to the indicated line number. This is The Price Is Right algorithm where
you read up to the designated lines without going over.</p>
<p>Each pattern is matched, or not matched, using the SQL
<code>LIKE</code> or <code>NOT LIKE</code> operator. In case of errors
the tester writes out the actual output and the expected patterns having
all this information handy.</p>
<p>The line numbers are all changed to literally “XXXX” after this pass
so that the difference in later passes is not a cascade of of trivial
line number changes in otherwise identical output.</p>
<p>Let’s look at another example:</p>
<div class="sourceCode" id="cb238"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">TEST</span><span class="co">: create a table using type discrimation: kinds</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {create_table_stmt}: with_kind: { id: integer&lt;some_key&gt;, cost: real&lt;dollars&gt;, value: real&lt;dollars&gt; }</span></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {col_def}: id: integer&lt;some_key&gt;</span></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {col_def}: cost: real&lt;dollars&gt;</span></span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {col_def}: value: real&lt;dollars&gt;</span></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- - Error</span></span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a><span class="kw">create</span> <span class="kw">table</span> with_kind(</span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">id</span> <span class="dt">integer</span><span class="op">&lt;</span>some_key<span class="op">&gt;</span>,</span>
<span id="cb238-9"><a href="#cb238-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">cost</span> <span class="dt">real</span><span class="op">&lt;</span>dollars<span class="op">&gt;</span>,</span>
<span id="cb238-10"><a href="#cb238-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">value</span> <span class="dt">real</span><span class="op">&lt;</span>dollars<span class="op">&gt;</span></span>
<span id="cb238-11"><a href="#cb238-11" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>This reads pretty easily now:</p>
<ul>
<li><code>{create_table_stmt}</code> : the struct type of the table must
be an exact match for what is expected</li>
<li><code>{col_def}</code> : there are 3 different
<code>{col_def}</code> nodes, one for each column</li>
<li><code>- Error</code> : there are no reported errors</li>
</ul>
<p>So there are no errors reported nor are there any in the AST. At
least the part of the AST that was checked. The AST actually had other
stuff too but it’s normal to just test the “essential” stuff. There are
many tests that try many variations and we don’t want to check every
fact in every case of every test.</p>
<p>If you want to see the whole AST output for this, it’s easy enough.
It’s sitting in <code>sem_test.out.ref</code></p>
<pre><code>The statement ending at line XXXX

CREATE TABLE with_kind(
  id INTEGER&lt;some_key&gt;,
  cost REAL&lt;dollars&gt;,
  value REAL&lt;dollars&gt;
);

  {create_table_stmt}: with_kind: { id: integer&lt;some_key&gt;, cost: real&lt;dollars&gt;, value: real&lt;dollars&gt; }
  | {create_table_name_flags}
  | | {table_flags_attrs}
  | | | {int 0}
  | | {name with_kind}
  | {col_key_list}
    | {col_def}: id: integer&lt;some_key&gt;
    | | {col_def_type_attrs}: ok
    |   | {col_def_name_type}
    |     | {name id}
    |     | {type_int}: integer&lt;some_key&gt;
    |       | {name some_key}
    | {col_key_list}
      | {col_def}: cost: real&lt;dollars&gt;
      | | {col_def_type_attrs}: ok
      |   | {col_def_name_type}
      |     | {name cost}
      |     | {type_real}: real&lt;dollars&gt;
      |       | {name dollars}
      | {col_key_list}
        | {col_def}: value: real&lt;dollars&gt;
          | {col_def_type_attrs}: ok
            | {col_def_name_type}
              | {name value}
              | {type_real}: real&lt;dollars&gt;
                | {name dollars}</code></pre>
<p>As you can see there was potentially a lot more than could have been
verified but those view key lines were selected because their
correctness really implies the rest. In fact just the
<code>{create_table_stmt}</code> line really was enough to know that
everthing was fine.</p>
<p>Let’s look at one more example, this time on that is checking for
errors. Many tests check for errors because correctly reporting errors
is the primary job of <code>sem.c</code>. It’s fair to say that there
are more tests for error cases than there are for correct cases because
there are a lot more ways to write code incorrectly than correctly.
Here’s the test:</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">TEST</span><span class="co">: join with bogus ON expression type</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- + Error % expected numeric expression &#39;ON&#39;</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- +1 Error</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {select_stmt}: err</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- + {on}: err</span></span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="op">*</span> <span class="kw">from</span> foo</span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a><span class="kw">inner</span> <span class="kw">join</span> bar <span class="kw">as</span> T2 <span class="kw">on</span> <span class="st">&#39;v&#39;</span></span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span> <span class="st">&#39;w&#39;</span></span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a><span class="kw">having</span> <span class="st">&#39;x&#39;</span></span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a><span class="kw">limit</span> <span class="st">&#39;y&#39;</span>;</span></code></pre></div>
<ul>
<li><code>+ Error % expected numeric expression 'ON'</code> : there must
be a reported Error message with the indicated error text</li>
<li><code>+1 Error</code> : this indicates that there must be
<em>exactly</em> 1 match for the pattern “Error” (i.e. exactly one
error)
<ul>
<li>note that there are several problems with the test statement but
error processing is supposed to stop after the first</li>
</ul></li>
<li><code>-- + {on}: err</code> : verifies that the ON clause was marked
as being in error</li>
<li><code>-- + {select_stmt}: err</code> : verifies that the error
correctly propogated up to the top level statement</li>
</ul>
<p>Note that the patterns can be in any order and every pattern is
matched against the whole input so for instance:</p>
<pre><code>-- + {on}: err
-- + {on}: err</code></pre>
<p>The above does not imply that there are two such <code>{on}</code>
nodes. The second line will match the same text as the first. To to
enforce that there were exactly two matches you use:</p>
<pre><code>-- +2 {on}: err</code></pre>
<p>There is no syntax for “at least two matches” though one could easily
be added. So far it hasn’t been especially necessary.</p>
<p>As we’ll see this simple pattern is used in many other tests. All
that is required for it work is output with lines of the form “The
statement ending at line XXXX”</p>
<p>The <code>sem_test_dev.sql</code> test file is a set of tests that
are run with the <code>--dev</code> flag passed to CQL. This is the mode
where certain statements that are prohibited in production code are
verified. This file is very small indeed and the exact prohibitions are
left as an exercise to the reader.</p>
<h3 id="code-generation-tests">Code Generation Tests</h3>
<p>The test logic for the “codegen” family of tests
(<code>cg_test*.sql</code>) is virtually identical to the semantic test
family. The same testing utililty is used, and it works the same way,
looking for the same marker. The only difference in this stage is that
the test output is generated code, not an AST. The codegen tests are a
great way to lock down important code fragments in the output. Note that
the codegen tests do not actually execute any generated code. That’s the
next category.</p>
<p>Here’s an sample test:</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">TEST</span><span class="co">: unused temp in unary not emitted</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- - cql_int32 _tmp_int_0 = 0;</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- - cql_int32 _tmp_int_1 = 0;</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- + o = i.value;</span></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- + o = - 1;</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a><span class="kw">create</span> proc unused_temp(i <span class="dt">integer</span>, <span class="kw">out</span> o <span class="dt">integer</span> <span class="kw">not</span> <span class="kw">null</span>)</span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> o <span class="op">:=</span> <span class="fu">coalesce</span>(i, <span class="op">-</span><span class="dv">1</span>);</span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span>;</span></code></pre></div>
<p>This test is verifying one of the optimizations that we talked about
in <a href="https://cgsql.dev/cql-guide/int03#result-variables">Part
3</a>. In many cases temporary variables for results (such as function
calls) can be elided.</p>
<ul>
<li><code>- cql_int32 _tmp_int_0 = 0;</code> : verifies that this
temporary is NOT created</li>
<li><code>- cql_int32 _tmp_int_1 = 0;</code> : likewise</li>
<li><code>+ o = i.value;</code> : the first alternative in coalesce
directly assigns to <code>o</code></li>
<li><code>+ o = - 1;</code> : as does the second</li>
</ul>
<p>It might be helpful to look at the full output, which as always is in
a <code>.ref</code> file. In this case <code>cg_test.c.ref</code>. Here
is the full output with the line number normalized:</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The statement ending at line XXXX</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a><span class="co">CREATE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL)</span></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a><span class="re">BEGIN</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a><span class="co">  SET o := coalesce(i, -1);</span></span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a><span class="re">END</span><span class="co">;</span></span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _PROC_ &quot;unused_temp&quot;</span></span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a><span class="co">// export: DECLARE PROC unused_temp (i INTEGER, OUT o INTEGER NOT NULL);</span></span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> unused_temp<span class="op">(</span>cql_nullable_int32 i<span class="op">,</span> cql_int32 <span class="op">*</span>_Nonnull o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true" tabindex="-1"></a>  cql_contract_argument_notnull<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>o<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>o <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// set out arg to non-garbage</span></span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>i<span class="op">.</span>is_null<span class="op">)</span> <span class="op">{</span></span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">*</span>o <span class="op">=</span> i<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb244-20"><a href="#cb244-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb244-21"><a href="#cb244-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>o <span class="op">=</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb244-22"><a href="#cb244-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb244-23"><a href="#cb244-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-24"><a href="#cb244-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb244-25"><a href="#cb244-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef _PROC_</span></span></code></pre></div>
<p>As we can see, the test has picked out the bits that it wanted to
verify. The <code>coalesce</code> function is verified elsewhere – in
this test we’re making sure that this pattern doesn’t cause extra
temporaries.</p>
<p>Let’s take a quick look at the part of <code>test_common.sh</code>
that runs this:</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a><span class="fu">code_gen_c_test()</span> <span class="kw">{</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&#39;--------------------------------- STAGE 5 -- C CODE GEN TEST&#39;</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> running codegen test</span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="va">${CQL}</span> <span class="at">--test</span> <span class="at">--cg</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_c.h&quot;</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_c.c&quot;</span> <span class="dt">\</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_exports.out&quot;</span> <span class="at">--in</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/cg_test.sql&quot;</span> <span class="dt">\</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">--global_proc</span> cql_startup <span class="at">--generate_exports</span> <span class="dv">2</span><span class="op">&gt;</span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_c.err&quot;</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;ERROR:&quot;</span></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_c.err&quot;</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> validating codegen</span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cql-verify&quot;</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/cg_test.sql&quot;</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/cg_test_c.c&quot;</span></span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;ERROR: failed verification&quot;</span></span>
<span id="cb245-17"><a href="#cb245-17" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb245-18"><a href="#cb245-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb245-19"><a href="#cb245-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-20"><a href="#cb245-20" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> testing for successful compilation of generated C</span>
<span id="cb245-21"><a href="#cb245-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rm</span> <span class="at">-f</span> out/cg_test_c.o</span>
<span id="cb245-22"><a href="#cb245-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="ex">do_make</span> out/cg_test_c.o</span>
<span id="cb245-23"><a href="#cb245-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb245-24"><a href="#cb245-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;ERROR: failed to compile the C code from the code gen test&quot;</span></span>
<span id="cb245-25"><a href="#cb245-25" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb245-26"><a href="#cb245-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb245-27"><a href="#cb245-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-28"><a href="#cb245-28" aria-hidden="true" tabindex="-1"></a>  <span class="ex">...</span></span>
<span id="cb245-29"><a href="#cb245-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-30"><a href="#cb245-30" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&quot;  computing diffs (empty if none)&quot;</span></span>
<span id="cb245-31"><a href="#cb245-31" aria-hidden="true" tabindex="-1"></a>  <span class="ex">on_diff_exit</span> cg_test_c.c</span>
<span id="cb245-32"><a href="#cb245-32" aria-hidden="true" tabindex="-1"></a>  <span class="ex">on_diff_exit</span> cg_test_c.h</span>
<span id="cb245-33"><a href="#cb245-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-34"><a href="#cb245-34" aria-hidden="true" tabindex="-1"></a>  <span class="ex">...</span> other tests</span>
<span id="cb245-35"><a href="#cb245-35" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>Briefly reviewing this, we see the following important steps:</p>
<ul>
<li><code>{CQL} --test --cg etc.</code> : run the compiler on the test
input
<ul>
<li>the test fails if there are any errors</li>
</ul></li>
<li><code>cql-verify</code> : performs the pattern matching
<ul>
<li>the output has the same statement markers as in the semantic
case</li>
</ul></li>
<li><code>do_make</code> : use <code>make</code> to build the generated
code ensuring it compiles cleanly
<ul>
<li>if the C compiler returns any failure, the test fails</li>
</ul></li>
<li><code>on_diff_exit</code> : compares the test output to the
reference output
<ul>
<li>any difference fails the test</li>
</ul></li>
</ul>
<p>This is all remarkably similar to the semantic tests. All the code
generators are tested in the same way.</p>
<h3 id="run-tests">Run Tests</h3>
<p>The last category of tests actually does execution. The main “run
test” happens at “stage 13”, because there are <em>many</em> codegen
tests for the various output formats and these all pass before before we
try to execute anything. This is not so bad because the tests are quite
quick with a full test pass taking less than 90s on my laptop.</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="fu">run_test()</span> <span class="kw">{</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&#39;--------------------------------- STAGE 13 -- RUN CODE TEST&#39;</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> running codegen test with execution</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="ot">! </span><span class="fu">cc</span> <span class="at">-E</span> <span class="at">-x</span> c <span class="at">-w</span> <span class="st">&quot;</span><span class="va">${TEST_DIR}</span><span class="st">/run_test.sql&quot;</span> <span class="dt">\</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;</span><span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/run_test_cpp.out&quot;</span></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> preprocessing failed.</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> <span class="ot">! </span><span class="va">${CQL}</span> <span class="at">--nolines</span> <span class="dt">\</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">--cg</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/run_test.h&quot;</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/run_test.c&quot;</span> <span class="dt">\</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">--in</span> <span class="st">&quot;</span><span class="va">${OUT_DIR}</span><span class="st">/run_test_cpp.out&quot;</span> <span class="dt">\</span></span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">--global_proc</span> cql_startup <span class="at">--rt</span> c</span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> codegen failed.</span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> <span class="ot">! </span><span class="kw">(</span><span class="bu">echo</span> <span class="st">&quot;  compiling code&quot;</span><span class="kw">;</span> <span class="ex">do_make</span> run_test <span class="kw">)</span></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> build failed</span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> <span class="ot">! </span><span class="kw">(</span><span class="bu">echo</span> <span class="st">&quot;  executing tests&quot;</span><span class="kw">;</span> <span class="st">&quot;./</span><span class="va">${OUT_DIR}</span><span class="st">/a.out&quot;</span><span class="kw">)</span></span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">then</span></span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> tests failed</span>
<span id="cb246-23"><a href="#cb246-23" aria-hidden="true" tabindex="-1"></a>    <span class="ex">failed</span></span>
<span id="cb246-24"><a href="#cb246-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">fi</span></span>
<span id="cb246-25"><a href="#cb246-25" aria-hidden="true" tabindex="-1"></a>  <span class="ex">...</span></span></code></pre></div>
<p>The main structure is mostly what one would expect:</p>
<ul>
<li><code>cc -E -x c</code> : this is used to pre-process the run test
file so that we can use C pre-processor features to define tests
<ul>
<li>there are quite a few helpful macros as we’ll see</li>
<li>if pre-processing fails, the test fails</li>
</ul></li>
<li><code>{CQL} --nolines --cg ...</code> : this is used to create the
<code>.h</code> and <code>.c</code> file for the compiland
<ul>
<li><code>--nolines</code> is used to suppress the <code>#</code>
directives that would associate the generated code with the .sql
file</li>
<li>compilation failures cause the test to fail</li>
</ul></li>
<li><code>do_make</code> : as before this causes <code>make</code> to
build the compiland (<code>run_test</code>)
<ul>
<li>this build target includes the necessary bootstrap code to open a
database and start the tests</li>
<li>any failures cause the test to fail</li>
</ul></li>
<li><code>a.out</code> : the tests execute
<ul>
<li>the tests return a failure status code if anything goes wrong</li>
<li>any failure causes the test to fail</li>
</ul></li>
</ul>
<p>The test file <code>run_test.sql</code> includes test macros from
<code>cqltest.h</code> – all of these are very simple. The main ones are
<code>BEGIN_SUITE</code>, <code>END_SUITE</code>,
<code>BEGIN_TEST</code> and <code>END_TEST</code> for structure; and
<code>EXPECT</code> to verify a boolean expression.</p>
<p>Here’s a simple test case with several expectations:</p>
<pre><code>BEGIN_TEST(arithmetic)
  EXPECT_SQL_TOO((1 + 2) * 3 == 9);
  EXPECT_SQL_TOO(1 + 2 * 3 == 7);
  EXPECT_SQL_TOO(6 / 3 == 2);
  EXPECT_SQL_TOO(7 - 5 == 2);
  EXPECT_SQL_TOO(6 % 5 == 1);
  EXPECT_SQL_TOO(5 / 2.5 == 2);
  EXPECT_SQL_TOO(-(1+3) == -4);
  EXPECT_SQL_TOO(-1+3 == 2);
  EXPECT_SQL_TOO(1+-3 == -2);
  EXPECT_SQL_TOO(longs.neg == -1);
  EXPECT_SQL_TOO(-longs.neg == 1);
  EXPECT_SQL_TOO(- -longs.neg == -1);
END_TEST(arithmetic)</code></pre>
<p>We should also reveal <code>EXPECT_SQL_TOO</code>, discussed
below:</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="op">--</span> use this <span class="cf">for</span> both normal eval and SQLite eval</span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define EXPECT_SQL_TOO(x) EXPECT(x); EXPECT((select x))</span></span></code></pre></div>
<p>Now back to the test:</p>
<ul>
<li><code>EXPECT(x)</code> : verifies that <code>x</code> is true
(i.e. a non-zero numeric)
<ul>
<li>not used directly in this example</li>
</ul></li>
<li><code>EXPECT_SQL_TOO</code> : as the definition shows,
<ul>
<li><code>x</code> must be true (as above)</li>
<li><code>(select x)</code> must also be true,
<ul>
<li>i.e. when SQLite is asked to evaluate the expression the result is
also a “pass”</li>
</ul></li>
<li>this is used to verify consistency of order of operations and other
evaluations that must be the same in both forms</li>
<li>note that when <code>(select ...)</code> is used, CQL plays no part
in evaluating the expression, the text of the expression goes to SQLite
and any variables are bound as described in Part 3.</li>
</ul></li>
</ul>
<p>The run test exercises many features, but the testing strategy is
always the same:</p>
<ul>
<li>exercise some code pattern</li>
<li>use <code>EXPECT</code> to validate the results are correct</li>
<li>the expressions in the <code>EXPECT</code> are usually crafted
carefully to show that a certain mistake is not being made
<ul>
<li>e.g. expressions where the result would be different if there are
bugs in order of operations</li>
<li>e.g. expressions that would crash with divide by zero if code that
isn’t supposed to run actually ran</li>
</ul></li>
</ul>
<h3 id="schema-upgrade-testing">Schema Upgrade Testing</h3>
<p>The schema upgrade tester is quite a bit different than the others
and relies heavily on execution of the upgraders. Before we get into
that there is a preliminary topic:</p>
<h4 id="previous-schema-validation">“Previous Schema” Validation</h4>
<p>In order to ensure that it is possible to create an upgrader, CQL
provides features to validate the current schema against the previous
schema ensuring that nothing has been done that would make an upgrader
impossible. This is more fully discussed in <a
href="https://cgsql.dev/cql-guide/ch11">Chapter 11</a> of the Guide.</p>
<p>“Previous Schema” validation is a form of semantic check and so its
testing happens as described above. Importantly, as with the other
back-end passes the schema upgrader does not have to concern itself with
error cases as they are already ruled out. The upgrader itself will be
the subject of Part 5.</p>
<h4 id="packing-list">Packing List</h4>
<p>The test assets for upgrade tests are found in the
<code>upgrade</code> directory and consist of *
<code>SchemaPersistentV0.sql</code> : baseline version of the test
schema * <code>SchemaPersistentV1.sql</code> : v1 of the test schema *
<code>SchemaPersistentV2.sql</code> : v2 of the test schema *
<code>SchemaPersistentV3.sql</code> : v3 of the test schema *
<code>downgrade_test.c</code> : a test that simulates attemping to go
backwards in schema versions * <code>upgrade_test.c</code> : the C
harness that launches the upgraders and fires the tests *
<code>upgrade_test.sh</code> : the shell script that makes all this
happen * <code>upgrade_validate.sql</code> : some simple code that
sanity checks the recorded schema version against tables in it * used to
ensure that the schema we are on is the schema we think we are on, not
to validate all facets of it * also renders the contents of
<code>sqlite_master</code> in a canonical form</p>
<p>We haven’t yet discussed the internals of schema upgrade, so for
purposes of this part we’re only going to discuss how the testing
proceeds. The upgrade will be considered “magic” for now.</p>
<p>In addition to these assets, we also have reference files: *
<code>upgrade_schema_v0.out.ref</code> : expected content of v0 *
<code>upgrade_schema_v1.out.ref</code> : expected content of v1 *
<code>upgrade_schema_v2.out.ref</code> : expected content of v2 *
<code>upgrade_schema_v3.out.ref</code> : expected content of v3</p>
<h4 id="upgrade_validate.sql"><code>upgrade_validate.sql</code></h4>
<p>This file has a single procedure <code>validate_transition</code>
which does the two jobs: * emits the canonicalized version of
<code>sqlite_master</code> to the output * this is needed because
<code>sqlite_master</code> text can vary between Sqlite versions *
checks for basic things that should be present in a given version</p>
<p>The output of the validator looks like this:</p>
<pre><code>reference results for version 0

----- g1 -----

type: table
tbl_name: g1
CREATE TABLE g1(
  id INTEGER PRIMARY KEY,
  name TEXT)

----- sqlite_autoindex_test_cql_schema_facets_1 -----

type: index
tbl_name: test_cql_schema_facets

----- test_cql_schema_facets -----

type: table
tbl_name: test_cql_schema_facets
CREATE TABLE test_cql_schema_facets(
  facet TEXT NOT NULL PRIMARY KEY,
  version LONG_INT NOT NULL)</code></pre>
<p>The formatting rules are very simple and so the output is pretty
readable.</p>
<p>The verifications are very simple.</p>
<p>First this happens:</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>let version <span class="op">:=</span> <span class="fu">cast</span>(test_cql_get_facet_version(<span class="ot">&quot;cql_schema_version&quot;</span>) <span class="kw">as</span> <span class="dt">integer</span>);</span></code></pre></div>
<p>The printing happens, then this simple validation:</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>  let recreate_sql <span class="op">:=</span> (</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">select</span> sql <span class="kw">from</span> sqlite_master</span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> name <span class="op">=</span> <span class="st">&#39;test_this_table_will_become_create&#39;</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">nothing</span> <span class="kw">null</span>);</span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a><span class="op">..</span>.</span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">switch</span> version</span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">when</span> <span class="dv">0</span> <span class="cf">then</span></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> recreate_sql <span class="kw">is</span> <span class="kw">null</span> <span class="kw">or</span> recreate_sql <span class="kw">not</span> <span class="kw">like</span> <span class="st">&#39;%xyzzy INTEGER%&#39;</span> <span class="cf">then</span></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">call</span> printf(<span class="ot">&quot;ERROR! test_this_table_will_become_create should have a column named xyzzy in v%d\n&quot;</span>, version);</span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a>      throw;</span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span> <span class="cf">if</span>;</span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">..</span>.</span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">call</span> printf(<span class="ot">&quot;ERROR! expected schema version v%d\n&quot;</span>, version);</span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>    throw;</span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span>;</span></code></pre></div>
<p>In short, the version number must be one of the valid versions and
each version is expecting that particular table to be in some condition
it can recognize.</p>
<p>The real validation is done by noting any changes in the reference
output plus a series of invariants.</p>
<h4 id="prosecution-of-the-upgrade-test">Prosecution of the Upgrade
Test</h4>
<p>** Launch **</p>
<p>We kick things off as follows:</p>
<ul>
<li><code>test.sh</code> calls <code>upgrade/upgrade_test.sh</code>
<ul>
<li>this test doesn’t usually run standalone (but it can)</li>
</ul></li>
</ul>
<p>** Build Stage **</p>
<p>This creates the various binaries we will need:</p>
<ul>
<li><code>upgrade_validate.sql</code> is compiled down to C
<ul>
<li>this code works for all schema versions, it’s generic</li>
</ul></li>
<li><code>SchemaPersistentV[0-3].sql</code> are compiled into C (this
takes two steps)
<ul>
<li>first, the CQL upgrader is generated from the schema</li>
<li>second, the CQL upgrader is compiled to C</li>
</ul></li>
<li><code>make</code> is used to lower all of the C into executables
<code>upgrade[0-3]</code> plus <code>downgrade_test</code>
<ul>
<li>the shared validation code is linked into all 4 upgraders</li>
<li><code>downgrade_test.c</code> is linked with the code for
<code>upgrade1</code></li>
</ul></li>
</ul>
<p>** Basic Upgrades **</p>
<p>Here we test going from scratch to each of the 4 target versions:</p>
<ul>
<li><code>upgrade[0-3]</code> are each run in turn with no initial
database
<ul>
<li>i.e. their target database is deleted before each run</li>
</ul></li>
<li>the validation output is compared against the reference output
<ul>
<li>any differences fail the test</li>
</ul></li>
</ul>
<p>** Previous Schema Validation **</p>
<p>This sanity checks that the chain of schema we have built should work
when upgrading from one version to the next:</p>
<ul>
<li>try each schema with this predecessor:
<ul>
<li><code>SchemaPersistentV1.sql</code> with
<code>SchemaPersistentV0.sql</code> as the previous</li>
<li><code>SchemaPersistentV2.sql</code> with
<code>SchemaPersistentV1.sql</code> as the previous</li>
<li><code>SchemaPersistentV3.sql</code> with
<code>SchemaPersistentV2.sql</code> as the previous</li>
</ul></li>
<li>if any of these produce errors something is structurally wrong with
the test or else previous schema validation is broken</li>
</ul>
<p>** Two-Step Upgrades **</p>
<p>Now we verify that we can go from any version to any other version
with a stop in between to persist.</p>
<p>An example should make this clearer:</p>
<ul>
<li>We start from scratch and go to v2
<ul>
<li>this should produce the v2 reference schema output as before</li>
</ul></li>
<li>We run the v4 upgrader on this v2 schema
<ul>
<li>this should produce the v4 reference schema output as before</li>
<li>i.e. if we go from nothing to v2 to v4 we get the same as if we just
go to v4 directly</li>
</ul></li>
</ul>
<p>There are quite a few combinations like this, the test output lists
them all:</p>
<pre><code>Upgrade from nothing to v0, then to v0 -- must match direct update to v0
Upgrade from nothing to v0, then to v1 -- must match direct update to v1
Upgrade from nothing to v1, then to v1 -- must match direct update to v1
Upgrade from nothing to v0, then to v2 -- must match direct update to v2
Upgrade from nothing to v1, then to v2 -- must match direct update to v2
Upgrade from nothing to v2, then to v2 -- must match direct update to v2
Upgrade from nothing to v0, then to v3 -- must match direct update to v3
Upgrade from nothing to v1, then to v3 -- must match direct update to v3
Upgrade from nothing to v2, then to v3 -- must match direct update to v3
Upgrade from nothing to v3, then to v3 -- must match direct update to v3</code></pre>
<p>Note that one of the combinations tested is starting on
<code>Vn</code> and “upgrading” from there to <code>Vn</code>. This
should do nothing.</p>
<p>** Testing downgrade **</p>
<p>Here we make sure that any attempt to “go backwards” results in an
error.</p>
<ul>
<li>the <code>v3</code> schema created by the previous test is used as
input to the downgrade test</li>
<li>the downgrade test was linked with the <code>v2</code> upgrader</li>
<li>when executed the <code>v2</code> upgrader should report the error
<ul>
<li>this test’s verifier checks for a correct error report</li>
</ul></li>
<li>the test test fails if the error is no correctly reported</li>
</ul>
<p>The combination of testing reference outputs plus testing these many
invariants at various stages results in a powerful integration test. The
actual schema for the varios versions includes all the supported
transitions such as creating and deleting tables and columns, and
recreating views, indicies, and triggers.</p>
<p>All of the possible transitions are more fully discussed in <a
href="https://cgsql.dev/cql-guide/ch10">Chapter 10</a> of the Guide
which pairs nicely with the previous schema validions discussed in <a
href="https://cgsql.dev/cql-guide/ch11">Chapter 11</a>.</p>
<h3 id="testing-the-line-directives-produced-by-cql">Testing the
<code>#line</code> directives produced by CQL</h3>
<p>[An additional section should be added for the code that verifies the
source line number mappings even though this is a pretty exotic
case.]</p>
<h3 id="summary">Summary</h3>
<p>While there are a few more isolated verifications that happen in
<code>test.sh</code> and of course there is the plumbing necessary to
let <code>cov.sh</code> use the test script to create coverage reports,
the above forms make up the vast majority of the test patterns.</p>
<p>Generally, the test files are designed to hold as many tests as can
reasonably fit with the gating factor being cases where different flags
are necessary. There are two different stages were many different tiny
input files are used to create trivial failures like missing command
line arguments and such. But those cases are all just looking for simple
error text and a failure code, so they should be self-evident. With so
many options, many such baby tests are needed.</p>
<h2 id="part-5-cql-runtime">Part 5: CQL Runtime</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-4">Preface</h3>
<p>Part 5 continues with a discussion of the essentials of the CQL
Runtime. As in the previous sections, the goal here is not to go over
every detail but rather to give a sense of how the runtime works in
general – the core strategies and implementation choices – so that when
reading the source you will have an idea how it all hangs together. To
accomplish this, we’ll illustrate the key pieces that can be customized
and we’ll discuss some interesting cases.</p>
<h2 id="cql-runtime">CQL Runtime</h2>
<p>The parts of the runtime that you can change are in
<code>cqlrt.h</code>, that file invariably ends by including
<code>cqlrt_common.h</code> which are the runtime parts that you
shouldn’t change. Of course this is open source so you can change
anything, but the common things usually don’t need to change –
<code>cqlrt.h</code> should provide you with everything you need to
target new environments.</p>
<p>The compiler itself can be customized see <code>rt.c</code> to emit
different strings to work with your runtime. This is pretty easy to do
without creating a merge hell for yourself. Meta Platforms, for
instance, has its own CQL runtime customized for use on phones that is
not open source (and really I don’t think anyone would want it anyway).
But the point is that you can make your own. In fact I know of two just
within Meta Platforms.</p>
<p>We’ll go over <code>cqlrt.h</code> bit by bit. Keeping in mind it
might change but this is essentially what’s going on. And the essentials
don’t change very often.</p>
<h3 id="standard-headers">Standard headers</h3>
<p>The rest of the system will use these, <code>cqlrt.h</code> is
responsible for bringing in what you need later, or what
<code>cqlrt_common.h</code> needs on your system.</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stddef.h&gt;</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sqlite3.h&gt;</span></span>
<span id="cb253-8"><a href="#cb253-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-9"><a href="#cb253-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef __clang__</span></span>
<span id="cb253-10"><a href="#cb253-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef _Nonnull</span></span>
<span id="cb253-11"><a href="#cb253-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Hide Clang-only nullability specifiers if not Clang */</span></span>
<span id="cb253-12"><a href="#cb253-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define _Nonnull</span></span>
<span id="cb253-13"><a href="#cb253-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define _Nullable</span></span>
<span id="cb253-14"><a href="#cb253-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb253-15"><a href="#cb253-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h3 id="contract-and-error-macros">Contract and Error Macros</h3>
<p>CQL has a few different macros it uses for errors.
<code>contract</code>, <code>invariant</code>, and <code>tripwire</code>
usually all map to <code>assert</code>. Note that <code>tripwire</code>
doesn’t have to be fatal, it can log in production and continue. This is
a “softer” assertion. Something that you’re trying out that you’d like
to be a <code>contract</code> but maybe there are lingering cases that
have to be fixed first.</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_contract assert</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_invariant assert</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_tripwire assert</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_log_database_error(...)</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_error_trace()</span></span></code></pre></div>
<h3 id="the-value-types">The Value Types</h3>
<p>You can define these types to be whatever is appropriate on your
system. Usually the mapping is pretty obvious.</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="co">// value types</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">char</span> cql_bool<span class="op">;</span></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_true (cql_bool)1</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_false (cql_bool)0</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> cql_hash_code<span class="op">;</span></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int32_t</span> cql_int32<span class="op">;</span></span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint32_t</span> cql_uint32<span class="op">;</span></span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint16_t</span> cql_uint16<span class="op">;</span></span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> sqlite3_int64 cql_int64<span class="op">;</span></span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">double</span> cql_double<span class="op">;</span></span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> cql_code<span class="op">;</span></span></code></pre></div>
<h3 id="the-reference-types">The Reference Types</h3>
<p>The default runtime first defines 4 types of reference objects. These
are the only reference types that CQL creates itself. In fact CQL
doesn’t actually create <code>CQL_C_TYPE_OBJECT</code> but the tests do.
CQL never creates raw object things, only external functions can do
that.</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="co">// metatypes for the straight C implementation</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_C_TYPE_STRING 0</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_C_TYPE_BLOB 1</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_C_TYPE_RESULTS 2</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_C_TYPE_BOXED_STMT 3</span></span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_C_TYPE_OBJECT 4</span></span></code></pre></div>
<p>All the reference types are reference counted. So they need a simple
shape that allows them to know their own type and have a count. They
also have a finalize method to clean up their memory when the count goes
to zero.</p>
<p>You get to define <code>cql_type_ref</code> to be whatever you
want.</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="co">// base ref counting struct</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_type <span class="op">*</span>cql_type_ref<span class="op">;</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_type <span class="op">{</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> type<span class="op">;</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ref_count<span class="op">;</span></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">(*</span>_Nullable finalize<span class="op">)(</span>cql_type_ref _Nonnull ref<span class="op">);</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_type<span class="op">;</span></span></code></pre></div>
<p>Whatever you do with the types you’ll need to define a retain and
release method that uses them as the signature. Normal references should
have a generic value comparison and a hash.</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cql_retain<span class="op">(</span>cql_type_ref _Nullable ref<span class="op">);</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cql_release<span class="op">(</span>cql_type_ref _Nullable ref<span class="op">);</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>cql_hash_code cql_ref_hash<span class="op">(</span>cql_type_ref _Nonnull typeref<span class="op">);</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a>cql_bool cql_ref_equal<span class="op">(</span>cql_type_ref _Nullable typeref1<span class="op">,</span> cql_type_ref _Nullable typeref2<span class="op">);</span></span></code></pre></div>
<p>Now each of the various kinds of reference types needs an object
which probably includes the base type above. It doesn’t have to. You can
arrange for some other universal way to do these. On iOS these can be
easily mapped to <code>CF</code> types.</p>
<p>The <code>retain</code> and <code>release</code> macros should all
map to the same thing. The compiler emits different variations for
readability only. It doesn’t really work if they don’t have common
retain/release semantics.</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="co">// builtin object</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_object <span class="op">*</span>cql_object_ref<span class="op">;</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_object <span class="op">{</span></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a>  cql_type base<span class="op">;</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>_Nonnull ptr<span class="op">;</span></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_object<span class="op">;</span></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_object_retain(object) cql_retain((cql_type_ref)object);</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_object_release(object) cql_release((cql_type_ref)object);</span></span></code></pre></div>
<p>Boxed statement gets its own implementation, same as object.</p>
<pre><code>// builtin statement box
typedef struct cql_boxed_stmt *cql_boxed_stmt_ref;
typedef struct cql_boxed_stmt {
  cql_type base;
  sqlite3_stmt *_Nullable stmt;
} cql_boxed_stmt;</code></pre>
<p>Same for blob, and blob has a couple of additional helper macros that
are used to get information. Blobs also have hash and equality
functions.</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="co">// builtin blob</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_blob <span class="op">*</span>cql_blob_ref<span class="op">;</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_blob <span class="op">{</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>  cql_type base<span class="op">;</span></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>_Nonnull ptr<span class="op">;</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>  cql_uint32 size<span class="op">;</span></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_blob<span class="op">;</span></span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_blob_retain(object) cql_retain((cql_type_ref)object);</span></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_blob_release(object) cql_release((cql_type_ref)object);</span></span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a>cql_blob_ref _Nonnull cql_blob_ref_new<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>_Nonnull data<span class="op">,</span> cql_uint32 size<span class="op">);</span></span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_get_blob_bytes(data) (data-&gt;ptr)</span></span>
<span id="cb261-12"><a href="#cb261-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_get_blob_size(data) (data-&gt;size)</span></span>
<span id="cb261-13"><a href="#cb261-13" aria-hidden="true" tabindex="-1"></a>cql_hash_code cql_blob_hash<span class="op">(</span>cql_blob_ref _Nullable str<span class="op">);</span></span>
<span id="cb261-14"><a href="#cb261-14" aria-hidden="true" tabindex="-1"></a>cql_bool cql_blob_equal<span class="op">(</span>cql_blob_ref _Nullable blob1<span class="op">,</span> cql_blob_ref _Nullable blob2<span class="op">);</span></span></code></pre></div>
<p>Strings are the same as the others but they have many more functions
associated with them.</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="co">// builtin string</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_string <span class="op">*</span>cql_string_ref<span class="op">;</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_string <span class="op">{</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a>  cql_type base<span class="op">;</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nullable ptr<span class="op">;</span></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_string<span class="op">;</span></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a>cql_string_ref _Nonnull cql_string_ref_new<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>_Nonnull cstr<span class="op">);</span></span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_string_retain(string) cql_retain((cql_type_ref)string);</span></span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_string_release(string) cql_release((cql_type_ref)string);</span></span></code></pre></div>
<p>The compiler uses this macro to create a named string literal. You
decide how those will be implemented right here.</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_string_literal(name, text) \</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a><span class="pp">  cql_string name##_ = { \</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a><span class="pp">    .base = { \</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a><span class="pp">      .type = CQL_C_TYPE_STRING, \</span></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a><span class="pp">      .ref_count = 1, \</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a><span class="pp">      .finalize = NULL, \</span></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a><span class="pp">    }, \</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a><span class="pp">    .ptr = text, \</span></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a><span class="pp">  }; \</span></span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a><span class="pp">  cql_string_ref name = &amp;name##_</span></span></code></pre></div>
<p>Strings get assorted comparison and hashing functions. Note blob also
had a hash.</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cql_string_compare<span class="op">(</span>cql_string_ref _Nonnull s1<span class="op">,</span> cql_string_ref _Nonnull s2<span class="op">);</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a>cql_hash_code cql_string_hash<span class="op">(</span>cql_string_ref _Nullable str<span class="op">);</span></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>cql_bool cql_string_equal<span class="op">(</span>cql_string_ref _Nullable s1<span class="op">,</span> cql_string_ref _Nullable s2<span class="op">);</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cql_string_like<span class="op">(</span>cql_string_ref _Nonnull s1<span class="op">,</span> cql_string_ref _Nonnull s2<span class="op">);</span></span></code></pre></div>
<p>Strings can be converted from their reference form to standard C
form. These macros define how this is done. Note that temporary
allocations are possible here but the standard implementation does not
actually need to do an alloc. It stores UTF8 in the string pointer so
it’s ready to go.</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_alloc_cstr(cstr, str) const char *_Nonnull cstr = (str)-&gt;ptr</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_free_cstr(cstr, str) 0</span></span></code></pre></div>
<p>The macros for result sets have somewhat less flexibility. The main
thing that you can do here is add additional fields to the “meta”
structure. It needs those key fields because it is created by the
compiler. However the API is used to create a result set so that can be
any object you like. It only has to respond to the
<code>get_meta</code>, <code>get_data</code>, and <code>get_count</code>
apis. Those can be mapped as you desire. In principle there could have
been a macro to create the “meta” as well (a PR for this is welcome) but
it’s really a pain for not much benefit. The advantage of defining your
own “meta” is that you can use it to add additional custom APIs to your
result set that might need some storage.</p>
<p>The additional API
<code>cql_result_set_note_ownership_transferred(result_set)</code> is
used in the event that you are moving ownership of the buffers from out
of CQL’s universe. So like maybe JNI is absorbing the result, or
Objective C is absorbing the result. The default implementation is a
no-op.</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="co">// builtin result set</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_result_set <span class="op">*</span>cql_result_set_ref<span class="op">;</span></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_result_set_meta <span class="op">{</span></span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> cql_result_set <span class="op">{</span></span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a>  cql_type base<span class="op">;</span></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a>  cql_result_set_meta meta<span class="op">;</span></span>
<span id="cb266-11"><a href="#cb266-11" aria-hidden="true" tabindex="-1"></a>  cql_int32 count<span class="op">;</span></span>
<span id="cb266-12"><a href="#cb266-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nonnull data<span class="op">;</span></span>
<span id="cb266-13"><a href="#cb266-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> cql_result_set<span class="op">;</span></span>
<span id="cb266-14"><a href="#cb266-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-15"><a href="#cb266-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_type_decl(result_set_type, result_set_ref) \</span></span>
<span id="cb266-16"><a href="#cb266-16" aria-hidden="true" tabindex="-1"></a><span class="pp">  typedef struct _##result_set_type *result_set_ref;</span></span>
<span id="cb266-17"><a href="#cb266-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-18"><a href="#cb266-18" aria-hidden="true" tabindex="-1"></a>cql_result_set_ref _Nonnull cql_result_set_create<span class="op">(</span></span>
<span id="cb266-19"><a href="#cb266-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nonnull data<span class="op">,</span></span>
<span id="cb266-20"><a href="#cb266-20" aria-hidden="true" tabindex="-1"></a>  cql_int32 count<span class="op">,</span></span>
<span id="cb266-21"><a href="#cb266-21" aria-hidden="true" tabindex="-1"></a>  cql_result_set_meta meta<span class="op">);</span></span>
<span id="cb266-22"><a href="#cb266-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-23"><a href="#cb266-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_retain(result_set) cql_retain((cql_type_ref)result_set);</span></span>
<span id="cb266-24"><a href="#cb266-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_release(result_set) cql_release((cql_type_ref)result_set);</span></span>
<span id="cb266-25"><a href="#cb266-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_note_ownership_transferred(result_set)</span></span>
<span id="cb266-26"><a href="#cb266-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_get_meta(result_set) (&amp;((cql_result_set_ref)result_set)-&gt;meta)</span></span>
<span id="cb266-27"><a href="#cb266-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_get_data(result_set) ((cql_result_set_ref)result_set)-&gt;data</span></span>
<span id="cb266-28"><a href="#cb266-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_result_set_get_count(result_set) ((cql_result_set_ref)result_set)-&gt;count</span></span></code></pre></div>
<h3 id="mocking">Mocking</h3>
<p>The CQL run test needs to do some mocking. This bit is here for that
test. If you want to use the run test with your version of
<code>cqlrt</code> you’ll need to define a shim for
<code>sqlite3_step</code> that can be intercepted. This probably isn’t
going to come up.</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef CQL_RUN_TEST</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define sqlite3_step mockable_sqlite3_step</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>SQLITE_API cql_code mockable_sqlite3_step<span class="op">(</span>sqlite3_stmt <span class="op">*</span>_Nonnull<span class="op">);</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h3 id="profiling">Profiling</h3>
<p>If you want to support profiling you can implement
<code>cql_profile_start</code> and <code>cql_profile_stop</code> to do
whatever you want. The CRC uniquely identifies a procedure (you can log
that). The <code>index</code> provides you with a place to store
something that you can use as a handle in your logging system. Typically
an integer. This lets you assign indices to the procedures you actually
saw in any given run and then log them or something like that. No data
about parameters is provided, this is deliberate.</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="co">// No-op implementation of profiling</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a><span class="co">// * Note: we emit the crc as an expression just to be sure that there are no compiler</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a><span class="co">//   errors caused by names being incorrect.  This improves the quality of the CQL</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a><span class="co">//   code gen tests significantly.  If these were empty macros (as they once were)</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   you could emit any junk in the call and it would still compile.</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_profile_start(crc, index) (void)crc; (void)index;</span></span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define cql_profile_stop(crc, index)  (void)crc; (void)index;</span></span></code></pre></div>
<p>The definitions in <code>cqlrt_common.c</code> can provide codegen
than either has generic “getters” for each column type (useful for JNI)
or produces a unique getter that isn’t shared. The rowset metadata will
include the values for <code>getBoolean</code>, <code>getDouble</code>
etc. if <code>CQL_NO_GETTERS</code> is 0. Getters are a little slower
for C but give you a small number of functions that need to have JNI if
you are targeting Java.</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="co">// the basic version doesn&#39;t use column getters</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CQL_NO_GETTERS 1</span></span></code></pre></div>
<h3 id="encoding-of-sensitive-columns">Encoding of Sensitive
Columns</h3>
<p>By setting an attribute on any procedure that produces a result set
you can have the selected sensitive values encoded. If this happens CQL
first asks for the encoder and then calls the encode methods passing in
the encoder. These aren’t meant to be cryptograhically secure but rather
to provide some ability to prevent mistakes. If you opt in, sensitive
values have to be deliberately decoded and that provides an audit
trail.</p>
<p>The default implementation of all this is a no-op.</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="co">// implementation of encoding values. All sensitive values read from sqlite db will</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a><span class="co">// be encoded at the source. CQL never decode encoded sensitive string unless the</span></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="co">// user call explicitly decode function from code.</span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>cql_object_ref _Nullable cql_copy_encoder<span class="op">(</span>sqlite3 <span class="op">*</span>_Nonnull db<span class="op">);</span></span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a>cql_bool cql_encode_bool<span class="op">(...)</span></span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>cql_int32 cql_encode_int32<span class="op">(...)</span></span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a>cql_int64 cql_encode_int64<span class="op">(...)</span></span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a>cql_double cql_encode_double<span class="op">(...)</span></span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a>cql_string_ref _Nonnull cql_encode_string_ref_new<span class="op">(...);</span></span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a>cql_blob_ref _Nonnull cql_encode_blob_ref_new<span class="op">(..);</span></span>
<span id="cb270-11"><a href="#cb270-11" aria-hidden="true" tabindex="-1"></a>cql_bool cql_decode_bool<span class="op">(...);</span></span>
<span id="cb270-12"><a href="#cb270-12" aria-hidden="true" tabindex="-1"></a>cql_int32 cql_decode_int32<span class="op">(...);</span></span>
<span id="cb270-13"><a href="#cb270-13" aria-hidden="true" tabindex="-1"></a>cql_int64 cql_decode_int64<span class="op">(...);</span></span>
<span id="cb270-14"><a href="#cb270-14" aria-hidden="true" tabindex="-1"></a>cql_double cql_decode_double<span class="op">(...);</span></span>
<span id="cb270-15"><a href="#cb270-15" aria-hidden="true" tabindex="-1"></a>cql_string_ref _Nonnull cql_decode_string_ref_new<span class="op">(...);</span></span>
<span id="cb270-16"><a href="#cb270-16" aria-hidden="true" tabindex="-1"></a>cql_blob_ref _Nonnull cql_decode_blob_ref_new<span class="op">(...);</span></span></code></pre></div>
<h3 id="boxing-statements">Boxing Statements</h3>
<p>You must provide helpers to “box” and “unbox” a SQLite statement into
a <code>cql_ref_type</code> of the appropriate type. These are used to
create boxed cursors.</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>cql_object_ref _Nonnull cql_box_stmt<span class="op">(</span>sqlite3_stmt <span class="op">*</span>_Nullable stmt<span class="op">);</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>sqlite3_stmt <span class="op">*</span>_Nullable cql_unbox_stmt<span class="op">(</span>cql_object_ref _Nonnull ref<span class="op">);</span></span></code></pre></div>
<h3 id="the-common-headers">The Common Headers</h3>
<p>The standard APIs all build on the above, so they should be included
last.</p>
<p>Now in some cases the signature of the things you provide in
<code>cqlrt.h</code> is basically fixed, so it seems like it would be
easier to move the prototpyes into <code>cqlrt_common.h</code>. However,
in many cases additional things are needed like <code>declspec</code> or
<code>export</code> or other system specific things. The result is that
<code>cqlrt.h</code> is maybe a bit more verbose that it strictly needs
to be. Also some versions of cqlrt.h choose to implement some of the
APIs as macros…</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">NOTE</span><span class="co">: This must be included *after* all of the above symbols/macros.</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;cqlrt_common.h&quot;</span></span></code></pre></div>
<h3 id="the-cqlrt_cf-runtime">The <code>cqlrt_cf</code> Runtime</h3>
<p>In order to use the Objective-C code-gen (<code>--rt objc</code>) you
need a runtime that has reference types that are friendly to
Objective-C. For this purpose we created an open-source version of such
a runtime: it can be found in the <code>sources/cqlrt_cf</code>
directory. This runtime is also a decent example of how much
customization you can do with just a little code. Some brief notes:</p>
<ul>
<li>This runtime really only makes sense on macOS, iOS, or maybe some
other place that Core Foundation (<code>CF</code>) exists
<ul>
<li>As such its build process is considerably less portable than other
parts of the system</li>
</ul></li>
<li>The CQL reference types have been redefined so that they map to:
<ul>
<li><code>CFStringRef</code> (strings)</li>
<li><code>CFTypeRef</code> (objects)</li>
<li><code>CFDataRef</code> (blobs)</li>
</ul></li>
<li>The key worker functions use <code>CF</code>, e.g.
<ul>
<li><code>cql_ref_hash</code> maps to <code>CFHash</code></li>
<li><code>cql_ref_equal</code> maps to <code>CFEqual</code></li>
<li><code>cql_retain</code> uses <code>CFRetain</code> (with a null
guard)</li>
<li><code>cql_release</code> uses <code>CFRelease</code> (with a null
guard)</li>
</ul></li>
<li>Strings use <code>CF</code> idioms, e.g.
<ul>
<li>string literals are created with <code>CFSTR</code></li>
<li>C strings are created by using <code>CFStringGetCStringPtr</code> or
<code>CFStringGetCString</code> when needed</li>
</ul></li>
</ul>
<p>Of course, since the meaning of some primitive types has changed, the
contract to the CQL generated code has changed accordingly. For
instance:</p>
<ul>
<li>procedures compiled against this runtime expect string arguments to
be <code>CFStringRef</code></li>
<li>result sets provide <code>CFStringRef</code> values for string
columns</li>
</ul>
<p>The consequence of this is that the Objective-C code generation
<code>--rt objc</code> finds friendly contracts that it can freely
convert to types like <code>NSString *</code> which results in seamless
integration with the rest of an Objective-C application.</p>
<p>Of course the downside of all this is that the <code>cqlrt_cf</code>
runtime is less portable. It can only go where <code>CF</code> exists.
Still, it is an interesting demonstration of the flexablity of the
system.</p>
<p>The system could be further improved by creating a custom result type
(e.g. <code>--rt c_cf</code>) and using some of the result type options
for the C code generation. For instance, the compiler could do these
things:</p>
<ul>
<li>generate <code>CFStringRef foo;</code> instead of
<code>cql_string_ref foo;</code> for declarations</li>
<li>generate <code>SInt32 an_integer</code> instead of
<code>cql_int32 an_integer</code></li>
</ul>
<p>Even though <code>cqlrt_cf</code> is already mapping
<code>cql_int32</code> to something compatible with <code>CF</code>,
making such changes would make the C output a little bit more
<code>CF</code> idiomatic. This educational exercise could probably be
completed in just a few minutes by interested readers.</p>
<p>The <code>make.sh</code> file in the <code>sources/cqlrt_cf</code>
directory illustrates how to get CQL to use this new runtime. The demo
itself is a simple port of the code in <a
href="https://cgsql.dev/cql-guide/x10">Appendix 10</a>.</p>
<h3 id="recap-2">Recap</h3>
<p>The CQL runtime, <code>cqlrt.c</code>, is intended to be replaced.
The version that ships with the distribution is a simple, portable
implementation that is single threaded. Serious users of CQL will likely
want to replace the default version of the runtime with something more
tuned to their use case.</p>
<p>Topics covered included:</p>
<ul>
<li>contract, error, and tracing macros</li>
<li>how value types are defined</li>
<li>how reference types are defined</li>
<li>mocking (for use in a test suite)</li>
<li>profiling</li>
<li>encoding of sensitive columns</li>
<li>boxing statements</li>
<li>the <code>cqlrt_cf</code> runtime</li>
</ul>
<p>As with the other parts, no attempt was made to cover every detail.
That is best done by reading the source code.</p>
<h2 id="part-6-schema-management">Part 6: Schema Management</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-5">Preface</h3>
<p>Part 6 continues with a discussion of the essentials of schema
management in the CQL compiler. As in the previous parts, the goal here
is not to go over every detail of the system but rather to give a sense
of how schema management happens in general – the core strategies and
implementation choices – so that when reading the management code you
will have an idea how it all hangs together. To accomplish this, various
key data structures will be explained in detail and accompanied by
examples of their use.</p>
<h2 id="schema-management">Schema Management</h2>
<p>The primary goal of the schema management features of the CQL
compiler is to provide the ability to create a “schema upgrader” that
can move a given user’s database from a previous version of the schema
to the current version. Because of the limitations of SQL in general,
and SQLite in particular, not all transforms are possible; so
additionally the system must correctly detect and prevent upgrades that
cannot be safely performed.</p>
<p>The full set of schema attributes and their meaning is described in
<a href="https://cgsql.dev/cql-guide/ch10">Chapter 10</a> and the full
set of validations is described in <a
href="https://cgsql.dev/cql-guide/ch11">Chapter 11</a>. Briefly the
directives are:</p>
<ul>
<li><code>@create(n)</code>: indicates a table/column is to be created
at version <code>n</code>.</li>
<li><code>@delete(n)</code>: indicates a table/column is to be deleted
at version <code>n</code>.</li>
<li><code>@recreate</code>: indicates the table contents are not
precious
<ul>
<li>the table can be dropped and created when its schema changes</li>
<li>this does not combine with <code>@create</code></li>
<li>it applies only to tables</li>
<li>views, triggers, and indices are always on the
<code>@recreate</code> plan and do not have to be marked so</li>
</ul></li>
</ul>
<p>Now the various annotations can occur substantially in any order as
there are no rules that require that tables that are created later in
time appear later in the input. This means the appearance order of
tables is in general very inconvenient for any upgrading logic. However,
the semantic validation pass gathers all the annotations into two large
<code>bytebuf</code> objects which can be readily sorted – one for
things on the <code>@create</code> plan and one for the
<code>@recreate</code> plan. These will be discussed below.</p>
<p>At this point it’s probably best to start looking at some of the code
fragments. We’re going to be looking at all the steps in the top level
function:</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Main entry point for schema upgrade code-gen.</span></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> cg_schema_upgrade_main<span class="op">(</span>ast_node <span class="op">*</span>head<span class="op">)</span> <span class="op">{</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>options<span class="op">.</span>file_names_count <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the schema upgrader code generator in CQL does not produce
<code>C</code> but rather it produces more <code>CQL</code> which then
has to be compiled down to <code>C</code>. This choice means that the
codegen is a lot more readable and gets the benefit of the usual CQL
error checking and exception management.</p>
<h3 id="check-for-errors-check-for---global_proc">Check for errors,
check for <code>--global_proc</code></h3>
<p>We start with some simple error checks: Any semantic errors abort the
code-generation. The <code>--global_proc</code> names the procedure that
will do the upgrade. It is also used as a prefix on all of the tables
that the upgrader requires. This makes it possible, if desired, to have
separate upgraders for different parts of your schema, or to combine
upgraders from two different unrelated subsystems in the same
database.</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>  cql_exit_on_semantic_errors<span class="op">(</span>head<span class="op">);</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a>  exit_on_no_global_proc<span class="op">();</span></span></code></pre></div>
<h3 id="preparing-the-attributes">Preparing the Attributes</h3>
<p>The two arrays <code>schema_annotations</code> and
<code>recreate_annotations</code> are sorted. The item count can be
easily computed using the allocated size of these items, both of which
are of type <code>bytebuf</code>. The comparators provided to
<code>qsort</code> put these arrays in exactly the order needed.</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// first sort the schema annotations according to version, type etc.</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// we want to process these in an orderly fashion and the upgrade rules</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// are nothing like the declared order.</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>base <span class="op">=</span> schema_annotations<span class="op">-&gt;</span>ptr<span class="op">;</span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> schema_items_size <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>schema_annotation<span class="op">);</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> schema_items_count <span class="op">=</span> schema_annotations<span class="op">-&gt;</span>used <span class="op">/</span> schema_items_size<span class="op">;</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>  schema_annotation <span class="op">*</span>notes <span class="op">=</span> <span class="op">(</span>schema_annotation<span class="op">*)</span>base<span class="op">;</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> max_schema_version <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>schema_items_count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a>     qsort<span class="op">(</span>base<span class="op">,</span> schema_items_count<span class="op">,</span> schema_items_size<span class="op">,</span> annotation_comparator<span class="op">);</span></span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a>     max_schema_version <span class="op">=</span> notes<span class="op">[</span>schema_items_count <span class="op">-</span> <span class="dv">1</span><span class="op">].</span>version<span class="op">;</span></span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-14"><a href="#cb275-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// likewise, @recreate annotations, in the correct upgrade order (see comparator)</span></span>
<span id="cb275-15"><a href="#cb275-15" aria-hidden="true" tabindex="-1"></a>  base <span class="op">=</span> recreate_annotations<span class="op">-&gt;</span>ptr<span class="op">;</span></span>
<span id="cb275-16"><a href="#cb275-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> recreate_items_size <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>recreate_annotation<span class="op">);</span></span>
<span id="cb275-17"><a href="#cb275-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> recreate_items_count <span class="op">=</span> recreate_annotations<span class="op">-&gt;</span>used <span class="op">/</span> recreate_items_size<span class="op">;</span></span>
<span id="cb275-18"><a href="#cb275-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>recreate_items_count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb275-19"><a href="#cb275-19" aria-hidden="true" tabindex="-1"></a>    qsort<span class="op">(</span>base<span class="op">,</span> recreate_items_count<span class="op">,</span> recreate_items_size<span class="op">,</span> recreate_comparator<span class="op">);</span></span>
<span id="cb275-20"><a href="#cb275-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb275-21"><a href="#cb275-21" aria-hidden="true" tabindex="-1"></a>  recreate_annotation <span class="op">*</span>recreates <span class="op">=</span> <span class="op">(</span>recreate_annotation <span class="op">*)</span>base<span class="op">;</span></span></code></pre></div>
<h3 id="creating-the-global-crc">Creating the Global CRC</h3>
<p>Schema upgrade is expensive, so we want to be able to quickly detect
if the schema installed is already the latest version. To do this we
compute a single global 64-bit CRC for the current version of the
schema. This can be compared against a stored schema CRC from the last
run. If the CRCs match, no work needs to be done.</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>all_schema<span class="op">);</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// emit canonicalized schema for everything we will upgrade</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this will include the schema declarations for the ad hoc migrations, too;</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a>  cg_generate_schema_by_mode<span class="op">(&amp;</span>all_schema<span class="op">,</span> SCHEMA_TO_UPGRADE<span class="op">);</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// compute the master CRC using schema and migration scripts</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a>  llint_t schema_crc <span class="op">=</span> <span class="op">(</span>llint_t<span class="op">)</span>crc_charbuf<span class="op">(&amp;</span>all_schema<span class="op">);</span></span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-9"><a href="#cb276-9" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>all_schema<span class="op">);</span></span></code></pre></div>
<p>The schema generator is used to emit the full schema, including
annotations, into a buffer. A raw CRC of the buffer gives us the
“global” or “overall” CRC for the whole schema.</p>
<h3 id="output-fragments">Output Fragments</h3>
<p>A number of buffers will hold the various pieces of output.</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>preamble<span class="op">);</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>main<span class="op">);</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>decls<span class="op">);</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>pending<span class="op">);</span></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>upgrade<span class="op">);</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>baseline<span class="op">);</span></span></code></pre></div>
<p>These will be assembled as follows:</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>output_file<span class="op">);</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> decls<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> preamble<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> main<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>  cql_write_file<span class="op">(</span>options<span class="op">.</span>file_names<span class="op">[</span><span class="dv">0</span><span class="op">],</span> output_file<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>output_file<span class="op">);</span></span></code></pre></div>
<p>In short: * first <code>decls</code>, this declares the schema among
other things * then, <code>preamble</code>, this contains helper
procedures * then, <code>main</code>, the primary upgrader steps go
here</p>
<p>We’ll go over all of these in subsequent sections.</p>
<h3 id="declarations-section">Declarations Section</h3>
<p>The result type includes a customizable prefix string. This is the
first thing to go out. Typically this is the appropriate copyright
notice. <code>rt.c</code> has this information and that file is
replaceable.</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> rt<span class="op">-&gt;</span>source_prefix<span class="op">);</span></span></code></pre></div>
<p>The schema upgrade script is in the business of creating tables from
old versions and then altering them. The table declarations will be for
the final shape. We need to emit <code>@SCHEMA_UPGRADE_SCRIPT</code> so
that the CQL compiler knows that there will be multiple declarations of
the same table and they might not be identical. The upgrade script is in
the business of getting things to the end state. Likewise it is normal
for the schema upgrade script to refer to columns that have been
deleted, this is because a column might be created in say version 5 and
then deleted in version 10. The upgrade code goes through the columns
lifecycle, so even though the declarations already say the column is
doomed to die in version 10, the creation code in version 5 is legal –
and necessary. Schema migration steps that run in version 6, 7, 8, or 9
might use the contents of the column as part of essential data
migration. We can never know what version we might find in a database
that is being upgraded, it could be very far in the past, at a time
where a deleted column still existed.</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;-- no columns will be considered hidden in this script</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;-- DDL in procs will not count as declarations</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;@SCHEMA_UPGRADE_SCRIPT;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>A convenience comment goes in the <code>decls</code> section with the
CRC.</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;-- schema crc %lld</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span> schema_crc<span class="op">);</span></span></code></pre></div>
<p>There are a set of functions that allow the creation of, and access
to, an in-memory cache of the facet state. These functions are all
defined in <code>cqlrt_common.c</code>. But they have to be declared to
CQL to use them.</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a>  cg_schema_emit_facet_functions<span class="op">(&amp;</span>decls<span class="op">);</span></span></code></pre></div>
<p>The table <code>sqlite_master</code> is used to read schema state.
That table has to be declared.</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>  cg_schema_emit_sqlite_master<span class="op">(&amp;</span>decls<span class="op">);</span></span></code></pre></div>
<p>The full schema may be used by the upgraders, we need a declaration
of all of that.</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;-- declare full schema of tables and views to be upgraded and their dependencies -- </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a>  cg_generate_schema_by_mode<span class="op">(&amp;</span>decls<span class="op">,</span> SCHEMA_TO_DECLARE<span class="op">);</span></span></code></pre></div>
<p>At this point a quick side-step to the output modes and region
arguments is appropriate.</p>
<h4 id="schema-region-arguments">Schema Region Arguments</h4>
<p>The upgrader honors the arguments <code>--include_regions</code> and
<code>--exclude_regions</code>. If they are absent that is the same as
“include everything” and “exclude nothing”. Recall that schema regions
allow you to group schema as you wish. A typical use might be to define
some “core” schema in a set of regions (maybe just one) and then a set
of “optional” schema in some additional regions.</p>
<p>An upgrader for just “core” could be created by adding
<code>--include_regions core</code>. When creating upgraders for the
optional parts, there are two choices:</p>
<ul>
<li><code>--include-regions optional1</code> : makes an upgrader for
<code>optional1</code> and <code>core</code> (the assumption being that
<code>optional1</code> was declared to depend on <code>core</code>)</li>
<li><code>--include-regions optional1</code>
<code>--exclude-regions core</code> : makes an upgrader for
<code>optional1</code> which should run after the standalone
<code>core</code> upgrader has already run
<ul>
<li>this allows you to share the “core” parts between any number of
“optional” parts</li>
<li>and of course this can nest; there can be several “core” parts; and
so forth</li>
</ul></li>
</ul>
<h4 id="schema-output-modes">Schema Output Modes</h4>
<p>The flag bits are these:</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We declare all schema we might depend on in this upgrade (this is the include list)</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a><span class="co">// e.g. we need all our dependent tables so that we can legally use them in an FK</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_TO_DECLARE 1</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We only emit schema that we are actually updating (this is include - exclude)</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a><span class="co">// e.g. a table on the exclude list is assumed to be upgraded by its own script</span></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a><span class="co">// in a different run.</span></span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_TO_UPGRADE 2</span></span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-10"><a href="#cb285-10" aria-hidden="true" tabindex="-1"></a><span class="co">// We get TEMP items IF and ONLY IF this bit is set</span></span>
<span id="cb285-11"><a href="#cb285-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCHEMA_TEMP_ITEMS 4</span></span></code></pre></div>
<p>As we saw before, the schema we CRC is
<code>SCHEMA_TO_UPGRADE</code>. This is all the regions that were
selected but not their dependencies. The point of this is that you might
make an upgrader for say a “core” part of your schema which can be
shared and then make additional upgraders for various parts that use the
“core” but are otherwise “optional”. Each of those “optional” upgraders
needs its own CRC that includes its schema but not the “core” schema.
However the “optional” schema can refer to “core” schema (e.g. in
foreign keys) so all of the tables are declared. This is
<code>SCHEMA_TO_DECLARE</code> mode.</p>
<ul>
<li>declare all schema you are allowed to refer to</li>
<li>CRC, and upgrade, only the parts selected by the region
arguments</li>
</ul>
<h3 id="the-schema-helpers">The Schema Helpers</h3>
<p>This bit generates the <code>facets</code> table, the full name is
<code>your_global_proc_cql_schema_facets</code> where
<code>your_global_proc</code> is the <code>--global_proc</code>
argument. This is referred to simply as the <code>facets</code> table.
There is an identical temporary table that is used to store the contents
of the <code>facets</code> table upon startup. This allows the upgrader
to produce a complete difference. The <code>facets</code> table is
nothing more than a mapping between the name of some facet of the schema
(like a table, a view, a column) and its last known verison info –
usually its CRC.</p>
<ul>
<li>NOTE: this temp table predates the in-memory facets data structure
so it could probably be removed
<ul>
<li>the diff would have to work against the in-memory datastructure
which is immutable hence just as good as a temp table</li>
<li>look for a change like this soon</li>
</ul></li>
</ul>
<p>The remaining procedures are for testing facet state or
<code>sqlite_master</code> state. All of them get the usual global
prefix. For ease of discussion I will elide the prefix for the rest of
this document.</p>
<ul>
<li><code>check_column_exists</code> : checks if the indicated column is
present in <code>sqlite_master</code>
<ul>
<li>necessary because there is no
<code>ALTER TABLE ADD COLUMN IF NOT EXISTS</code> command</li>
</ul></li>
<li><code>create_cql_schema_facets_if_needed</code> : actually creates
the <code>facets</code> table if it does not exist</li>
<li><code>save_cql_schema_facets</code> : creates the
<code>cql_schema_facets_saved</code> temp table and populates it</li>
<li><code>cql_set_facet_version</code> : sets one facet to the indicated
value
<ul>
<li>this writes to the database, not the in-memory version of the
table</li>
</ul></li>
<li><code>cql_get_facet_version</code> : reads a facet value from the
facet table
<ul>
<li>this is only used to check the master schema value, after that the
in-memory version is used</li>
</ul></li>
<li><code>cql_get_version_crc</code> : gets the CRC for a given schema
version
<ul>
<li>each schema version has its own CRC in addition to the global
CRC</li>
<li>this information is stored in the facets table with a simple naming
convention for the facet name</li>
<li>the in memory version of the table is always used here</li>
</ul></li>
<li><code>cql_set_version_crc</code> : sets the CRC for a given schema
version in the facet table
<ul>
<li>this writes to the database, not the in-memory version of the
table</li>
</ul></li>
<li><code>cql_drop_legacy_triggers</code> : drops any triggers of the
from <code>tr__*</code>
<ul>
<li>for historical reasons the original triggers did not include
tombstones when deleted</li>
<li>this kludge is here to clean up legacy triggers and its peculiar to
Messenger only</li>
<li>this should really be removed from the OSS version but it’s never
been a priority</li>
<li>sorry…</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb286"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>  cg_schema_helpers<span class="op">(&amp;</span>decls<span class="op">);</span></span></code></pre></div>
<h3 id="declared-upgrade-procedures">Declared Upgrade Procedures</h3>
<p>The annotations can include an upgrade procedure. The term
“migration” procedure is sometimes used as well and is synonymous. This
is some code that should run after the schema alteration has been made
to create/delete/move some data around in the new schema. Each of these
must be declared before it is used and the declarations will be here, at
the end of the <code>decls</code> section after this introductory
comment.</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>decls<span class="op">,</span> <span class="st">&quot;-- declared upgrade procedures if any</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<h3 id="the-upgrading-workers">The Upgrading Workers</h3>
<p>The main upgrader will invoke these key workers to do its job. This
is where the <code>preamble</code> section starts. It contains the meat
of the upgrade steps wrapped in procedures that do the job.</p>
<div class="sourceCode" id="cb288"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>  cg_schema_emit_baseline_tables_proc<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="op">&amp;</span>baseline<span class="op">);</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> view_creates <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> view_drops <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>  cg_schema_manage_views<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="op">&amp;</span>view_drops<span class="op">,</span> <span class="op">&amp;</span>view_creates<span class="op">);</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> index_creates <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> index_drops <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a>  cg_schema_manage_indices<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="op">&amp;</span>index_drops<span class="op">,</span> <span class="op">&amp;</span>index_creates<span class="op">);</span></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> trigger_creates <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> trigger_drops <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true" tabindex="-1"></a>  cg_schema_manage_triggers<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="op">&amp;</span>trigger_drops<span class="op">,</span> <span class="op">&amp;</span>trigger_creates<span class="op">);</span></span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>recreate_items_count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb288-13"><a href="#cb288-13" aria-hidden="true" tabindex="-1"></a>    cg_schema_manage_recreate_tables<span class="op">(&amp;</span>preamble<span class="op">,</span> recreates<span class="op">,</span> recreate_items_count<span class="op">);</span></span>
<span id="cb288-14"><a href="#cb288-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb288-15"><a href="#cb288-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-16"><a href="#cb288-16" aria-hidden="true" tabindex="-1"></a>  bool_t has_temp_schema <span class="op">=</span> cg_schema_emit_temp_schema_proc<span class="op">(&amp;</span>preamble<span class="op">);</span></span>
<span id="cb288-17"><a href="#cb288-17" aria-hidden="true" tabindex="-1"></a>  bool_t one_time_drop_needed <span class="op">=</span> false<span class="op">;</span></span></code></pre></div>
<p>These are the last of the worker methods:</p>
<ul>
<li><code>cg_schema_emit_baseline_tables_proc</code> : emits a procedure
that will create the schema at its baseline version
<ul>
<li>this means whatever “v0” of the schema was, no creates or deletes
have yet happened</li>
</ul></li>
<li><code>cg_schema_manage_views</code> : creates the view management
procedures
<ul>
<li><code>cql_drop_all_views</code> : drops all views</li>
<li><code>cql_create_all_views</code> : creates all views</li>
<li>both of these run unless the global CRC matches</li>
</ul></li>
<li><code>cg_schema_manage_indices</code> : creates the index management
procedures
<ul>
<li><code>cql_drop_all_indices</code> : drops any index that exists and
whose CRC changed</li>
<li><code>cql_create_all_indices</code> : creates any index whose CRC
changed</li>
<li>recreating indices can be costly so it is only done if the index
actually changed</li>
</ul></li>
<li><code>cg_schema_manage_triggers</code> : creates the trigger
management procedures
<ul>
<li><code>cql_drop_all_triggers</code> : drops all triggers</li>
<li><code>cql_create_all_triggers</code> : creates all triggers</li>
<li>both of these run unless the global CRC matches</li>
<li>additionally any legacy triggers will be deleted (see
<code>cql_drop_legacy_triggers</code>)</li>
</ul></li>
<li><code>cg_schema_manage_recreate_tables</code> : creates the
<code>cql_recreate_tables</code> worker
<ul>
<li>the <code>recreate_annotations</code> array is used to find all the
recreate tables</li>
<li>the entries are sorted by group, then name, so that annotations
within a group are together</li>
<li>the procedure contains code to delete the procedure or group and
recreate it if the CRC does not match</li>
<li>the CRC is computed using the code for create instructions and is
stored in a facet with a suitable name</li>
<li>the easiest way to think of this code is that it always emits a
chunk of recreates for a group
<ul>
<li>ungrouped tables are a group of 1</li>
<li>group delete/create instructions accumulate until the next entry is
in a different group</li>
</ul></li>
</ul></li>
<li><code>cg_schema_emit_temp_schema_proc</code> : emits a procedure to
create any temporary schema
<ul>
<li>temp tables are always created in full at the latest version</li>
<li>this code is run regardless of whether the global CRC matches or
not</li>
</ul></li>
</ul>
<p>All of these functions semantic outputs like
<code>all_indices_list</code>, <code>all_views_list</code>, etc. to do
their job (except <code>cg_schema_manage_recreate_tables</code> as
noted). Generally they have all the data they need handed to them on a
silver platter by the semantic pass. This is not an accident.</p>
<h4 id="reading-the-facets-into-memory">Reading the Facets into
Memory</h4>
<p>The <code>setup_facets</code> procedure simply selects out the entire
<code>facets</code> table with a cursor and uses
<code>cql_facet_add</code> to get them into a hash table. This is the
primary source of facets information during the run. This is a good
example of what the codegen looks like so we’ll include this one in
full.</p>
<div class="sourceCode" id="cb289"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// code to read the facets into the hash table</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;@attribute(cql:private)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;CREATE PROCEDURE %s_setup_facets()</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;BEGIN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;  BEGIN TRY</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;    SET %s_facets := cql_facets_new();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;    DECLARE C CURSOR FOR SELECT * from %s_cql_schema_facets;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;    LOOP FETCH C</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;    BEGIN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;      LET added := cql_facet_add(%s_facets, C.facet, C.version);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;    END;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-13"><a href="#cb289-13" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;  END TRY;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-14"><a href="#cb289-14" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;  BEGIN CATCH</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-15"><a href="#cb289-15" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;   -- if table doesn&#39;t exist we just have empty facets, that&#39;s ok</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-16"><a href="#cb289-16" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;  END CATCH;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-17"><a href="#cb289-17" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>preamble<span class="op">,</span> <span class="st">&quot;END;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-18"><a href="#cb289-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-19"><a href="#cb289-19" aria-hidden="true" tabindex="-1"></a><span class="er">### The Main Upgrader</span></span>
<span id="cb289-20"><a href="#cb289-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-21"><a href="#cb289-21" aria-hidden="true" tabindex="-1"></a>And now we come to the main upgrading procedure `perform_upgrade_steps`<span class="op">.</span></span>
<span id="cb289-22"><a href="#cb289-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-23"><a href="#cb289-23" aria-hidden="true" tabindex="-1"></a>We&#39;ll go over this section by section<span class="op">.</span></span>
<span id="cb289-24"><a href="#cb289-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-25"><a href="#cb289-25" aria-hidden="true" tabindex="-1"></a><span class="er">#### Standard Steps</span></span>
<span id="cb289-26"><a href="#cb289-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-27"><a href="#cb289-27" aria-hidden="true" tabindex="-1"></a>```c</span>
<span id="cb289-28"><a href="#cb289-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the main upgrade worker</span></span>
<span id="cb289-29"><a href="#cb289-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-30"><a href="#cb289-30" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">@attribute(cql:private)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-31"><a href="#cb289-31" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;CREATE PROCEDURE %s_perform_upgrade_steps()</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-32"><a href="#cb289-32" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;BEGIN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-33"><a href="#cb289-33" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;  DECLARE schema_version LONG INTEGER NOT NULL;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-34"><a href="#cb289-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-35"><a href="#cb289-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>view_drops<span class="op">)</span> <span class="op">{</span></span>
<span id="cb289-36"><a href="#cb289-36" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    -- dropping all views --</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-37"><a href="#cb289-37" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_drop_all_views();</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-38"><a href="#cb289-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb289-39"><a href="#cb289-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-40"><a href="#cb289-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>index_drops<span class="op">)</span> <span class="op">{</span></span>
<span id="cb289-41"><a href="#cb289-41" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    -- dropping condemned or changing indices --</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-42"><a href="#cb289-42" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_drop_all_indices();</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-43"><a href="#cb289-43" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb289-44"><a href="#cb289-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-45"><a href="#cb289-45" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>trigger_drops<span class="op">)</span> <span class="op">{</span></span>
<span id="cb289-46"><a href="#cb289-46" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    -- dropping condemned or changing triggers --</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-47"><a href="#cb289-47" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_drop_all_triggers();</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-48"><a href="#cb289-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb289-49"><a href="#cb289-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-50"><a href="#cb289-50" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>baseline<span class="op">.</span>used <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb289-51"><a href="#cb289-51" aria-hidden="true" tabindex="-1"></a>    llint_t baseline_crc <span class="op">=</span> <span class="op">(</span>llint_t<span class="op">)</span>crc_charbuf<span class="op">(&amp;</span>baseline<span class="op">);</span></span>
<span id="cb289-52"><a href="#cb289-52" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    ---- install baseline schema if needed ----</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-53"><a href="#cb289-53" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_get_version_crc(0, schema_version);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-54"><a href="#cb289-54" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    IF schema_version != %lld THEN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> baseline_crc<span class="op">);</span></span>
<span id="cb289-55"><a href="#cb289-55" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;      CALL %s_cql_install_baseline_schema();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb289-56"><a href="#cb289-56" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;      CALL %s_cql_set_version_crc(0, %lld);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">,</span> baseline_crc<span class="op">);</span></span>
<span id="cb289-57"><a href="#cb289-57" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    END IF;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb289-58"><a href="#cb289-58" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>First we deal with the preliminaries:</p>
<ul>
<li>drop the views if there are any</li>
<li>drop the indices that need dropping</li>
<li>drop the triggers if there are any</li>
<li>install the baseline schema if there is any</li>
</ul>
<h4 id="process-standard-annotations">Process Standard Annotations</h4>
<p>In this phase we walk the annotations from
<code>schema_annotations</code> which are now stored in
<code>notes</code>.</p>
<p>They have been sorted in exactly the right order to process them (by
version, then type, then target). We’ll create one set of instructions
per version number as we simply accumulate instructions for any version
while we’re still on the same version then spit them all out. Adding
<code>target</code> to the sort order ensures that the results have a
total ordering (there are no ties that might yield an ambiguous
order).</p>
<p>We set up a loop to walk over the annotations and we flush if we ever
encounter an annotation for a different version number. We’ll have to
force a flush at the end as well. <code>cg_schema_end_version</code>
does the flush.</p>
<div class="sourceCode" id="cb290"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> prev_version <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> schema_items_count<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a>    schema_annotation <span class="op">*</span>note <span class="op">=</span> <span class="op">&amp;</span>notes<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>version_annotation <span class="op">=</span> note<span class="op">-&gt;</span>annotation_ast<span class="op">;</span></span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> type <span class="op">=</span> note<span class="op">-&gt;</span>annotation_type<span class="op">;</span></span>
<span id="cb290-9"><a href="#cb290-9" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>type <span class="op">&gt;=</span> SCHEMA_ANNOTATION_FIRST <span class="op">&amp;&amp;</span> type <span class="op">&lt;=</span> SCHEMA_ANNOTATION_LAST<span class="op">);</span></span>
<span id="cb290-10"><a href="#cb290-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-11"><a href="#cb290-11" aria-hidden="true" tabindex="-1"></a>    Contract<span class="op">(</span>is_ast_version_annotation<span class="op">(</span>version_annotation<span class="op">));</span></span>
<span id="cb290-12"><a href="#cb290-12" aria-hidden="true" tabindex="-1"></a>    EXTRACT_OPTION<span class="op">(</span>vers<span class="op">,</span> version_annotation<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb290-13"><a href="#cb290-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-14"><a href="#cb290-14" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>note<span class="op">-&gt;</span>version <span class="op">==</span> vers<span class="op">);</span></span>
<span id="cb290-15"><a href="#cb290-15" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>vers <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb290-16"><a href="#cb290-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-17"><a href="#cb290-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>prev_version <span class="op">!=</span> vers<span class="op">)</span> <span class="op">{</span></span>
<span id="cb290-18"><a href="#cb290-18" aria-hidden="true" tabindex="-1"></a>      cg_schema_end_version<span class="op">(&amp;</span>main<span class="op">,</span> <span class="op">&amp;</span>upgrade<span class="op">,</span> <span class="op">&amp;</span>pending<span class="op">,</span> prev_version<span class="op">);</span></span>
<span id="cb290-19"><a href="#cb290-19" aria-hidden="true" tabindex="-1"></a>      prev_version <span class="op">=</span> vers<span class="op">;</span></span>
<span id="cb290-20"><a href="#cb290-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>If we find any item that is in a region we are not upgrading, we skip
it.</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a>    CSTR target_name <span class="op">=</span> note<span class="op">-&gt;</span>target_name<span class="op">;</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>type <span class="op">&gt;=</span> SCHEMA_ANNOTATION_FIRST <span class="op">&amp;&amp;</span> type <span class="op">&lt;=</span> SCHEMA_ANNOTATION_LAST<span class="op">);</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>include_from_region<span class="op">(</span>note<span class="op">-&gt;</span>target_ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region<span class="op">,</span> SCHEMA_TO_UPGRADE<span class="op">))</span> <span class="op">{</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>There are several annotation types. Each one requires appropriate
commands</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_CREATE_COLUMN<span class="op">:</span> <span class="op">{</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> emit ALTER TABLE ADD COLUMN <span class="cf">if</span> the column does not already exist</span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_DELETE_COLUMN<span class="op">:</span> <span class="op">{</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> it&#39;s not possible to delete columns in SQLite <span class="op">(</span>this is changing<span class="op">)</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> we simply emit a comment and move on</span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_CREATE_TABLE<span class="op">:</span> <span class="op">{</span></span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> <span class="cf">if</span> the table is moving from @recreate to @create we have to drop any stale version</span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> of it one time<span class="op">.</span>  We emit a call to `cql_one_time_drop` and record that we need</span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> to generate that procedure in `one_time_drop_needed`<span class="op">.</span></span>
<span id="cb292-17"><a href="#cb292-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span>in all cases emit a CREATE TABLE IF NOT EXISTS</span>
<span id="cb292-18"><a href="#cb292-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-19"><a href="#cb292-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb292-20"><a href="#cb292-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-21"><a href="#cb292-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_DELETE_TABLE<span class="op">:</span> <span class="op">{</span></span>
<span id="cb292-22"><a href="#cb292-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> emit DROP TABLE IF EXISTS <span class="cf">for</span> the target</span>
<span id="cb292-23"><a href="#cb292-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-24"><a href="#cb292-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb292-25"><a href="#cb292-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-26"><a href="#cb292-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_DELETE_INDEX<span class="op">:</span></span>
<span id="cb292-27"><a href="#cb292-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_DELETE_VIEW<span class="op">:</span></span>
<span id="cb292-28"><a href="#cb292-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_DELETE_TRIGGER<span class="op">:</span></span>
<span id="cb292-29"><a href="#cb292-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> this annotation indicates there is a tombstone on the item</span>
<span id="cb292-30"><a href="#cb292-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> this was handled in the appropriate `manage` worker above<span class="op">,</span> nothing needs</span>
<span id="cb292-31"><a href="#cb292-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> to be done here except run any migration procs <span class="op">(</span>see below<span class="op">)</span></span>
<span id="cb292-32"><a href="#cb292-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-33"><a href="#cb292-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-34"><a href="#cb292-34" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> SCHEMA_ANNOTATION_AD_HOC<span class="op">:</span></span>
<span id="cb292-35"><a href="#cb292-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> ad hoc migration procs allow <span class="cf">for</span> code to be run one time when we hit</span>
<span id="cb292-36"><a href="#cb292-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span> a particular schema version<span class="op">,</span> this just allows the migration proc to run</span>
<span id="cb292-37"><a href="#cb292-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// no annotation based actions other than migration proc (handled below)</span></span>
<span id="cb292-38"><a href="#cb292-38" aria-hidden="true" tabindex="-1"></a>        Contract<span class="op">(</span>version_annotation<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb292-39"><a href="#cb292-39" aria-hidden="true" tabindex="-1"></a>        bprintf<span class="op">(&amp;</span>upgrade<span class="op">,</span> <span class="st">&quot;      -- ad hoc migration proc %s will run</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span> target_name<span class="op">);</span></span>
<span id="cb292-40"><a href="#cb292-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb292-41"><a href="#cb292-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>The above constitutes the bulk of the upgrading logic which, as you
can see, isn’t that complicated.</p>
<p>Any of the above might have a migration proc. If there is one in the
node, then generate: * emit a call to <code>cql_facet_find</code> to see
if the migration proc has already run * emit a declaration for the
migration proc into the <code>decls</code> section * emit a call to the
procedure (it accept no arguments) * emit a call to
<code>cql_set_facet_version</code> to record that the migrator ran</p>
<p>When the loop is done, any pending migration code is flushed using
<code>cg_schema_end_version</code> again.</p>
<p>At this point we can move on to the finalization steps.</p>
<h4 id="finalization-steps">Finalization Steps</h4>
<p>With the standard upgrade finished, there is just some house keeping
left:</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>recreate_items_count<span class="op">)</span> <span class="op">{</span></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_recreate_tables();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>view_creates<span class="op">)</span> <span class="op">{</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_create_all_views();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>index_creates<span class="op">)</span> <span class="op">{</span></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_create_all_indices();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>trigger_creates<span class="op">)</span> <span class="op">{</span></span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_create_all_triggers();</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">);</span></span>
<span id="cb293-15"><a href="#cb293-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb293-16"><a href="#cb293-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-17"><a href="#cb293-17" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_set_facet_version(&#39;cql_schema_version&#39;, %d);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">,</span> prev_version<span class="op">);</span></span>
<span id="cb293-18"><a href="#cb293-18" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;    CALL %s_cql_set_facet_version(&#39;cql_schema_crc&#39;, %lld);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> global_proc_name<span class="op">,</span> schema_crc<span class="op">);</span></span>
<span id="cb293-19"><a href="#cb293-19" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>main<span class="op">,</span> <span class="st">&quot;END;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<ul>
<li><code>cql_recreate_tables</code> : must run if there are any tables
marked recreate
<ul>
<li>this procedure will have code to drop and recreate any changed
tables</li>
<li>this procedure was created by
<code>cg_schema_manage_recreate_tables</code> and that process is
described above
<ul>
<li>basically, it uses <code>recreate_annotations</code> to do the
job</li>
</ul></li>
<li>any that were condemned by marking with <code>@delete</code> will
not be created again here</li>
</ul></li>
<li><code>cql_create_all_views</code> : must run if there are any views,
they need to be put back
<ul>
<li>any that were condemned by marking with <code>@delete</code> are not
created again here</li>
</ul></li>
<li><code>cql_create_all_indices</code> : must run if there are any
indices, this will create any that are missing
<ul>
<li>any that were changing were previously deleted, this is where they
come back</li>
<li>any that were condemned by marking with <code>@delete</code> are not
created again here</li>
</ul></li>
<li><code>cql_create_all_triggers</code> : must run if there are any
triggers, they need to be put back
<ul>
<li>any that were condemned by marking with <code>@delete</code> are not
created again here</li>
<li>triggers might cause weird side-effects during upgrade hence they
are always dropped</li>
<li>stale triggers especially could be problematic</li>
<li>any triggers that refer to views couldn’t possibly run as the views
are gone</li>
<li>hence, triggers are always dropped and recreated</li>
</ul></li>
</ul>
<h4 id="the-main-steps">The “Main” Steps</h4>
<p>We’re getting very close to the top level now</p>
<ul>
<li><p><code>perform_needed_upgrades</code> : this orchestrates the
upgrade, if it is called there is one</p>
<ul>
<li><code>cql_facet_find</code> : is used to check for a schema
“downgrade”
<ul>
<li>abort with an error if that happens</li>
</ul></li>
<li><code>save_cql_schema_facets</code> : saves the facets as they exist
so we can diff them</li>
<li><code>perform_upgrade_steps</code> : does the upgrade</li>
<li>a <code>LEFT OUTER JOIN</code> between
<code>cql_schema_facets</code> and <code>cql_schema_facets_saved</code>
reports differences</li>
<li>any errors will cause the normal CQL error flow</li>
</ul></li>
<li><p>the main entry point is named by
<code>global_proc_name</code></p>
<ul>
<li><code>create_cql_schema_facets_if_needed</code> is used to create
the <code>facets</code> table if it doesn’t already exist</li>
<li>the special facet <code>cql_schema_crc</code> is read from the
<code>facets</code> table</li>
<li>if the CRC stored there matches our target then we return “no
differences”, otherwise</li>
<li><code>setup_facets</code> : loads the in-memory version of the
facets table</li>
<li><code>perform_needed_upgrades</code> : does the work and creates the
diff</li>
<li><code>cql_facets_delete</code> is used to free the in-memory
storage, even if there were errors in
<code>perform_needed_upgrades</code></li>
</ul></li>
<li><p><code>cql_install_temp_schema</code> : installs temporary schema
if there is any, regardless of the CRC</p></li>
<li><p>the <code>one_time_drop</code> code is emitted if it was
needed</p></li>
</ul>
<h4 id="writing-the-buffer">Writing the Buffer</h4>
<p>At this point the main buffers <code>decls</code>,
<code>preamble</code>, and <code>main</code> are ready to go. We’re back
to where we started but we can quickly recap the overall flow.</p>
<div class="sourceCode" id="cb294"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>output_file<span class="op">);</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> decls<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> preamble<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(&amp;</span>output_file<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> main<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb294-5"><a href="#cb294-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-6"><a href="#cb294-6" aria-hidden="true" tabindex="-1"></a>  cql_write_file<span class="op">(</span>options<span class="op">.</span>file_names<span class="op">[</span><span class="dv">0</span><span class="op">],</span> output_file<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb294-7"><a href="#cb294-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-8"><a href="#cb294-8" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>output_file<span class="op">);</span></span></code></pre></div>
<p>There is nothing left but to <code>CHARBUF_CLOSE</code> the interim
buffers we created.</p>
<h3 id="recap-3">Recap</h3>
<p>At present <code>cg_schema.c</code> accomplishes a lot and is fairly
light at only 1313 lines (at present). It is able to do so because it
can leverage heavy lifting done in the semantic analysis phase and
schema generation that can be done like all other SQL generation by the
echoing code discussed in <a
href="https://cgsql.dev/cql-guide/int01">Part 1</a>.</p>
<p>Topics covered included:</p>
<ul>
<li>the essential sources of schema information from the semantic
pass</li>
<li>the state tables used in the database and helpers for read/write of
the same</li>
<li>the interaction with schema regions</li>
<li>the prosecution steps for tables, columns, views, triggers,
indices</li>
<li>the key annotation types and what code they create</li>
<li>the handling of recreate tables, temp tables, and the base
schema</li>
<li>how all of these are wired together starting from the upgrader’s
“main”</li>
</ul>
<p>As with the other parts, no attempt was made to cover every function
in detail. That is best done by reading the source code. But there is
overall structure here and an understanding of the basic principles is
helpful before diving into the source code.</p>
<h2 id="part-7-json-generation">Part 7: JSON Generation</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-6">Preface</h3>
<p>Part 7 continues with a discussion of the JSON generation code. As in
the previous sections, the goal here is not to go over every detail but
rather to give a sense of how JSON creation works in general – the core
strategies and implementation choices – so that when reading the source
you will have an idea how it all hangs together. To accomplish this,
we’ll illustrate the key strategies used to extract the data and format
the JSON.</p>
<h2 id="json-schema">JSON Schema</h2>
<p>The JSON schema is described in <a
href="https://cgsql.dev/cql-guide/ch13">Chapter 13</a> of the Guide and
there is a nice diagram of its <a
href="https://cgsql.dev/json-diagram">grammar</a> for reference. So, we
won’t be discussing all the details of the output. Instead we’re going
to go over the theory of how the JSON generator works. It is structured
very much like the other code generators but it happens to produce a
JSON file. It’s call the “JSON Schema” because most of the content is a
description of the database schema in JSON form. As such it’s almost
entirely just a simple walk of the AST in the correct order. The only
really tricky bit is the extra dependency analysis on the AST. This
allows us to emit usage information in the output for downstream tools
to use as needed.</p>
<p>We’ll cover these topics:</p>
<ul>
<li>walking the AST</li>
<li>formatting</li>
<li>computing the dependencies</li>
</ul>
<p>This should be a short chapter compared to the others, this output
really is much simpler to create than the C or the schema upgrader.</p>
<h3 id="walking-the-ast">Walking the AST</h3>
<p>If you run this command:</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cql <span class="at">--in</span> x <span class="at">--rt</span> json_schema <span class="at">--cg</span> x.json</span></code></pre></div>
<p>Where <code>x</code> is an empty file, you’ll get the following
skeletal JSON, lightly reformatted for brevity:</p>
<div class="sourceCode" id="cb296"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tables&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;virtualTables&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;views&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;indices&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;triggers&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;attributes&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;queries&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-9"><a href="#cb296-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;inserts&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-10"><a href="#cb296-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;generalInserts&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-11"><a href="#cb296-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;updates&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-12"><a href="#cb296-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;deletes&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-13"><a href="#cb296-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;general&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-14"><a href="#cb296-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;regions&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-15"><a href="#cb296-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;adHocMigrationProcs&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb296-16"><a href="#cb296-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;enums&quot;</span> <span class="fu">:</span> <span class="ot">[</span>  <span class="ot">]</span></span>
<span id="cb296-17"><a href="#cb296-17" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>From this we can deduce a great deal of the structure of the
code:</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Main entry point for json schema format</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> cg_json_schema_main<span class="op">(</span>ast_node <span class="op">*</span>head<span class="op">)</span> <span class="op">{</span></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>options<span class="op">.</span>file_names_count <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>  cql_exit_on_semantic_errors<span class="op">(</span>head<span class="op">);</span></span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>  tables_to_procs <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>main<span class="op">);</span></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>output <span class="op">=</span> <span class="op">&amp;</span>main<span class="op">;</span></span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> rt<span class="op">-&gt;</span>source_prefix<span class="op">);</span></span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-14"><a href="#cb297-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// master dictionary begins</span></span>
<span id="cb297-15"><a href="#cb297-15" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">{</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-16"><a href="#cb297-16" aria-hidden="true" tabindex="-1"></a>  BEGIN_INDENT<span class="op">(</span>defs<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb297-17"><a href="#cb297-17" aria-hidden="true" tabindex="-1"></a>  cg_json_tables<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-18"><a href="#cb297-18" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-19"><a href="#cb297-19" aria-hidden="true" tabindex="-1"></a>  cg_json_virtual_tables<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-20"><a href="#cb297-20" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-21"><a href="#cb297-21" aria-hidden="true" tabindex="-1"></a>  cg_json_views<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-22"><a href="#cb297-22" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-23"><a href="#cb297-23" aria-hidden="true" tabindex="-1"></a>  cg_json_indices<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-24"><a href="#cb297-24" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-25"><a href="#cb297-25" aria-hidden="true" tabindex="-1"></a>  cg_json_triggers<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-26"><a href="#cb297-26" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-27"><a href="#cb297-27" aria-hidden="true" tabindex="-1"></a>  cg_json_stmt_list<span class="op">(</span>output<span class="op">,</span> head<span class="op">);</span></span>
<span id="cb297-28"><a href="#cb297-28" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-29"><a href="#cb297-29" aria-hidden="true" tabindex="-1"></a>  cg_json_regions<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-30"><a href="#cb297-30" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-31"><a href="#cb297-31" aria-hidden="true" tabindex="-1"></a>  cg_json_ad_hoc_migration_procs<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-32"><a href="#cb297-32" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-33"><a href="#cb297-33" aria-hidden="true" tabindex="-1"></a>  cg_json_enums<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-34"><a href="#cb297-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-35"><a href="#cb297-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>options<span class="op">.</span>test<span class="op">)</span> <span class="op">{</span></span>
<span id="cb297-36"><a href="#cb297-36" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-37"><a href="#cb297-37" aria-hidden="true" tabindex="-1"></a>    cg_json_table_users<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb297-38"><a href="#cb297-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb297-39"><a href="#cb297-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-40"><a href="#cb297-40" aria-hidden="true" tabindex="-1"></a>  END_INDENT<span class="op">(</span>defs<span class="op">);</span></span>
<span id="cb297-41"><a href="#cb297-41" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb297-42"><a href="#cb297-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-43"><a href="#cb297-43" aria-hidden="true" tabindex="-1"></a>  cql_write_file<span class="op">(</span>options<span class="op">.</span>file_names<span class="op">[</span><span class="dv">0</span><span class="op">],</span> output<span class="op">-&gt;</span>ptr<span class="op">);</span></span>
<span id="cb297-44"><a href="#cb297-44" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>main<span class="op">);</span></span>
<span id="cb297-45"><a href="#cb297-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-46"><a href="#cb297-46" aria-hidden="true" tabindex="-1"></a>  SYMTAB_CLEANUP<span class="op">(</span>tables_to_procs<span class="op">);</span></span>
<span id="cb297-47"><a href="#cb297-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>cg_json_schema_main</code> is the main function and you can see
that it mirrors that skeletal JSON output nearly exactly with some
additional test output options. We’ll cover the test output in a later
section when we’ve had a chance to discuss the dependency analysis.</p>
<h4 id="example-json-writer-views">Example JSON Writer: Views</h4>
<p>These are sufficiently easy that we can just walk through one of the
procedures front to back. Let’s look at the “views” section.</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The set of views look rather like the query section in as much as</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a><span class="co">// they are in fact nothing more than named select statements.  However</span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the output here is somewhat simplified.  We only emit the whole select</span></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a><span class="co">// statement and any binding args, we don&#39;t also emit all the pieces of the select.</span></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_json_views<span class="op">(</span>charbuf <span class="op">*</span>output<span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">views</span><span class="sc">\&quot;</span><span class="st"> : [</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a>  BEGIN_INDENT<span class="op">(</span>views<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> all_views_list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-11"><a href="#cb298-11" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>ast <span class="op">=</span> item<span class="op">-&gt;</span>ast<span class="op">;</span></span>
<span id="cb298-12"><a href="#cb298-12" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>is_ast_create_view_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb298-13"><a href="#cb298-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-14"><a href="#cb298-14" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>misc_attrs <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb298-15"><a href="#cb298-15" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>attr_target <span class="op">=</span> ast<span class="op">-&gt;</span>parent<span class="op">;</span></span>
<span id="cb298-16"><a href="#cb298-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_stmt_and_attr<span class="op">(</span>attr_target<span class="op">))</span> <span class="op">{</span></span>
<span id="cb298-17"><a href="#cb298-17" aria-hidden="true" tabindex="-1"></a>      EXTRACT_STMT_AND_MISC_ATTRS<span class="op">(</span>stmt<span class="op">,</span> misc<span class="op">,</span> attr_target<span class="op">-&gt;</span>parent<span class="op">);</span></span>
<span id="cb298-18"><a href="#cb298-18" aria-hidden="true" tabindex="-1"></a>      misc_attrs <span class="op">=</span> misc<span class="op">;</span></span>
<span id="cb298-19"><a href="#cb298-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-20"><a href="#cb298-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-21"><a href="#cb298-21" aria-hidden="true" tabindex="-1"></a>    cg_json_test_details<span class="op">(</span>output<span class="op">,</span> ast<span class="op">,</span> misc_attrs<span class="op">);</span></span>
<span id="cb298-22"><a href="#cb298-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-23"><a href="#cb298-23" aria-hidden="true" tabindex="-1"></a>    EXTRACT_OPTION<span class="op">(</span>flags<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb298-24"><a href="#cb298-24" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>view_and_attrs<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb298-25"><a href="#cb298-25" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>name_and_select<span class="op">,</span> view_and_attrs<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb298-26"><a href="#cb298-26" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>select_stmt<span class="op">,</span> name_and_select<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb298-27"><a href="#cb298-27" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> name_and_select<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb298-28"><a href="#cb298-28" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">);</span></span>
<span id="cb298-29"><a href="#cb298-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-30"><a href="#cb298-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-31"><a href="#cb298-31" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb298-32"><a href="#cb298-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-33"><a href="#cb298-33" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;{</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb298-34"><a href="#cb298-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-35"><a href="#cb298-35" aria-hidden="true" tabindex="-1"></a>    bool_t is_deleted <span class="op">=</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb298-36"><a href="#cb298-36" aria-hidden="true" tabindex="-1"></a>    BEGIN_INDENT<span class="op">(</span>view<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb298-37"><a href="#cb298-37" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">name</span><span class="sc">\&quot;</span><span class="st"> : </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb298-38"><a href="#cb298-38" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">CRC</span><span class="sc">\&quot;</span><span class="st"> : </span><span class="sc">\&quot;</span><span class="st">%lld</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">,</span> crc_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb298-39"><a href="#cb298-39" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">isTemp</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> <span class="op">!!(</span>flags <span class="op">&amp;</span> VIEW_IS_TEMP<span class="op">));</span></span>
<span id="cb298-40"><a href="#cb298-40" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">isDeleted</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> is_deleted<span class="op">);</span></span>
<span id="cb298-41"><a href="#cb298-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_deleted<span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-42"><a href="#cb298-42" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">deletedVersion</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version<span class="op">);</span></span>
<span id="cb298-43"><a href="#cb298-43" aria-hidden="true" tabindex="-1"></a>      cg_json_deleted_migration_proc<span class="op">(</span>output<span class="op">,</span> view_and_attrs<span class="op">);</span></span>
<span id="cb298-44"><a href="#cb298-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-45"><a href="#cb298-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-46"><a href="#cb298-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-47"><a href="#cb298-47" aria-hidden="true" tabindex="-1"></a>      cg_json_emit_region_info<span class="op">(</span>output<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb298-48"><a href="#cb298-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-49"><a href="#cb298-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-50"><a href="#cb298-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb298-51"><a href="#cb298-51" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb298-52"><a href="#cb298-52" aria-hidden="true" tabindex="-1"></a>      cg_json_misc_attrs<span class="op">(</span>output<span class="op">,</span> misc_attrs<span class="op">);</span></span>
<span id="cb298-53"><a href="#cb298-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-54"><a href="#cb298-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-55"><a href="#cb298-55" aria-hidden="true" tabindex="-1"></a>    cg_json_projection<span class="op">(</span>output<span class="op">,</span> select_stmt<span class="op">);</span></span>
<span id="cb298-56"><a href="#cb298-56" aria-hidden="true" tabindex="-1"></a>    cg_fragment_with_params<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;select&quot;</span><span class="op">,</span> select_stmt<span class="op">,</span> gen_one_stmt<span class="op">);</span></span>
<span id="cb298-57"><a href="#cb298-57" aria-hidden="true" tabindex="-1"></a>    cg_json_dependencies<span class="op">(</span>output<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb298-58"><a href="#cb298-58" aria-hidden="true" tabindex="-1"></a>    END_INDENT<span class="op">(</span>view<span class="op">);</span></span>
<span id="cb298-59"><a href="#cb298-59" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb298-60"><a href="#cb298-60" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb298-61"><a href="#cb298-61" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb298-62"><a href="#cb298-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-63"><a href="#cb298-63" aria-hidden="true" tabindex="-1"></a>  END_INDENT<span class="op">(</span>views<span class="op">);</span></span>
<span id="cb298-64"><a href="#cb298-64" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;]&quot;</span><span class="op">);</span></span>
<span id="cb298-65"><a href="#cb298-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="view-loop">View Loop</h4>
<p>Already we can see the structure emerging, and of course its nothing
more than a bunch of <code>bprintf</code>. Let’s do it section by
section:</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">views</span><span class="sc">\&quot;</span><span class="st"> : [</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>BEGIN_INDENT<span class="op">(</span>views<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> all_views_list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">..</span></span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true" tabindex="-1"></a>END_INDENT<span class="op">(</span>views<span class="op">);</span></span>
<span id="cb299-9"><a href="#cb299-9" aria-hidden="true" tabindex="-1"></a>bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;]&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Unsurprisingly, this code will iterate the
<code>all_views_list</code> which was created precisely for this kind of
output. The semantic pass populates this list for use downstream.</p>
<p>We’ll deal with <code>BEGIN_INDENT</code> a bit later, but it should
be clear what it does by the name for now. So we’ve made the “views”
section and we’ll put 0 or more views in it.</p>
<h4 id="view-extraction">View Extraction</h4>
<p>The next section extracts the necessary information and emits the
test output:</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>ast <span class="op">=</span> item<span class="op">-&gt;</span>ast<span class="op">;</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>    Invariant<span class="op">(</span>is_ast_create_view_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>misc_attrs <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>attr_target <span class="op">=</span> ast<span class="op">-&gt;</span>parent<span class="op">;</span></span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_stmt_and_attr<span class="op">(</span>attr_target<span class="op">))</span> <span class="op">{</span></span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a>      EXTRACT_STMT_AND_MISC_ATTRS<span class="op">(</span>stmt<span class="op">,</span> misc<span class="op">,</span> attr_target<span class="op">-&gt;</span>parent<span class="op">);</span></span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true" tabindex="-1"></a>      misc_attrs <span class="op">=</span> misc<span class="op">;</span></span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-11"><a href="#cb300-11" aria-hidden="true" tabindex="-1"></a>    cg_json_test_details<span class="op">(</span>output<span class="op">,</span> ast<span class="op">,</span> misc_attrs<span class="op">);</span></span>
<span id="cb300-12"><a href="#cb300-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-13"><a href="#cb300-13" aria-hidden="true" tabindex="-1"></a>    EXTRACT_OPTION<span class="op">(</span>flags<span class="op">,</span> ast<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb300-14"><a href="#cb300-14" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>view_and_attrs<span class="op">,</span> ast<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb300-15"><a href="#cb300-15" aria-hidden="true" tabindex="-1"></a>    EXTRACT<span class="op">(</span>name_and_select<span class="op">,</span> view_and_attrs<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb300-16"><a href="#cb300-16" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>select_stmt<span class="op">,</span> name_and_select<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb300-17"><a href="#cb300-17" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> name_and_select<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb300-18"><a href="#cb300-18" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STRING<span class="op">(</span>name<span class="op">,</span> name_ast<span class="op">);</span></span></code></pre></div>
<p>The <code>is_ast_stmt_and_attr</code> node tell us if there were any
misc attributes on the statement. Those attributes can be extracted and
printed. We have to look up the tree a little bit from where we are
because this is the “all views” list, if there were attributes on this
view they were attached two levels up. In any case
<code>misc_attrs</code> ends with attributes if there are any.</p>
<p>After the test output, the necessary view attributes are extracted
the usual way with <code>EXTRACT</code> macros for the view shape.</p>
<h4 id="test-output">Test Output</h4>
<div class="sourceCode" id="cb301"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_json_test_details<span class="op">(</span>charbuf <span class="op">*</span>output<span class="op">,</span> ast_node <span class="op">*</span>ast<span class="op">,</span> ast_node <span class="op">*</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>options<span class="op">.</span>test<span class="op">)</span> <span class="op">{</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">The statement ending at line %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> ast<span class="op">-&gt;</span>lineno<span class="op">);</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>    gen_set_output_buffer<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb301-8"><a href="#cb301-8" aria-hidden="true" tabindex="-1"></a>      gen_with_callbacks<span class="op">(</span>misc_attrs<span class="op">,</span> gen_misc_attrs<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb301-9"><a href="#cb301-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb301-10"><a href="#cb301-10" aria-hidden="true" tabindex="-1"></a>    gen_with_callbacks<span class="op">(</span>ast<span class="op">,</span> gen_one_stmt<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb301-11"><a href="#cb301-11" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb301-12"><a href="#cb301-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb301-13"><a href="#cb301-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>All of the JSON fragments have the usual test pattern “The statement
ending at line nnn”. This means that the normal validator will be able
to find comments in the test file and associate them with json parts.
The testing strategies are discussed in [Part
4]((https://cgsql.dev/cql-guide/int04).</p>
<p>In addition, while in test mode, we also emit the original statement
that caused this JSON fragment to be created. This allows the test
patterns to cross check the input and output and also makes the test
output more readable for humans.</p>
<p>Note that in test mode the JSON is effectively corrupted by the test
output as it is not well-formed JSON in any way. So use of –test is
strictly for validation only.</p>
<h4 id="view-basics">View Basics</h4>
<p>All of the things that go into the JSON have some attributes that are
universally present and generally come directly from the AST.</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;{</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a>  bool_t is_deleted <span class="op">=</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a>  BEGIN_INDENT<span class="op">(</span>view<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">name</span><span class="sc">\&quot;</span><span class="st"> : </span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">CRC</span><span class="sc">\&quot;</span><span class="st"> : </span><span class="sc">\&quot;</span><span class="st">%lld</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">,</span> crc_stmt<span class="op">(</span>ast<span class="op">));</span></span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">isTemp</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> <span class="op">!!(</span>flags <span class="op">&amp;</span> VIEW_IS_TEMP<span class="op">));</span></span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">isDeleted</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> is_deleted<span class="op">);</span></span>
<span id="cb302-13"><a href="#cb302-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_deleted<span class="op">)</span> <span class="op">{</span></span>
<span id="cb302-14"><a href="#cb302-14" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">deletedVersion</span><span class="sc">\&quot;</span><span class="st"> : %d&quot;</span><span class="op">,</span> ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version<span class="op">);</span></span>
<span id="cb302-15"><a href="#cb302-15" aria-hidden="true" tabindex="-1"></a>    cg_json_deleted_migration_proc<span class="op">(</span>output<span class="op">,</span> view_and_attrs<span class="op">);</span></span>
<span id="cb302-16"><a href="#cb302-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb302-17"><a href="#cb302-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-18"><a href="#cb302-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb302-19"><a href="#cb302-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-20"><a href="#cb302-20" aria-hidden="true" tabindex="-1"></a>  END_INDENT<span class="op">(</span>view<span class="op">);</span></span>
<span id="cb302-21"><a href="#cb302-21" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb302-22"><a href="#cb302-22" aria-hidden="true" tabindex="-1"></a>  i<span class="op">++;</span></span>
<span id="cb302-23"><a href="#cb302-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This part of the output is the simplest</p>
<ul>
<li>we emit a comma if we need one (only the first entry doesn’t)</li>
<li>we start the view object ‘{’</li>
<li>more indenting for the interior of the view</li>
<li>emit the view name</li>
<li>emit the CRC of the view (this makes it easy to see if the view
changed)
<ul>
<li><code>crc_stmt</code> computes the CRC by echoing the statement into
a scratch buffer and then running the CRC algorithm on that buffer</li>
</ul></li>
<li>note the “,” pattern, this pattern is used because sometimes there
are optional parts and using a leading “,” makes it clear which part is
supposed to emit the comma
<ul>
<li>it turns out getting the commas right is one of the greater
annoyances of JSON output</li>
</ul></li>
<li>emit “isTemp”</li>
<li>emit “isDeleted”</li>
<li>if the view is deleted, emit “deletedVersion”</li>
<li>if there is a migration procedure on the <code>@delete</code>
attribute emit that as well
<ul>
<li><code>cg_json_deleted_migration_proc</code> scans the attribute list
for <code>@delete</code> attribute and emits the procedure name on that
attribute if there is one</li>
</ul></li>
</ul>
<h4 id="optional-info">Optional Info</h4>
<p>The next fragment emits two optional pieces that are present in many
types of objects:</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ast<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>region<span class="op">)</span> <span class="op">{</span></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a>      cg_json_emit_region_info<span class="op">(</span>output<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a>      bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true" tabindex="-1"></a>      cg_json_misc_attrs<span class="op">(</span>output<span class="op">,</span> misc_attrs<span class="op">);</span></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>if there is a region assocatied with this view, we emit it here
<ul>
<li><code>cg_json_emit_region_info</code> emits two things:
<ul>
<li>the view’s region</li>
<li>the “deployment region” of that region if any (regions are contained
in deployable groups)</li>
<li>see <a
href="https://cgsql.dev/cql-guide/ch10#schema-regions">Chapter 10</a>
for more info on regions and deployment regions</li>
</ul></li>
</ul></li>
<li>if there are any miscellaneous attributes they are emitted
<ul>
<li>we’ll use <code>cg_json_misc_attrs</code> as our general formatting
example when we get to that</li>
</ul></li>
</ul>
<h4 id="the-view-details">The View Details</h4>
<p>There is very little left in the view emitting code:</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>  cg_json_projection<span class="op">(</span>output<span class="op">,</span> select_stmt<span class="op">);</span></span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a>  cg_fragment_with_params<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;select&quot;</span><span class="op">,</span> select_stmt<span class="op">,</span> gen_one_stmt<span class="op">);</span></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a>  cg_json_dependencies<span class="op">(</span>output<span class="op">,</span> ast<span class="op">);</span></span></code></pre></div>
<ul>
<li><code>cg_json_projection</code> emits the name and type of each
column in the view select list</li>
<li><code>cg_fragment_with_params</code> emits the statement that
creates the view in an attribute named “select”
<ul>
<li>the normal echoing code emits the statement</li>
<li>views have no variables to bind but other statement forms inside of
procedures can have variables in the statement</li>
<li>the variable names are replace with “?” in the text of the
statement</li>
<li>the names of the variable appear in “selectArgs” (always empty for
views)</li>
</ul></li>
<li><code>cg_json_dependencies</code> emits the tables and views that
were used by this view, it gets its own section</li>
</ul>
<p>Those few things produce all JSON for a view. All the other schema
elements do basically the same things. Most of the helpers are shared
so, for instance, regions, misc attributes, and dependencies appear in
nearly every kind of object in the JSON.</p>
<h3 id="formatting-the-json">Formatting the JSON</h3>
<p>To make the JSON pretty we want to indent it appropriately and put
commas in the right places. There are some useful macros for this, and
they all rely on the fact that the emitted text goes to a
<code>charbuf</code> variable creatively called <code>output</code>.</p>
<p>Here’s a sample procedure that was mentioned earlier, it does the
usual things:</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Emit a list of attributes for the current entity, it could be any kind of entity.</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Whatever it is we spit out the attributes here in array format.</span></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_json_misc_attrs<span class="op">(</span>charbuf <span class="op">*</span>output<span class="op">,</span> ast_node <span class="op">*</span>_Nonnull list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_misc_attrs<span class="op">(</span>list<span class="op">));</span></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">attributes</span><span class="sc">\&quot;</span><span class="st"> : [</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a>  BEGIN_INDENT<span class="op">(</span>attr<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a>  BEGIN_LIST<span class="op">;</span></span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-9"><a href="#cb305-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>ast_node <span class="op">*</span>item <span class="op">=</span> list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb305-10"><a href="#cb305-10" aria-hidden="true" tabindex="-1"></a>    COMMA<span class="op">;</span></span>
<span id="cb305-11"><a href="#cb305-11" aria-hidden="true" tabindex="-1"></a>    cg_json_misc_attr<span class="op">(</span>output<span class="op">,</span> item<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb305-12"><a href="#cb305-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb305-13"><a href="#cb305-13" aria-hidden="true" tabindex="-1"></a>  END_LIST<span class="op">;</span></span>
<span id="cb305-14"><a href="#cb305-14" aria-hidden="true" tabindex="-1"></a>  END_INDENT<span class="op">(</span>attr<span class="op">);</span></span>
<span id="cb305-15"><a href="#cb305-15" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;]&quot;</span><span class="op">);</span></span>
<span id="cb305-16"><a href="#cb305-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The miscellaneous attributes are going to be emitted in a list, and
since any one attribute can actually be a list of attributes, this ends
up being recursive (<code>cg_json_misc_attr</code> can end up calling
back to <code>cg_json_misc_attrs</code>). Attributes are actually quite
flexible. Let’s look at the helpers that will be used to do this
formatting.</p>
<p>From <code>charbuf.h</code>:</p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a><span class="co">// These helpers push a buffer and use it for the output temporarily.</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a><span class="co">// When the buffer is finished (at END_INDENT) bindent is used to</span></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a><span class="co">// indent it by the indicated amount.  They assume the output buffer is called</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;output&quot;.</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BEGIN_INDENT(name, level) \</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a><span class="pp">  charbuf *name##_saved = output; \</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a><span class="pp">  int32_t name##_level = level; \</span></span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_OPEN(name); \</span></span>
<span id="cb306-9"><a href="#cb306-9" aria-hidden="true" tabindex="-1"></a><span class="pp">  output = &amp;name;</span></span>
<span id="cb306-10"><a href="#cb306-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-11"><a href="#cb306-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define END_INDENT(name) \</span></span>
<span id="cb306-12"><a href="#cb306-12" aria-hidden="true" tabindex="-1"></a><span class="pp">  output = name##_saved; \</span></span>
<span id="cb306-13"><a href="#cb306-13" aria-hidden="true" tabindex="-1"></a><span class="pp">  bindent(output, &amp;name, name##_level); \</span></span>
<span id="cb306-14"><a href="#cb306-14" aria-hidden="true" tabindex="-1"></a><span class="pp">  CHARBUF_CLOSE(name); \</span></span></code></pre></div>
<ul>
<li><code>BEGIN_INDENT</code> : sets up the indenting
<ul>
<li>save the current output buffer</li>
<li>stash the desired indent level in a named local</li>
<li>make a new scratch buffer using the given name</li>
<li>set the output to be the scratch buffer</li>
</ul></li>
<li><code>END_INDENT</code> : flushes the indented stuff
<ul>
<li>restores the output buffer to what it was</li>
<li>writes the temporary buffer into the output buffer, indenting it by
the desired abount</li>
<li>close the temporrary buffer</li>
</ul></li>
<li><code>bindent</code> : a <code>charbuf</code> helper that reads the
input line by line and writes it with indenting spaces to the
output</li>
</ul>
<p>The rest of the helpers manage the commas in the (nested) lists:</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="co">// These little helpers are for handling comma seperated lists where you may or may</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a><span class="co">// not need a comma in various places.  The local tracks if there is an item already</span></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a><span class="co">// present and you either get &quot;,\n&quot;  or just &quot;\n&quot; as needed.</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BEGIN_LIST bool_t list_start = 1</span></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CONTINUE_LIST bool_t list_start = 0</span></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define COMMA if (!list_start) bprintf(output, &quot;,\n&quot;); else list_start = 0</span></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define END_LIST if (!list_start) bprintf(output, &quot;\n&quot;)</span></span></code></pre></div>
<ul>
<li><code>BEGIN_LIST</code> : starts a list, records that we are at the
beginning of the list</li>
<li><code>CONTINUE_LIST</code> : starts a list, but assumes things have
already been put into it</li>
<li><code>COMMA</code> : a new item is about to be emitted, add a comma
if one is needed
<ul>
<li>i.e. add a comma if we are not on the first item</li>
</ul></li>
<li><code>END_LIST</code> : emits a blank line if anything went into the
list
<ul>
<li>this puts us in the write place to put an end marker such as ‘]’ or
‘}’</li>
</ul></li>
</ul>
<p>So reviewing this bit of code, * emit the attribute name and start
the array “[” * we start indenting * we start a list * we emit a comma
if needed * we emit the new misc attribute * this will crack the AST,
and get the attribute name and value * this can recurse *
<code>cg_json_misc_attr</code> is pretty simple and a good exercise for
the reader * repeat for all attributes * end the list * end the
indenting * emit the attribute end ”]”</p>
<h4 id="quoted-text">Quoted Text</h4>
<p>Most quoted text in the JSON output is either hard-coded constants,
or else is a CQL identifier and therefore has no special characters.
Those two cases are very simple and no escaping or special formatting is
needed. We just emit the text with quotes around it. However, there are
cases where general text that might have special characters in it needs
to be emitted. When that happens a call like this is used:</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>cg_pretty_quote_plaintext<span class="op">(</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>    sql<span class="op">.</span>ptr<span class="op">,</span></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>    output<span class="op">,</span></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>    PRETTY_QUOTE_JSON <span class="op">|</span> PRETTY_QUOTE_SINGLE_LINE<span class="op">);</span></span></code></pre></div>
<p><code>cg_pretty_quote_plaintext</code> has been discussed before when
it was used to create SQL strings for the C output. This usage is
similar. Here we’re using <code>PRETTY_QUOTE_JSON</code> to indicate
that only escape sequences supported by JSON should appear in the
output. The format for hexadecimal escape sequences for non-printable
characters is different than C and some of the C short escapes are not
supported (e.g. “” is not legal JSON). We always use
<code>PRETTY_QUOTE_SINGLE_LINE</code> in the JSON output so that
multi-line SQL is rendered as one line. Remember here we are are
JSON-escaping the SQL so the embedded newlines in the original SQL were
already converted to ‘' ’n’ (two characters) and therefore any newlines
still in the string are those placed there by the line breaking of the
SQL not by newlines in string literals. Hence those newlines are
optional, any whitespace will do.</p>
<p>In any case, <code>cg_pretty_quote_plaintext</code> is just the
function to do what we need and this output is only slightly different
than what would be emitted for the C codegen.</p>
<h3 id="dependency-analysis">Dependency Analysis</h3>
<p>There are a number of places where dependencies have to be computed.
To do this job, this function is used universally:</p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a><span class="co">// For procedures and triggers we want to walk the statement list and emit a set</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a><span class="co">// of dependency entries that show what the code in question is using and how.</span></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a><span class="co">// We track tables that are used and if they appear in say the FROM clause</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a><span class="co">// (or some other read-context) or if they are the subject of an insert, update,</span></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a><span class="co">// or delete.  We also track the use of nested procedures and produce a list of</span></span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a><span class="co">// procs the subject might call.  Of course no proc calls ever appear in triggers.</span></span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_json_dependencies<span class="op">(</span>charbuf <span class="op">*</span>output<span class="op">,</span> ast_node <span class="op">*</span>ast<span class="op">)</span> <span class="op">{</span></span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In general this code walks any AST looking for a variety of patterns
in the AST that correspond to use of tables, directly or indirectly.
Actually more accurately, <code>cg_json_dependencies</code> uses
<code>find_table_refs</code> to do the job, and it does so by:</p>
<ul>
<li>creating an output buffer for each kind of thing
<code>find_table_refs</code> might find</li>
<li>setting up a simple callback to fill in the buffer</li>
<li>invoking <code>find_table_refs</code></li>
<li>formatting the buffers that have any resulting dependency data and
emitting them as dependencies</li>
</ul>
<p>This works for any kind of AST really, though typically you do this
for procedures or triggers because they have an interesting body. But
the analysis also makes sense for views because views can refer to other
views and to tables.</p>
<p>The primary code looks like this:</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>  table_callbacks callbacks <span class="op">=</span> <span class="op">{</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_any_table <span class="op">=</span> cg_found_table<span class="op">,</span></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_any_view <span class="op">=</span> cg_found_view<span class="op">,</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_inserts <span class="op">=</span> cg_found_insert<span class="op">,</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_updates <span class="op">=</span> cg_found_update<span class="op">,</span></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_deletes <span class="op">=</span> cg_found_delete<span class="op">,</span></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_from <span class="op">=</span> cg_found_from<span class="op">,</span></span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_proc <span class="op">=</span> cg_found_proc<span class="op">,</span></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>callback_context <span class="op">=</span> <span class="op">&amp;</span>context<span class="op">,</span></span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>  find_table_refs<span class="op">(&amp;</span>callbacks<span class="op">,</span> ast<span class="op">);</span></span></code></pre></div>
<p>And an example callback:</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is the callback function that tells us a view name was found in the body</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a><span class="co">// of the stored proc we are currently examining.  The void context information</span></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a><span class="co">// is how we remember which proc we were processing.   For each table we have</span></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a><span class="co">// a character buffer.  We look it up, create it if not present, and write into it.</span></span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We also write into the buffer for the current proc which came in with the context.</span></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_found_view<span class="op">(</span></span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a>  CSTR view_name<span class="op">,</span></span>
<span id="cb311-8"><a href="#cb311-8" aria-hidden="true" tabindex="-1"></a>  ast_node<span class="op">*</span> table_ast<span class="op">,</span></span>
<span id="cb311-9"><a href="#cb311-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span><span class="op">*</span> pvContext<span class="op">)</span></span>
<span id="cb311-10"><a href="#cb311-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb311-11"><a href="#cb311-11" aria-hidden="true" tabindex="-1"></a>  json_context <span class="op">*</span>context <span class="op">=</span> <span class="op">(</span>json_context <span class="op">*)</span>pvContext<span class="op">;</span></span>
<span id="cb311-12"><a href="#cb311-12" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>context<span class="op">-&gt;</span>cookie <span class="op">==</span> cookie_str<span class="op">);</span>  <span class="co">// sanity check</span></span>
<span id="cb311-13"><a href="#cb311-13" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>context<span class="op">-&gt;</span>used_views<span class="op">);</span></span>
<span id="cb311-14"><a href="#cb311-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-15"><a href="#cb311-15" aria-hidden="true" tabindex="-1"></a>  add_name_to_output<span class="op">(</span>context<span class="op">-&gt;</span>used_views<span class="op">,</span> view_name<span class="op">);</span></span>
<span id="cb311-16"><a href="#cb311-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The callback gets the <code>pvContext</code> back, which is the
<code>context</code> local variable from
<code>cg_json_dependencies</code>. This has all the buffers in it. All
we have to do is add the name to the buffer, which is done as
follows:</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> add_name_to_output<span class="op">(</span>charbuf<span class="op">*</span> output<span class="op">,</span> CSTR table_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>output<span class="op">);</span></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>output<span class="op">-&gt;</span>used <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">);</span></span>
<span id="cb312-5"><a href="#cb312-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb312-6"><a href="#cb312-6" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">,</span> table_name<span class="op">);</span></span>
<span id="cb312-7"><a href="#cb312-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>add a comma if needed</li>
<li>add the name</li>
<li>done :D</li>
</ul>
<p>Note: The added name of course doesn’t have to be a table name, but
it usually is.</p>
<p>So we can see that <code>find_table_refs</code> will tell us the kind
of thing it found and the name of the thing.</p>
<p>When all this is done each kind of dependency is emitted if it
exists, like so:</p>
<div class="sourceCode" id="cb313"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>used_views<span class="op">.</span>used <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>output<span class="op">,</span> <span class="st">&quot;,</span><span class="sc">\n\&quot;</span><span class="st">usesViews</span><span class="sc">\&quot;</span><span class="st"> : [ %s ]&quot;</span><span class="op">,</span> used_views<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>This gives us a quoted list of the dependencies. Now, how do we find
these?</p>
<h4 id="walking-the-ast-for-dependencies">Walking the AST for
Dependencies</h4>
<p><code>find_table_refs</code> is a fairly simple tree walk that looks
for certain key patterns actually the tree walk happens in
<code>find_table_node</code> which looks for tables and procedure calls
in the nested AST.</p>
<p><code>find_table_refs</code> records the callbacks that were
specified, and it makes some symbol tables so that the same
table/view/procedure is not reported twice. After that it starts walking
the AST recursively looking for the patterns. Here’s an example:</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Recursively finds table nodes, executing the callback for each that is found.  The</span></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a><span class="co">// callback will not be executed more than once for the same table name.</span></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> find_table_node<span class="op">(</span>table_callbacks <span class="op">*</span>callbacks<span class="op">,</span> ast_node <span class="op">*</span>node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Check the type of node so that we can find the direct references to tables. We</span></span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// can&#39;t know the difference between a table or view in the ast, so we will need to</span></span>
<span id="cb314-7"><a href="#cb314-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// later find the definition to see if it points to a create_table_stmt to distinguish</span></span>
<span id="cb314-8"><a href="#cb314-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// from views.</span></span>
<span id="cb314-9"><a href="#cb314-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-10"><a href="#cb314-10" aria-hidden="true" tabindex="-1"></a>  find_ast_str_node_callback alt_callback <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb314-11"><a href="#cb314-11" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>alt_visited <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb314-12"><a href="#cb314-12" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>table_or_view_name_ast <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb314-13"><a href="#cb314-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-14"><a href="#cb314-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb314-15"><a href="#cb314-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>is_ast_delete_stmt<span class="op">(</span>node<span class="op">))</span> <span class="op">{</span></span>
<span id="cb314-16"><a href="#cb314-16" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>name_ast<span class="op">,</span> node<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb314-17"><a href="#cb314-17" aria-hidden="true" tabindex="-1"></a>    table_or_view_name_ast <span class="op">=</span> name_ast<span class="op">;</span></span>
<span id="cb314-18"><a href="#cb314-18" aria-hidden="true" tabindex="-1"></a>    alt_callback <span class="op">=</span> callbacks<span class="op">-&gt;</span>callback_deletes<span class="op">;</span></span>
<span id="cb314-19"><a href="#cb314-19" aria-hidden="true" tabindex="-1"></a>    alt_visited <span class="op">=</span> callbacks<span class="op">-&gt;</span>visited_delete<span class="op">;</span></span>
<span id="cb314-20"><a href="#cb314-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb314-21"><a href="#cb314-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-22"><a href="#cb314-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb314-23"><a href="#cb314-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-24"><a href="#cb314-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code afterward will do these steps:</p>
<ul>
<li>notice that <code>table_or_view_name_ast</code> was set, hence
something was found</li>
<li>determine that it is in fact a table</li>
<li>call the general callback for any table seen (but only once for this
table)</li>
<li>call the alternate callback that this is a table being deleted (but
only once)</li>
</ul>
<p>Almost all the other operations work similarly: *
<code>table_or_view_name_ast</code> is set * <code>alt_callback</code>
is called but only if * <code>alt_visited</code> doesn’t already have
the symbol</p>
<p>The exception to the above is the processing that’s done for
procedure calls. We’ve actually only talked about table dependencies so
far but, additionally, any procedure includes dependencies on the
procedures it calls.</p>
<p>If a procedure call is found then
<code>callbacks-&gt;callback_proc</code> is used and
<code>callbacks-&gt;visited_proc</code> verifies that there are no
duplicates. So much the same except the names are procedure names.</p>
<p>Note that the code does not do transitive closure of procedure calls
because in general the called procedure is likely in a different
translation unit. However with the direct calls in place it is easy
enough to do transitive closure from the JSON if you do have all the
procedures in one unit or if you have several JSON results from
different compilations.</p>
<p>However, when a view is encountered, the code does follow into the
view body and recursively reports what the view uses. This means that
the reported tables do include any tables that were used indirectly via
views.</p>
<p>Finally, any CTEs that are used will not be reported because
<code>find_table_or_view_even_deleted</code> will fail for a CTE.
However the body of the CTE is processed so while the CTE name does not
appear, what the CTE uses does appear, just like any other table
usage.</p>
<h3 id="additional-test-output">Additional Test Output</h3>
<p>The extra test output is simply a reverse index: a mapping that goes
from any table to the procedures that depend on that table.</p>
<p>The mapping can easily be created by processing the JSON for
procedures, each such procedure includes its dependency information. As
a result it’s only used for additional validation.</p>
<h3 id="recap-4">Recap</h3>
<p>The JSON output produced by <code>cg_json_schema.c</code> is similar
to other codegen output but lacks most of the complexities. It deals
largely with the declared schema and the declared procedures and their
parameters. Most of the output it needs to produce is well supported by
the normal text emission features in the compiler and so we end up with
a very straightforward walk of the AST, visiting each of the relevant
kinds of nodes in order.</p>
<p>Topics covered included:</p>
<ul>
<li>the types of output that will be produced</li>
<li>the general structure of the main JSON emitter</li>
<li>an example emitter</li>
<li>typical formatting features necessary to produce good quality
JSON</li>
<li>a tour of the dependency emitter</li>
</ul>
<p>As with the other parts, no attempt was made to cover every function
in detail. That is best done by reading the source code. But there is
overall structure here and an understanding of the basic principles is
helpful before diving into the source code.</p>
<h2 id="part-8-test-helpers">Part 8: Test Helpers</h2>
<!---
-- Copyright (c) Meta Platforms, Inc. and affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->
<h3 id="preface-7">Preface</h3>
<p>Part 8 continues with a discussion of the Test Helper generation
code. As in the previous sections, the goal here is not to go over every
detail but rather to give a sense of how helpers are created in general
– the core strategies and implementation choices – so that when reading
the source you will have an idea how it all hangs together.</p>
<h2 id="test-helpers">Test Helpers</h2>
<p>The testability features are described in <a
href="https://cgsql.dev/cql-guide/ch12">Chapter 12</a> of the Guide So,
we won’t be discussing all the details of what can be created. Instead
we’re going to go over the theory of how the generator works. This
generator is somewhat different than others in that it only concerns
itself with procedures and only those that have been suitably annotated
– there are large parts of the tree that are of no interest to the test
helper logic, including, importantly the body of procedures. Only the
signature matters. As we’ll see there is a fairly large family of
generators that are like this.</p>
<p>We’ll have one section for every kind of output, but really only the
<code>dummy_test</code> helper is worthy of detailed discussion the
others, as we’ll see, are very simple.</p>
<h3 id="initialization">Initialization</h3>
<p>The generator is wired like the others with a suitable main, this one
is pretty simple:</p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Main entry point for test_helpers</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a>cql_noexport <span class="dt">void</span> cg_test_helpers_main<span class="op">(</span>ast_node <span class="op">*</span>head<span class="op">)</span> <span class="op">{</span></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>options<span class="op">.</span>file_names_count <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>  cql_exit_on_semantic_errors<span class="op">(</span>head<span class="op">);</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>  exit_on_validating_schema<span class="op">();</span></span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a>  cg_test_helpers_reset_globals<span class="op">();</span></span>
<span id="cb315-7"><a href="#cb315-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-8"><a href="#cb315-8" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>output_buf<span class="op">);</span></span>
<span id="cb315-9"><a href="#cb315-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-10"><a href="#cb315-10" aria-hidden="true" tabindex="-1"></a>  cg_th_output <span class="op">=</span> <span class="op">&amp;</span>output_buf<span class="op">;</span></span>
<span id="cb315-11"><a href="#cb315-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-12"><a href="#cb315-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_output<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> rt<span class="op">-&gt;</span>source_prefix<span class="op">);</span></span>
<span id="cb315-13"><a href="#cb315-13" aria-hidden="true" tabindex="-1"></a>  cg_test_helpers_stmt_list<span class="op">(</span>head<span class="op">);</span></span>
<span id="cb315-14"><a href="#cb315-14" aria-hidden="true" tabindex="-1"></a>  cql_write_file<span class="op">(</span>options<span class="op">.</span>file_names<span class="op">[</span><span class="dv">0</span><span class="op">],</span> cg_th_output<span class="op">-&gt;</span>ptr<span class="op">);</span></span>
<span id="cb315-15"><a href="#cb315-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-16"><a href="#cb315-16" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>output_buf<span class="op">);</span></span>
<span id="cb315-17"><a href="#cb315-17" aria-hidden="true" tabindex="-1"></a>  cg_test_helpers_reset_globals<span class="op">();</span></span>
<span id="cb315-18"><a href="#cb315-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The text output will be ultimately put into <code>output_buf</code>
defined here and <code>helper_flags</code> will track which kinds of
helpers we saw. This helps us to emit the right sections of output as
we’ll see.</p>
<p>The code iterates the AST looking at the top level statement list
only and in particular looking for <code>CREATE PROC</code>
statements.</p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Iterate through statement list</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_test_helpers_stmt_list<span class="op">(</span>ast_node <span class="op">*</span>head<span class="op">)</span> <span class="op">{</span></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_stmt_list<span class="op">(</span>head<span class="op">));</span></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a>  init_all_trigger_per_table<span class="op">();</span></span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a>  init_all_indexes_per_table<span class="op">();</span></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>procs_buf<span class="op">);</span></span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>  CHARBUF_OPEN<span class="op">(</span>decls_buf<span class="op">);</span></span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a>  cg_th_procs <span class="op">=</span> <span class="op">&amp;</span>procs_buf<span class="op">;</span></span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a>  cg_th_decls <span class="op">=</span> <span class="op">&amp;</span>decls_buf<span class="op">;</span></span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-11"><a href="#cb316-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>ast_node <span class="op">*</span>ast <span class="op">=</span> head<span class="op">;</span> ast<span class="op">;</span> ast <span class="op">=</span> ast<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb316-12"><a href="#cb316-12" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STMT_AND_MISC_ATTRS<span class="op">(</span>stmt<span class="op">,</span> misc_attrs<span class="op">,</span> ast<span class="op">);</span></span>
<span id="cb316-13"><a href="#cb316-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-14"><a href="#cb316-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_create_proc_stmt<span class="op">(</span>stmt<span class="op">))</span> <span class="op">{</span></span>
<span id="cb316-15"><a href="#cb316-15" aria-hidden="true" tabindex="-1"></a>      EXTRACT_STRING<span class="op">(</span>proc_name<span class="op">,</span> stmt<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb316-16"><a href="#cb316-16" aria-hidden="true" tabindex="-1"></a>      cg_test_helpers_create_proc_stmt<span class="op">(</span>stmt<span class="op">,</span> misc_attrs<span class="op">);</span></span>
<span id="cb316-17"><a href="#cb316-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb316-18"><a href="#cb316-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb316-19"><a href="#cb316-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-20"><a href="#cb316-20" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_output<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> decls_buf<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb316-21"><a href="#cb316-21" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_output<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb316-22"><a href="#cb316-22" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_output<span class="op">,</span> <span class="st">&quot;%s&quot;</span><span class="op">,</span> procs_buf<span class="op">.</span>ptr<span class="op">);</span></span>
<span id="cb316-23"><a href="#cb316-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-24"><a href="#cb316-24" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>decls_buf<span class="op">);</span></span>
<span id="cb316-25"><a href="#cb316-25" aria-hidden="true" tabindex="-1"></a>  CHARBUF_CLOSE<span class="op">(</span>procs_buf<span class="op">);</span></span>
<span id="cb316-26"><a href="#cb316-26" aria-hidden="true" tabindex="-1"></a>  symtab_delete<span class="op">(</span>all_tables_with_triggers<span class="op">);</span></span>
<span id="cb316-27"><a href="#cb316-27" aria-hidden="true" tabindex="-1"></a>  all_tables_with_triggers <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb316-28"><a href="#cb316-28" aria-hidden="true" tabindex="-1"></a>  symtab_delete<span class="op">(</span>all_tables_with_indexes<span class="op">);</span></span>
<span id="cb316-29"><a href="#cb316-29" aria-hidden="true" tabindex="-1"></a>  all_tables_with_indexes <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb316-30"><a href="#cb316-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are some preliminaries:</p>
<ul>
<li>we make a symbol table that maps from tables names to the list of
triggers on that table by walking all the triggers</li>
<li>we make a symbol table that maps from tables names to the list of
indices on that table by walking all the indices</li>
<li>we’ll need two buffers one for declarations (that must go first) and
one for procedure bodies</li>
<li>each <code>CREATE PROC</code> statement potentially contributes to
both sections</li>
<li><code>cg_test_helpers_create_proc_stmt</code> checks for the helper
attributes and sets up the dispatch to emit the test helpers</li>
</ul>
<p>To do this we have to walk any misc attributes on the procedure we’re
looking for things of the form
<code>@attribute(cql:autotest=xxx)</code></p>
<div class="sourceCode" id="cb317"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_test_helpers_create_proc_stmt<span class="op">(</span>ast_node <span class="op">*</span>stmt<span class="op">,</span> ast_node <span class="op">*</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_create_proc_stmt<span class="op">(</span>stmt<span class="op">));</span></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>misc_attrs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a>    helper_flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>    dummy_test_infos <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true" tabindex="-1"></a>    find_misc_attrs<span class="op">(</span>misc_attrs<span class="op">,</span> test_helpers_find_ast_misc_attr_callback<span class="op">,</span> stmt<span class="op">);</span></span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-10"><a href="#cb317-10" aria-hidden="true" tabindex="-1"></a>    symtab_delete<span class="op">(</span>dummy_test_infos<span class="op">);</span></span>
<span id="cb317-11"><a href="#cb317-11" aria-hidden="true" tabindex="-1"></a>    dummy_test_infos <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb317-12"><a href="#cb317-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb317-13"><a href="#cb317-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>find_misc_attrs</code> calls
<code>test_helpers_find_ast_misc_attr_callback</code>. We’re going to
keep track of which kinds of helpers we have found to help us with the
output. This is where <code>helper_flags</code> comes in. The flags
are:</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DUMMY_TABLE           1 </span><span class="co">// dummy_table attribute flag</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DUMMY_INSERT          2 </span><span class="co">// dummy_insert attribute flag</span></span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DUMMY_SELECT          4 </span><span class="co">// dummy_select attribute flag</span></span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DUMMY_RESULT_SET      8 </span><span class="co">// dummy_result_set attribute flag</span></span>
<span id="cb318-5"><a href="#cb318-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DUMMY_TEST         0x10 </span><span class="co">// dummy_test attribute flag</span></span></code></pre></div>
<p>And now we’re ready for actual dispatch:</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is invoked for every misc attribute on every create proc statement</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a><span class="co">// in this translation unit.  We&#39;re looking for attributes of the form cql:autotest=(...)</span></span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a><span class="co">// and we ignore anything else.</span></span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> test_helpers_find_ast_misc_attr_callback<span class="op">(</span></span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a>  CSTR _Nullable misc_attr_prefix<span class="op">,</span></span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>  CSTR _Nonnull misc_attr_name<span class="op">,</span></span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>_Nullable ast_misc_attr_value_list<span class="op">,</span></span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable context<span class="op">)</span></span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb319-10"><a href="#cb319-10" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>stmt <span class="op">=</span> <span class="op">(</span>ast_node <span class="op">*)</span>context<span class="op">;</span></span>
<span id="cb319-11"><a href="#cb319-11" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>is_ast_create_proc_stmt<span class="op">(</span>stmt<span class="op">));</span></span>
<span id="cb319-12"><a href="#cb319-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-13"><a href="#cb319-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>misc_attr_prefix <span class="op">&amp;&amp;</span></span>
<span id="cb319-14"><a href="#cb319-14" aria-hidden="true" tabindex="-1"></a>      misc_attr_name <span class="op">&amp;&amp;</span></span>
<span id="cb319-15"><a href="#cb319-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">!</span>Strcasecmp<span class="op">(</span>misc_attr_prefix<span class="op">,</span> <span class="st">&quot;cql&quot;</span><span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb319-16"><a href="#cb319-16" aria-hidden="true" tabindex="-1"></a>      <span class="op">!</span>Strcasecmp<span class="op">(</span>misc_attr_name<span class="op">,</span> <span class="st">&quot;autotest&quot;</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb319-17"><a href="#cb319-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb319-18"><a href="#cb319-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb319-19"><a href="#cb319-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The main dispatch looks like this:</p>
<div class="sourceCode" id="cb320"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="co">// In principle, any option can be combined with any other but some only make sense for procs with</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a><span class="co">// a result.</span></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a>EXTRACT_STRING<span class="op">(</span>autotest_attr_name<span class="op">,</span> misc_attr_value<span class="op">);</span></span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>is_autotest_dummy_test<span class="op">(</span>autotest_attr_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a>  cg_test_helpers_dummy_test<span class="op">(</span>stmt<span class="op">);</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-9"><a href="#cb320-9" aria-hidden="true" tabindex="-1"></a><span class="co">// these options are only for procs that return a result set</span></span>
<span id="cb320-10"><a href="#cb320-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>has_result_set<span class="op">(</span>stmt<span class="op">)</span> <span class="op">||</span> has_out_stmt_result<span class="op">(</span>stmt<span class="op">)</span> <span class="op">||</span> has_out_union_stmt_result<span class="op">(</span>stmt<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-11"><a href="#cb320-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>is_autotest_dummy_table<span class="op">(</span>autotest_attr_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-12"><a href="#cb320-12" aria-hidden="true" tabindex="-1"></a>    helper_flags <span class="op">|=</span> DUMMY_TABLE<span class="op">;</span></span>
<span id="cb320-13"><a href="#cb320-13" aria-hidden="true" tabindex="-1"></a>    cg_test_helpers_dummy_table<span class="op">(</span>proc_name<span class="op">);</span></span>
<span id="cb320-14"><a href="#cb320-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb320-15"><a href="#cb320-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>is_autotest_dummy_insert<span class="op">(</span>autotest_attr_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-16"><a href="#cb320-16" aria-hidden="true" tabindex="-1"></a>    helper_flags <span class="op">|=</span> DUMMY_INSERT<span class="op">;</span></span>
<span id="cb320-17"><a href="#cb320-17" aria-hidden="true" tabindex="-1"></a>    cg_test_helpers_dummy_insert<span class="op">(</span>proc_name<span class="op">);</span></span>
<span id="cb320-18"><a href="#cb320-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb320-19"><a href="#cb320-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>is_autotest_dummy_select<span class="op">(</span>autotest_attr_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-20"><a href="#cb320-20" aria-hidden="true" tabindex="-1"></a>    helper_flags <span class="op">|=</span> DUMMY_SELECT<span class="op">;</span></span>
<span id="cb320-21"><a href="#cb320-21" aria-hidden="true" tabindex="-1"></a>    cg_test_helpers_dummy_select<span class="op">(</span>proc_name<span class="op">);</span></span>
<span id="cb320-22"><a href="#cb320-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb320-23"><a href="#cb320-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>is_autotest_dummy_result_set<span class="op">(</span>autotest_attr_name<span class="op">))</span> <span class="op">{</span></span>
<span id="cb320-24"><a href="#cb320-24" aria-hidden="true" tabindex="-1"></a>    helper_flags <span class="op">|=</span> DUMMY_RESULT_SET<span class="op">;</span></span>
<span id="cb320-25"><a href="#cb320-25" aria-hidden="true" tabindex="-1"></a>    cg_test_helpers_dummy_result_set<span class="op">(</span>proc_name<span class="op">);</span></span>
<span id="cb320-26"><a href="#cb320-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb320-27"><a href="#cb320-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Most of these options are very simple indeed.
<code>cg_test_helpers_dummy_test</code> is the trickiest by far and
we’ll save it for last, let’s dispense with the easy stuff.</p>
<h3 id="dummy-table-dummy-insert-dummy-select-dummy-result-set">Dummy
Table, Dummy Insert, Dummy Select, Dummy Result Set</h3>
<p>All of these are a very simple template. The language includes just
the right features to emit these procedures as nearly constant strings.
The <code>LIKE</code> construct was literally designed to make these
patterns super simple. You can see all the patterns in <a
href="https://cgsql.dev/cql-guide/ch12">Chapter 12</a> but let’s look at
the code for the first one. This is “dummy table”.</p>
<div class="sourceCode" id="cb321"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Emit an open proc which creates a temp table in the form of the original proc</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Emit a close proc which drops the temp table</span></span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_test_helpers_dummy_table<span class="op">(</span>CSTR name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;CREATE PROC open_%s()</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;BEGIN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;  CREATE TEMP TABLE test_%s(LIKE %s);</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">,</span> name<span class="op">);</span></span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;END;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-9"><a href="#cb321-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-10"><a href="#cb321-10" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-11"><a href="#cb321-11" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;CREATE PROC close_%s()</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb321-12"><a href="#cb321-12" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;BEGIN</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-13"><a href="#cb321-13" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;  DROP TABLE test_%s;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb321-14"><a href="#cb321-14" aria-hidden="true" tabindex="-1"></a>  bprintf<span class="op">(</span>cg_th_procs<span class="op">,</span> <span class="st">&quot;END;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb321-15"><a href="#cb321-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The purpose of this is to create helper functions that can create a
temporary table with the same columns in it as the procedure you are
trying to mock. You can then select rows out of that table (with
<code>dummy_select</code>) or insert rows into the table (with
<code>dummy_insert</code>). Or you can make a single row result set
(often enough) with <code>dummy_result_set</code>.</p>
<p>As we can see we simply prepend <code>open_</code> to the procedure
name and use that to create a test helper that make the temporary table.
The table’s columns are defined to be <code>LIKE</code> the result shape
of the procedure under test. Recall this helper is only available to
procedures that return a result set. The temporary table gets a
<code>test_</code> prefix. Assuming the procedure with the annotation is
<code>foo</code> then this code is universal:</p>
<div class="sourceCode" id="cb322"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> TEMP <span class="kw">TABLE</span> test_foo(<span class="kw">LIKE</span> foo);</span></code></pre></div>
<p>Is universal, no matter the result shape of <code>foo</code> you get
a table with those columns.</p>
<p>For this to work we need to emit a declaration of <code>foo</code>
before this code. However, since we have the full definition of
<code>foo</code> handy that is no problem. We remember that we’ll need
it by setting a flag in <code>helper_flags</code>.</p>
<p>The code for <code>close_foo</code> is even simpler if that’s
possible. The great thing is all need to know the columns of
<code>foo</code> has been removed from the test helper. The CQL compiler
handles this as a matter of course and it is generally useful. See <a
href="https://cgsql.dev/cql-guide/ch05#reshaping-data-cursor-like-forms">Chapter
5</a> for more examples.</p>
<p>All the others are equally simple and use similar tricks. These were
the first test helpers. They’re actually not that popular because they
are so easy to create yourself anyway.</p>
<h3 id="dummy-test">Dummy Test</h3>
<p>The dummy test code emitter is non-trivial. Let’s quickly review the
things it has to do and then we can go over how each of these is
accomplished. Assuming we have an procedure <code>your_proc</code> that
has been annotated like this:</p>
<div class="sourceCode" id="cb323"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="ot">@attribute(cql:autotest=(dummy_test))</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a><span class="kw">create</span> proc your_proc(<span class="op">..</span>args<span class="op">..</span>.)</span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- assorted references to tables and views</span></span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span>;</span></code></pre></div>
<p>Dummy test will produce the following:</p>
<ul>
<li><code>test_your_proc_create_tables</code>
<ul>
<li>a procedure that creates all the tables and views that
<code>your_proc</code> needs</li>
</ul></li>
<li><code>test_your_proc_drop_tables</code>
<ul>
<li>a procedure that drops those same tables and views</li>
</ul></li>
<li><code>test_your_proc_create_indexes</code>
<ul>
<li>a procedure that creates your indices, in a test you may or may not
want to create the indices</li>
</ul></li>
<li><code>test_your_proc_drop_indexes</code>
<ul>
<li>a procedure the drops those same indices</li>
</ul></li>
<li><code>test_your_proc_create_triggers</code>
<ul>
<li>a procedure that creates your trigger, in a test you may or may not
want to create the triggers</li>
</ul></li>
<li><code>test_your_proc_drop_triggers</code>
<ul>
<li>a procedure the drops those same triggers</li>
</ul></li>
<li><code>test_your_proc_read_table1</code>
<ul>
<li>for each table or view in the <code>create_tables</code> a procedure
that selects all the data out of that object is created in case you need
it</li>
</ul></li>
<li><code>test_your_proc_populate_tables</code>
<ul>
<li>a procedure that loads all the tables from
<code>create_tables</code> with sample data</li>
<li>FK relationships are obeyed</li>
<li>user data may be specified in an attribute and that data will be
used in preference to auto-generated data</li>
</ul></li>
</ul>
<p>These are more fully discussed in <a
href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern">Chapter
12</a>.</p>
<h4 id="building-the-trigger-and-index-mappings">Building the Trigger
and Index mappings</h4>
<p>In order to know which indices and triggers we might need we have to
be able to map from the tables/views in <code>your_proc</code> to the
indices. To set up for this a general purpose reverse mapping is
created. We’ll look at the triggers version. The indices version is
nearly identical.</p>
<div class="sourceCode" id="cb324"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Walk through all triggers and create a dictionnary of triggers per tables.</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> init_all_trigger_per_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>all_tables_with_triggers <span class="op">==</span> NULL<span class="op">);</span></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>  all_tables_with_triggers <span class="op">=</span> symtab_new<span class="op">();</span></span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-6"><a href="#cb324-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> all_triggers_list<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb324-7"><a href="#cb324-7" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>create_trigger_stmt<span class="op">,</span> item<span class="op">-&gt;</span>ast<span class="op">);</span></span>
<span id="cb324-8"><a href="#cb324-8" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>trigger_body_vers<span class="op">,</span> create_trigger_stmt<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb324-9"><a href="#cb324-9" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>trigger_def<span class="op">,</span> trigger_body_vers<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb324-10"><a href="#cb324-10" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>trigger_condition<span class="op">,</span> trigger_def<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb324-11"><a href="#cb324-11" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>trigger_op_target<span class="op">,</span> trigger_condition<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb324-12"><a href="#cb324-12" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>trigger_target_action<span class="op">,</span> trigger_op_target<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb324-13"><a href="#cb324-13" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>table_name_ast<span class="op">,</span> trigger_target_action<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb324-14"><a href="#cb324-14" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STRING<span class="op">(</span>table_name<span class="op">,</span> table_name_ast<span class="op">);</span></span>
<span id="cb324-15"><a href="#cb324-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-16"><a href="#cb324-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>create_trigger_stmt<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb324-17"><a href="#cb324-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">// dummy_test should not emit deleted trigger</span></span>
<span id="cb324-18"><a href="#cb324-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb324-19"><a href="#cb324-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb324-20"><a href="#cb324-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-21"><a href="#cb324-21" aria-hidden="true" tabindex="-1"></a>    symtab_append_bytes<span class="op">(</span>all_tables_with_triggers<span class="op">,</span> table_name<span class="op">,</span> <span class="op">&amp;</span>create_trigger_stmt<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>create_trigger_stmt<span class="op">));</span></span>
<span id="cb324-22"><a href="#cb324-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb324-23"><a href="#cb324-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The steps are pretty simple:</p>
<ul>
<li>we make a symbol table that will map from the table name to an array
of statements</li>
<li>there is a convenient <code>all_triggers</code> list that has all
the triggers</li>
<li>from each trigger we <code>EXTRACT</code> the table or view name
(named <code>table_name</code> even if it’s a view)</li>
<li>we append the trigger statement pointer to the end of such
statements for the table</li>
<li>any triggers marked with <code>@delete</code> are not included for
obvious reasons</li>
</ul>
<p>At the end of this looking up the table name will give you a list of
trigger statement AST pointers. From there of course you can get
everything you need.</p>
<p>The index version is basically the same, the details of the
<code>EXTRACT</code> ops to go from index to table name are different
and of course we start from the <code>all_indices_list</code></p>
<h4 id="computing-the-dependencies-of-a-procedure">Computing The
Dependencies of a Procedure</h4>
<p>Sticking with our particular example, in order to determine that
tables/views that <code>your_proc</code> might need, the generator has
to walk its entire body looking for things that are tables. This is
handled by the <code>find_all_table_nodes</code> function.</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> find_all_table_nodes<span class="op">(</span>dummy_test_info <span class="op">*</span>info<span class="op">,</span> ast_node <span class="op">*</span>node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a>  table_callbacks callbacks <span class="op">=</span> <span class="op">{</span></span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>callback_any_table <span class="op">=</span> found_table_or_view<span class="op">,</span></span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>callback_any_view <span class="op">=</span> found_table_or_view<span class="op">,</span></span>
<span id="cb325-5"><a href="#cb325-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>callback_context <span class="op">=</span> info<span class="op">,</span></span>
<span id="cb325-6"><a href="#cb325-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>notify_table_or_view_drops <span class="op">=</span> true<span class="op">,</span></span>
<span id="cb325-7"><a href="#cb325-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>notify_fk <span class="op">=</span> true<span class="op">,</span></span>
<span id="cb325-8"><a href="#cb325-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>notify_triggers <span class="op">=</span> true<span class="op">,</span></span>
<span id="cb325-9"><a href="#cb325-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb325-10"><a href="#cb325-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-11"><a href="#cb325-11" aria-hidden="true" tabindex="-1"></a>  info<span class="op">-&gt;</span>callbacks  <span class="op">=</span> <span class="op">&amp;</span>callbacks<span class="op">;</span></span>
<span id="cb325-12"><a href="#cb325-12" aria-hidden="true" tabindex="-1"></a>  find_table_refs<span class="op">(&amp;</span>callbacks<span class="op">,</span> node<span class="op">);</span></span>
<span id="cb325-13"><a href="#cb325-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-14"><a href="#cb325-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// stitch the views to the tables to make one list, views first</span></span>
<span id="cb325-15"><a href="#cb325-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>list_item <span class="op">*</span>item <span class="op">=</span> info<span class="op">-&gt;</span>found_views<span class="op">;</span> item<span class="op">;</span> item <span class="op">=</span> item<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb325-16"><a href="#cb325-16" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="op">(!</span>item<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb325-17"><a href="#cb325-17" aria-hidden="true" tabindex="-1"></a>       item<span class="op">-&gt;</span>next <span class="op">=</span> info<span class="op">-&gt;</span>found_tables<span class="op">;</span></span>
<span id="cb325-18"><a href="#cb325-18" aria-hidden="true" tabindex="-1"></a>       info<span class="op">-&gt;</span>found_tables <span class="op">=</span> info<span class="op">-&gt;</span>found_views<span class="op">;</span></span>
<span id="cb325-19"><a href="#cb325-19" aria-hidden="true" tabindex="-1"></a>       <span class="cf">break</span><span class="op">;</span></span>
<span id="cb325-20"><a href="#cb325-20" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb325-21"><a href="#cb325-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb325-22"><a href="#cb325-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// this shouldn&#39;t be used after it&#39;s been linked in</span></span>
<span id="cb325-23"><a href="#cb325-23" aria-hidden="true" tabindex="-1"></a>  info<span class="op">-&gt;</span>found_views <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb325-24"><a href="#cb325-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code uses the general dependency walker in
<code>cg_common.c</code> to visit all tables and views. It is a
recursive walk and the general steps for prosecution go something like
this:</p>
<ul>
<li>starting from <code>your_proc</code> the entire body of the
procedure is visited</li>
<li>references to tables or views in update, delete, insert, select etc.
statements are identified</li>
<li>each such table/view is added to the found tables list (at most
once)</li>
<li>for views, the recursion proceeds to the body of the view as though
the body had been inline in the procedure</li>
<li>for tables, the recursion proceeds to the body of the table to
discover any FK relationships that need to be followed</li>
<li>if any found item has triggers, the trigger body is walked, any
tables/views mentioned there become additional found items</li>
<li>any given table/view and hence trigger is only visited once</li>
</ul>
<p>The net of all this, the “found items”, is a list of all the tables
and views that the procedure uses, directly or indirectly. As discussed
in <a
href="https://cgsql.dev/cql-guide/ch12#generalized-dummy-test-pattern">Chapter
12</a> this walk does not include tables and views used by procedures
that <code>your_proc</code> calls.</p>
<p>To get the dependencies in the correct order, the tables have been
walked following the foreign key chain and all views go after all
tables. The views are stitched together. The business of diving into
views/tables/triggers and maintainence of the found items is done by the
callback function <code>found_table_or_view</code>. The actual source is
more descriptive comments than code but the code is included here as it
is brief.</p>
<div class="sourceCode" id="cb326"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="co">// comments elided for brevity, the why of all this is described in the code</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> found_table_or_view<span class="op">(</span></span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a>  CSTR _Nonnull table_or_view_name<span class="op">,</span></span>
<span id="cb326-4"><a href="#cb326-4" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>_Nonnull table_or_view<span class="op">,</span></span>
<span id="cb326-5"><a href="#cb326-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="op">*</span>_Nullable context<span class="op">)</span></span>
<span id="cb326-6"><a href="#cb326-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb326-7"><a href="#cb326-7" aria-hidden="true" tabindex="-1"></a>  Contract<span class="op">(</span>table_or_view<span class="op">);</span></span>
<span id="cb326-8"><a href="#cb326-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-9"><a href="#cb326-9" aria-hidden="true" tabindex="-1"></a>  dummy_test_info <span class="op">*</span>info <span class="op">=</span> <span class="op">(</span>dummy_test_info <span class="op">*)</span>context<span class="op">;</span></span>
<span id="cb326-10"><a href="#cb326-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-11"><a href="#cb326-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> deleted <span class="op">=</span> table_or_view<span class="op">-&gt;</span>sem<span class="op">-&gt;</span>delete_version <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb326-12"><a href="#cb326-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>deleted<span class="op">)</span> <span class="op">{</span></span>
<span id="cb326-13"><a href="#cb326-13" aria-hidden="true" tabindex="-1"></a>    continue_find_table_node<span class="op">(</span>info<span class="op">-&gt;</span>callbacks<span class="op">,</span> table_or_view<span class="op">);</span></span>
<span id="cb326-14"><a href="#cb326-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-15"><a href="#cb326-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_ast_create_view_stmt<span class="op">(</span>table_or_view<span class="op">))</span> <span class="op">{</span></span>
<span id="cb326-16"><a href="#cb326-16" aria-hidden="true" tabindex="-1"></a>      add_item_to_list<span class="op">(&amp;</span>info<span class="op">-&gt;</span>found_views<span class="op">,</span> table_or_view<span class="op">);</span></span>
<span id="cb326-17"><a href="#cb326-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb326-18"><a href="#cb326-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb326-19"><a href="#cb326-19" aria-hidden="true" tabindex="-1"></a>      add_item_to_list<span class="op">(&amp;</span>info<span class="op">-&gt;</span>found_tables<span class="op">,</span> table_or_view<span class="op">);</span></span>
<span id="cb326-20"><a href="#cb326-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb326-21"><a href="#cb326-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-22"><a href="#cb326-22" aria-hidden="true" tabindex="-1"></a>    find_all_triggers_node<span class="op">(</span>info<span class="op">,</span> table_or_view_name<span class="op">);</span></span>
<span id="cb326-23"><a href="#cb326-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb326-24"><a href="#cb326-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The general purpose walker notifies exactly once on each visited
table/view and <code>continue_find_table_node</code> is used to dive
into the bodies of views/tables that would otherwise not be searched.
Likewise <code>find_all_triggers_node</code> dives into the body of any
triggers that are on the found item.</p>
<h4 id="emitting-indices-and-triggers">Emitting Indices and
Triggers</h4>
<p>With the “found tables” computed (creatively stored in a field called
<code>found_tables</code>) it’s very easy to loop over these and
generate the necessary indices for each found table (keeping in mind the
“found table” can be a view).</p>
<p>The <code>create index statement</code> is emitted by the usual
<code>gen_statement_with_callbacks</code> form that echos the AST.</p>
<p>The <code>drop index</code> can be trivially created by name.</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Emit create and drop index statement for all indexes on a table.</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> cg_emit_index_stmt<span class="op">(</span></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a>  CSTR table_name<span class="op">,</span></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>gen_create_indexes<span class="op">,</span></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a>  charbuf <span class="op">*</span>gen_drop_indexes<span class="op">,</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a>  gen_sql_callbacks <span class="op">*</span>callback<span class="op">)</span></span>
<span id="cb327-7"><a href="#cb327-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb327-8"><a href="#cb327-8" aria-hidden="true" tabindex="-1"></a>  symtab_entry <span class="op">*</span>indexes_entry <span class="op">=</span> symtab_find<span class="op">(</span>all_tables_with_indexes<span class="op">,</span> table_name<span class="op">);</span></span>
<span id="cb327-9"><a href="#cb327-9" aria-hidden="true" tabindex="-1"></a>  bytebuf <span class="op">*</span>buf <span class="op">=</span> indexes_entry <span class="op">?</span> <span class="op">(</span>bytebuf <span class="op">*)</span>indexes_entry<span class="op">-&gt;</span>val <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb327-10"><a href="#cb327-10" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">**</span>indexes_ast <span class="op">=</span> buf <span class="op">?</span> <span class="op">(</span>ast_node <span class="op">**)</span>buf<span class="op">-&gt;</span>ptr <span class="op">:</span> NULL<span class="op">;</span></span>
<span id="cb327-11"><a href="#cb327-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> count <span class="op">=</span> buf <span class="op">?</span> buf<span class="op">-&gt;</span>used <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(*</span>indexes_ast<span class="op">)</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb327-12"><a href="#cb327-12" aria-hidden="true" tabindex="-1"></a>  gen_set_output_buffer<span class="op">(</span>gen_create_indexes<span class="op">);</span></span>
<span id="cb327-13"><a href="#cb327-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-14"><a href="#cb327-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb327-15"><a href="#cb327-15" aria-hidden="true" tabindex="-1"></a>    ast_node <span class="op">*</span>index_ast <span class="op">=</span> indexes_ast<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb327-16"><a href="#cb327-16" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>create_index_stmt<span class="op">,</span> index_ast<span class="op">);</span></span>
<span id="cb327-17"><a href="#cb327-17" aria-hidden="true" tabindex="-1"></a>    EXTRACT_NOTNULL<span class="op">(</span>create_index_on_list<span class="op">,</span> create_index_stmt<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb327-18"><a href="#cb327-18" aria-hidden="true" tabindex="-1"></a>    EXTRACT_ANY_NOTNULL<span class="op">(</span>index_name_ast<span class="op">,</span> create_index_on_list<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb327-19"><a href="#cb327-19" aria-hidden="true" tabindex="-1"></a>    EXTRACT_STRING<span class="op">(</span>index_name<span class="op">,</span> index_name_ast<span class="op">);</span></span>
<span id="cb327-20"><a href="#cb327-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-21"><a href="#cb327-21" aria-hidden="true" tabindex="-1"></a>    gen_statement_with_callbacks<span class="op">(</span>index_ast<span class="op">,</span> callback<span class="op">);</span></span>
<span id="cb327-22"><a href="#cb327-22" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>gen_create_indexes<span class="op">,</span> <span class="st">&quot;;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb327-23"><a href="#cb327-23" aria-hidden="true" tabindex="-1"></a>    bprintf<span class="op">(</span>gen_drop_indexes<span class="op">,</span> <span class="st">&quot;DROP INDEX IF EXISTS %s;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> index_name<span class="op">);</span></span>
<span id="cb327-24"><a href="#cb327-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb327-25"><a href="#cb327-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Triggers are done in exactly the same way except that instead of
looping over found tables we can actually generate them as they are
discovered inside of <code>find_all_triggers_node</code>. Recal that we
had to visit the triggers when computing the found tables anyway. We did
not have to visit the indices hence the difference.</p>
<p>These walks allow us to produce:
<code>test_your_proc_create_indexes</code>,
<code>test_your_proc_drop_indexes</code>,
<code>test_your_proc_create_triggers</code>,
<code>test_your_proc_drop_triggers</code></p>
<h4 id="emitting-tables-and-views">Emitting Tables and Views</h4>
<p>Starting from the found tables, again it is very easy to generate the
code to create and drop the tables and views. The only trick here is
that the tables depend on one another so order is important. The tables
are discovered with the deepest dependency first, new found items are
added to the head of the found tables but it’s a post-order walk so that
means that the deepest tables/views are at the front of the list. This
means the list is naturally in the order that it needs to be to delete
the tables (parent tables at the end). So the algorithm goes like
this:</p>
<ul>
<li>emit the drop tables/views in the found order</li>
<li>reverse the list</li>
<li>emit the create tables/views in the reverse order</li>
<li>for each table/view emit the reader `test_your_proc_read_[item]</li>
<li>for tables we emit an insertion fragment into
<code>test_your_proc_populate_tables</code> using
<code>cg_dummy_test_populate</code>
<ul>
<li>population is discussed in the following sections</li>
</ul></li>
</ul>
<p>As in the other cases <code>gen_statement_with_callbacks</code> is
used to create the DDL statements: * <code>CREATE TABLE</code> *
<code>CREATE VIEW</code> * <code>CREATE VIRTUAL TABLE</code></p>
<p>The delete side is easily created with ad hoc <code>DROP TABLE</code>
or <code>DROP VIEW</code> statements.</p>
<p>The reading procedure is always of the form
<code>SELECT * FROM foo</code> so that too is trivial to generate with a
fixed template. The “echoing” system once again is doing a lot of the
heavy lifting.</p>
<p>These walks give us <code>test_your_proc_create_tables</code>,
<code>test_your_proc_drop_tables</code>, and
<code>test_your_proc_read_[item]</code> and drive the population
process</p>
<h4 id="gathering-ad-hoc-data-to-be-inserted">Gathering Ad Hoc Data To
Be Inserted</h4>
<p>Before we get into the mechanics of the population code, we have to
visit one more area. It’s possible to include data in the the
<code>dummy_test</code> annotaiton itself. This is data that you want to
have populated. This data will be included in the overall data
populator. If there is enough of it (at least 2 rows per candidate
table) then it might be all the data you get. Now the data format here
is not designed to be fully general, after all it’s not that hard to
just write <code>INSERT ... VALUES</code> for all your tables anyway.
The goal is to provide something that will help you not have to remember
all the FK relationships and maybe let you economically specify some
leaf data you need and get the rest for free. It’s also possible to
manually create dummy data that just won’t work, again, scrubbing all
this is way beyond the ability of a simple test helper. When the code
runs you’ll get SQLite errors which can be readily addressed.</p>
<p>So keeping in mind this sort of “entry level data support” as the
goal, we can take a look at how the system works – it’s all in the
function <code>collect_dummy_test_info</code> which includes this
helpful comment on structure.</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="co">// the data attribute looks kind of like this:</span></span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a><span class="co">// @attribute(cql:autotest = (</span></span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a><span class="co">//   .. other auto test attributes</span></span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a><span class="co">//   (dummy_test,</span></span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a><span class="co">//     (table_name1, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a><span class="co">//     (table_name2, (col1, col2), (col1_val1, col2_val1), (col1_val2, col2_val2) ),</span></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a><span class="co">//     ...</span></span>
<span id="cb328-8"><a href="#cb328-8" aria-hidden="true" tabindex="-1"></a><span class="co">//   )</span></span>
<span id="cb328-9"><a href="#cb328-9" aria-hidden="true" tabindex="-1"></a><span class="co">//   .. other auto test attributes</span></span>
<span id="cb328-10"><a href="#cb328-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ))</span></span>
<span id="cb328-11"><a href="#cb328-11" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb328-12"><a href="#cb328-12" aria-hidden="true" tabindex="-1"></a><span class="co">// we&#39;re concerned with the dummy_test entries here, they have a very specific format</span></span>
<span id="cb328-13"><a href="#cb328-13" aria-hidden="true" tabindex="-1"></a><span class="co">// i.e. first the table then the column names, and then a list of matching columns and values</span></span></code></pre></div>
<p>So we’re going to walk a list of attributes each one begins with a
table name, then a list of columns, and then a list of values.</p>
<p>All of the data is in the symbol table <code>dummy_test_infos</code>
which is indexed by table name. For each table name we find we ensure
there is a symbol table at that slot. So <code>dummy_test_infos</code>
is a symbol table of symbol tables. It’s actually going to be something
like <code>value_list = dummy_test_infos['table']['column']</code></p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// collect table name from dummy_test info</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>  ast_node <span class="op">*</span>table_list <span class="op">=</span> dummy_attr<span class="op">-&gt;</span>left<span class="op">;</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>table_name<span class="op">,</span> table_list<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a>  symtab <span class="op">*</span>col_syms <span class="op">=</span> symtab_ensure_symtab<span class="op">(</span>dummy_test_infos<span class="op">,</span> table_name<span class="op">);</span></span></code></pre></div>
<p>Next we’re going to find the column names, they are the next entry in
the list so we go <code>right</code> to get the
<code>column_name_list</code></p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="co">// collect column names from dummy_test info</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>ast_node <span class="op">*</span>column_name_list <span class="op">=</span> table_list<span class="op">-&gt;</span>right<span class="op">;</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>ast_node <span class="op">*</span>list <span class="op">=</span> column_name_list<span class="op">-&gt;</span>left<span class="op">;</span> list<span class="op">;</span> list <span class="op">=</span> list<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>  EXTRACT_STRING<span class="op">(</span>column_name<span class="op">,</span> list<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a>  sem_t col_type <span class="op">=</span> find_column_type<span class="op">(</span>table_name<span class="op">,</span> column_name<span class="op">);</span></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-7"><a href="#cb330-7" aria-hidden="true" tabindex="-1"></a>  bytebuf <span class="op">*</span>column_values <span class="op">=</span> symtab_ensure_bytebuf<span class="op">(</span>col_syms<span class="op">,</span> column_name<span class="op">);</span></span>
<span id="cb330-8"><a href="#cb330-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-9"><a href="#cb330-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// store the column meta data, create space to hold values in databuf</span></span>
<span id="cb330-10"><a href="#cb330-10" aria-hidden="true" tabindex="-1"></a>  bytebuf_append_var<span class="op">(&amp;</span>col_data_buf<span class="op">,</span> column_values<span class="op">);</span></span>
<span id="cb330-11"><a href="#cb330-11" aria-hidden="true" tabindex="-1"></a>  bytebuf_append_var<span class="op">(&amp;</span>col_type_buf<span class="op">,</span> col_type<span class="op">);</span></span>
<span id="cb330-12"><a href="#cb330-12" aria-hidden="true" tabindex="-1"></a>  bytebuf_append_var<span class="op">(&amp;</span>col_name_buf<span class="op">,</span> column_name<span class="op">);</span></span>
<span id="cb330-13"><a href="#cb330-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The primary purpose of this part of the loop is then to add the
column names to <code>col_syms</code> so that they are linked to the
dummy info for this table. The line
<code>bytebuf *column_values = symtab_ensure_bytebuf(col_syms, column_name);</code>
does this. And this also creates the byte buffer that will hold the
eventual values.</p>
<p>We also keep a side set of buffers that has the column name, type,
and the values in the <code>col_name</code>, <code>col_type</code>, and
<code>col_data</code> buffers respectively. These are used to handle the
foreign key work shortly and they allow us to not have to look up all
the names over and over.</p>
<pre><code>// collect column value from dummy_test info. We can have multiple rows of column value
for (ast_node *values_ast = column_name_list-&gt;right;
     values_ast;
     values_ast = values_ast-&gt;right) {

  int32_t column_index = 0;

  // collect one row of column value
  for (ast_node *list = values_ast-&gt;left; list; list = list-&gt;right) {
    ast_node *misc_attr_value = list-&gt;left;
    Contract(col_data_buf.used);
    bytebuf *column_values = ((bytebuf **) col_data_buf.ptr)[column_index];
    sem_t column_type = ((sem_t *) col_type_buf.ptr)[column_index];
    CSTR column_name = ((CSTR *) col_name_buf.ptr)[column_index];

    bytebuf_append_var(column_values, misc_attr_value);
    column_index++;

    ...foreign key stuff goes here...
  }
  .. some cleanup
}</code></pre>
<p>The most important part is
<code>bytebuf_append_var(column_values, misc_attr_value);</code> this is
where the attribute value is added to the list of values that are on the
column.</p>
<p>Finally, the “foreign key stuff”. What we need to do here is check
the column name in the table to see if it’s part of a foreign key and if
it is we recursively add the current data value to the referenced column
in the reference table. That way if you add an initalizer to a leaf
table you don’t also have to add it to all the parent tables. If it
wasn’t for this feature the manual data wouldn’t be very useful at all,
hand written <code>INSERT</code> statements would be just as good.</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If a column value is added to dummy_test info for a foreign key column then</span></span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a><span class="co">// we need to make sure that same column value is also added as a value in the</span></span>
<span id="cb332-3"><a href="#cb332-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the referenced table&#39;s dummy_test info.</span></span>
<span id="cb332-4"><a href="#cb332-4" aria-hidden="true" tabindex="-1"></a><span class="co">// e.g.</span></span>
<span id="cb332-5"><a href="#cb332-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   create table A(id integer primary key);</span></span>
<span id="cb332-6"><a href="#cb332-6" aria-hidden="true" tabindex="-1"></a><span class="co">//   create table B(id integer primary key references A(id));</span></span>
<span id="cb332-7"><a href="#cb332-7" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb332-8"><a href="#cb332-8" aria-hidden="true" tabindex="-1"></a><span class="co">// If there is sample data provided for B.id then we must also ensure that</span></span>
<span id="cb332-9"><a href="#cb332-9" aria-hidden="true" tabindex="-1"></a><span class="co">// the value provided for B.id is also add as a sample row in A with the same</span></span>
<span id="cb332-10"><a href="#cb332-10" aria-hidden="true" tabindex="-1"></a><span class="co">// value for id.</span></span>
<span id="cb332-11"><a href="#cb332-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>is_foreign_key<span class="op">(</span>column_type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb332-12"><a href="#cb332-12" aria-hidden="true" tabindex="-1"></a>  add_value_to_referenced_table<span class="op">(</span>table_name<span class="op">,</span> column_name<span class="op">,</span> column_type<span class="op">,</span> misc_attr_value<span class="op">);</span></span>
<span id="cb332-13"><a href="#cb332-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When this is a done all of the initializers will have been added to
the appropriate column of the appropriate table. Again the overall
structure is something like:
<code>value_list = dummy_test_infos['table']['column']</code></p>
<h4 id="emitting-the-table-population-fragments">Emitting the Table
Population Fragments</h4>
<p>With any custom initalizers in the <code>dummy_test_infos</code>
structure we can do the population fragment for any given table.</p>
<p>The general algorithm here goes like this:</p>
<ul>
<li>the total number of rows we will generate will be the number of
column values in the initializers or else
<code>DUMMY_TEST_INSERT_ROWS</code>, whichever is larger</li>
<li>the insert statement generated will include
<code>dummy_seed([value_seed])</code> where value_seed starts at 123 and
goes up 1 for every row generated
<ul>
<li>dummy_seed will create values for any missing columns using the seed
so any combination of included columns is ok, we’ll always get a
complete insert</li>
</ul></li>
<li>foreign key columns use a provided intializer from the parent table
if there is one, or else they use 1, 2, 3 etc.
<ul>
<li>likewise if a column is referenceable by some other table it uses
the known sequence 1, 2, 3 etc. for its value rather than the varying
seed</li>
<li>in this way child tables can know that partent tables will have a
value they can use since both tables will have at least
<code>DUMMY_TEST_INSERT_ROWS</code> and any rows that were not manually
initialized will match</li>
<li>note that foreign key columns always get this treatment, whether
they were mentioned or not</li>
</ul></li>
<li>to mix things up the <code>dummy_nullables</code> and
<code>dummy_defaults</code> are added on every other row which makes
missing values be NULL and/or the default value if one is present</li>
</ul>
<p>This is enough to generate a set of insert statements for the table
in question and since the fragments are generated in the table creation
order the resulting insert statements will have the parent tables first
so the foreign keys of later tables will be correct.</p>
<p>This can go wrong if the manual initializations use keys that
conflict with the default generation or if the manual intializations
have PK conflicts or other such things. No attempt is made to sort that
out. The run time errors should be clear and these are, after all, only
test helpers. It’s very easy to avoid these hazards and you get a pretty
clear error message if you don’t so that seems good enough.</p>
<p>These fragments are ultimately combined to make the body of the
procedure <code>test_your_proc_populate_tables</code>.</p>
<h3 id="recap-5">Recap</h3>
<p>The test helpers in <code>cg_test_helpers.c</code> are very simple
nearly-constant templates with the exception of <code>dummy_test</code>
which includes:</p>
<ul>
<li>table and view creation</li>
<li>index creation</li>
<li>trigger creation</li>
<li>data population</li>
</ul>
<p>Topics covered included:</p>
<ul>
<li>how the candidate procedures are discovered</li>
<li>how the attributes are scanned for test directives</li>
<li>how each dummy test type is dispatched</li>
<li>how <code>dummy_test</code> handles data initialization</li>
<li>how <code>dummy_test</code> does its dependency analysis</li>
</ul>
<p>As with the other parts, no attempt was made to cover every function
in detail. That is best done by reading the source code. But there is
overall structure here and an understanding of the basic principles is
helpful before diving into the source code.</p>
</body>
</html>
