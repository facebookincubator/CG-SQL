<!---
-- Copyright (c) Facebook, Inc. and its affiliates.
--
-- This source code is licensed under the MIT license found in the
-- LICENSE file in the root directory of this source tree.
-->

## 14. CQL Query Fragments

CQL Query fragments are the most sophisticated rewrite CQL offers for productivity.  The idea is that a very large query
can be represented in "fragments" that add columns or add rows based on the original "core" query.  The final query
will be an assembled rewrite of all the fragments chained together.  Specifically, the motivation for this is that you
can have a "core" query that fetches the essential columns for some UI design and then you can add query extension
fragments that add new/additional columns for some new set of features.  The core and extended columns can be in their
own fragment and they can be compiled independently.  The result of this is that any errors are in much smaller
and easier to understand fragments rather than in some monster "fetch everything" query;  any given extension does not
have to know all the details of all the other extensions and can take a limited dependency on even the core query.

It's easiest to illustrate this with an example so let's begin there.

Let's first start with this very simple schema.

```
create table T1(
  id integer primary key,
  name text not null,
  rate real not null
);

create table T2(
  id integer primary key references T1(id),
  flag bool not null
);

create table T3(
  id integer primary key references T1(id),
  flag2 bool not null
);
```
Typically there would be a lot more columns but where you see `flag1` and `flag2` appear in fragments you can imagine any number
of additional columns of any type.  So we can keep the examples simple.

### Base Query Fragments

The base fragment might look something like this:

```
@attribute(cql:base_fragment=your_frags)
create proc base_frag(id_ integer not null)
begin
  with
    your_frags(*) as (select * from T1 where T1.id = id_)
    select * from your_frags;
end;
```

Here are the essential aspects:

* the base fragment is given a name, it can be anything, probably something that describes the purpose of the fragments
* the procedure name can be anything at all
* the procedure must consiste of exactly one `with...select` statement
* the fragment name must be the one and only CTE in the select statement
* you must select all the columns from the CTE

Note the syntax helper `your_frags(*)` is just shorthand to avoid retyping all the column names of T1.

The interesting part is `(select * from T1 where T1.id = id_)` which could have been any select statement of your choice. Everything else in the procedure must follow the designated format, and the format is enforced due to the presence of `@attribute(cql:base_fragment=your_frags)`.  

The point of putting everything on rails like this is that all base fragments will look the same and it will be clear how to transform the any base fragment into the final query when it is assembled with its extensions.

Note: the base fragment produces no codegen at all.  There is no `base_frag` procedure in the output.  This is just a template.  Also, the name of the procedure cannot be `your_frags` this name will be used by the assembly fragment later.  Really any descriptive unique name will do as the name does not appear in the output at all.

### Extension Query Fragments

#### Adding Columns

The most common thing that an extension might want to do is add columns to the result.  There can be any number of such extensions in the final assembly.  Here's a simple example that adds one column.

```sql
@attribute(cql:extension_fragment=your_frags)
create proc adds_columns(id_ integer not null)
begin
  with
    your_frags(*) as (select 1 id, "name" name, 1.0 rate),
    extension_one(*) as (
    select your_frags.*, T2.flag
      from your_frags
      left outer join T2 on your_frags.id = T2.id)
  select * from extension_one;
end;
```
Again there are some important features to this extension and they are largely completely constrained, i.e. you must follow the pattern.

* the attribute indicates `extension_fragment` and the name (here `your_frags`) must have been previously declared in a `base_fragment`
* the procedure name can be any unique name other than `your_frags`, it corresponds to this particular extension's purpose
* the procedure arguments must be identical to the base fragment arguments
* the first CTE must match the attribute, `your_frags` in this case
* you do not need to repeat the full select statement for your_frags, any surrogate with the same column names and types will do
  * the base fragment code might include a #define to make this easier 
    * e.g. `#define your_frags_core as your_frag(*) as (select 1 id, "name" name, 1.0 rate)`
  * doing so will make maintenance easier if new columns are added to the base fragment
* there must be exactly one additional CTE 
  * it may have any descriptive name you like
  * it must begin with `select your_frags.*` with the appropriate CTE name
  * it must add at least one column (or it would be uninteresting)
  * it may not have any clause other than the first `from` (e.g. no `where`, `having`, `limit` etc.)
    * if any of these were allowed it would remove or re-order rows in the base query which is not allowed
    * the from clause may include nested selects which have no restrictions
  * it must select from the base fragment name and left outer join to whereever it likes to get optional additional columns
    * because of this the additional column(s) will certainly be a nullable type in the projection
* the final select must be exactly `select * from extension_one` with the appropriate name
* keeping all this in mind, the interesting bit happens here:  `left outer join T2 on your_frags.id = T2.id`
  * this is where you get the data for your additional column based on values in the core column.

This fragment can be (and should be) compiled in its own compiland while using `#include` to get the base fragment only.  This will result in code gen for the accessor functions for a piece of the overall query -- the part this extension knows about.  Importantly code that uses this extension's data does not need or want to know about any other extensions that may be present, thereby keeping
dependencies under control.

The C signatures generated would look like this:

```c
extern cql_int32 adds_columns_get_id(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_string_ref _Nonnull adds_columns_get_name(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_double adds_columns_get_rate(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_bool adds_columns_get_flag_is_null(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_bool adds_columns_get_flag_value(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);
```

Even if there were dozens of other extensions, the functions for reading those columns would not be declared in the header for
this extension.  Any given extension "sees" only the core columns plus any columns it added.

#### Adding Rows

Query extensions also frequently want to add additional rows to the main result set, based on the data that is already present.

The second form of extension allows for this, it is slightly more general.  Here is an example:

```sql
@attribute(cql:extension_fragment=your_frags)
create proc adds_rows(id_ integer)
begin
  with
    your_frags(*) as (select 1 id, "name" name, 1.0 rate),
    extension_two(*) as (
    select your_frags.*, 0 flag2 from your_frags
    union all
    select your_frags.*, T3.flag2 from your_frags
    inner join T3 on your_frags.id = T3.id)
  select * from extension_two;
end;
```

Let's review the features of this second template form:
* there is a surrogate for the core query
* there is a manatory second CTE
* the second CTE is a compound query with `union all` and it has exactly two branches
* both branches include `your_frags.*` to ensure that all of the core columns are present
  * NOTE: this is a significant limitation that probably needs to be removed in future!
* the first branch specifies the default value for any additional columns it wants to add as it applies to the previous rows
  * in this case `0 flag2` indicates that flag2 will be "false" by default
* the second branch specifies any additional desired rows, joining from the core columns to get those rows
  * in this case we're joining to T3 to get the value of flag2, adding some rows to the overall output 
* the final select after the CTE section must exactly in the form `select * from extension_two` which is the name of the one and only additional CTE with no other clauses or options
  * in practice only the CTE will be used to create the final assembly so even if you did change the final select to something else it would be moot

The generated code for this will look something like so:

```c
extern cql_int32 adds_rows_get_id(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_string_ref _Nonnull adds_rows_get_name(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_double adds_rows_get_rate(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_int32 adds_rows_get_flag2(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);
```

Which gives you access to the core columns and flag_2. Note that in this case flag2 did not have to be nullable.  Again
this fragment can and should be compiled standalone with only the declaration for the base fragment in the same translation unit.


#### Assembling the Fragments

With all the fragments independently declared they need to be unified to create one final query. This is where the
major rewriting happens.  The `assembly_fragment` looks something like this:

```sql
@attribute(cql:assembly_fragment=your_frags)
create proc your_frags(id_ integer not null)
begin
  with
    your_frags(*) as (select 1 id, "name" name, 1.0 rate)
    select * from your_frags;
end;
```

It will always be as simple as this, all the complexity is in the fragments.

* the `assembly_fragment` name must match the core fragment name
* the procedure arguments must be identical to the base fragment arguments
* the  procedure must have the same name as the assembly fragment (`your_frags` in this case)
  * the code that was generated for the previous fragments anticipates this and makes reference to what will be generated here
  * this is enforced
* the assembled query is what you run to get the result set.  
  * the other fragments only produce result set readers
* there is a surrogate for the core fragment as usual
* all of this will ultimately be replaced with the fragments chained together
* the final select should be of the form `select * from your_frags` but it can include ordering and/or filtering, this statement will be present in final codegen 


When compiling the assembly fragment, you should include the code, and all the other fragments, and the assembly template.  The presence of the assembly_fragment will cause codegen for the extension fragments to be suppressed. The assembly translation unit only contains the assembly query from the fragments.

Now let's look at how the query is rewritten, the process is pretty methodical.

After rewriting the assembly looks like this:

```sql
CREATE PROC assembled_frag (id_ INTEGER NOT NULL)
BEGIN
  WITH
  your_frags (id, name, rate) AS (SELECT *
    FROM T1
    WHERE T1.id = id_),
  extension_one (id, name, rate, flag) AS (SELECT your_frags.*, T2.flag
    FROM your_frags
    LEFT OUTER JOIN T2 ON your_frags.id = T2.id),
  extension_two (id, name, rate, flag, flag2) AS (SELECT extension_one.*, 0 AS flag2
    FROM extension_one
  UNION ALL
  SELECT extension_one.*, T3.flag2
    FROM extension_one
    INNER JOIN T3 ON extension_one.id = T3.id)
  SELECT *
    FROM extension_two;
END;
```

Let's dissect this part by part, each CTE serves a purpose.

* the core CTE was replaced by the CTE in the base_fragment, it appears directly
* next the first extension was added as a CTE referring to the base fragment just as before
* next the second extension was added as a CTE
  * all references to the core fragment were replaced with references to extension_one
  * any extra column names in the CTE were added such that all previous column names are introduced
* this process continues until all extensions are exhausted
* the final select statement reads all the columns from the last extension CTE

The result of all this is a single query that gets all the various columns that were requested in all the extensions
and all the `union all` operations play out as written.  The extensions are emitted in the order that they appear
in the translation unit with the assembly.

This provides considerable ability to compose a large query but each fragment can be independently checked for errors
so that nobody ever has to debug the (possibly monstrous) overall result.  Fragments can be removed simply by
excluding them from the final assembly (with e.g. #ifdefs)

With the rewrite of the assembly_fragment complete, the codegen for that proc is the normal codegen for a procedure with a single select.

As always, Java and Objective C codegen on these pieces will produce suitable wrappers for the C.

The output code for the assembly fragment generates these reading functions:

```c
extern cql_int32 your_frags_get_id(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_string_ref _Nonnull your_frags_get_name(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_double your_frags_get_rate(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_bool __PRIVATE__your_frags_get_flag_is_null(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_bool __PRIVATE__your_frags_get_flag_value(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_int32 __PRIVATE__your_frags_get_flag2(
  your_frags_result_set_ref _Nonnull result_set, 
  cql_int32 row);

extern cql_int32 your_frags_result_count(
  your_frags_result_set_ref _Nonnull result_set);
```

These are exactly what you would get for a normal query except that the pieces that came from extensions are marked `PRIVATE`.  Those methods should not be used directly but instead the methods generated for each extension proc should be used.

Additionally, to create the result set, as usual. 

```c
extern CQL_WARN_UNUSED cql_code your_frags_fetch_results(
  sqlite3 *_Nonnull _db_, 
  your_frags_result_set_ref _Nullable *_Nonnull result_set, 
  cql_int32 id_);
```

With the combined set of methods you can flexibilty create a variety of assembled queries from extensions in a fairly straightforward way.

<div style="page-break-after: always; visibility: hidden"></div>
